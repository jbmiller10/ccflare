This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.lock, *.txt, *.md, *repopack*, *repomix*, /**/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
apps/
  lander/
    src/
      _headers
      _redirects
      index.html
      styles.css
    package.json
  server/
    src/
      server.ts
    package.json
    tsconfig.json
  tui/
    src/
      components/
        charts/
          BarChart.tsx
          index.ts
          LineChart.tsx
          PieChart.tsx
          SparklineChart.tsx
          utils.ts
        AccountsScreen.tsx
        AnalyticsScreen.tsx
        LogsScreen.tsx
        RequestsScreen.tsx
        ServerScreen.tsx
        StatsScreen.tsx
        StrategyScreen.tsx
        TokenUsageDisplay.tsx
      types/
        open.d.ts
      App.tsx
      main.ts
    package.json
    tsconfig.json
packages/
  agents/
    src/
      discovery.ts
      index.ts
      paths.ts
      workspace-persistence.ts
    package.json
    tsconfig.json
  cli-commands/
    src/
      commands/
        account.ts
        analyze.ts
        help.ts
        stats.ts
      prompts/
        adapter.ts
        index.ts
        std-adapter.ts
      utils/
        browser.ts
      index.ts
      runner.ts
    package.json
    tsconfig.json
  config/
    src/
      index.ts
      paths-common.ts
      paths.ts
    package.json
    tsconfig.json
  core/
    src/
      constants.ts
      errors.ts
      index.ts
      lifecycle.ts
      models.ts
      pricing.ts
      request-events.ts
      strategy.ts
      validation.ts
    package.json
    tsconfig.json
  core-di/
    src/
      container.ts
      index.ts
    package.json
    tsconfig.json
  dashboard-web/
    src/
      components/
        accounts/
          AccountAddForm.tsx
          AccountList.tsx
          AccountListItem.tsx
          DeleteConfirmationDialog.tsx
          index.ts
          RateLimitProgress.tsx
          RenameAccountDialog.tsx
        agents/
          AgentCard.tsx
          AgentEditDialog.tsx
          index.ts
          WorkspaceCard.tsx
        analytics/
          AnalyticsCharts.tsx
          AnalyticsControls.tsx
          AnalyticsFilters.tsx
          index.ts
          ModelAnalytics.tsx
          TokenSpeedAnalytics.tsx
        charts/
          BaseAreaChart.tsx
          BaseBarChart.tsx
          BaseLineChart.tsx
          BasePieChart.tsx
          BaseScatterChart.tsx
          chart-utils.ts
          ChartContainer.tsx
          ChartTooltip.tsx
          CostChart.tsx
          index.ts
          ModelPerformanceChart.tsx
          ModelPerformanceComparison.tsx
          ModelTokenSpeedChart.tsx
          MultiModelChart.tsx
          RequestVolumeChart.tsx
          ResponseTimeChart.tsx
          TokenSpeedChart.tsx
          TokenUsageChart.tsx
          types.ts
        conversation/
          index.ts
          Message.tsx
          MessageBubble.tsx
          ThinkingBlock.tsx
          ToolResultBlock.tsx
          ToolUsageBlock.tsx
        overview/
          ChartsSection.tsx
          DataRetentionCard.tsx
          LoadingSkeleton.tsx
          MetricCard.tsx
          RateLimitInfo.tsx
          SystemStatus.tsx
          TimeRangeSelector.tsx
        tools/
          SystemPromptInterceptorCard.tsx
        ui/
          badge.tsx
          button.tsx
          card.tsx
          dialog.tsx
          dropdown-menu.tsx
          input.tsx
          label.tsx
          popover.tsx
          progress.tsx
          select.tsx
          separator.tsx
          skeleton.tsx
          switch.tsx
          tabs.tsx
          textarea.tsx
        AccountsTab.tsx
        AgentsTab.tsx
        AnalyticsTab.tsx
        ConversationView.tsx
        CopyButton.tsx
        LogsTab.tsx
        navigation.tsx
        OverviewTab.tsx
        RequestDetailsModal.tsx
        RequestsTab.tsx
        StatsTab.tsx
        StrategyCard.tsx
        theme-toggle.tsx
        TokenUsageDisplay.tsx
        ToolsTab.tsx
      constants/
        index.ts
      contexts/
        theme-context.tsx
      hooks/
        queries.ts
        useApiError.ts
        useCollapsible.ts
        useRequestStream.ts
      lib/
        chart-utils.ts
        query-keys.ts
        utils.ts
      api.ts
      App.tsx
      favicon.svg
      frontend.tsx
      global.d.ts
      index.css
      index.html
    styles/
      globals.css
    build.ts
    bunfig.toml
    components.json
    package.json
    tsconfig.json
  database/
    src/
      repositories/
        account.repository.ts
        agent-preference.repository.ts
        base.repository.ts
        interceptor.repository.ts
        oauth.repository.ts
        request.repository.ts
        stats.repository.ts
        strategy.repository.ts
        system-kv.repository.ts
      analyze-performance.ts
      async-writer.ts
      database-operations.ts
      factory.ts
      index.ts
      migrations.ts
      paths.ts
      performance-indexes.ts
    package.json
    tsconfig.json
  errors/
    src/
      index.ts
    package.json
    tsconfig.json
  http-api/
    src/
      handlers/
        accounts.ts
        agents-update.ts
        agents.ts
        analytics.ts
        config.ts
        health.ts
        logs-history.ts
        logs.ts
        maintenance.ts
        oauth.ts
        requests-stream.ts
        requests.ts
        stats.ts
        tools.ts
      utils/
        handler-factory.ts
        http-error.ts
      index.ts
      router.ts
      types.ts
    package.json
    tsconfig.json
  http-common/
    src/
      client.ts
      errors.ts
      headers.ts
      index.ts
      responses.ts
    package.json
    tsconfig.json
  load-balancer/
    src/
      strategies/
        index.ts
      index.ts
    package.json
    tsconfig.json
  logger/
    src/
      file-writer.ts
      index.ts
    package.json
    tsconfig.json
  oauth-flow/
    src/
      index.ts
    package.json
  providers/
    src/
      oauth/
        base-oauth-provider.ts
        index.ts
        pkce.ts
      providers/
        anthropic/
          index.ts
          oauth.ts
          provider.ts
        index.ts
      base.ts
      index.ts
      registry.ts
      types.ts
    package.json
    tsconfig.json
  proxy/
    src/
      handlers/
        account-selector.ts
        agent-interceptor.ts
        index.ts
        proxy-operations.ts
        proxy-types.ts
        request-handler.ts
        response-processor.ts
        token-manager.ts
      constants.ts
      index.ts
      post-processor.worker.ts
      proxy.ts
      response-handler.ts
      stream-tee.ts
      types.ts
      worker-messages.ts
    package.json
    tsconfig.json
  tui-core/
    src/
      accounts.ts
      analytics.ts
      args.ts
      index.ts
      logs.ts
      requests.ts
      stats.ts
      strategy.ts
    package.json
    tsconfig.json
  types/
    src/
      account.ts
      agent-constants.ts
      agent.ts
      api.ts
      context.ts
      conversation.ts
      index.ts
      logging.ts
      request.ts
      stats.ts
      strategy.ts
    package.json
    tsconfig.json
  ui-common/
    src/
      components/
        TokenUsageDisplay.tsx
      parsers/
        parse-conversation.ts
      utils/
        clean-line-numbers.ts
        generate-message-key.ts
        normalize-text.ts
      formatters.ts
      index.ts
      presenters.ts
    package.json
    tsconfig.json
  ui-constants/
    src/
      index.ts
    package.json
    tsconfig.json
.biomeignore
.env.example
.gitignore
biome.json
LICENSE
package.json
tsconfig.json

================================================================
Files
================================================================

================
File: apps/lander/src/_headers
================
/*
  X-Frame-Options: DENY
  X-Content-Type-Options: nosniff
  X-XSS-Protection: 1; mode=block
  Referrer-Policy: strict-origin-when-cross-origin
  Permissions-Policy: accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()
  Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https:; connect-src 'self'

/*.css
  Cache-Control: public, max-age=31536000, immutable

/*.js
  Cache-Control: public, max-age=31536000, immutable

/*.woff2
  Cache-Control: public, max-age=31536000, immutable

/index.html
  Cache-Control: public, max-age=0, must-revalidate

================
File: apps/lander/src/_redirects
================
# Redirects for Cloudflare Pages
# Add any redirects here as needed
# Example: /old-path /new-path 301

================
File: apps/lander/src/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ccflare - The Ultimate Claude Code Proxy for Power Users</title>
    <meta name="description" content="Track every request. Go low-level. Never hit rate limits again. The ultimate Claude Code proxy with full visibility and control over your API usage.">
    
    <!-- SEO Meta Tags -->
    <meta name="keywords" content="Claude API proxy, Claude rate limit, Claude load balancer, Anthropic API proxy, Claude API analytics, Claude token tracking, Claude cost monitoring, Claude failover, Claude API monitoring, Claude request tracking, Claude debugging, Claude API management, Claude multiple accounts, Claude API gateway, Claude proxy server">
    <meta name="author" content="ccflare">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="revisit-after" content="7 days">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ccflare.com/">
    <meta property="og:title" content="ccflare - Never Hit Claude API Rate Limits Again">
    <meta property="og:description" content="The ultimate Claude API proxy with intelligent load balancing, request-level analytics, and real-time monitoring. Track every token, analyze costs, debug everything.">
    <meta property="og:image" content="https://ccflare.com/screenshot-analytics.png">
    <meta property="og:site_name" content="ccflare">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ccflare.com/">
    <meta name="twitter:title" content="ccflare - Never Hit Claude API Rate Limits Again">
    <meta name="twitter:description" content="The ultimate Claude API proxy with intelligent load balancing, request-level analytics, and real-time monitoring.">
    <meta name="twitter:image" content="https://ccflare.com/screenshot-analytics.png">
    
    <!-- Additional SEO -->
    <link rel="canonical" href="https://ccflare.com/">
    <meta name="theme-color" content="#F38020">
    
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "ccflare",
        "applicationCategory": "DeveloperApplication",
        "operatingSystem": "Windows, macOS, Linux",
        "description": "Claude API proxy with intelligent load balancing, request-level analytics, and rate limit management",
        "url": "https://ccflare.com",
        "author": {
            "@type": "Organization",
            "name": "ccflare"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "5",
            "ratingCount": "100"
        },
        "keywords": "Claude API proxy, rate limiting, load balancer, API analytics, token tracking"
    }
    </script>
</head>
<body>
    <div class="grain"></div>
    
    <header class="header">
        <nav class="nav-container">
            <div class="logo-wrapper">
                <div class="logo-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L3 7V12C3 16.55 6.84 20.74 12 22C17.16 20.74 21 16.55 21 12V7L12 2Z" fill="#F38020"/>
                    </svg>
                </div>
                <span class="logo-text">ccflare</span>
            </div>
            <div class="nav-links">
                <a href="#features">Features</a>
                <a href="#performance">Performance</a>
                <a href="#pricing">Pricing</a>
                <a href="https://github.com/snipeship/ccflare" target="_blank" class="github-link">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z"/>
                    </svg>
                    <span>GitHub</span>
                </a>
            </div>
        </nav>
    </header>

    <main>
        <section class="hero">
            <div class="hero-background"></div>
            <div class="hero-container">
                <div class="hero-content">
                    <div class="hero-badge">For Power Users</div>
                    <h1 class="hero-title">
                        Track Every Request.<br>
                        <span class="gradient-text">Go Low-Level.</span>
                    </h1>
                    <p class="hero-subtitle">
                        Never hit Claude API rate limits again. One command gives you a full Anthropic API proxy server, 
                        real-time token analytics, and intelligent load balancing across multiple accounts. It's really that simple.
                    </p>
                    <div class="hero-actions">
                        <a href="#get-started" class="btn btn-primary">
                            <span>Get Started</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                        </a>
                        <a href="https://github.com/snipeship/ccflare" class="btn btn-secondary" target="_blank">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z"/>
                            </svg>
                            <span>Star on GitHub</span>
                        </a>
                    </div>
                    <div class="hero-stats">
                        <div class="stat">
                            <span class="stat-value">99.9%</span>
                            <span class="stat-label">Uptime</span>
                        </div>
                        <div class="stat-divider"></div>
                        <div class="stat">
                            <span class="stat-value">&lt;10ms</span>
                            <span class="stat-label">Overhead</span>
                        </div>
                        <div class="stat-divider"></div>
                        <div class="stat">
                            <span class="stat-value">∞</span>
                            <span class="stat-label">Scale</span>
                        </div>
                    </div>
                </div>
                <div class="hero-screenshot">
                    <div class="hero-screenshot-wrapper">
                        <img src="screenshot-analytics.png" alt="Claude API analytics dashboard - real-time token usage tracking, cost monitoring, and request analytics for Anthropic API" loading="eager">
                        <div class="hero-screenshot-glow"></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="features" class="features">
            <div class="container">
                <div class="section-header">
                    <h2>Built for Power Users</h2>
                    <p>Everything you need to take control of your Claude API usage</p>
                </div>
                <div class="features-grid">
                    <div class="feature-card featured">
                        <div class="feature-icon">
                            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 12h-4l-3 9L9 3l-3 9H2"/>
                            </svg>
                        </div>
                        <h3>Request-Level Claude API Tracking</h3>
                        <p>Monitor every Anthropic API call with millisecond precision. Track Claude token usage, API costs, latency, and success rates in real-time.</p>
                        <div class="feature-stats">
                            <div class="feature-stat">
                                <span class="stat-number">< 10ms</span>
                                <span class="stat-label">Overhead</span>
                            </div>
                            <div class="feature-stat">
                                <span class="stat-number">100%</span>
                                <span class="stat-label">Coverage</span>
                            </div>
                        </div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                                <line x1="8" y1="21" x2="16" y2="21"/>
                                <line x1="12" y1="17" x2="12" y2="21"/>
                            </svg>
                        </div>
                        <h3>Real-time Dashboard</h3>
                        <p>Live analytics with account health, rate limit status, and usage patterns at your fingertips.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                            </svg>
                        </div>
                        <h3>Deep Debugging</h3>
                        <p>Full request/response logging, error traces, and diagnostics. Know exactly what's happening.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 20v-6m0 0v-6m0 6h6m-6 0H6"/>
                                <circle cx="12" cy="12" r="10"/>
                            </svg>
                        </div>
                        <h3>Fine-grained Control</h3>
                        <p>Set custom rate limits, quotas, and priorities per account. Control every aspect.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/>
                            </svg>
                        </div>
                        <h3>Smart Routing</h3>
                        <p>Multiple load balancing strategies. Automatic failover. Your proxy, your rules.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                            </svg>
                        </div>
                        <h3>Zero Downtime</h3>
                        <p>Seamless account failover. Never lose a request. Track everything that happens.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="screenshots" class="screenshots">
            <div class="container-wide">
                <div class="section-header">
                    <h2>See It In Action</h2>
                    <p>Powerful analytics and monitoring at your fingertips</p>
                </div>
                
                <!-- Main Featured Screenshot -->
                <div class="screenshot-hero">
                    <div class="screenshot-hero-content">
                        <div class="screenshot-hero-text">
                            <h3>Powerful Analytics at Your Fingertips</h3>
                            <p>Track every request, monitor token usage, and analyze costs in real-time. Get deep insights into your API usage patterns with beautiful, actionable analytics.</p>
                            <div class="screenshot-features">
                                <div class="screenshot-feature">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span>Token usage tracking</span>
                                </div>
                                <div class="screenshot-feature">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span>Cost analysis per model</span>
                                </div>
                                <div class="screenshot-feature">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span>Response time metrics</span>
                                </div>
                            </div>
                        </div>
                        <div class="screenshot-hero-image">
                            <img src="screenshot-analytics.png" alt="Claude API analytics - token usage, cost tracking, and request monitoring for Anthropic Claude" loading="lazy">
                        </div>
                    </div>
                </div>

                <!-- Secondary Screenshots Grid -->
                <div class="screenshots-secondary">
                    <div class="screenshot-card-large">
                        <div class="screenshot-card-header">
                            <h3>Real-time Dashboard</h3>
                            <p>Monitor all accounts, request rates, and system health in one unified view</p>
                        </div>
                        <div class="screenshot-wrapper-large">
                            <img src="screenshot-dashboard.png" alt="Claude API proxy dashboard - monitor multiple accounts, rate limits, and API health in real-time" loading="lazy">
                        </div>
                    </div>
                    <div class="screenshot-card-large">
                        <div class="screenshot-card-header">
                            <h3>Debug Console</h3>
                            <p>Full request/response logging with error traces and diagnostics</p>
                        </div>
                        <div class="screenshot-wrapper-large">
                            <img src="screenshot-logs.png" alt="Claude API debug console - request/response logs, error tracking, and API diagnostics" loading="lazy">
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="performance" class="performance">
            <div class="container">
                <div class="section-header">
                    <h2>Track Everything. Miss Nothing.</h2>
                    <p>Real-time insights into your Claude API usage</p>
                </div>
                <div class="performance-grid">
                    <div class="performance-card">
                        <div class="performance-metric">
                            <span class="metric-value">10M+</span>
                            <span class="metric-label">Requests Handled</span>
                        </div>
                        <div class="performance-chart">
                            <div class="chart-bar" style="height: 40%"></div>
                            <div class="chart-bar" style="height: 60%"></div>
                            <div class="chart-bar" style="height: 80%"></div>
                            <div class="chart-bar" style="height: 100%"></div>
                            <div class="chart-bar" style="height: 90%"></div>
                        </div>
                    </div>
                    <div class="performance-card">
                        <div class="performance-metric">
                            <span class="metric-value">0</span>
                            <span class="metric-label">Rate Limit Errors</span>
                        </div>
                        <div class="performance-icon success">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                        </div>
                    </div>
                    <div class="performance-card">
                        <div class="performance-metric">
                            <span class="metric-value">99.99%</span>
                            <span class="metric-label">API Availability</span>
                        </div>
                        <div class="uptime-indicator">
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="get-started" class="get-started">
            <div class="container">
                <div class="section-header">
                    <h2>One Command. Everything You Need.</h2>
                    <p>Seriously, it's this simple</p>
                </div>
                <div class="hero-code-block">
                    <div class="code-block large">
                        <pre><code># Clone, install, and run - that's it!
git clone https://github.com/snipeship/ccflare
cd ccflare
bun install
<span class="highlight">bun run ccflare</span></code></pre>
                    </div>
                    <div class="command-benefits">
                        <h3>That single command gives you:</h3>
                        <ul>
                            <li>✅ Full proxy server on port 8080</li>
                            <li>✅ Interactive TUI for monitoring</li>
                            <li>✅ Web dashboard at http://localhost:8080/dashboard</li>
                            <li>✅ Real-time analytics and request logs</li>
                            <li>✅ Automatic rate limit handling</li>
                        </ul>
                    </div>
                </div>
                <div class="steps-grid">
                    <div class="step-card">
                        <div class="step-number">01</div>
                        <h3>Add Your Accounts</h3>
                        <div class="code-block">
                            <pre><code># In another terminal
bun cli add work-account
bun cli add personal-account</code></pre>
                        </div>
                    </div>
                    <div class="step-card">
                        <div class="step-number">02</div>
                        <h3>Configure Claude</h3>
                        <div class="code-block">
                            <pre><code># Point Claude to your proxy
export ANTHROPIC_BASE_URL=http://localhost:8080</code></pre>
                        </div>
                    </div>
                    <div class="step-card">
                        <div class="step-number">03</div>
                        <h3>Never Hit Rate Limits</h3>
                        <div class="code-block">
                            <pre><code># Just use Claude normally
# ccflare handles the rest! 🚀</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="pricing" class="pricing">
            <div class="container">
                <div class="section-header">
                    <h2>Open Source. Full Control.</h2>
                    <p>Run it yourself. Modify it. Own your infrastructure.</p>
                </div>
                <div class="pricing-card">
                    <div class="pricing-header">
                        <h3>No Bullshit Edition</h3>
                        <div class="price">
                            <span class="currency">$</span>
                            <span class="amount">0</span>
                            <span class="period">/forever</span>
                        </div>
                    </div>
                    <ul class="pricing-features">
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Unlimited accounts</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Request-level tracking and analytics</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Low-level debugging and monitoring tools</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Full source code access. MIT licensed. No strings attached.</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Claude support (why do you need customer support when you can fix it yourself?)</span>
                        </li>
                    </ul>
                    <a href="https://github.com/snipeship/ccflare" class="btn btn-primary btn-block" target="_blank">
                        Get Started Now
                    </a>
                </div>
            </div>
        </section>

        <section class="cta">
            <div class="container">
                <div class="cta-content">
                    <h2>Take Control of Your Claude API Usage</h2>
                    <p>Track every Anthropic API request. Monitor rate limits. Never get blocked again with intelligent load balancing.</p>
                    <div class="cta-actions">
                        <a href="https://github.com/snipeship/ccflare" class="btn btn-primary" target="_blank">
                            <span>Get ccflare</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <div class="logo-wrapper">
                        <div class="logo-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 2L3 7V12C3 16.55 6.84 20.74 12 22C17.16 20.74 21 16.55 21 12V7L12 2Z" fill="#F38020"/>
                            </svg>
                        </div>
                        <span class="logo-text">ccflare</span>
                    </div>
                    <p class="footer-tagline">The open-source Claude API proxy for rate limit management and request analytics.</p>
                </div>
                <div class="footer-links">
                    <a href="https://github.com/snipeship/ccflare" target="_blank">GitHub</a>
                    <a href="https://github.com/snipeship/ccflare/issues" target="_blank">Issues</a>
                    <a href="https://github.com/snipeship/ccflare/blob/main/LICENSE" target="_blank">License</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 ccflare. Built with ❤️ for developers who ship.</p>
            </div>
        </div>
    </footer>
</body>
</html>

================
File: apps/lander/src/styles.css
================
:root {
⋮----
* {
⋮----
body {
⋮----
/* Grain overlay */
.grain {
⋮----
/* Header */
.header {
⋮----
.nav-container {
⋮----
.logo-wrapper {
⋮----
.logo-icon {
⋮----
.logo-text {
⋮----
.nav-links {
⋮----
.nav-links a {
⋮----
.nav-links a:hover {
⋮----
.github-link {
⋮----
.github-link:hover {
⋮----
/* Hero Section */
.hero {
⋮----
.hero-background {
⋮----
.hero-container {
⋮----
.hero-content {
⋮----
/* Hero Screenshot */
.hero-screenshot {
⋮----
.hero-screenshot-wrapper {
⋮----
.hero-screenshot-wrapper:hover {
⋮----
.hero-screenshot-wrapper img {
⋮----
.hero-screenshot-glow {
⋮----
.hero-badge {
⋮----
.hero-title {
⋮----
.gradient-text {
⋮----
.hero-subtitle {
⋮----
.hero-actions {
⋮----
/* Buttons */
.btn {
⋮----
.btn-primary {
⋮----
.btn-primary:hover {
⋮----
.btn-secondary {
⋮----
.btn-secondary:hover {
⋮----
.btn-block {
⋮----
/* Hero Stats */
.hero-stats {
⋮----
.stat {
⋮----
.stat-value {
⋮----
.stat-label {
⋮----
.stat-divider {
⋮----
/* Container */
.container {
⋮----
/* Section Header */
.section-header {
⋮----
.section-header h2 {
⋮----
.section-header p {
⋮----
/* Features Section */
.features {
⋮----
.features-grid {
⋮----
.feature-card {
⋮----
.feature-card:hover {
⋮----
.feature-icon {
⋮----
.feature-card h3 {
⋮----
.feature-card p {
⋮----
/* Featured Feature Card */
.feature-card.featured {
⋮----
.feature-card.featured::before {
⋮----
.feature-card.featured:hover::before {
⋮----
.feature-card.featured .feature-icon {
⋮----
.feature-stats {
⋮----
.feature-stat {
⋮----
.stat-number {
⋮----
/* Screenshots Section */
.screenshots {
⋮----
.container-wide {
⋮----
/* Featured Screenshot Hero */
.screenshot-hero {
⋮----
.screenshot-hero-content {
⋮----
.screenshot-hero-text h3 {
⋮----
.screenshot-hero-text p {
⋮----
.screenshot-features {
⋮----
.screenshot-feature {
⋮----
.screenshot-feature svg {
⋮----
.screenshot-hero-image {
⋮----
.screenshot-hero-image:hover {
⋮----
.screenshot-hero-image img {
⋮----
/* Secondary Screenshots */
.screenshots-secondary {
⋮----
.screenshot-card-large {
⋮----
.screenshot-card-large:hover {
⋮----
.screenshot-card-header {
⋮----
.screenshot-card-header h3 {
⋮----
.screenshot-card-header p {
⋮----
.screenshot-wrapper-large {
⋮----
.screenshot-wrapper-large img {
⋮----
/* Legacy styles for compatibility */
.screenshots-grid {
⋮----
/* Performance Section */
.performance {
⋮----
.performance-grid {
⋮----
.performance-card {
⋮----
.performance-metric {
⋮----
.metric-value {
⋮----
.metric-label {
⋮----
.performance-chart {
⋮----
.chart-bar {
⋮----
.performance-icon {
⋮----
.performance-icon.success {
⋮----
.uptime-indicator {
⋮----
.uptime-bar {
⋮----
/* Get Started Section */
.get-started {
⋮----
.steps-grid {
⋮----
.step-card {
⋮----
.step-number {
⋮----
.step-card h3 {
⋮----
.code-block {
⋮----
.code-block pre {
⋮----
/* Pricing Section */
.pricing {
⋮----
.pricing-card {
⋮----
.pricing-header {
⋮----
.pricing-header h3 {
⋮----
.price {
⋮----
.pricing-tagline {
⋮----
.currency {
⋮----
.amount {
⋮----
.period {
⋮----
.pricing-features {
⋮----
.pricing-features li {
⋮----
.pricing-features li:last-child {
⋮----
.pricing-features svg {
⋮----
/* CTA Section */
.cta {
⋮----
.cta-content {
⋮----
.cta-content h2 {
⋮----
.cta-content p {
⋮----
.cta-actions {
⋮----
/* Footer */
.footer {
⋮----
.footer-content {
⋮----
.footer-brand {
⋮----
.footer-tagline {
⋮----
.footer-links {
⋮----
.footer-links a {
⋮----
.footer-links a:hover {
⋮----
.footer-bottom {
⋮----
/* Hero Code Block */
.hero-code-block {
⋮----
.code-block.large {
⋮----
.code-block.large pre {
⋮----
.code-block .highlight {
⋮----
.command-benefits {
⋮----
.command-benefits h3 {
⋮----
.command-benefits ul {
⋮----
.command-benefits li {
⋮----
/* Responsive */
⋮----
.screenshot-hero-text {
⋮----
.nav-links a:not(.github-link) {

================
File: apps/lander/package.json
================
{
	"name": "@ccflare/lander",
	"version": "1.0.0",
	"description": "Landing page for ccflare - The ultimate Claude Code proxy for power users",
	"private": true,
	"scripts": {
		"build": "mkdir -p dist && cp -r src/* dist/",
		"preview": "bunx serve src"
	},
	"keywords": [
		"ccflare",
		"landing-page",
		"static-site"
	],
	"author": "snipeship",
	"license": "MIT"
}

================
File: apps/server/package.json
================
{
	"name": "@ccflare/server",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/server.ts",
	"scripts": {
		"dev": "bun run --hot src/server.ts",
		"start": "bun run src/server.ts",
		"build": "bun build src/server.ts --compile --outfile dist/ccflare-server",
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/core-di": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/load-balancer": "workspace:*",
		"@ccflare/proxy": "workspace:*",
		"@ccflare/dashboard-web": "workspace:*",
		"@ccflare/http-api": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}

================
File: apps/server/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: apps/tui/src/components/charts/BarChart.tsx
================
import { Box, Text } from "ink";
import { createBar, formatAxisValue, getColorForValue } from "./utils";
⋮----
export interface BarChartData {
	label: string;
	value: number;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
}
⋮----
interface BarChartProps {
	data: BarChartData[];
	width?: number;
	showValues?: boolean;
	title?: string;
	colorThresholds?: { good: number; warning: number };
}

================
File: apps/tui/src/components/charts/index.ts
================


================
File: apps/tui/src/components/charts/LineChart.tsx
================
import { Box, Text } from "ink";
import { formatAxisValue, getSparkChar, normalizeData } from "./utils";
⋮----
export interface LineChartData {
	x: string;
	y: number;
}
⋮----
interface LineChartProps {
	data: LineChartData[];
	height?: number;
	width?: number;
	title?: string;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
	showAxes?: boolean;
}
⋮----
// Create the chart grid
⋮----
// Plot the points
⋮----
// Use different characters based on the position in the y-axis
⋮----
{/* Y-axis labels and chart */}
⋮----
{/* X-axis labels */}

================
File: apps/tui/src/components/charts/PieChart.tsx
================
import { Box, Text } from "ink";
import { formatAxisValue } from "./utils";
⋮----
export interface PieChartData {
	label: string;
	value: number;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
}
⋮----
interface PieChartProps {
	data: PieChartData[];
	title?: string;
	showLegend?: boolean;
	size?: "small" | "medium" | "large";
}
⋮----
// Sort by percentage for better visualization
⋮----
// Simple ASCII representation
⋮----
// Create a simple circular visualization
⋮----
// Determine which segment this point belongs to
let angle = Math.atan2(dy, dx) + Math.PI; // 0 to 2π
angle = angle / (2 * Math.PI); // 0 to 1
⋮----
{/* Pie visualization */}
⋮----
{/* Legend */}
⋮----
<Text dimColor>Total:

================
File: apps/tui/src/components/charts/SparklineChart.tsx
================
import { Box, Text } from "ink";
import { createSparkline, formatAxisValue } from "./utils";
⋮----
interface SparklineChartProps {
	data: number[];
	label?: string;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
	showMinMax?: boolean;
	showCurrent?: boolean;
}
⋮----
export function SparklineChart({
	data,
	label,
	color = "cyan",
	showMinMax = true,
	showCurrent = true,
}: SparklineChartProps)
⋮----
[
⋮----

================
File: apps/tui/src/components/charts/utils.ts
================
// Bar chart characters
⋮----
// Line chart characters
⋮----
// Sparkline characters
⋮----
// Get a bar character based on percentage (0-1)
export function getBarChar(percentage: number): string
⋮----
// Get a sparkline character based on value position in range
export function getSparkChar(value: number, min: number, max: number): string
⋮----
// Normalize data to fit within a specific range
export function normalizeData(
	data: number[],
	targetMax: number,
):
⋮----
// Format a number for display with appropriate units
export function formatAxisValue(value: number): string
⋮----
// Create a horizontal bar
export function createBar(
	value: number,
	maxValue: number,
	width: number,
	showPercentage = true,
): string
⋮----
// Add partial bar for the remaining percentage
⋮----
// Create a sparkline from data
export function createSparkline(data: number[]): string
⋮----
// Get color based on value and thresholds
export function getColorForValue(
	value: number,
	thresholds: { good: number; warning: number },
	inverse = false,
): "green" | "yellow" | "red"

================
File: apps/tui/src/components/AccountsScreen.tsx
================
import type { AccountDisplay } from "@ccflare/types";
import { AccountPresenter } from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import SelectInput from "ink-select-input";
import TextInput from "ink-text-input";
import { useCallback, useEffect, useState } from "react";
⋮----
interface AccountsScreenProps {
	onBack: () => void;
}
⋮----
type Mode = "list" | "add" | "remove" | "confirmRemove" | "waitingForCode";
⋮----
const handleBeginAddAccount = async () =>
⋮----
const handleCompleteAddAccount = async () =>
⋮----
const handleRemoveAccount = (name: string) =>
⋮----
const handleConfirmRemove = async () =>
⋮----
// Handle error
⋮----
setSelectedMode(item.value as "max" | "console");
setStep("tier");

================
File: apps/tui/src/components/LogsScreen.tsx
================
import { Box, Text, useInput } from "ink";
import { useEffect, useState } from "react";
⋮----
interface LogsScreenProps {
	onBack: () => void;
}
⋮----
interface LogEntry {
	ts: number;
	level: string;
	msg: string;
}
⋮----
// Load historical logs on mount
⋮----
const loadHistory = async () =>
⋮----
setLogs(history.slice(-200)); // Keep last 200 logs
⋮----
setLogs((prev) => [...prev.slice(-200), log]); // Keep last 200 logs
⋮----
const getLogColor = (level: string) =>
⋮----
<Text color=

================
File: apps/tui/src/components/RequestsScreen.tsx
================
import { formatCost, formatTokens } from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import { useCallback, useEffect, useState } from "react";
import { TokenUsageDisplay } from "./TokenUsageDisplay";
⋮----
interface RequestsScreenProps {
	onBack: () => void;
}
⋮----
export function RequestsScreen(
⋮----
const interval = setInterval(loadRequests, 10000); // Auto-refresh every 10 seconds
⋮----
// For TUI, we want to show just time not full timestamp for space reasons
const formatTime = (ts: number): string =>
⋮----
const decodeBase64 = (str: string | null): string =>
⋮----
const formatJson = (str: string): string =>
⋮----
// If it's not valid JSON, return as-is
⋮----
{/* Token Usage Section */}
⋮----
// Paginated view
⋮----

⋮----
<Text color="green">

================
File: apps/tui/src/components/ServerScreen.tsx
================
import { NETWORK } from "@ccflare/core";
import { Box, Text, useInput } from "ink";
⋮----
interface ServerScreenProps {
	onBack: () => void;
}
⋮----
export function ServerScreen(
⋮----
// Server is auto-started now, so just show the running status
⋮----
// Open dashboard in browser
⋮----
// Fallback if open package is not available

================
File: apps/tui/src/components/StatsScreen.tsx
================
import {
	formatCost,
	formatNumber,
	formatPercentage,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import { useCallback, useEffect, useState } from "react";
import { BarChart, PieChart, SparklineChart } from "./charts";
⋮----
interface StatsScreenProps {
	onBack: () => void;
}
⋮----
export function StatsScreen(
⋮----
const interval = setInterval(loadStats, 5000); // Auto-refresh every 5 seconds
⋮----
// For TUI, we want to show just time not full timestamp for space reasons
const formatTime = (date: Date): string =>
⋮----
// Calculate additional metrics
⋮----
<Text dimColor>Last updated:
⋮----
{/* Overall Statistics */}
⋮----

⋮----
{/* Token Usage */}
⋮----
{/* Cost Information */}
⋮----
{/* Account Usage */}
⋮----
{/* Charts Section - Toggle with 'c' */}
⋮----
{/* Token Usage Pie Chart */}
⋮----
{/* Account Performance Bar Chart */}
⋮----
{/* Success Rate Sparkline */}
⋮----
{/* Recent Errors */}

================
File: apps/tui/src/components/StrategyScreen.tsx
================
import { Box, Text, useInput } from "ink";
import SelectInput from "ink-select-input";
import { useCallback, useEffect, useState } from "react";
⋮----
interface StrategyScreenProps {
	onBack: () => void;
}
⋮----
type Mode = "view" | "select";
⋮----
export function StrategyScreen(

================
File: apps/tui/src/components/TokenUsageDisplay.tsx
================
import type { RequestSummary } from "@ccflare/tui-core";
import { processTokenUsage } from "@ccflare/ui-common";
import { Box, Text } from "ink";
⋮----
interface TokenUsageDisplayProps {
	summary: RequestSummary;
}

================
File: apps/tui/src/types/open.d.ts
================
interface OpenOptions {
		wait?: boolean;
		background?: boolean;
		newInstance?: boolean;
		allowNonzeroExitCode?: boolean;
		app?: {
			name: string | readonly string[];
			arguments?: readonly string[];
		};
	}
function open(target: string, options?: OpenOptions): Promise<void>;

================
File: apps/tui/src/App.tsx
================
import { Box, Text, useApp } from "ink";
import SelectInput from "ink-select-input";
import { useState } from "react";
import { AccountsScreen } from "./components/AccountsScreen";
import { AnalyticsScreen } from "./components/AnalyticsScreen";
import { LogsScreen } from "./components/LogsScreen";
import { RequestsScreen } from "./components/RequestsScreen";
import { ServerScreen } from "./components/ServerScreen";
import { StatsScreen } from "./components/StatsScreen";
import { StrategyScreen } from "./components/StrategyScreen";
⋮----
type Screen =
	| "home"
	| "server"
	| "accounts"
	| "stats"
	| "analytics"
	| "requests"
	| "logs"
	| "strategy";
⋮----
const handleSelect = (item:
⋮----
const handleBack = () =>

================
File: apps/tui/package.json
================
{
	"name": "ccflare",
	"version": "1.0.0",
	"description": "TUI for ccflare load balancer",
	"bin": {
		"ccflare": "./dist/ccflare"
	},
	"type": "module",
	"scripts": {
		"dev": "bun run src/main.ts",
		"build": "bun build src/main.ts --compile --outfile dist/ccflare --target=bun",
		"prepublishOnly": "bun run build",
		"postpublish": "chmod +x dist/ccflare"
	},
	"dependencies": {
		"@ccflare/tui-core": "workspace:*",
		"@ccflare/ui-common": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/core-di": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/server": "workspace:*",
		"ink": "^6.0.0",
		"ink-select-input": "^6.0.0",
		"ink-spinner": "^5.0.0",
		"ink-text-input": "^6.0.0",
		"react": "^19.0.0"
	},
	"devDependencies": {
		"@types/react": "^19.0.0",
		"@types/node": "^20.0.0",
		"react-devtools-core": "^5.0.0"
	},
	"files": [
		"dist"
	],
	"keywords": [
		"ccflare",
		"load-balancer",
		"tui",
		"cli"
	],
	"publishConfig": {
		"access": "public"
	}
}

================
File: apps/tui/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"jsx": "react-jsx",
		"module": "ESNext",
		"target": "ESNext",
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"types": ["react", "node"]
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}

================
File: packages/agents/src/index.ts
================


================
File: packages/agents/src/paths.ts
================
import { homedir } from "node:os";
import { join } from "node:path";
⋮----
export function getAgentsDirectory(): string

================
File: packages/agents/src/workspace-persistence.ts
================
import { existsSync } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import { homedir } from "node:os";
import { join } from "node:path";
import { Logger } from "@ccflare/logger";
import type { AgentWorkspace } from "@ccflare/types";
⋮----
interface WorkspacesData {
	version: number;
	workspaces: AgentWorkspace[];
}
⋮----
export class WorkspacePersistence
⋮----
async loadWorkspaces(): Promise<AgentWorkspace[]>
⋮----
async saveWorkspaces(workspaces: AgentWorkspace[]): Promise<void>
⋮----
// Ensure directory exists

================
File: packages/agents/package.json
================
{
	"name": "@ccflare/agents",
	"version": "1.0.0",
	"description": "Agent discovery and management for ccflare",
	"main": "dist/index.js",
	"types": "dist/index.d.ts",
	"scripts": {
		"build": "tsc",
		"dev": "tsc --watch",
		"clean": "rm -rf dist",
		"lint": "biome check --write",
		"format": "biome format --write",
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/config": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/types": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^22.5.4",
		"typescript": "^5.7.2"
	}
}

================
File: packages/agents/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"outDir": "./dist",
		"rootDir": "./src"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}

================
File: packages/cli-commands/src/commands/analyze.ts
================
import type { Database } from "bun:sqlite";
import { TIME_CONSTANTS } from "@ccflare/core";
import { analyzeIndexUsage } from "@ccflare/database";
⋮----
/**
 * Analyze query performance and index usage
 */
export function analyzePerformance(db: Database): void
⋮----
// Basic index usage analysis
⋮----
// Show detailed query performance for common patterns
⋮----
// Check if statistics need updating
⋮----
// Get last ANALYZE time
⋮----
// Show index coverage

================
File: packages/cli-commands/src/commands/stats.ts
================
import type { Database } from "bun:sqlite";
⋮----
/**
 * Reset all account statistics
 */
export function resetAllStats(db: Database): void
⋮----
/**
 * Clear all request history
 */
export function clearRequestHistory(db: Database):

================
File: packages/cli-commands/src/prompts/adapter.ts
================
/**
 * Prompt adapter interface for abstracting user input collection
 */
export interface PromptAdapter {
	/**
	 * Present a selection menu to the user
	 * @param question The question to ask
	 * @param options Array of options with label and value
	 * @returns Promise resolving to the selected value
	 */
	select<T extends string | number>(
		question: string,
		options: Array<{ label: string; value: T }>,
	): Promise<T>;

	/**
	 * Get text input from the user
	 * @param question The question to ask
	 * @param mask Whether to mask the input (for passwords)
	 * @returns Promise resolving to the entered text
	 */
	input(question: string, mask?: boolean): Promise<string>;

	/**
	 * Get a yes/no confirmation from the user
	 * @param question The question to ask
	 * @returns Promise resolving to true if confirmed, false otherwise
	 */
	confirm(question: string): Promise<boolean>;
}
⋮----
/**
	 * Present a selection menu to the user
	 * @param question The question to ask
	 * @param options Array of options with label and value
	 * @returns Promise resolving to the selected value
	 */
select<T extends string | number>(
		question: string,
		options: Array<{ label: string; value: T }>,
	): Promise<T>;
⋮----
/**
	 * Get text input from the user
	 * @param question The question to ask
	 * @param mask Whether to mask the input (for passwords)
	 * @returns Promise resolving to the entered text
	 */
input(question: string, mask?: boolean): Promise<string>;
⋮----
/**
	 * Get a yes/no confirmation from the user
	 * @param question The question to ask
	 * @returns Promise resolving to true if confirmed, false otherwise
	 */
confirm(question: string): Promise<boolean>;

================
File: packages/cli-commands/src/prompts/index.ts
================
import { stdPromptAdapter } from "./std-adapter";
⋮----
// Re-export adapter types
⋮----
/**
 * Prompt user to select account mode
 */
export async function promptAccountMode(): Promise<"max" | "console">
⋮----
/**
 * Prompt user to select account tier
 */
export async function promptAccountTier(): Promise<1 | 5 | 20>
⋮----
/**
 * Prompt user to enter authorization code
 */
export async function promptAuthorizationCode(): Promise<string>
⋮----
/**
 * Prompt user to confirm account removal
 */
export async function promptAccountRemovalConfirmation(
	accountName: string,
): Promise<boolean>

================
File: packages/cli-commands/src/prompts/std-adapter.ts
================
import type { PromptAdapter } from "./adapter";
⋮----
/**
 * Standard prompt adapter using blocking prompt() calls
 */
export class StdPromptAdapter implements PromptAdapter
async select<T extends string | number>(
⋮----
async select<T extends string | number>(
		question: string,
		options: Array<{ label: string; value: T }>,
): Promise<T>
⋮----
async input(question: string, _mask?: boolean): Promise<string>
⋮----
// Note: Bun's prompt() doesn't support masking, so we ignore the mask parameter
⋮----
async confirm(question: string): Promise<boolean>
⋮----
// Export singleton instance

================
File: packages/cli-commands/src/index.ts
================
// Export all commands
⋮----
// Export prompts
⋮----
// Export main CLI runner
⋮----
// Export utilities

================
File: packages/cli-commands/src/runner.ts
================
import { parseArgs } from "node:util";
import { Config } from "@ccflare/config";
import { shutdown } from "@ccflare/core";
import { container, SERVICE_KEYS } from "@ccflare/core-di";
import { DatabaseFactory } from "@ccflare/database";
import {
	addAccount,
	getAccountsList,
	pauseAccount,
	removeAccountWithConfirmation,
	resumeAccount,
} from "./commands/account";
import { analyzePerformance } from "./commands/analyze";
import { getHelpText } from "./commands/help";
import { clearRequestHistory, resetAllStats } from "./commands/stats";
⋮----
/**
 * Main CLI runner
 */
export async function runCli(argv: string[]): Promise<void>
⋮----
// Initialize DI container and services
⋮----
// Parse command line arguments
⋮----
// Parse options
⋮----
// Header
⋮----
// Rows
⋮----
// Always shutdown resources

================
File: packages/cli-commands/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/config/src/paths-common.ts
================
import { homedir } from "node:os";
import { join } from "node:path";
import { platform } from "node:process";
⋮----
/**
 * Get the platform-specific configuration directory for ccflare
 */
export function getPlatformConfigDir(): string
⋮----
// Windows: Use LOCALAPPDATA or APPDATA
⋮----
// Linux/macOS: Follow XDG Base Directory specification

================
File: packages/config/src/paths.ts
================
import { join } from "node:path";
import { getPlatformConfigDir } from "./paths-common";
⋮----
export function resolveConfigPath(): string
⋮----
// Check for explicit config path from environment
⋮----
// Use common platform config directory

================
File: packages/config/package.json
================
{
	"name": "@ccflare/config",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/logger": "workspace:*"
	}
}

================
File: packages/config/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/core/src/constants.ts
================
/**
 * Centralized constants for the ccflare application
 * All magic numbers should be defined here to improve maintainability
 */
⋮----
// Time constants (all in milliseconds)
⋮----
// Base units
⋮----
// Session durations
SESSION_DURATION_DEFAULT: 5 * 60 * 60 * 1000, // 5 hours
SESSION_DURATION_FALLBACK: 3600000, // 1 hour
⋮----
// Timeouts
STREAM_TIMEOUT_DEFAULT: 1000 * 60 * 1, // 1 minute
OAUTH_STATE_TTL: 10, // 10 minutes (stored separately as minutes)
RETRY_DELAY_DEFAULT: 1000, // 1 second
⋮----
// Cache durations
CACHE_YEAR: 31536000, // 365 days in seconds for HTTP cache headers
⋮----
// Buffer sizes (in bytes unless specified)
⋮----
// Stream usage buffer size in KB (multiplied by 1024 to get bytes)
⋮----
// Stream body max size
⋮----
STREAM_BODY_MAX_BYTES: 256 * 1024, // 256KB default
⋮----
// Anthropic provider stream cap
ANTHROPIC_STREAM_CAP_BYTES: 32768, // 32KB
⋮----
// Stream tee default max bytes
STREAM_TEE_MAX_BYTES: 1024 * 1024, // 1MB
⋮----
// Log file size
LOG_FILE_MAX_SIZE: 10 * 1024 * 1024, // 10MB
⋮----
// Network constants
⋮----
// Ports
⋮----
// Timeouts
IDLE_TIMEOUT_MAX: 255, // Max allowed by Bun
⋮----
// Cache control headers
⋮----
// HTTP cache control max-age values (in seconds)
STATIC_ASSETS_MAX_AGE: 31536000, // 1 year
⋮----
// Request/Response limits
⋮----
// Request history limits
⋮----
// Account name constraints
⋮----
// UI formatting
⋮----
// HTTP status codes
⋮----
// Account tiers - removed unused ACCOUNT_TIERS export
// Statistical calculations - removed unused STATS export

================
File: packages/core/src/errors.ts
================
/**
 * Custom error classes for standardized error handling across the application
 */
⋮----
/**
 * Base error class for all application errors
 */
export abstract class AppError extends Error
⋮----
constructor(
		message: string,
		public readonly code: string,
		public readonly statusCode: number,
		context?: Record<string, unknown>,
)
⋮----
toJSON()
⋮----
/**
 * Authentication and authorization errors
 */
export class AuthError extends AppError
⋮----
constructor(message: string, context?: Record<string, unknown>)
⋮----
export class TokenRefreshError extends AuthError
⋮----
constructor(accountId: string, originalError?: Error)
⋮----
/**
 * Rate limiting errors
 */
export class RateLimitError extends AppError
⋮----
constructor(
		public readonly accountId: string,
		public readonly resetTime: number,
		public readonly remaining?: number,
)
⋮----
/**
 * Validation errors
 */
export class ValidationError extends AppError
⋮----
constructor(
		message: string,
		public readonly field?: string,
		public readonly value?: unknown,
)
⋮----
/**
 * Provider errors
 */
export class ProviderError extends AppError
⋮----
constructor(
		message: string,
		public readonly provider: string,
		statusCode = 502,
		context?: Record<string, unknown>,
)
⋮----
export class OAuthError extends ProviderError
⋮----
constructor(
		message: string,
		provider: string,
		public readonly oauthCode?: string,
)
⋮----
/**
 * Service unavailable errors
 */
export class ServiceUnavailableError extends AppError
⋮----
constructor(
		message: string,
		public readonly service?: string,
)
⋮----
/**
 * Type guards
 */
export function isAppError(error: unknown): error is AppError
⋮----
/**
 * Error logger that sanitizes sensitive data
 */
export function logError(
	error: unknown,
	logger: { error: (msg: string, ...args: unknown[]) => void },
): void
⋮----
// Sanitize sensitive context data
⋮----
/**
 * Sanitize error context to remove sensitive data
 */
function sanitizeErrorContext(
	context: Record<string, unknown>,
): Record<string, unknown>

================
File: packages/core/src/lifecycle.ts
================
export interface Disposable {
	dispose(): Promise<void> | void;
}
⋮----
dispose(): Promise<void> | void;
⋮----
class LifecycleManager
⋮----
register(disposable: Disposable): void
⋮----
unregister(disposable: Disposable): void
⋮----
async shutdown(): Promise<void>
⋮----
// Dispose in reverse order of registration
⋮----
clear(): void
⋮----
// Global lifecycle manager instance
⋮----
export function registerDisposable(disposable: Disposable): void
⋮----
export function unregisterDisposable(disposable: Disposable): void
⋮----
export async function shutdown(): Promise<void>
⋮----
export function clearDisposables(): void

================
File: packages/core/src/strategy.ts
================
import { type Account, StrategyName } from "@ccflare/types";
⋮----
// Array of all strategies for backwards compatibility
⋮----
export function isValidStrategy(strategy: string): strategy is StrategyName
⋮----
// Default load balancing strategy
⋮----
// Helper to check if an account is available (not rate-limited or paused)
export function isAccountAvailable(
	account: Account,
	now = Date.now(),
): boolean
⋮----
// Re-export from types package for backwards compatibility

================
File: packages/core/package.json
================
{
	"name": "@ccflare/core",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/types": "workspace:*"
	}
}

================
File: packages/core/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/core-di/src/container.ts
================
type ServiceFactory<T> = () => T;
type ServiceKey = string | symbol;
⋮----
class Container
⋮----
register<T>(key: ServiceKey, factory: ServiceFactory<T>): void
⋮----
registerInstance<T>(key: ServiceKey, instance: T): void
⋮----
resolve<T>(key: ServiceKey): T
⋮----
// Check if instance already exists
⋮----
// Check if factory exists
⋮----
// Create instance and cache it (singleton)
⋮----
has(key: ServiceKey): boolean
⋮----
clear(): void
⋮----
// Global container instance

================
File: packages/core-di/src/index.ts
================
import { container as _container } from "./container";
⋮----
// Service keys - using symbols for better encapsulation
⋮----
// Type-safe service resolution helper
export function getService<T>(key: keyof typeof SERVICE_KEYS): T

================
File: packages/core-di/package.json
================
{
	"name": "@ccflare/core-di",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	}
}

================
File: packages/core-di/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/dashboard-web/src/components/accounts/DeleteConfirmationDialog.tsx
================
import { AlertCircle } from "lucide-react";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Input } from "../ui/input";
import { Label } from "../ui/label";
⋮----
interface DeleteConfirmationDialogProps {
	accountName: string;
	confirmInput: string;
	onConfirmInputChange: (value: string) => void;
	onConfirm: () => void;
	onCancel: () => void;
}
⋮----
export function DeleteConfirmationDialog({
	accountName,
	confirmInput,
	onConfirmInputChange,
	onConfirm,
	onCancel,
}: DeleteConfirmationDialogProps)

================
File: packages/dashboard-web/src/components/agents/WorkspaceCard.tsx
================
import type { AgentWorkspace } from "@ccflare/types";
import { formatDistanceToNow } from "date-fns";
import { Folder, FolderOpen, Package } from "lucide-react";
import { Badge } from "../ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
⋮----
interface WorkspaceCardProps {
	workspace: AgentWorkspace & { agentCount?: number };
	isActive?: boolean;
}

================
File: packages/dashboard-web/src/components/analytics/AnalyticsControls.tsx
================
import { CalendarDays, RefreshCw } from "lucide-react";
import type { TimeRange } from "../../constants";
import { Button } from "../ui/button";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { AnalyticsFilters, type FilterState } from "./AnalyticsFilters";
⋮----
interface AnalyticsControlsProps {
	timeRange: TimeRange;
	setTimeRange: (range: TimeRange) => void;
	viewMode: "normal" | "cumulative";
	setViewMode: (mode: "normal" | "cumulative") => void;
	filters: FilterState;
	setFilters: (filters: FilterState) => void;
	availableAccounts: string[];
	availableModels: string[];
	activeFilterCount: number;
	filterOpen: boolean;
	setFilterOpen: (open: boolean) => void;
	loading: boolean;
	onRefresh: () => void;
}
⋮----
export function AnalyticsControls({
	timeRange,
	setTimeRange,
	viewMode,
	setViewMode,
	filters,
	setFilters,
	availableAccounts,
	availableModels,
	activeFilterCount,
	filterOpen,
	setFilterOpen,
	loading,
	onRefresh,
}: AnalyticsControlsProps)
⋮----
onValueChange=
⋮----
onClick=

================
File: packages/dashboard-web/src/components/analytics/AnalyticsFilters.tsx
================
import { Filter } from "lucide-react";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import { Label } from "../ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "../ui/popover";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Separator } from "../ui/separator";
⋮----
export interface FilterState {
	accounts: string[];
	models: string[];
	status: "all" | "success" | "error";
}
⋮----
interface AnalyticsFiltersProps {
	filters: FilterState;
	setFilters: (filters: FilterState) => void;
	availableAccounts: string[];
	availableModels: string[];
	activeFilterCount: number;
	filterOpen: boolean;
	setFilterOpen: (open: boolean) => void;
}
⋮----
{/* Status Filter */}
⋮----
{/* Account Filter */}
⋮----
checked=
⋮----
setFilters({
														...filters,
														accounts: [...filters.accounts, account],
													});
⋮----
{/* Model Filter */}
⋮----
setFilters({
														...filters,
														models: [...filters.models, model],
													});

================
File: packages/dashboard-web/src/components/charts/BasePieChart.tsx
================
import type { ReactNode } from "react";
import {
	Cell,
	Legend,
	Pie,
	PieChart,
	ResponsiveContainer,
	Tooltip,
} from "recharts";
import {
	CHART_COLORS,
	type CHART_HEIGHTS,
	type CHART_TOOLTIP_STYLE,
} from "../../constants";
import { ChartContainer } from "./ChartContainer";
import { getChartHeight, getTooltipStyles } from "./chart-utils";
import type { ChartClickHandler, TooltipFormatterFunction } from "./types";
⋮----
interface BasePieChartProps {
	data: Array<{ name: string; value: number; [key: string]: string | number }>;
	dataKey?: string;
	nameKey?: string;
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	innerRadius?: number;
	outerRadius?: number;
	paddingAngle?: number;
	cx?: string | number;
	cy?: string | number;
	colors?: string[];
	tooltipFormatter?: TooltipFormatterFunction;
	tooltipStyle?: keyof typeof CHART_TOOLTIP_STYLE | object;
	animationDuration?: number;
	showLegend?: boolean;
	legendLayout?: "horizontal" | "vertical";
	legendAlign?: "left" | "center" | "right";
	legendVerticalAlign?: "top" | "middle" | "bottom";
	renderLabel?: boolean;
	className?: string;
	error?: Error | null;
	emptyState?: ReactNode;
	onPieClick?: ChartClickHandler;
}

================
File: packages/dashboard-web/src/components/charts/ChartContainer.tsx
================
import { RefreshCw } from "lucide-react";
import type { ReactNode } from "react";
import { CHART_HEIGHTS } from "../../constants";
⋮----
interface ChartContainerProps {
	children: ReactNode;
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	className?: string;
	error?: Error | null;
	emptyState?: ReactNode;
	isEmpty?: boolean;
}
⋮----
export function ChartContainer({
	children,
	loading = false,
	height = "medium",
	className = "",
	error = null,
	emptyState,
	isEmpty = false,
}: ChartContainerProps)

================
File: packages/dashboard-web/src/components/charts/ChartTooltip.tsx
================
import { CHART_TOOLTIP_STYLE } from "../../constants";
import type { TooltipFormatterValue } from "./types";
⋮----
interface PayloadItem {
	dataKey: string;
	value: TooltipFormatterValue;
	name?: string;
	color?: string;
}
⋮----
interface ChartTooltipProps {
	active?: boolean;
	payload?: PayloadItem[];
	label?: string;
	formatters?: Record<string, (value: TooltipFormatterValue) => string>;
	labelFormatter?: (label: string) => string;
	style?: keyof typeof CHART_TOOLTIP_STYLE | object;
}
⋮----
export function ChartTooltip({
	active,
	payload,
	label,
	formatters = {},
	labelFormatter,
	style = "default",
}: ChartTooltipProps)

================
File: packages/dashboard-web/src/components/charts/ResponseTimeChart.tsx
================
import { COLORS } from "../../constants";
import { BaseAreaChart } from "./BaseAreaChart";
⋮----
interface ResponseTimeChartProps {
	data: Array<{
		time: string;
		responseTime: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}
⋮----
export function ResponseTimeChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: ResponseTimeChartProps)

================
File: packages/dashboard-web/src/components/charts/types.ts
================
// Common types for chart components
export type ChartDataPoint = Record<string, string | number>;
⋮----
export type TooltipFormatterValue = string | number | [number, number];
⋮----
export type TooltipFormatterFunction = (
	value: TooltipFormatterValue,
	name?: string,
) => [string, string] | string;
⋮----
// Use any for chart click handlers to match recharts types
// biome-ignore lint/suspicious/noExplicitAny: recharts types require any
export type ChartClickHandler = (data: any) => void;

================
File: packages/dashboard-web/src/components/overview/ChartsSection.tsx
================
import { CHART_COLORS, COLORS } from "../../constants";
import {
	BaseAreaChart,
	BaseBarChart,
	BaseLineChart,
	BasePieChart,
} from "../charts";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
⋮----
interface ChartsSectionProps {
	timeSeriesData: Array<{
		time: string;
		requests: number;
		successRate: number;
		responseTime: number;
		cost: string;
	}>;
	modelData: Array<{ name: string; value: number }>;
	accountHealthData: Array<{
		name: string;
		requests: number;
		successRate: number;
	}>;
	loading: boolean;
}
⋮----
{/* Charts Row 1 */}
⋮----
{/* Request Volume Chart */}
⋮----
{/* Success Rate Chart */}
⋮----
{/* Charts Row 2 */}
⋮----
{/* Model Distribution */}
⋮----
{/* Account Health */}

================
File: packages/dashboard-web/src/components/overview/LoadingSkeleton.tsx
================
import { Card, CardContent, CardHeader } from "../ui/card";
import { Skeleton } from "../ui/skeleton";
⋮----
// biome-ignore lint/suspicious/noArrayIndexKey: Skeleton cards are temporary placeholders

================
File: packages/dashboard-web/src/components/overview/SystemStatus.tsx
================
import { CheckCircle, XCircle } from "lucide-react";
import { Badge } from "../ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
⋮----
interface SystemStatusProps {
	recentErrors?: string[];
}

================
File: packages/dashboard-web/src/components/ui/badge.tsx
================
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "../../lib/utils";
⋮----
interface BadgeProps
	extends React.HTMLAttributes<HTMLDivElement>,
		VariantProps<typeof badgeVariants> {}
⋮----
<div className={cn(badgeVariants({ variant }), className)} {...props} />
	);

================
File: packages/dashboard-web/src/components/ui/button.tsx
================
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "../../lib/utils";
⋮----
interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

================
File: packages/dashboard-web/src/components/ui/dropdown-menu.tsx
================
import { Check, ChevronRight, Circle } from "lucide-react";
⋮----
import { cn } from "../../lib/utils";
⋮----
className=

================
File: packages/dashboard-web/src/components/ui/input.tsx
================
import { cn } from "../../lib/utils";
⋮----
export interface InputProps
	extends React.InputHTMLAttributes<HTMLInputElement> {}
⋮----
className=

================
File: packages/dashboard-web/src/components/ui/label.tsx
================
import { cva, type VariantProps } from "class-variance-authority";
⋮----
import { cn } from "../../lib/utils";

================
File: packages/dashboard-web/src/components/ui/popover.tsx
================
import { cn } from "../../lib/utils";

================
File: packages/dashboard-web/src/components/ui/select.tsx
================
import { Check, ChevronDown } from "lucide-react";
⋮----
import { cn } from "../../lib/utils";
⋮----
className=

================
File: packages/dashboard-web/src/components/ui/separator.tsx
================
import { cn } from "../../lib/utils";

================
File: packages/dashboard-web/src/components/ui/skeleton.tsx
================
import { cn } from "../../lib/utils";
⋮----
className={cn("animate-pulse rounded-md bg-muted", className)}
			{...props}
		/>
	);

================
File: packages/dashboard-web/src/components/ui/switch.tsx
================
import { cn } from "../../lib/utils";
⋮----
className=

================
File: packages/dashboard-web/src/components/ui/tabs.tsx
================
import { cn } from "../../lib/utils";

================
File: packages/dashboard-web/src/components/CopyButton.tsx
================
import { Check, Copy } from "lucide-react";
import { type ComponentProps, useRef, useState } from "react";
import { cn } from "../lib/utils";
import { Button } from "./ui/button";
⋮----
interface CopyButtonProps {
	/**
	 * String or function returning the string to copy.
	 */
	value?: string;
	getValue?: () => string;
	/**
	 * Forwarded props to underlying Button
	 */
	variant?: ComponentProps<typeof Button>["variant"];
	size?: ComponentProps<typeof Button>["size"];
	className?: string;
	/**
	 * Children to render inside the button. If provided, an icon will be shown to the left.
	 */
	children?: React.ReactNode;
	/**
	 * Optional title attribute for accessibility.
	 */
	title?: string;
}
⋮----
/**
	 * String or function returning the string to copy.
	 */
⋮----
/**
	 * Forwarded props to underlying Button
	 */
⋮----
/**
	 * Children to render inside the button. If provided, an icon will be shown to the left.
	 */
⋮----
/**
	 * Optional title attribute for accessibility.
	 */
⋮----
/**
 * A small wrapper around the standard Button that copies supplied text to the
 * clipboard and temporarily shows a "Copied!" label with a subtle animation.
 */
⋮----
const handleCopy = () =>
⋮----
// Reset after 1.5s
⋮----
className=

================
File: packages/dashboard-web/src/components/StatsTab.tsx
================
import { formatPercentage } from "@ccflare/ui-common";
import { RefreshCw } from "lucide-react";
import { useResetStats, useStats } from "../hooks/queries";
import { useApiError } from "../hooks/useApiError";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
⋮----
export function StatsTab()
⋮----
const handleResetStats = async () =>
⋮----
// Since we can't set error directly, we'll just alert the user
⋮----
<p className="text-destructive">Error:
⋮----
onClick=

================
File: packages/dashboard-web/src/components/StrategyCard.tsx
================
import { RefreshCw, Settings } from "lucide-react";
import { useCallback, useEffect, useState } from "react";
import { api } from "../api";
import { Badge } from "./ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "./ui/select";
import { Skeleton } from "./ui/skeleton";
⋮----
const handleStrategyChange = async (newStrategy: string) =>

================
File: packages/dashboard-web/src/components/theme-toggle.tsx
================
import { Monitor, Moon, Sun } from "lucide-react";
import { useTheme } from "../contexts/theme-context";
import { Button } from "./ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "./ui/dropdown-menu";

================
File: packages/dashboard-web/src/components/TokenUsageDisplay.tsx
================
import { processTokenUsage } from "@ccflare/ui-common";
import type { RequestSummary } from "../api";
⋮----
interface TokenUsageDisplayProps {
	summary: RequestSummary | undefined;
}
⋮----
// Convert RequestSummary to TokenUsageData format, handling null -> undefined conversion

================
File: packages/dashboard-web/src/contexts/theme-context.tsx
================
import type React from "react";
import { createContext, useContext, useEffect, useState } from "react";
⋮----
type Theme = "dark" | "light" | "system";
⋮----
type ThemeContextType = {
	theme: Theme;
	setTheme: (theme: Theme) => void;
};
⋮----
export function ThemeProvider(
⋮----
const handleChange = () =>
⋮----
export function useTheme()

================
File: packages/dashboard-web/src/hooks/useApiError.ts
================
import {
	type ErrorFormatterOptions,
	type ErrorType,
	formatError as formatErrorFromPackage,
	getErrorType,
	isAuthError as isAuthErrorCheck,
	isNetworkError as isNetworkErrorCheck,
	isRateLimitError as isRateLimitErrorCheck,
} from "@ccflare/errors";
import { useCallback, useMemo } from "react";
⋮----
export interface UseApiErrorOptions extends ErrorFormatterOptions {
	/**
	 * Whether to log errors to console
	 * @default false
	 */
	logErrors?: boolean;
}
⋮----
/**
	 * Whether to log errors to console
	 * @default false
	 */
⋮----
export interface UseApiErrorReturn {
	/**
	 * Format an error into a user-friendly message
	 */
	formatError: (error: unknown) => string;
	/**
	 * Check if an error is a network error
	 */
	isNetworkError: (error: unknown) => boolean;
	/**
	 * Check if an error is an authentication error
	 */
	isAuthError: (error: unknown) => boolean;
	/**
	 * Check if an error is a rate limit error
	 */
	isRateLimitError: (error: unknown) => boolean;
	/**
	 * Get error type
	 */
	getErrorType: (error: unknown) => ErrorType;
}
⋮----
/**
	 * Format an error into a user-friendly message
	 */
⋮----
/**
	 * Check if an error is a network error
	 */
⋮----
/**
	 * Check if an error is an authentication error
	 */
⋮----
/**
	 * Check if an error is a rate limit error
	 */
⋮----
/**
	 * Get error type
	 */
⋮----
/**
 * Hook for consistent error handling across the dashboard
 *
 * @example
 * ```tsx
 * const { formatError, isNetworkError } = useApiError({
 *   errorMap: {
 *     "Network Error": "Unable to connect to the server. Please check your connection.",
 *   }
 * });
 *
 * try {
 *   await api.getAccounts();
 * } catch (err) {
 *   const message = formatError(err);
 *   setError(message);
 * }
 * ```
 */
export function useApiError(
	options: UseApiErrorOptions = {},
): UseApiErrorReturn
⋮----
// Memoize formatOptions to avoid re-creating on every render
⋮----
// Override auth error message for dashboard context
⋮----
// biome-ignore lint/correctness/useExhaustiveDependencies: formatOptions is destructured from options
⋮----
// Use the formatError from the errors package with custom auth message

================
File: packages/dashboard-web/src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
⋮----
export function cn(...inputs: ClassValue[])

================
File: packages/dashboard-web/src/favicon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <defs>
    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:1" />
    </linearGradient>
  </defs>
  <rect width="100" height="100" rx="20" fill="url(#gradient)"/>
  <text x="50" y="65" font-family="system-ui, -apple-system, sans-serif" font-size="48" font-weight="bold" text-anchor="middle" fill="white">CF</text>
</svg>

================
File: packages/dashboard-web/src/global.d.ts
================
/// <reference lib="dom" />
/// <reference lib="dom.iterable" />
⋮----
interface Window {
		EventSource: typeof EventSource;
	}

================
File: packages/dashboard-web/src/index.css
================
@layer base {
⋮----
:root {
⋮----
@apply font-sans;
⋮----
body {

================
File: packages/dashboard-web/src/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
    <title>ccflare Dashboard</title>
    <script type="module" src="./frontend.tsx" async></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>

================
File: packages/dashboard-web/styles/globals.css
================
@plugin "tailwindcss-animate";
⋮----
:root {
⋮----
--primary: hsl(24 89% 56%); /* ccflare Orange #F38020 */
⋮----
--accent: hsl(24 89% 56%); /* ccflare Orange */
⋮----
--ring: hsl(24 89% 56%); /* ccflare Orange */
⋮----
.dark {
⋮----
--background: hsl(220 13% 8%); /* Dark background like ccflare */
⋮----
--primary: hsl(24 89% 56%); /* ccflare Orange */
⋮----
@theme inline {
⋮----
@layer base {
⋮----
* {
body {
⋮----
/* Custom scrollbar */
::-webkit-scrollbar {
⋮----
::-webkit-scrollbar-track {
⋮----
@apply bg-background;
⋮----
::-webkit-scrollbar-thumb {
⋮----
::-webkit-scrollbar-thumb:hover {
⋮----
/* Charts custom styling */
.recharts-surface {
⋮----
/* Smooth transitions for theme switching */
⋮----
/* Glass morphism effects */
.glass {
⋮----
/* Gradient text */
.gradient-text {
⋮----
/* Card hover effects */
.card-hover {
⋮----
/* Success/Error/Warning colors */
.text-success {
⋮----
.text-warning {
⋮----
.bg-success {
⋮----
.bg-warning {

================
File: packages/dashboard-web/build.ts
================
import { existsSync } from "node:fs";
import { rm, writeFile } from "node:fs/promises";
import path from "node:path";
import plugin from "bun-plugin-tailwind";
⋮----
// Generate manifest.json with asset mappings

================
File: packages/dashboard-web/bunfig.toml
================
[serve.static]
plugins = ["bun-plugin-tailwind"]
env = "BUN_PUBLIC_*"

================
File: packages/dashboard-web/components.json
================
{
	"$schema": "https://ui.shadcn.com/schema.json",
	"style": "new-york",
	"rsc": false,
	"tsx": true,
	"tailwind": {
		"config": "",
		"css": "styles/globals.css",
		"baseColor": "zinc",
		"cssVariables": true,
		"prefix": ""
	},
	"aliases": {
		"components": "@/components",
		"utils": "@/lib/utils",
		"ui": "@/components/ui",
		"lib": "@/lib",
		"hooks": "@/hooks"
	},
	"iconLibrary": "lucide"
}

================
File: packages/dashboard-web/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"lib": ["ESNext", "DOM", "DOM.Iterable"],
		"target": "ESNext",
		"module": "ESNext",
		"moduleDetection": "force",
		"jsx": "react-jsx",
		"allowJs": true,
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"verbatimModuleSyntax": true,
		"noEmit": true,
		"strict": true,
		"skipLibCheck": true,
		"noFallthroughCasesInSwitch": true,
		"baseUrl": ".",
		"paths": {
			"@/*": ["./src/*"]
		}
	},
	"include": ["src/**/*"],
	"exclude": ["dist", "node_modules"]
}

================
File: packages/database/src/repositories/base.repository.ts
================
import type { Database } from "bun:sqlite";
⋮----
type QueryParams = Array<string | number | boolean | null | Buffer>;
⋮----
export abstract class BaseRepository<_T>
⋮----
constructor(protected db: Database)
⋮----
protected query<R>(sql: string, params: QueryParams = []): R[]
⋮----
protected get<R>(sql: string, params: QueryParams = []): R | null
⋮----
protected run(sql: string, params: QueryParams = []): void
⋮----
protected runWithChanges(sql: string, params: QueryParams = []): number

================
File: packages/database/src/repositories/oauth.repository.ts
================
import { BaseRepository } from "./base.repository";
⋮----
export interface OAuthSession {
	accountName: string;
	verifier: string;
	mode: "console" | "max";
	tier: number;
}
⋮----
export class OAuthRepository extends BaseRepository<OAuthSession>
⋮----
createSession(
		sessionId: string,
		accountName: string,
		verifier: string,
		mode: "console" | "max",
		tier: number,
		ttlMinutes = 10,
): void
⋮----
getSession(sessionId: string): OAuthSession | null
⋮----
deleteSession(sessionId: string): void
⋮----
cleanupExpiredSessions(): number

================
File: packages/database/src/repositories/stats.repository.ts
================
/**
 * Consolidated stats repository to eliminate duplication between tui-core and http-api
 */
import type { Database } from "bun:sqlite";
import { NO_ACCOUNT_ID } from "@ccflare/types";
⋮----
export interface AccountStats {
	name: string;
	requestCount: number;
	successRate: number;
	totalRequests?: number;
}
⋮----
export interface AggregatedStats {
	totalRequests: number;
	successfulRequests: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	inputTokens: number;
	outputTokens: number;
	cacheReadInputTokens: number;
	cacheCreationInputTokens: number;
	avgTokensPerSecond: number | null;
}
⋮----
export class StatsRepository
⋮----
constructor(private db: Database)
⋮----
/**
	 * Get aggregated statistics for all requests
	 */
getAggregatedStats(): AggregatedStats
⋮----
// Calculate total tokens
⋮----
/**
	 * Get account statistics with success rates
	 * This consolidates the duplicated logic between tui-core and http-api
	 */
getAccountStats(limit = 10, includeUnauthenticated = true): AccountStats[]
⋮----
// Get account request counts
⋮----
// Calculate success rate per account using a batch query
⋮----
// Create a map for O(1) lookup
⋮----
// Combine the data
⋮----
/**
	 * Get count of active accounts
	 */
getActiveAccountCount(): number
⋮----
/**
	 * Get recent errors (already exists in request.repository, but adding for completeness)
	 */
getRecentErrors(limit = 10): string[]
⋮----
/**
	 * Get top models by usage
	 */
getTopModels(
		limit = 5,
): Array<

================
File: packages/database/src/repositories/strategy.repository.ts
================
import { BaseRepository } from "./base.repository";
⋮----
export interface StrategyData {
	name: string;
	config: Record<string, unknown>;
	updatedAt: number;
}
⋮----
export class StrategyRepository extends BaseRepository<StrategyData>
⋮----
getStrategy(name: string): StrategyData | null
⋮----
set(name: string, config: Record<string, unknown>): void
⋮----
list(): StrategyData[]
⋮----
delete(name: string): boolean

================
File: packages/database/src/analyze-performance.ts
================
import { Database } from "bun:sqlite";
import { Logger } from "@ccflare/logger";
import { resolveDbPath } from "./paths";
import { analyzeIndexUsage } from "./performance-indexes";
⋮----
/**
 * Analyze query performance and index usage
 */
function analyzeQueryPerformance(db: Database)
⋮----
// Test queries that should benefit from the new indexes
⋮----
params: [Date.now() - 24 * 60 * 60 * 1000], // Last 24 hours
⋮----
// Run each test query with EXPLAIN QUERY PLAN
⋮----
// Get query plan
⋮----
// Time the actual query
⋮----
/**
 * Show index statistics
 */
function showIndexStats(db: Database)
⋮----
// Get index list with size estimates
⋮----
// Run ANALYZE to update statistics
⋮----
/**
 * Main function
 */
function main()
⋮----
// Show basic index usage analysis
⋮----
// Show detailed index statistics
⋮----
// Analyze query performance
⋮----
// Run if called directly

================
File: packages/database/src/async-writer.ts
================
import type { Disposable } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
⋮----
type DbJob = () => void | Promise<void>;
⋮----
export class AsyncDbWriter implements Disposable
⋮----
constructor()
⋮----
// Process queue every 100ms
⋮----
enqueue(job: DbJob): void
⋮----
// Immediately try to process if not already running
⋮----
private async processQueue(): Promise<void>
⋮----
async dispose(): Promise<void>
⋮----
// Stop the interval
⋮----
// Process any remaining jobs

================
File: packages/database/src/factory.ts
================
import { registerDisposable, unregisterDisposable } from "@ccflare/core";
import { DatabaseOperations, type RuntimeConfig } from "./index";
⋮----
export function initialize(
	dbPathParam?: string,
	runtimeConfigParam?: RuntimeConfig,
): void
⋮----
export function getInstance(): DatabaseOperations
⋮----
// Register with lifecycle manager
⋮----
export function closeAll(): void
⋮----
export function reset(): void

================
File: packages/database/src/index.ts
================
// Re-export the DatabaseOperations class
import { DatabaseOperations } from "./database-operations";
⋮----
// Re-export other utilities
⋮----
// Re-export repository types

================
File: packages/database/src/paths.ts
================
import { join } from "node:path";
import { getPlatformConfigDir } from "@ccflare/config";
⋮----
export function resolveDbPath(): string
⋮----
// Check for explicit DB path from environment
⋮----
// Use common platform config directory

================
File: packages/database/src/performance-indexes.ts
================
import type { Database } from "bun:sqlite";
import { Logger } from "@ccflare/logger";
⋮----
/**
 * Add performance indexes to improve query performance
 * This migration adds indexes based on common query patterns in the application
 */
export function addPerformanceIndexes(db: Database): void
⋮----
// 1. Composite index on requests(timestamp, account_used) for time-based account queries
// Used in analytics for filtering by time range and account
⋮----
// 2. Index on requests(model, timestamp) for model analytics
// Used in model distribution and performance queries
⋮----
// 3. Index on requests(success, timestamp) for success rate calculations
// Used in analytics for calculating success rates over time
⋮----
// 4. Index on accounts(paused) for finding active accounts
// Used in load balancer to quickly filter active accounts
⋮----
// 5. Index on requests(account_used, timestamp) for per-account analytics
// Used in account performance queries
⋮----
// 6. Additional indexes based on observed query patterns
⋮----
// Index for cost analysis queries
⋮----
// Index for response time analysis (for p95 calculations)
⋮----
// Index for token usage analysis
⋮----
// Index for account name lookups (used in analytics joins)
⋮----
// Index for rate limit checks
⋮----
// Index for session management
⋮----
// Composite index for account ordering in load balancer
⋮----
/**
 * Analyze current index usage and suggest optimizations
 */
export function analyzeIndexUsage(db: Database): void
⋮----
// Get all indexes
⋮----
// Analyze table statistics

================
File: packages/database/package.json
================
{
	"name": "@ccflare/database",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit",
		"analyze": "bun run ./src/analyze-performance.ts"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/logger": "workspace:*"
	}
}

================
File: packages/database/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/errors/src/index.ts
================
// Re-export core errors that are available
⋮----
// Error type constants
⋮----
export type ErrorType = (typeof ERROR_TYPES)[keyof typeof ERROR_TYPES];
⋮----
// HTTP error class for API responses
export class HttpError extends Error
⋮----
constructor(
		public status: number,
		message: string,
		public details?: unknown,
)
⋮----
// Common HTTP error factories
export const BadRequest = (message: string, details?: unknown)
⋮----
export const Unauthorized = (message: string, details?: unknown)
⋮----
export const Forbidden = (message: string, details?: unknown)
⋮----
export const NotFound = (message: string, details?: unknown)
⋮----
export const Conflict = (message: string, details?: unknown)
⋮----
export const UnprocessableEntity = (message: string, details?: unknown)
⋮----
export const TooManyRequests = (message: string, details?: unknown)
⋮----
export const InternalServerError = (message: string, details?: unknown)
⋮----
export const BadGateway = (message: string, details?: unknown)
⋮----
export const ServiceUnavailable = (message: string, details?: unknown)
⋮----
export const GatewayTimeout = (message: string, details?: unknown)
⋮----
// Error type detection
export function getErrorType(error: unknown): ErrorType
⋮----
// Check for specific error types in message
⋮----
// Error type checkers
export const isNetworkError = (error: unknown): boolean
⋮----
export const isAuthError = (error: unknown): boolean
⋮----
export const isRateLimitError = (error: unknown): boolean
⋮----
export const isValidationError = (error: unknown): boolean
⋮----
export const isServerError = (error: unknown): boolean
⋮----
// Default error messages
⋮----
// Error formatting options
export interface ErrorFormatterOptions {
	defaultMessage?: string;
	errorMap?: Record<string, string>;
	includeDetails?: boolean;
}
⋮----
// Format error for user display
export function formatError(
	error: unknown,
	options: ErrorFormatterOptions = {},
): string
⋮----
// Handle null/undefined
⋮----
// Handle Error instances
⋮----
// Check error map for custom messages
⋮----
// Get error type and use default message if appropriate
⋮----
// For known error types, prefer the default message unless includeDetails is true
⋮----
// Return the actual error message
⋮----
// Handle string errors
⋮----
// Handle objects with message property
⋮----
// Fallback
⋮----
// Parse HTTP response error
export async function parseHttpError(response: Response): Promise<HttpError>
⋮----
// Ignore parsing errors

================
File: packages/errors/package.json
================
{
	"name": "@ccflare/errors",
	"version": "1.0.0",
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"scripts": {
		"typecheck": "tsc --noEmit",
		"lint": "biome check --write --unsafe"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*"
	},
	"devDependencies": {
		"@types/bun": "1.1.15",
		"typescript": "5.7.2"
	}
}

================
File: packages/errors/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"baseUrl": ".",
		"outDir": "./dist",
		"rootDir": "./src"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}

================
File: packages/http-api/src/handlers/health.ts
================
import type { Database } from "bun:sqlite";
import type { Config } from "@ccflare/config";
import { jsonResponse } from "@ccflare/http-common";
import type { HealthResponse } from "../types";
⋮----
/**
 * Create a health check handler
 */
export function createHealthHandler(db: Database, config: Config)

================
File: packages/http-api/src/handlers/logs-history.ts
================
import {
	errorResponse,
	InternalServerError,
	jsonResponse,
} from "@ccflare/http-common";
import { logFileWriter } from "@ccflare/logger";
⋮----
/**
 * Create a logs history handler to fetch past logs
 */
export function createLogsHistoryHandler()
⋮----
// Get the last 1000 logs by default

================
File: packages/http-api/src/handlers/logs.ts
================
import { sseResponse } from "@ccflare/http-common";
import { Logger, logBus } from "@ccflare/logger";
import type { LogEvent } from "@ccflare/types";
⋮----
/**
 * Create a logs stream handler using Server-Sent Events
 */
export function createLogsStreamHandler()
⋮----
// Use TransformStream for better Bun compatibility
⋮----
// Send initial connection message
⋮----
// Listen for log events
const handleLogEvent = async (event: LogEvent) =>
⋮----
// Stream closed
⋮----
// Subscribe to log events
⋮----
// Clean up on request abort
⋮----
// ReadableStream doesn't have a standard 'closed' property
// This is a workaround for stream closure detection
⋮----
// Just rely on the error handling in handleLogEvent
// to detect when the stream is closed

================
File: packages/http-api/src/handlers/requests.ts
================
import type { Database } from "bun:sqlite";
import type { DatabaseOperations } from "@ccflare/database";
import { jsonResponse } from "@ccflare/http-common";
import type { RequestResponse } from "../types";
⋮----
/**
 * Create a requests summary handler (existing functionality)
 */
export function createRequestsSummaryHandler(db: Database)
⋮----
/**
 * Create a detailed requests handler with full payload data
 */
export function createRequestsDetailHandler(dbOps: DatabaseOperations)
⋮----
// Add account name to the meta field if available

================
File: packages/http-api/src/handlers/stats.ts
================
import type { DatabaseOperations } from "@ccflare/database";
import { jsonResponse } from "@ccflare/http-common";
⋮----
/**
 * Create a stats handler
 */
export function createStatsHandler(dbOps: DatabaseOperations)
⋮----
// Get overall statistics using the consolidated repository
⋮----
// Get per-account stats (including unauthenticated requests)
⋮----
// Get recent errors
⋮----
// Get top models
⋮----
/**
 * Create a stats reset handler
 */
export function createStatsResetHandler(dbOps: DatabaseOperations)
⋮----
// Clear request history
⋮----
// Reset account statistics

================
File: packages/http-api/src/utils/handler-factory.ts
================
import { errorResponse } from "@ccflare/http-common";
import type { APIContext } from "../types";
⋮----
export interface HandlerOptions {
	requiresAuth?: boolean;
	method?: string;
}
⋮----
/**
 * Factory for creating consistent API handlers with error handling
 */
export function createHandler<T extends unknown[], R>(
	handler: (context: APIContext, ...args: T) => R | Promise<R>,
	_options: HandlerOptions = {},
): (...args: T) => Promise<Response>
⋮----
// In a real implementation, you'd pass the context here
// For now, we'll assume it's available through dependency injection
⋮----
/**
 * Helper for parsing and validating request body
 */
export async function parseRequestBody<T>(req: Request): Promise<T>
⋮----
/**
 * Helper for extracting common query parameters
 */
export function extractQueryParams(
	url: URL,
	params: string[],
): Record<string, string | null>

================
File: packages/http-api/src/utils/http-error.ts
================
// Re-export all HTTP utilities from the shared http-common package

================
File: packages/http-api/src/index.ts
================
// Export router - the main public API
⋮----
// Export types
⋮----
// Export utilities

================
File: packages/http-api/package.json
================
{
	"name": "@ccflare/http-api",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/agents": "workspace:*",
		"@ccflare/core": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/oauth-flow": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}

================
File: packages/http-api/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/http-common/src/client.ts
================
import { HttpError, parseHttpError } from "@ccflare/errors";
⋮----
export interface RequestOptions extends RequestInit {
	timeout?: number;
	retries?: number;
	retryDelay?: number;
	baseUrl?: string;
}
⋮----
export interface ClientOptions {
	baseUrl?: string;
	defaultHeaders?: HeadersInit;
	timeout?: number;
	retries?: number;
	retryDelay?: number;
}
⋮----
/**
 * Base HTTP client with common functionality
 */
export class HttpClient
⋮----
constructor(options: ClientOptions =
⋮----
/**
	 * Make an HTTP request with retries and timeout
	 */
async request<T = unknown>(
		url: string,
		options: RequestOptions = {},
): Promise<T>
⋮----
// Don't retry on client errors (4xx)
⋮----
// Don't retry on abort
⋮----
// Retry if we have attempts left
⋮----
/**
	 * Convenience methods
	 */
get<T = unknown>(url: string, options?: RequestOptions): Promise<T>
⋮----
post<T = unknown>(
		url: string,
		body?: unknown,
		options?: RequestOptions,
): Promise<T>
⋮----
put<T = unknown>(
		url: string,
		body?: unknown,
		options?: RequestOptions,
): Promise<T>
⋮----
patch<T = unknown>(
		url: string,
		body?: unknown,
		options?: RequestOptions,
): Promise<T>
⋮----
delete<T = unknown>(url: string, options?: RequestOptions): Promise<T>
⋮----
/**
	 * Delay helper for retries
	 */
private delay(ms: number): Promise<void>

================
File: packages/http-common/src/errors.ts
================
// Re-export HTTP errors from the unified errors package

================
File: packages/http-common/src/responses.ts
================
import { HttpError } from "./errors";
⋮----
/**
 * Create a JSON response with proper headers
 */
export function jsonResponse(
	data: unknown,
	status = 200,
	headers?: HeadersInit,
): Response
⋮----
/**
 * Create an error response from any error type
 */
export function errorResponse(error: unknown): Response
⋮----
// Handle generic errors
⋮----
// In browser context, we can't log to files
// Server-side code should handle logging before calling errorResponse
⋮----
/**
 * Create a success response with optional data
 */
export function successResponse(
	data?: unknown,
	message = "Success",
	status = 200,
): Response
⋮----
/**
 * Create a paginated response
 */
export function paginatedResponse<T>(
	items: T[],
	page: number,
	perPage: number,
	total: number,
	headers?: HeadersInit,
): Response
⋮----
/**
 * Create a streaming response for Server-Sent Events
 */
export function sseResponse(
	stream: ReadableStream,
	headers?: HeadersInit,
): Response

================
File: packages/http-common/package.json
================
{
	"name": "@ccflare/http-common",
	"private": true,
	"version": "0.0.0",
	"type": "module",
	"exports": {
		".": "./src/index.ts",
		"./*": "./src/*.ts"
	},
	"scripts": {
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/types": "workspace:*",
		"@ccflare/errors": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^22.10.2",
		"typescript": "^5.7.2"
	}
}

================
File: packages/http-common/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist"
	},
	"include": ["src/**/*"]
}

================
File: packages/load-balancer/src/strategies/index.ts
================
import { isAccountAvailable, TIME_CONSTANTS } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type {
	Account,
	LoadBalancingStrategy,
	RequestMeta,
	StrategyStore,
} from "@ccflare/types";
⋮----
export class SessionStrategy implements LoadBalancingStrategy
⋮----
constructor(
		sessionDurationMs: number = TIME_CONSTANTS.SESSION_DURATION_DEFAULT,
)
⋮----
initialize(store: StrategyStore): void
⋮----
private resetSessionIfExpired(account: Account): void
⋮----
// Reset session
⋮----
// Update the account object to reflect changes
⋮----
select(accounts: Account[], _meta: RequestMeta): Account[]
⋮----
// Find account with active session (most recent session_start within window)
⋮----
// If we have an active account and it's available, use it exclusively
⋮----
// Reset session if expired (shouldn't happen but just in case)
⋮----
// Return active account first, then others as fallback
⋮----
// No active session or active account is rate limited
// Filter available accounts
⋮----
// Pick the first available account and start a new session with it
⋮----
// Return chosen account first, then others as fallback

================
File: packages/load-balancer/src/index.ts
================


================
File: packages/load-balancer/package.json
================
{
	"name": "@ccflare/load-balancer",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/logger": "workspace:*"
	}
}

================
File: packages/load-balancer/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/logger/src/file-writer.ts
================
import { createWriteStream, existsSync, mkdirSync, statSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import {
	BUFFER_SIZES,
	type Disposable,
	LIMITS,
	registerDisposable,
} from "@ccflare/core";
import type { LogEvent } from "@ccflare/types";
⋮----
export class LogFileWriter implements Disposable
⋮----
constructor()
⋮----
// Create log directory in tmp folder
⋮----
private initStream(): void
⋮----
// Check if we need to rotate
⋮----
// Create write stream with append mode
⋮----
private rotateLog(): void
⋮----
// Simple rotation: just delete old log
// In production, you might want to keep a few rotated files
⋮----
// For now, just delete the old file
// In a production system, you'd rename it to keep history
⋮----
write(event: LogEvent): void
⋮----
async readLogs(limit: number = LIMITS.LOG_READ_DEFAULT): Promise<LogEvent[]>
⋮----
// Return the last N logs
⋮----
close(): void
⋮----
dispose(): void
⋮----
// Singleton instance
⋮----
// Register with lifecycle manager

================
File: packages/logger/src/index.ts
================
import { EventEmitter } from "node:events";
import type { LogEvent } from "@ccflare/types";
import { logFileWriter } from "./file-writer";
⋮----
export enum LogLevel {
	DEBUG = 0,
	INFO = 1,
	WARN = 2,
	ERROR = 3,
}
⋮----
export type LogFormat = "pretty" | "json";
⋮----
// Event emitter for log streaming
⋮----
export class Logger
⋮----
constructor(prefix: string = "", level: LogLevel = LogLevel.INFO)
⋮----
// Only show console output in debug mode or if ccflare_DEBUG is set
⋮----
private getLogLevelFromEnv(): LogLevel | null
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
private formatMessage(level: string, message: string, data?: any): string
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
debug(message: string, data?: any): void
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
info(message: string, data?: any): void
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
warn(message: string, data?: any): void
⋮----
// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any error type
error(message: string, error?: any): void
⋮----
setLevel(level: LogLevel): void
⋮----
// Update silentConsole when level changes
⋮----
getLevel(): LogLevel
⋮----
// Default logger instance

================
File: packages/logger/package.json
================
{
	"name": "@ccflare/logger",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}

================
File: packages/logger/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/oauth-flow/package.json
================
{
	"name": "@ccflare/oauth-flow",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/config": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}

================
File: packages/providers/src/oauth/base-oauth-provider.ts
================
import { generatePKCE } from "./pkce";
⋮----
export interface OAuthConfig {
	clientId: string;
	authorizationUrl: string;
	tokenUrl: string;
	redirectUri: string;
	scopes: string[];
}
⋮----
export interface OAuthTokens {
	accessToken: string;
	refreshToken?: string;
	expiresAt: number;
}
⋮----
/**
 * Base class for OAuth providers to reduce duplication
 */
export abstract class BaseOAuthProvider
⋮----
constructor(config: OAuthConfig)
⋮----
/**
	 * Generate authorization URL with PKCE
	 */
async generateAuthUrl(
		state: string,
): Promise<
⋮----
// Allow subclasses to add custom parameters
⋮----
/**
	 * Exchange authorization code for tokens
	 */
async exchangeCodeForTokens(
		code: string,
		verifier: string,
): Promise<OAuthTokens>
⋮----
// Allow subclasses to add custom token parameters
⋮----
/**
	 * Refresh tokens using refresh token
	 */
async refreshTokens(refreshToken: string): Promise<OAuthTokens>
⋮----
/**
	 * Hook for subclasses to add custom authorization parameters
	 */
protected addCustomAuthParams(_params: URLSearchParams): void
⋮----
// Default implementation does nothing
⋮----
/**
	 * Hook for subclasses to add custom token exchange parameters
	 */
protected addCustomTokenParams(_params: URLSearchParams): void
⋮----
// Default implementation does nothing
⋮----
/**
	 * Parse token response - must be implemented by subclasses
	 */
protected abstract parseTokenResponse(data: unknown): OAuthTokens;

================
File: packages/providers/src/oauth/index.ts
================


================
File: packages/providers/src/oauth/pkce.ts
================
import type { PKCEChallenge } from "../types";
⋮----
/**
 * Generate a PKCE challenge for OAuth flows
 */
export async function generatePKCE(): Promise<PKCEChallenge>
⋮----
// Generate random verifier
⋮----
// Calculate SHA-256 challenge
⋮----
/**
 * Base64 URL encode without padding
 */
function base64urlEncode(bytes: Uint8Array): string

================
File: packages/providers/src/providers/anthropic/index.ts
================


================
File: packages/providers/src/providers/anthropic/oauth.ts
================
import { OAuthError } from "@ccflare/core";
import type {
	OAuthProvider,
	OAuthProviderConfig,
	PKCEChallenge,
	TokenResult,
} from "../../types";
⋮----
export class AnthropicOAuthProvider implements OAuthProvider
⋮----
getOAuthConfig(mode: "console" | "max" = "console"): OAuthProviderConfig
⋮----
clientId: "", // Will be passed from config
⋮----
generateAuthUrl(config: OAuthProviderConfig, pkce: PKCEChallenge): string
⋮----
async exchangeCode(
		code: string,
		verifier: string,
		config: OAuthProviderConfig,
): Promise<TokenResult>
⋮----
// Failed to parse error response

================
File: packages/providers/src/providers/index.ts
================


================
File: packages/providers/src/index.ts
================
// Export all types
⋮----
// Export base provider class
⋮----
// Export OAuth utilities
⋮----
// Export providers
⋮----
// Export registry functions
⋮----
import { AnthropicProvider } from "./providers/anthropic/provider";
// Auto-register built-in providers
import { registry } from "./registry";

================
File: packages/providers/src/registry.ts
================
import type { OAuthProvider, Provider } from "./types";
⋮----
class ProviderRegistry
⋮----
/**
	 * Register a provider
	 */
registerProvider(provider: Provider): void
⋮----
// Auto-register OAuth provider if supported
⋮----
/**
	 * Get a provider by name
	 */
getProvider(name: string): Provider | undefined
⋮----
/**
	 * Get an OAuth provider by name
	 */
getOAuthProvider(name: string): OAuthProvider | undefined
⋮----
/**
	 * List all registered provider names
	 */
listProviders(): string[]
⋮----
/**
	 * List all providers that support OAuth
	 */
listOAuthProviders(): string[]
⋮----
/**
	 * Unregister a provider (useful for testing)
	 */
unregisterProvider(name: string): boolean
⋮----
/**
	 * Clear all providers (useful for testing)
	 */
clear(): void
⋮----
// Create singleton registry instance
⋮----
// Export convenience functions
export const registerProvider = (provider: Provider)
export const getProvider = (name: string)
export const getOAuthProvider = (name: string)
export const listProviders = ()
export const listOAuthProviders = ()

================
File: packages/providers/package.json
================
{
	"name": "@ccflare/providers",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*"
	}
}

================
File: packages/providers/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/proxy/src/handlers/account-selector.ts
================
import type { Account, RequestMeta } from "@ccflare/types";
import type { ProxyContext } from "./proxy-types";
⋮----
/**
 * Gets accounts ordered by the load balancing strategy
 * @param meta - Request metadata
 * @param ctx - The proxy context
 * @returns Array of ordered accounts
 */
export function getOrderedAccounts(
	meta: RequestMeta,
	ctx: ProxyContext,
): Account[]
⋮----
// Filter accounts by provider
⋮----
/**
 * Selects accounts for a request based on the load balancing strategy
 * @param meta - Request metadata
 * @param ctx - The proxy context
 * @returns Array of selected accounts
 */
export function selectAccountsForRequest(
	meta: RequestMeta,
	ctx: ProxyContext,
): Account[]

================
File: packages/proxy/src/handlers/index.ts
================


================
File: packages/proxy/src/handlers/proxy-types.ts
================
import type { RuntimeConfig } from "@ccflare/config";
import type { AsyncDbWriter, DatabaseOperations } from "@ccflare/database";
import type { Provider } from "@ccflare/providers";
import type { LoadBalancingStrategy } from "@ccflare/types";
⋮----
export interface ProxyContext {
	strategy: LoadBalancingStrategy;
	dbOps: DatabaseOperations;
	runtime: RuntimeConfig;
	provider: Provider;
	refreshInFlight: Map<string, Promise<string>>;
	asyncWriter: AsyncDbWriter;
	usageWorker: Worker;
}
⋮----
/** Error messages used throughout the proxy module */
⋮----
/** Timing constants */
⋮----
WORKER_SHUTDOWN_DELAY: 100, // ms
⋮----
/** HTTP headers used in proxy operations */

================
File: packages/proxy/src/handlers/request-handler.ts
================
import crypto from "node:crypto";
import { ValidationError } from "@ccflare/core";
import type { Provider } from "@ccflare/providers";
import type { RequestMeta } from "@ccflare/types";
import { ERROR_MESSAGES } from "./proxy-types";
⋮----
/**
 * Creates request metadata for tracking and analytics
 * @param req - The incoming request
 * @param url - The parsed URL
 * @returns Request metadata object
 */
export function createRequestMetadata(req: Request, url: URL): RequestMeta
⋮----
/**
 * Validates that the provider can handle the requested path
 * @param provider - The provider instance
 * @param pathname - The request path
 * @throws {ValidationError} If provider cannot handle the path
 */
export function validateProviderPath(
	provider: Provider,
	pathname: string,
): void
⋮----
/**
 * Prepares request body for analytics and creates body stream factory
 * @param req - The incoming request
 * @returns Object containing the buffered body and stream factory
 */
export async function prepareRequestBody(req: Request): Promise<
⋮----
/**
 * Makes the actual HTTP request to the provider
 * @param targetUrl - The target URL to fetch
 * @param method - HTTP method
 * @param headers - Request headers
 * @param createBodyStream - Function to create request body stream
 * @param hasBody - Whether the request has a body
 * @returns Promise resolving to the response
 */
export async function makeProxyRequest(
	targetUrl: string,
	method: string,
	headers: Headers,
	createBodyStream: () => ReadableStream<Uint8Array> | undefined,
	hasBody: boolean,
): Promise<Response>

================
File: packages/proxy/src/index.ts
================
// Re-export provider-related types and functions from @ccflare/providers

================
File: packages/proxy/src/stream-tee.ts
================
import { BUFFER_SIZES } from "@ccflare/core";
⋮----
/**
 * Tees a ReadableStream to capture data without blocking the original stream.
 * Allows buffering stream content for analytics while maintaining streaming performance.
 */
export function teeStream(
	upstream: ReadableStream<Uint8Array>,
	options: {
onChunk?: (chunk: Uint8Array)
⋮----
maxBytes?: number; // Max bytes to buffer (default: 1MB)
⋮----
async pull(controller)
⋮----
// Pass through to client immediately
⋮----
// Buffer for analytics if under limit
⋮----
// Still buffer this chunk partially to reach exactly maxBytes
⋮----
// Notify chunk handler
⋮----
cancel(reason)
⋮----
/**
 * Combines buffered chunks into a single Buffer
 */
export function combineChunks(chunks: Uint8Array[]): Buffer

================
File: packages/proxy/src/types.ts
================
export interface ProxyRequest {
	method: string;
	path: string;
	headers: Headers;
	body: ArrayBuffer | null;
	query: string;
}
⋮----
export interface ProxyResponse {
	status: number;
	statusText: string;
	headers: Headers;
	body: ReadableStream<Uint8Array> | string | null;
}

================
File: packages/proxy/package.json
================
{
	"name": "@ccflare/proxy",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/agents": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/core": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/ui-common": "workspace:*",
		"@dqbd/tiktoken": "^1.0.21"
	}
}

================
File: packages/proxy/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/tui-core/src/accounts.ts
================
import { openBrowser } from "@ccflare/cli-commands";
import { Config } from "@ccflare/config";
import { DatabaseFactory } from "@ccflare/database";
import { type BeginResult, createOAuthFlow } from "@ccflare/oauth-flow";
import type { AccountListItem, AddAccountOptions } from "@ccflare/types";
⋮----
export interface OAuthFlowResult extends BeginResult {
	// Extends BeginResult from oauth-flow package
}
⋮----
// Extends BeginResult from oauth-flow package
⋮----
/**
 * Begin OAuth flow for adding an account (TUI version)
 * Returns the auth URL and PKCE data needed to complete the flow
 */
export async function beginAddAccount(
	options: AddAccountOptions,
): Promise<OAuthFlowResult>
⋮----
// Create OAuth flow instance
⋮----
// Begin OAuth flow
⋮----
// Open browser
⋮----
/**
 * Complete OAuth flow after receiving authorization code
 */
export async function completeAddAccount(
	options: AddAccountOptions & { code: string; flowData: OAuthFlowResult },
): Promise<void>
⋮----
// Create OAuth flow instance
⋮----
// Complete OAuth flow
⋮----
/**
 * Legacy function for non-TUI usage
 */
export async function addAccount(options: AddAccountOptions): Promise<void>
⋮----
export async function getAccounts(): Promise<AccountListItem[]>
⋮----
export async function removeAccount(name: string): Promise<void>
⋮----
export async function pauseAccount(
	name: string,
): Promise<
⋮----
export async function resumeAccount(
	name: string,
): Promise<

================
File: packages/tui-core/src/logs.ts
================
import { logBus, logFileWriter } from "@ccflare/logger";
import type { LogEvent } from "@ccflare/types";
⋮----
export function streamLogs(callback: (log: LogEvent) => void): () => void
⋮----
const listener = (event: LogEvent) =>
⋮----
// Return unsubscribe function
⋮----
export async function getLogHistory(limit = 1000): Promise<LogEvent[]>

================
File: packages/tui-core/src/requests.ts
================
import { DatabaseFactory } from "@ccflare/database";
import type { RequestPayload } from "@ccflare/types";
⋮----
export interface RequestSummary {
	id: string;
	model?: string;
	inputTokens?: number;
	outputTokens?: number;
	totalTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	costUsd?: number;
	responseTimeMs?: number;
}
⋮----
export async function getRequests(limit = 100): Promise<RequestPayload[]>
⋮----
// Add account name if we have accountId
⋮----
export async function getRequestSummaries(
	limit = 100,
): Promise<Map<string, RequestSummary>>

================
File: packages/tui-core/src/stats.ts
================
import { DatabaseFactory } from "@ccflare/database";
⋮----
export interface Stats {
	totalRequests: number;
	successRate: number;
	activeAccounts: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	avgTokensPerSecond: number | null;
	tokenDetails?: {
		inputTokens: number;
		cacheReadInputTokens: number;
		cacheCreationInputTokens: number;
		outputTokens: number;
	};
	accounts: Array<{
		name: string;
		requestCount: number;
		successRate: number;
	}>;
	recentErrors: string[];
}
⋮----
export async function getStats(): Promise<Stats>
⋮----
// Get overall statistics using the consolidated repository
⋮----
// Get per-account stats using the consolidated repository
⋮----
// Get recent errors
⋮----
export async function resetStats(): Promise<void>
⋮----
// Clear request history
⋮----
// Reset account statistics
⋮----
export async function clearHistory(): Promise<void>
⋮----
export async function analyzePerformance(): Promise<void>

================
File: packages/tui-core/src/strategy.ts
================
import { Config } from "@ccflare/config";
⋮----
async function getPort(): Promise<number>
⋮----
export async function getStrategy(): Promise<string>
⋮----
export async function listStrategies(): Promise<string[]>
⋮----
export async function setStrategy(strategy: string): Promise<void>

================
File: packages/tui-core/package.json
================
{
	"name": "@ccflare/tui-core",
	"version": "1.0.0",
	"description": "Core controller logic for ccflare TUI",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/cli-commands": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/core": "workspace:*",
		"@ccflare/oauth-flow": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/types": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^20.0.0"
	}
}

================
File: packages/tui-core/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"module": "ESNext",
		"target": "ESNext",
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"types": ["node"]
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules"]
}

================
File: packages/types/src/context.ts
================
import type { Database } from "bun:sqlite";
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import type { Account } from "./account";
import type { RequestMeta } from "./api";
import type { StrategyStore } from "./strategy";
⋮----
// API context for HTTP handlers
export interface APIContext {
	db: Database;
	config: Config;
	dbOps: DatabaseOperations;
}
⋮----
// Load balancing strategy interface
export interface LoadBalancingStrategy {
	/**
	 * Return a filtered & ordered list of candidate accounts.
	 * Accounts that are rate-limited should be filtered out.
	 * The first account in the list should be tried first.
	 */
	select(accounts: Account[], meta: RequestMeta): Account[];

	/**
	 * Optional initialization method to inject dependencies
	 * Used for strategies that need access to a StrategyStore
	 */
	initialize?(store: StrategyStore): void;
}
⋮----
/**
	 * Return a filtered & ordered list of candidate accounts.
	 * Accounts that are rate-limited should be filtered out.
	 * The first account in the list should be tried first.
	 */
select(accounts: Account[], meta: RequestMeta): Account[];
⋮----
/**
	 * Optional initialization method to inject dependencies
	 * Used for strategies that need access to a StrategyStore
	 */
initialize?(store: StrategyStore): void;

================
File: packages/types/src/logging.ts
================
export interface LogEvent {
	ts: number;
	level: "DEBUG" | "INFO" | "WARN" | "ERROR";
	msg: string;
}

================
File: packages/types/src/strategy.ts
================
import type { Account } from "./account";
⋮----
export enum StrategyName {
	Session = "session",
}
⋮----
/**
 * Interface for strategy-specific database operations
 * Allows strategies to interact with the database without direct SQL access
 */
export interface StrategyStore {
	/**
	 * Reset session for an account
	 * Updates session_start and session_request_count
	 */
	resetAccountSession(accountId: string, timestamp: number): void;

	/**
	 * Get all accounts (optional method for strategies that need full account list)
	 */
	getAllAccounts?(): Account[];

	/**
	 * Update account request count
	 */
	updateAccountRequestCount?(accountId: string, count: number): void;

	/**
	 * Get account by ID
	 */
	getAccount?(accountId: string): Account | null;
}
⋮----
/**
	 * Reset session for an account
	 * Updates session_start and session_request_count
	 */
resetAccountSession(accountId: string, timestamp: number): void;
⋮----
/**
	 * Get all accounts (optional method for strategies that need full account list)
	 */
getAllAccounts?(): Account[];
⋮----
/**
	 * Update account request count
	 */
updateAccountRequestCount?(accountId: string, count: number): void;
⋮----
/**
	 * Get account by ID
	 */
getAccount?(accountId: string): Account | null;

================
File: packages/types/package.json
================
{
	"name": "@ccflare/types",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	}
}

================
File: packages/types/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/ui-common/src/components/TokenUsageDisplay.tsx
================
import {
	formatCost,
	formatDuration,
	formatTokens,
	formatTokensPerSecond,
} from "../formatters";
⋮----
/**
 * Token usage data structure
 */
export interface TokenUsageData {
	inputTokens?: number;
	outputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	totalTokens?: number;
	costUsd?: number;
	responseTimeMs?: number;
	tokensPerSecond?: number;
}
⋮----
/**
 * Processed token usage information for display
 */
export interface TokenUsageInfo {
	hasData: boolean;
	sections: {
		inputTokens?: { label: string; value: string };
		outputTokens?: { label: string; value: string };
		cacheReadTokens?: { label: string; value: string };
		cacheCreationTokens?: { label: string; value: string };
		totalTokens?: { label: string; value: string };
		cost?: { label: string; value: string };
		responseTime?: { label: string; value: string };
		tokensPerSecond?: { label: string; value: string };
	};
}
⋮----
/**
 * Process token usage data for display
 * This contains the shared business logic for both dashboard and TUI
 */
export function processTokenUsage(
	data: TokenUsageData | undefined,
): TokenUsageInfo
⋮----
// Input tokens
⋮----
// Output tokens
⋮----
// Cache read tokens
⋮----
// Cache creation tokens
⋮----
// Total tokens
⋮----
// Cost
⋮----
// Response time
⋮----
// Tokens per second
⋮----
/**
 * Helper to determine if there are cache tokens to display
 */
export function hasCacheTokens(data: TokenUsageData | undefined): boolean

================
File: packages/ui-common/src/formatters.ts
================
import { TIME_CONSTANTS } from "@ccflare/core";
⋮----
/**
 * Format duration in milliseconds to human-readable string
 */
export function formatDuration(ms: number): string
⋮----
/**
 * Format tokens with locale-aware thousands separator
 */
export function formatTokens(tokens?: number): string
⋮----
/**
 * Format USD cost with 4 decimal places
 */
export function formatCost(cost?: number): string
⋮----
/**
 * Format percentage with specified decimal places
 */
export function formatPercentage(value: number, decimals = 1): string
⋮----
/**
 * Format number with locale-aware thousands separator
 */
export function formatNumber(value: number): string
⋮----
/**
 * Format timestamp to locale string
 */
export function formatTimestamp(timestamp: number | string): string
⋮----
/**
 * Format tokens per second with 1 decimal place
 */
export function formatTokensPerSecond(tokensPerSecond?: number | null): string

================
File: packages/ui-common/package.json
================
{
	"name": "@ccflare/ui-common",
	"private": true,
	"version": "0.0.0",
	"type": "module",
	"exports": {
		".": "./src/index.ts",
		"./*": "./src/*.ts"
	},
	"scripts": {
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/types": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^22.10.2",
		"typescript": "^5.7.2"
	}
}

================
File: packages/ui-common/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist"
	},
	"include": ["src/**/*"]
}

================
File: packages/ui-constants/src/index.ts
================
// Color palette used across UI components
⋮----
// Chart color sequence for multi-series charts
⋮----
// Time range options for analytics
export type TimeRange = "1h" | "6h" | "24h" | "7d" | "30d";
⋮----
// Chart dimensions
⋮----
// Common chart tooltip styles
⋮----
// Chart common properties
⋮----
// API and data refresh intervals (in milliseconds)
⋮----
default: 30000, // 30 seconds
fast: 10000, // 10 seconds
slow: 60000, // 1 minute
⋮----
// API timeout
export const API_TIMEOUT = 30000; // 30 seconds
⋮----
// React Query configuration
⋮----
staleTime: 10000, // Consider data stale after 10 seconds
⋮----
// API default limits

================
File: packages/ui-constants/package.json
================
{
	"name": "@ccflare/ui-constants",
	"version": "1.0.0",
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"scripts": {
		"typecheck": "tsc --noEmit",
		"lint": "biome check --write --unsafe"
	},
	"devDependencies": {
		"@types/bun": "1.1.15",
		"typescript": "5.7.2"
	}
}

================
File: packages/ui-constants/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"baseUrl": ".",
		"outDir": "./dist",
		"rootDir": "./src"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}

================
File: .biomeignore
================
**/dist
**/dist/**
**/build
**/build/**
**/node_modules
**/node_modules/**
**/*.min.js
**/*.min.css
**/*.bundle.js
packages/dashboard-web/dist
packages/dashboard-web/dist/**

================
File: .env.example
================
# Port for the proxy server (optional, defaults to 8080)
PORT=8080

# Load-balancing strategy: least-requests | round-robin | session | weighted | weighted-round-robin
# - least-requests: Route to account with fewest requests (default)
# - round-robin: Distribute requests evenly across all accounts
# - session: Maintain 5-hour sessions per account
# - weighted: Route based on tier-adjusted request count (respects 1x, 5x, 20x tiers)
# - weighted-round-robin: Round-robin that gives more slots to higher tier accounts
LB_STRATEGY=least-requests

# Log level: DEBUG | INFO | WARN | ERROR (optional, defaults to INFO)
LOG_LEVEL=INFO

# Log format: pretty | json (optional, defaults to pretty)
# - pretty: Human-readable format with timestamps
# - json: Structured JSON logs for log aggregators
LOG_FORMAT=pretty

# Example of how to use the proxy with your application:
# ANTHROPIC_BASE_URL=http://localhost:8080

================
File: .gitignore
================
node_modules/
.env
.env.local
ccflare.db
ccflare.db-wal
ccflare.db-shm
dist/
.DS_Store
*.log
tsconfig.tsbuildinfo

================
File: biome.json
================
{
	"$schema": "https://biomejs.dev/schemas/2.1.2/schema.json",
	"vcs": {
		"enabled": true,
		"clientKind": "git",
		"useIgnoreFile": true
	},
	"files": {
		"ignoreUnknown": false,
		"includes": ["apps/**", "packages/**"]
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "tab"
	},
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "double"
		}
	},
	"assist": {
		"enabled": true,
		"actions": {
			"source": {
				"organizeImports": "on"
			}
		}
	}
}

================
File: LICENSE
================
MIT License

Copyright (c) 2025 snipeship

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
	"private": true,
	"name": "ccflare",
	"workspaces": [
		"apps/*",
		"packages/*"
	],
	"scripts": {
		"ccflare": "bun run build && bun run tui",
		"tui": "bun run apps/tui/src/main.ts",
		"dev": "bun run tui",
		"start": "bun run apps/server/src/server.ts",
		"server": "bun run apps/server/src/server.ts",
		"dev:server": "bun run --hot apps/server/src/server.ts",
		"dev:dashboard": "bun --hot packages/dashboard-web/src/index.tsx",
		"typecheck": "bunx tsc --noEmit",
		"build": "bun run build:dashboard && bun run build:tui",
		"build:dashboard": "bun run --cwd packages/dashboard-web build",
		"build:tui": "bun run --cwd apps/tui build",
		"build:lander": "bun run --cwd apps/lander build",
		"format": "bunx biome format --write .",
		"lint": "bunx --bun biome check --write --unsafe ."
	},
	"engines": {
		"bun": ">=1.2.8"
	},
	"devDependencies": {
		"@biomejs/biome": "2.1.2",
		"bun-types": "latest",
		"@types/bun": "latest",
		"typescript": "^5.0.0"
	},
	"overrides": {
		"react": "^19.0.0",
		"@types/react": "^19.0.0"
	}
}

================
File: packages/cli-commands/src/commands/help.ts
================
/**
 * Get help text for CLI commands
 */
export function getHelpText(): string

================
File: packages/cli-commands/src/utils/browser.ts
================
import { spawn } from "node:child_process";
import open from "open";
⋮----
/**
 * Try to open the user's default browser with the given URL.
 * Returns true on success, false otherwise.
 */
export async function openBrowser(url: string): Promise<boolean>
⋮----
// Fallback – Windows quoting is critical!
⋮----
// Use powershell -Command Start-Process 'url'
⋮----
// Linux generic fallback

================
File: packages/cli-commands/package.json
================
{
	"name": "@ccflare/cli-commands",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/core-di": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/oauth-flow": "workspace:*",
		"open": "^10.0.0"
	}
}

================
File: packages/core/src/validation.ts
================
/**
 * Input validation and sanitization utilities
 */
import { ValidationError } from "./errors";
⋮----
/**
 * Validates and sanitizes a string input
 */
export function validateString(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		minLength?: number;
		maxLength?: number;
		pattern?: RegExp;
		allowedValues?: readonly string[];
transform?: (value: string)
⋮----
// Handle undefined/null
⋮----
// Ensure it's a string
⋮----
// Apply transformation if provided
⋮----
// Validate length
⋮----
// Validate pattern
⋮----
// Validate allowed values
⋮----
/**
 * Validates and sanitizes a number input
 */
export function validateNumber(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		min?: number;
		max?: number;
		integer?: boolean;
		allowedValues?: readonly number[];
	} = {},
): number | undefined
⋮----
// Handle undefined/null
⋮----
// Convert string to number if needed
⋮----
// Validate integer
⋮----
// Validate range
⋮----
// Validate allowed values
⋮----
/**
 * Validates and sanitizes a boolean input
 */
export function validateBoolean(
	value: unknown,
	field: string,
	options: { required?: boolean } = {},
): boolean | undefined
⋮----
// Handle undefined/null
⋮----
// Handle boolean
⋮----
// Handle string booleans
⋮----
// Handle numbers
⋮----
/**
 * Validates and sanitizes an array input
 */
export function validateArray<T>(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		minLength?: number;
		maxLength?: number;
itemValidator?: (item: unknown, index: number)
⋮----
// Handle undefined/null
⋮----
// Ensure it's an array
⋮----
// Validate length
⋮----
// Validate items
⋮----
/**
 * Validates and sanitizes an object input
 */
export function validateObject<T extends Record<string, unknown>>(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		schema?: {
[K in keyof T]: (value: unknown)
⋮----
// Handle undefined/null
⋮----
// Ensure it's an object
⋮----
// Validate schema
⋮----
/**
 * Common string sanitizers
 */
⋮----
/**
 * Common validation patterns
 */
⋮----
// Account name: alphanumeric with spaces, hyphens, underscores, plus @ and . for email addresses
⋮----
// Path pattern for API endpoints

================
File: packages/dashboard-web/src/components/accounts/AccountAddForm.tsx
================
import { useState } from "react";
import { Button } from "../ui/button";
import { Input } from "../ui/input";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
⋮----
interface AccountAddFormProps {
	onAddAccount: (params: {
		name: string;
		mode: "max" | "console";
		tier: number;
	}) => Promise<{ authUrl: string; sessionId: string }>;
	onCompleteAccount: (params: {
		sessionId: string;
		code: string;
	}) => Promise<void>;
	onCancel: () => void;
	onSuccess: () => void;
	onError: (error: string) => void;
}
⋮----
const handleAddAccount = async () =>
⋮----
// Step 1: Initialize OAuth flow
⋮----
// Open auth URL in new tab
⋮----
// Move to code entry step
⋮----
const handleCodeSubmit = async () =>
⋮----
// Step 2: Complete OAuth flow
⋮----
// Success! Reset form
⋮----
const handleCancel = () =>
⋮----
setNewAccount(
⋮----
value=

================
File: packages/dashboard-web/src/components/accounts/RateLimitProgress.tsx
================
import { useEffect, useState } from "react";
import { cn } from "../../lib/utils";
import { Progress } from "../ui/progress";
⋮----
interface RateLimitProgressProps {
	resetIso: string | null;
	className?: string;
}
⋮----
const WINDOW_MS = 5 * 60 * 60 * 1000; // 5 hours in milliseconds
⋮----
const interval = setInterval(() => setNow(Date.now()), 10000); // Update every 10 seconds
⋮----
// Format time remaining

================
File: packages/dashboard-web/src/components/accounts/RenameAccountDialog.tsx
================
import { useState } from "react";
import { Button } from "../ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "../ui/dialog";
import { Input } from "../ui/input";
import { Label } from "../ui/label";
⋮----
interface RenameAccountDialogProps {
	isOpen: boolean;
	currentName: string;
	onClose: () => void;
	onRename: (newName: string) => void;
	isLoading?: boolean;
}
⋮----
export function RenameAccountDialog({
	isOpen,
	currentName,
	onClose,
	onRename,
	isLoading = false,
}: RenameAccountDialogProps)
⋮----
const handleSubmit = (e: React.FormEvent) =>
⋮----
// Validate new name
⋮----
const handleOpenChange = (open: boolean) =>

================
File: packages/dashboard-web/src/components/agents/index.ts
================


================
File: packages/dashboard-web/src/components/analytics/index.ts
================


================
File: packages/dashboard-web/src/components/analytics/ModelAnalytics.tsx
================
import { Activity, BarChart3, TrendingUp, Zap } from "lucide-react";
import { useState } from "react";
import type { TimeRange } from "../../constants";
import { ModelPerformanceComparison, ModelTokenSpeedChart } from "../charts";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../ui/tabs";
⋮----
interface ModelAnalyticsProps {
	modelPerformance: Array<{
		model: string;
		avgResponseTime: number;
		p95ResponseTime: number;
		errorRate: number;
		avgTokensPerSecond: number | null;
		minTokensPerSecond: number | null;
		maxTokensPerSecond: number | null;
	}>;
	costByModel: Array<{
		model: string;
		costUsd: number;
		requests: number;
		totalTokens?: number;
	}>;
	loading?: boolean;
	timeRange: TimeRange;
}
⋮----
// Prepare data for the comparison chart
⋮----
// Calculate cost per 1k tokens
⋮----
// Use actual token count for accurate calculation
⋮----
// Fallback: estimate based on average cost per request
⋮----
const _estimatedTokensPerRequest = 1000; // Rough estimate
⋮----
{/* Header with title and controls */}
⋮----
{/* Tabbed interface for different views */}
⋮----
{/* Multi-Metric Comparison Tab */}
⋮----
{/* Detailed Analysis Tab */}
⋮----
{/* Token Speed Chart */}
⋮----
{/* Model Stats Cards */}
⋮----
{/* Fastest Model Card */}
⋮----
{/* Most Reliable Model Card */}
⋮----
{/* Most Cost-Effective Model Card */}

================
File: packages/dashboard-web/src/components/analytics/TokenSpeedAnalytics.tsx
================
import { formatTokensPerSecond } from "@ccflare/ui-common";
import { Activity, Zap } from "lucide-react";
import type { TimeRange } from "../../constants";
import { ModelTokenSpeedChart } from "../charts/ModelTokenSpeedChart";
import { TokenSpeedChart } from "../charts/TokenSpeedChart";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";
⋮----
interface TokenSpeedAnalyticsProps {
	timeSeriesData: Array<{
		time: string;
		avgTokensPerSecond: number;
		[key: string]: string | number;
	}>;
	modelPerformance: Array<{
		model: string;
		avgTokensPerSecond: number | null;
		minTokensPerSecond: number | null;
		maxTokensPerSecond: number | null;
	}>;
	loading?: boolean;
	timeRange: TimeRange;
}
⋮----
export function TokenSpeedAnalytics({
	timeSeriesData,
	modelPerformance,
	loading = false,
	timeRange,
}: TokenSpeedAnalyticsProps)
⋮----
// Calculate overall statistics
⋮----
// Get the true maximum speed from model performance data
⋮----
// Find fastest model by peak speed
⋮----
{/* Statistics Cards */}
⋮----
{/* Charts */}

================
File: packages/dashboard-web/src/components/charts/BaseAreaChart.tsx
================
import type { ReactNode } from "react";
import {
	Area,
	AreaChart,
	CartesianGrid,
	Legend,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import {
	type CommonChartProps,
	getChartHeight,
	getTooltipStyles,
	isChartEmpty,
} from "./chart-utils";
⋮----
interface BaseAreaChartProps extends CommonChartProps {
	dataKey: string;
	color?: string;
	gradientId?: string;
	customGradient?: ReactNode;
	strokeWidth?: number;
	fillOpacity?: number;
}
⋮----
export function BaseAreaChart({
	data,
	dataKey,
	xAxisKey = "time",
	loading = false,
	height = "medium",
	color = COLORS.primary,
	gradientId = "colorGradient",
	customGradient,
	strokeWidth = 2,
	fillOpacity = 1,
	xAxisAngle = 0,
	xAxisTextAnchor = "middle",
	xAxisHeight = 30,
	xAxisTickFormatter,
	yAxisDomain,
	yAxisTickFormatter,
	tooltipFormatter,
	tooltipLabelFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	showLegend = false,
	legendHeight = 36,
	margin,
	className = "",
	error = null,
	emptyState,
	onChartClick,
}: BaseAreaChartProps)

================
File: packages/dashboard-web/src/components/charts/BaseBarChart.tsx
================
import {
	Bar,
	BarChart,
	CartesianGrid,
	Legend,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import {
	type CommonChartProps,
	getChartHeight,
	getTooltipStyles,
	isChartEmpty,
} from "./chart-utils";
⋮----
interface BarConfig {
	dataKey: string;
	fill?: string;
	name?: string;
	yAxisId?: string;
	radius?: [number, number, number, number];
}
⋮----
interface BaseBarChartProps extends CommonChartProps {
	bars: BarConfig | BarConfig[];
	layout?: "horizontal" | "vertical";
	xAxisType?: "number" | "category";
	yAxisType?: "number" | "category";
	yAxisWidth?: number;
	yAxisOrientation?: "left" | "right";
	secondaryYAxis?: boolean;
}

================
File: packages/dashboard-web/src/components/charts/BaseLineChart.tsx
================
import {
	CartesianGrid,
	Legend,
	Line,
	LineChart,
	ReferenceLine,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import {
	type CommonChartProps,
	getChartHeight,
	getTooltipStyles,
	isChartEmpty,
} from "./chart-utils";
⋮----
interface LineConfig {
	dataKey: string;
	stroke?: string;
	strokeWidth?: number;
	dot?: boolean;
	name?: string;
}
⋮----
interface ReferenceLineConfig {
	y: number;
	stroke?: string;
	strokeDasharray?: string;
	label?: string;
}
⋮----
interface BaseLineChartProps extends CommonChartProps {
	lines: LineConfig | LineConfig[];
	referenceLines?: ReferenceLineConfig[];
}

================
File: packages/dashboard-web/src/components/charts/BaseScatterChart.tsx
================
import type { ReactNode } from "react";
import {
	CartesianGrid,
	ResponsiveContainer,
	Scatter,
	ScatterChart,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import {
	type CHART_HEIGHTS,
	CHART_PROPS,
	type CHART_TOOLTIP_STYLE,
	COLORS,
} from "../../constants";
import { ChartContainer } from "./ChartContainer";
import { getChartHeight, getTooltipStyles, isChartEmpty } from "./chart-utils";
import type {
	ChartClickHandler,
	ChartDataPoint,
	TooltipFormatterFunction,
} from "./types";
⋮----
interface BaseScatterChartProps {
	data: ChartDataPoint[];
	xKey: string;
	yKey: string;
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	fill?: string;
	xAxisLabel?: string;
	yAxisLabel?: string;
	xAxisDomain?: [number | "auto", number | "auto"];
	xAxisTickFormatter?: (value: number | string) => string;
	yAxisDomain?: [number | "auto", number | "auto"];
	yAxisTickFormatter?: (value: number | string) => string;
	tooltipFormatter?: TooltipFormatterFunction;
	tooltipStyle?: keyof typeof CHART_TOOLTIP_STYLE | object;
	animationDuration?: number;
	margin?: { top?: number; right?: number; bottom?: number; left?: number };
	className?: string;
	error?: Error | null;
	emptyState?: ReactNode;
	onDotClick?: ChartClickHandler;
	renderLabel?: (entry: ChartDataPoint) => ReactNode;
}

================
File: packages/dashboard-web/src/components/charts/chart-utils.ts
================
import { CHART_HEIGHTS, CHART_TOOLTIP_STYLE } from "../../constants";
import type { ChartClickHandler, ChartDataPoint } from "./types";
⋮----
/**
 * Calculate chart height from height prop
 */
export function getChartHeight(
	height: keyof typeof CHART_HEIGHTS | number,
): number
⋮----
/**
 * Check if chart data is empty
 */
export function isChartEmpty(data: ChartDataPoint[] | undefined): boolean
⋮----
/**
 * Get tooltip styles from prop
 */
export function getTooltipStyles(
	tooltipStyle: keyof typeof CHART_TOOLTIP_STYLE | object,
): object
⋮----
/**
 * Common chart axis props
 */
export interface CommonAxisProps {
	xAxisKey?: string;
	xAxisAngle?: number;
	xAxisTextAnchor?: "start" | "middle" | "end";
	xAxisHeight?: number;
	xAxisTickFormatter?: (value: number | string) => string;
	yAxisDomain?: [number | "auto", number | "auto"];
	yAxisTickFormatter?: (value: number | string) => string;
}
⋮----
/**
 * Common chart props shared across all chart types
 */
export interface CommonChartProps extends CommonAxisProps {
	data: ChartDataPoint[];
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	className?: string;
	error?: Error | null;
	emptyState?: React.ReactNode;
	margin?: { top?: number; right?: number; bottom?: number; left?: number };
	showLegend?: boolean;
	legendHeight?: number;
	tooltipFormatter?: (value: number, name: string) => [string, string];
	tooltipLabelFormatter?: (label: string) => string;
	tooltipStyle?: keyof typeof CHART_TOOLTIP_STYLE | object;
	animationDuration?: number;
	onChartClick?: ChartClickHandler;
}

================
File: packages/dashboard-web/src/components/charts/CostChart.tsx
================
import { formatCost } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactCurrency } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";
⋮----
interface CostChartProps {
	data: Array<{
		time: string;
		cost: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}
⋮----
export function CostChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: CostChartProps)

================
File: packages/dashboard-web/src/components/charts/ModelPerformanceChart.tsx
================
import { formatPercentage } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseScatterChart } from "./BaseScatterChart";
⋮----
interface ModelPerformanceChartProps {
	data: Array<{
		model: string;
		avgTime: number;
		errorRate: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
}

================
File: packages/dashboard-web/src/components/charts/RequestVolumeChart.tsx
================
import { formatNumber } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";
⋮----
interface RequestVolumeChartProps {
	data: Array<{
		time: string;
		requests: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}
⋮----
export function RequestVolumeChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: RequestVolumeChartProps)

================
File: packages/dashboard-web/src/components/charts/TokenSpeedChart.tsx
================
import { formatTokensPerSecond } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";
⋮----
interface TokenSpeedChartProps {
	data: Array<{
		time: string;
		avgTokensPerSecond: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	timeRange?: string;
}
⋮----
export function TokenSpeedChart({
	data,
	loading = false,
	height = 400,
	timeRange = "24h",
}: TokenSpeedChartProps)
⋮----
// Filter out null values for better chart display

================
File: packages/dashboard-web/src/components/charts/TokenUsageChart.tsx
================
import { formatTokens } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";
⋮----
interface TokenUsageChartProps {
	data: Array<{
		time: string;
		tokens: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}
⋮----
export function TokenUsageChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: TokenUsageChartProps)

================
File: packages/dashboard-web/src/components/conversation/index.ts
================


================
File: packages/dashboard-web/src/components/conversation/ThinkingBlock.tsx
================
import { MessageSquare } from "lucide-react";
import React from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";
⋮----
interface ThinkingBlockProps {
	content: string;
}

================
File: packages/dashboard-web/src/components/conversation/ToolResultBlock.tsx
================
import { FileText } from "lucide-react";
import React from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";
⋮----
interface ToolResultBlockProps {
	content: string;
}

================
File: packages/dashboard-web/src/components/conversation/ToolUsageBlock.tsx
================
import { Terminal } from "lucide-react";
import React, { useMemo } from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";
⋮----
interface ToolUsageBlockProps {
	toolName: string;
	input?: Record<string, unknown>;
}
⋮----
function ToolUsageBlockComponent(

================
File: packages/dashboard-web/src/components/overview/DataRetentionCard.tsx
================
import { useEffect, useState } from "react";
import {
	useCleanupNow,
	useCompactDb,
	useRetention,
	useSetRetention,
} from "../../hooks/queries";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Input } from "../ui/input";

================
File: packages/dashboard-web/src/components/overview/MetricCard.tsx
================
import { formatPercentage } from "@ccflare/ui-common";
import { Info, TrendingDown, TrendingUp } from "lucide-react";
import { Card, CardContent } from "../ui/card";
import { Popover, PopoverContent, PopoverTrigger } from "../ui/popover";
⋮----
export interface MetricCardProps {
	title: string;
	value: string | number;
	change?: number;
	icon: React.ComponentType<{ className?: string }>;
	trend?: "up" | "down" | "flat";
	trendPeriod?: string;
}

================
File: packages/dashboard-web/src/components/overview/RateLimitInfo.tsx
================
import type { AccountResponse } from "@ccflare/types";
import { format } from "date-fns";
import { AlertCircle } from "lucide-react";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
⋮----
interface RateLimitInfoProps {
	accounts: AccountResponse[];
}

================
File: packages/dashboard-web/src/components/overview/TimeRangeSelector.tsx
================
import { Clock } from "lucide-react";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
⋮----
interface TimeRangeSelectorProps {
	value: string;
	onChange: (value: string) => void;
}

================
File: packages/dashboard-web/src/components/ui/card.tsx
================
import { cn } from "../../lib/utils";
⋮----
className=
⋮----
<div ref=

================
File: packages/dashboard-web/src/components/ui/dialog.tsx
================
import { X } from "lucide-react";
⋮----
import { cn } from "../../lib/utils";
⋮----
className=

================
File: packages/dashboard-web/src/components/ui/progress.tsx
================
import { cn } from "../../lib/utils";
⋮----
className=

================
File: packages/dashboard-web/src/components/ui/textarea.tsx
================
import { cn } from "../../lib/utils";
⋮----
export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

================
File: packages/dashboard-web/src/components/AccountsTab.tsx
================
import { AlertCircle, Plus } from "lucide-react";
import { useState } from "react";
import { type Account, api } from "../api";
import { useAccounts, useRenameAccount } from "../hooks/queries";
import { useApiError } from "../hooks/useApiError";
import {
	AccountAddForm,
	AccountList,
	DeleteConfirmationDialog,
	RenameAccountDialog,
} from "./accounts";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
⋮----
const handleAddAccount = async (params: {
		name: string;
		mode: "max" | "console";
		tier: number;
}) =>
⋮----
const handleCompleteAccount = async (params: {
		sessionId: string;
		code: string;
}) =>
⋮----
const handleRemoveAccount = (name: string) =>
⋮----
const handleConfirmDelete = async () =>
⋮----
const handleRename = (account: Account) =>
⋮----
const handleConfirmRename = async (newName: string) =>
⋮----
const handlePauseToggle = async (account: Account) =>
⋮----
onCancel=

================
File: packages/dashboard-web/src/components/LogsTab.tsx
================
import { Pause, Play, Trash2 } from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { api, type LogEntry } from "../api";
import { useLogHistory } from "../hooks/queries";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
⋮----
setLogs((prev) => [...prev.slice(-999), log]); // Keep last 1000 logs
// Auto-scroll to bottom when new log arrives
⋮----
// Load historical logs on mount
⋮----
// Auto-scroll to bottom after loading history
⋮----
const clearLogs = () =>
⋮----
const togglePause = () =>
⋮----
const getLogColor = (level: string | undefined) =>
⋮----
const formatTimestamp = (ts: number) =>

================
File: packages/dashboard-web/src/components/RequestDetailsModal.tsx
================
import { formatCost, formatTimestamp, formatTokens } from "@ccflare/ui-common";
import { Eye } from "lucide-react";
import { useState } from "react";
import type { RequestPayload, RequestSummary } from "../api";
import { ConversationView } from "./ConversationView";
import { CopyButton } from "./CopyButton";
import { TokenUsageDisplay } from "./TokenUsageDisplay";
import { Badge } from "./ui/badge";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogHeader,
	DialogTitle,
} from "./ui/dialog";
import { Label } from "./ui/label";
import { Switch } from "./ui/switch";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/tabs";
⋮----
interface RequestDetailsModalProps {
	request: RequestPayload;
	summary: RequestSummary | undefined;
	isOpen: boolean;
	onClose: () => void;
}
⋮----
const decodeBase64 = (str: string | null): string =>
⋮----
const formatJson = (str: string): string =>
⋮----
// If it's not valid JSON, return as-is
⋮----
const formatHeaders = (headers: Record<string, string>): string =>
⋮----
const formatBody = (body: string | null): string =>
⋮----
requestBody=
responseBody=
⋮----
getValue=

================
File: packages/dashboard-web/src/hooks/useCollapsible.ts
================
import { useMemo, useState } from "react";
⋮----
export const useCollapsible = (content: string, limit: number) =>
⋮----
const toggle = ()

================
File: packages/dashboard-web/src/lib/chart-utils.ts
================
/**
 * Format numbers in compact notation for chart axes
 * 1000 -> 1k
 * 1000000 -> 1M
 * 1000000000 -> 1B
 */
export function formatCompactNumber(value: number | string): string
⋮----
/**
 * Format currency in compact notation
 * $1234 -> $1.2k
 */
export function formatCompactCurrency(value: number | string): string

================
File: packages/dashboard-web/src/frontend.tsx
================
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { App } from "./App";
⋮----
// With hot module reloading, `import.meta.hot.data` is persisted.
if (!import.meta.hot.data.root)
⋮----
// The hot module reloading API is not available in production.

================
File: packages/database/src/repositories/account.repository.ts
================
import { type Account, type AccountRow, toAccount } from "@ccflare/types";
import { BaseRepository } from "./base.repository";
⋮----
export class AccountRepository extends BaseRepository<Account>
⋮----
findAll(): Account[]
⋮----
findById(accountId: string): Account | null
⋮----
updateTokens(
		accountId: string,
		accessToken: string,
		expiresAt: number,
		refreshToken?: string,
): void
⋮----
incrementUsage(accountId: string, sessionDurationMs: number): void
⋮----
setRateLimited(accountId: string, until: number): void
⋮----
updateRateLimitMeta(
		accountId: string,
		status: string,
		reset: number | null,
		remaining?: number | null,
): void
⋮----
updateTier(accountId: string, tier: number): void
⋮----
pause(accountId: string): void
⋮----
resume(accountId: string): void
⋮----
resetSession(accountId: string, timestamp: number): void
⋮----
updateRequestCount(accountId: string, count: number): void
⋮----
rename(accountId: string, newName: string): void

================
File: packages/database/src/repositories/agent-preference.repository.ts
================
import { BaseRepository } from "./base.repository";
⋮----
export interface AgentPreference {
	agentId: string;
	model: string;
	updatedAt: number;
}
⋮----
export class AgentPreferenceRepository extends BaseRepository<AgentPreference>
⋮----
/**
	 * Get model preference for a specific agent
	 */
getPreference(agentId: string):
⋮----
/**
	 * Get all agent preferences
	 */
getAllPreferences(): Array<
⋮----
/**
	 * Set model preference for an agent
	 */
setPreference(agentId: string, model: string): void
⋮----
/**
	 * Delete preference for an agent
	 */
deletePreference(agentId: string): boolean
⋮----
/**
	 * Set preferences for all agents in bulk
	 */
setBulkPreferences(agentIds: string[], model: string): void

================
File: packages/database/src/repositories/request.repository.ts
================
import { BaseRepository } from "./base.repository";
⋮----
export interface RequestData {
	id: string;
	method: string;
	path: string;
	accountUsed: string | null;
	statusCode: number | null;
	success: boolean;
	errorMessage: string | null;
	responseTime: number;
	failoverAttempts: number;
	agentUsed?: string;
	usage?: {
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
		tokensPerSecond?: number;
	};
}
⋮----
export class RequestRepository extends BaseRepository<RequestData>
⋮----
saveMeta(
		id: string,
		method: string,
		path: string,
		accountUsed: string | null,
		statusCode: number | null,
		timestamp?: number,
): void
⋮----
save(data: RequestData): void
⋮----
updateUsage(requestId: string, usage: RequestData["usage"]): void
⋮----
// Payload management
savePayload(id: string, data: unknown): void
⋮----
getPayload(id: string): unknown | null
⋮----
listPayloads(limit = 50): Array<
⋮----
listPayloadsWithAccountNames(
		limit = 50,
): Array<
⋮----
// Analytics queries
getRecentRequests(limit = 100): Array<
⋮----
getRequestStats(since?: number):
⋮----
/**
	 * Aggregate statistics with optional time range
	 * Consolidates duplicate SQL queries from stats handlers
	 */
aggregateStats(rangeMs?: number):
⋮----
/**
	 * Get top models by usage
	 */
getTopModels(limit = 10): Array<
⋮----
/**
	 * Get recent error messages
	 */
getRecentErrors(limit = 10): string[]
⋮----
getRequestsByAccount(since?: number): Array<
⋮----
deleteOlderThan(cutoffTs: number): number
⋮----
deleteOrphanedPayloads(): number
⋮----
deletePayloadsOlderThan(cutoffTs: number): number

================
File: packages/database/src/repositories/system-kv.repository.ts
================
import { BaseRepository } from "./base.repository";
⋮----
interface SystemKVRow {
	key: string;
	value: string;
}
⋮----
export class SystemKVRepository extends BaseRepository<SystemKVRow>
⋮----
getValue(key: string): string | null
⋮----
setValue(key: string, value: string): void

================
File: packages/http-api/src/handlers/agents.ts
================
import { agentRegistry } from "@ccflare/agents";
import { validateString } from "@ccflare/core";
import type { DatabaseOperations } from "@ccflare/database";
import {
	BadRequest,
	errorResponse,
	HttpError,
	jsonResponse,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import { ALLOWED_MODELS } from "@ccflare/types";
⋮----
export function createAgentsListHandler(dbOps: DatabaseOperations)
⋮----
// Create a map of preferences for easy lookup
⋮----
// Merge preferences with agents
⋮----
// Group agents by source
⋮----
// Get workspaces
⋮----
export function createAgentPreferenceUpdateHandler(dbOps: DatabaseOperations)
⋮----
// Validate model is in allowed list
⋮----
// Update preference
⋮----
export function createWorkspacesListHandler()
⋮----
// Add agent count for each workspace
⋮----
export function createBulkAgentPreferenceUpdateHandler(
	dbOps: DatabaseOperations,
)
⋮----
// Validate input
⋮----
// Validate model is in allowed list
⋮----
// Get all agents from the registry
⋮----
// Update all agent preferences in bulk

================
File: packages/http-api/src/handlers/maintenance.ts
================
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import { jsonResponse } from "@ccflare/http-common";
import type { CleanupResponse } from "../types";
⋮----
export function createCleanupHandler(
	dbOps: DatabaseOperations,
	config: Config,
)
⋮----
export function createCompactHandler(dbOps: DatabaseOperations)

================
File: packages/http-api/src/handlers/oauth.ts
================
import { Config } from "@ccflare/config";
import { patterns, validateNumber, validateString } from "@ccflare/core";
import type { DatabaseOperations } from "@ccflare/database";
import {
	BadRequest,
	errorResponse,
	InternalServerError,
	jsonResponse,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import { createOAuthFlow } from "@ccflare/oauth-flow";
⋮----
/**
 * Create an OAuth initialization handler
 */
export function createOAuthInitHandler(dbOps: DatabaseOperations)
⋮----
// Validate account name
⋮----
// Validate mode
⋮----
// Validate tier
⋮----
// Begin OAuth flow using consolidated logic
⋮----
// Store tier in session for later use
⋮----
10, // 10 minute TTL
⋮----
/**
 * Create an OAuth callback handler
 */
export function createOAuthCallbackHandler(dbOps: DatabaseOperations)
⋮----
// Validate session ID
⋮----
// Validate code
⋮----
// Get stored PKCE verifier from database
⋮----
// Create OAuth flow instance
⋮----
// We need to reconstruct the flow data since we can't pass the full BeginResult through HTTP
// The OAuth flow will handle the token exchange and account creation
⋮----
authUrl: "", // Not needed for complete
pkce: { verifier, challenge: "" }, // Only verifier is needed
⋮----
mode: savedMode || "max", // Add mode to match BeginResult type
⋮----
// Clean up OAuth session from database

================
File: packages/http-api/src/types.ts
================
// Re-export all types from the centralized types package

================
File: packages/http-common/src/index.ts
================
// Export error handling utilities
⋮----
// Export HTTP client
⋮----
// Export header utilities
⋮----
// Export response utilities

================
File: packages/providers/src/base.ts
================
import type { Account } from "@ccflare/types";
import type { Provider, RateLimitInfo, TokenRefreshResult } from "./types";
⋮----
export abstract class BaseProvider implements Provider
⋮----
/**
	 * Check if this provider can handle the given request path
	 * Default implementation: handle all paths
	 */
canHandle(_path: string): boolean
⋮----
/**
	 * Refresh the access token for an account
	 * Must be implemented by each provider
	 */
abstract refreshToken(
		account: Account,
		clientId: string,
	): Promise<TokenRefreshResult>;
⋮----
/**
	 * Build the target URL for the provider
	 * Must be implemented by each provider
	 */
abstract buildUrl(path: string, query: string): string;
⋮----
/**
	 * Prepare headers for the provider request
	 * Default implementation: Add Bearer token (if provided) and remove host header
	 * @param headers - Original request headers
	 * @param accessToken - OAuth access token (for Bearer authentication)
	 * @param apiKey - API key (provider-specific header)
	 */
prepareHeaders(
		headers: Headers,
		accessToken?: string,
		_apiKey?: string,
): Headers
⋮----
// Note: API key handling is provider-specific and should be
// implemented in the provider subclass
⋮----
/**
	 * Parse rate limit information from response
	 * Default implementation: Check unified headers first, then fall back to 429 status
	 *
	 * Note: The default implementation considers any unified status other than "allowed"
	 * to be a hard rate limit. Providers should override this method if they need to
	 * distinguish between soft warnings (e.g., "allowed_warning") and hard limits.
	 */
parseRateLimit(response: Response): RateLimitInfo
⋮----
// Check for unified rate limit headers (used by Anthropic and others)
⋮----
const resetTime = resetHeader ? Number(resetHeader) * 1000 : undefined; // Convert to ms
⋮----
// Fall back to traditional 429 check
⋮----
// Try to extract reset time from headers
⋮----
// Retry-After can be seconds or HTTP date
⋮----
/**
	 * Process the response before returning to client
	 * Default implementation: Return response as-is
	 */
async processResponse(
		response: Response,
		_account: Account | null,
): Promise<Response>
⋮----
/**
	 * Extract tier information from response if available
	 * Default implementation: Return null (no tier info)
	 */
async extractTierInfo?(_response: Response): Promise<number | null>
⋮----
/**
	 * Extract usage information from response if available
	 * Default implementation: Return null (no usage info)
	 */
async extractUsageInfo?(_response: Response): Promise<
⋮----
/**
	 * Check if the response is a streaming response
	 * Default implementation: Check for text/event-stream or stream in content-type
	 */
isStreamingResponse?(response: Response): boolean

================
File: packages/providers/src/types.ts
================
import type { Account } from "@ccflare/types";
⋮----
export interface TokenRefreshResult {
	accessToken: string;
	expiresAt: number;
	refreshToken: string; // Always required - either new token or existing one
}
⋮----
refreshToken: string; // Always required - either new token or existing one
⋮----
export interface RateLimitInfo {
	isRateLimited: boolean;
	resetTime?: number;
	statusHeader?: string;
	remaining?: number;
}
⋮----
export interface Provider {
	name: string;

	/**
	 * Check if this provider can handle the given request path
	 */
	canHandle(path: string): boolean;

	/**
	 * Refresh the access token for an account
	 */
	refreshToken(account: Account, clientId: string): Promise<TokenRefreshResult>;

	/**
	 * Build the target URL for the provider
	 */
	buildUrl(path: string, query: string): string;

	/**
	 * Prepare headers for the provider request
	 * @param headers - Original request headers
	 * @param accessToken - OAuth access token (for Bearer authentication)
	 * @param apiKey - API key (provider-specific header)
	 */
	prepareHeaders(
		headers: Headers,
		accessToken?: string,
		apiKey?: string,
	): Headers;

	/**
	 * Parse rate limit information from response
	 */
	parseRateLimit(response: Response): RateLimitInfo;

	/**
	 * Process the response before returning to client
	 */
	processResponse(
		response: Response,
		account: Account | null,
	): Promise<Response>;

	/**
	 * Extract tier information from response if available
	 */
	extractTierInfo?(response: Response): Promise<number | null>;

	/**
	 * Extract usage information from response if available
	 */
	extractUsageInfo?(response: Response): Promise<{
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
	} | null>;

	/**
	 * Check if the response is a streaming response
	 */
	isStreamingResponse?(response: Response): boolean;
}
⋮----
/**
	 * Check if this provider can handle the given request path
	 */
canHandle(path: string): boolean;
⋮----
/**
	 * Refresh the access token for an account
	 */
refreshToken(account: Account, clientId: string): Promise<TokenRefreshResult>;
⋮----
/**
	 * Build the target URL for the provider
	 */
buildUrl(path: string, query: string): string;
⋮----
/**
	 * Prepare headers for the provider request
	 * @param headers - Original request headers
	 * @param accessToken - OAuth access token (for Bearer authentication)
	 * @param apiKey - API key (provider-specific header)
	 */
prepareHeaders(
		headers: Headers,
		accessToken?: string,
		apiKey?: string,
	): Headers;
⋮----
/**
	 * Parse rate limit information from response
	 */
parseRateLimit(response: Response): RateLimitInfo;
⋮----
/**
	 * Process the response before returning to client
	 */
processResponse(
		response: Response,
		account: Account | null,
	): Promise<Response>;
⋮----
/**
	 * Extract tier information from response if available
	 */
extractTierInfo?(response: Response): Promise<number | null>;
⋮----
/**
	 * Extract usage information from response if available
	 */
extractUsageInfo?(response: Response): Promise<
⋮----
/**
	 * Check if the response is a streaming response
	 */
isStreamingResponse?(response: Response): boolean;
⋮----
// OAuth-specific types
export interface OAuthProviderConfig {
	authorizeUrl: string;
	tokenUrl: string;
	clientId: string;
	scopes: string[];
	redirectUri: string;
	mode?: string;
}
⋮----
export interface OAuthProvider {
	getOAuthConfig(mode?: string): OAuthProviderConfig;
	exchangeCode(
		code: string,
		verifier: string,
		config: OAuthProviderConfig,
	): Promise<TokenResult>;
	generateAuthUrl(config: OAuthProviderConfig, pkce: PKCEChallenge): string;
}
⋮----
getOAuthConfig(mode?: string): OAuthProviderConfig;
exchangeCode(
		code: string,
		verifier: string,
		config: OAuthProviderConfig,
	): Promise<TokenResult>;
generateAuthUrl(config: OAuthProviderConfig, pkce: PKCEChallenge): string;
⋮----
export interface PKCEChallenge {
	verifier: string;
	challenge: string;
}
⋮----
export interface TokenResult {
	refreshToken: string;
	accessToken: string;
	expiresAt: number;
}

================
File: packages/proxy/src/handlers/proxy-operations.ts
================
import { logError, ProviderError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type { Account, RequestMeta } from "@ccflare/types";
import { forwardToClient } from "../response-handler";
import { ERROR_MESSAGES, type ProxyContext } from "./proxy-types";
import { makeProxyRequest } from "./request-handler";
import { handleProxyError, processProxyResponse } from "./response-processor";
import { getValidAccessToken } from "./token-manager";
⋮----
/**
 * Handles proxy request without authentication
 * @param req - The incoming request
 * @param url - The parsed URL
 * @param requestMeta - Request metadata
 * @param requestBodyBuffer - Buffered request body
 * @param createBodyStream - Function to create body stream
 * @param ctx - The proxy context
 * @returns Promise resolving to the response
 * @throws {ProviderError} If the unauthenticated request fails
 */
export async function proxyUnauthenticated(
	req: Request,
	url: URL,
	requestMeta: RequestMeta,
	requestBodyBuffer: ArrayBuffer | null,
	createBodyStream: () => ReadableStream<Uint8Array> | undefined,
	ctx: ProxyContext,
): Promise<Response>
⋮----
/**
 * Attempts to proxy a request with a specific account
 * @param req - The incoming request
 * @param url - The parsed URL
 * @param account - The account to use
 * @param requestMeta - Request metadata
 * @param requestBodyBuffer - Buffered request body
 * @param createBodyStream - Function to create body stream
 * @param failoverAttempts - Number of failover attempts
 * @param ctx - The proxy context
 * @returns Promise resolving to response or null if failed
 */
export async function proxyWithAccount(
	req: Request,
	url: URL,
	account: Account,
	requestMeta: RequestMeta,
	requestBodyBuffer: ArrayBuffer | null,
	createBodyStream: () => ReadableStream<Uint8Array> | undefined,
	failoverAttempts: number,
	ctx: ProxyContext,
): Promise<Response | null>
⋮----
// Get valid access token
⋮----
// Prepare request
⋮----
// Make the request
⋮----
// Process response and check for rate limit
⋮----
return null; // Signal to try next account
⋮----
// Forward response to client

================
File: packages/proxy/src/handlers/response-processor.ts
================
import { logError, RateLimitError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type { Provider } from "@ccflare/providers";
import type { Account } from "@ccflare/types";
import type { ProxyContext } from "./proxy-types";
⋮----
/**
 * Handles rate limit response for an account
 * @param account - The rate-limited account
 * @param rateLimitInfo - Parsed rate limit information
 * @param ctx - The proxy context
 */
export function handleRateLimitResponse(
	account: Account,
	rateLimitInfo: ReturnType<Provider["parseRateLimit"]>,
	ctx: ProxyContext,
): void
⋮----
/**
 * Updates account metadata in the background
 * @param account - The account to update
 * @param response - The response to extract metadata from
 * @param ctx - The proxy context
 */
export function updateAccountMetadata(
	account: Account,
	response: Response,
	ctx: ProxyContext,
): void
⋮----
// Update basic usage
⋮----
// Extract and update rate limit info for every response
⋮----
// Only update rate limit metadata when we have actual rate limit headers
⋮----
// Extract tier info if supported
⋮----
/**
 * Processes a successful proxy response
 * @param response - The provider response
 * @param account - The account used
 * @param ctx - The proxy context
 * @returns Whether the response is rate-limited
 */
export function processProxyResponse(
	response: Response,
	account: Account,
	ctx: ProxyContext,
): boolean
⋮----
// Handle rate limit
⋮----
// Also update metadata for rate-limited responses
⋮----
return true; // Signal rate limit
⋮----
// Update account metadata in background
⋮----
/**
 * Handles errors that occur during proxy operations
 * @param error - The error that occurred
 * @param account - The account that failed (optional)
 * @param logger - Logger instance
 */
export function handleProxyError(
	error: unknown,
	account: Account | null,
	logger: Logger,
): void

================
File: packages/proxy/src/handlers/token-manager.ts
================
import { ServiceUnavailableError, TokenRefreshError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type { TokenRefreshResult } from "@ccflare/providers";
import type { Account } from "@ccflare/types";
import { TOKEN_REFRESH_BACKOFF_MS, TOKEN_SAFETY_WINDOW_MS } from "../constants";
import { ERROR_MESSAGES, type ProxyContext } from "./proxy-types";
⋮----
// Track refresh failures for backoff
⋮----
/**
 * Safely refreshes an access token with deduplication
 * @param account - The account to refresh token for
 * @param ctx - The proxy context
 * @returns Promise resolving to the new access token
 * @throws {TokenRefreshError} If token refresh fails
 * @throws {ServiceUnavailableError} If refresh promise is not found
 */
export async function refreshAccessTokenSafe(
	account: Account,
	ctx: ProxyContext,
): Promise<string>
⋮----
// Check for recent refresh failures and implement backoff
⋮----
// Check if a refresh is already in progress for this account
⋮----
// Create a new refresh promise and store it
⋮----
// 1. Persist to database asynchronously
⋮----
// 2. Update the live in-memory account object immediately
// This prevents subsequent requests from seeing stale token data
⋮----
// Clear any previous failure record on successful refresh
⋮----
// Record the failure timestamp for backoff
⋮----
// Clean up the map when done (success or failure)
⋮----
// Return the existing or new refresh promise
⋮----
/**
 * Gets a valid access token for an account, refreshing if necessary
 * @param account - The account to get token for
 * @param ctx - The proxy context
 * @returns Promise resolving to a valid access token
 */
export async function getValidAccessToken(
	account: Account,
	ctx: ProxyContext,
): Promise<string>
⋮----
// API key accounts don't use access tokens
⋮----
// Return empty string - the API key will be used in prepareHeaders
⋮----
// Check if token exists and won't expire within the safety window
⋮----
// Token is expired, missing, or will expire soon

================
File: packages/proxy/src/constants.ts
================
// Token management constants
export const TOKEN_SAFETY_WINDOW_MS = 30_000; // 30 seconds - proactive refresh window
export const TOKEN_REFRESH_BACKOFF_MS = 60_000; // 60 seconds - backoff after refresh failure

================
File: packages/tui-core/src/analytics.ts
================
import { DatabaseFactory } from "@ccflare/database";
⋮----
export interface TimeSeriesDataPoint {
	time: number;
	requests: number;
	tokens: number;
	cost: number;
	responseTime: number;
	errorRate: number;
	cacheHitRate: number;
	successRate: number;
}
⋮----
export interface ModelDistribution {
	model: string;
	count: number;
	percentage: number;
}
⋮----
export interface Analytics {
	timeSeries: TimeSeriesDataPoint[];
	modelDistribution: ModelDistribution[];
}
⋮----
function getRangeConfig(range: string):
⋮----
bucketMs: 5 * 60 * 1000, // 5 minutes
⋮----
bucketMs: 15 * 60 * 1000, // 15 minutes
⋮----
bucketMs: 30 * 60 * 1000, // 30 minutes
⋮----
bucketMs: 60 * 60 * 1000, // 1 hour
⋮----
bucketMs: 30 * 60 * 1000, // 30 minutes
⋮----
export async function getAnalytics(timeRange: string): Promise<Analytics>
⋮----
// Get time series data
⋮----
// Get model distribution

================
File: packages/tui-core/src/args.ts
================
import { parseArgs as nodeParseArgs } from "node:util";
⋮----
export interface ParsedArgs {
	help?: boolean;
	serve?: boolean;
	port?: number;
	logs?: boolean | number;
	stats?: boolean;
	addAccount?: string;
	mode?: "max" | "console";
	tier?: 1 | 5 | 20;
	list?: boolean;
	remove?: string;
	pause?: string;
	resume?: string;
	analyze?: boolean;
	resetStats?: boolean;
	clearHistory?: boolean;
	getModel?: boolean;
	setModel?: string;
}
⋮----
export function parseArgs(args: string[]): ParsedArgs

================
File: packages/tui-core/src/index.ts
================


================
File: packages/types/src/account.ts
================
// AccountTier represents the tier level (1, 5, or 20)
export type AccountTier = number;
⋮----
// Database row types that match the actual database schema
export interface AccountRow {
	id: string;
	name: string;
	provider: string | null;
	api_key: string | null;
	refresh_token: string;
	access_token: string | null;
	expires_at: number | null;
	created_at: number;
	last_used: number | null;
	request_count: number;
	total_requests: number;
	rate_limited_until?: number | null;
	session_start?: number | null;
	session_request_count?: number;
	account_tier: number;
	paused?: 0 | 1;
	rate_limit_reset?: number | null;
	rate_limit_status?: string | null;
	rate_limit_remaining?: number | null;
}
⋮----
// Domain model - used throughout the application
export interface Account {
	id: string;
	name: string;
	provider: string;
	api_key: string | null;
	refresh_token: string;
	access_token: string | null;
	expires_at: number | null;
	request_count: number;
	total_requests: number;
	last_used: number | null;
	created_at: number;
	rate_limited_until: number | null;
	session_start: number | null;
	session_request_count: number;
	account_tier: number; // 1, 5, or 20
	paused: boolean;
	rate_limit_reset: number | null;
	rate_limit_status: string | null;
	rate_limit_remaining: number | null;
}
⋮----
account_tier: number; // 1, 5, or 20
⋮----
// API response type - what clients receive
export interface AccountResponse {
	id: string;
	name: string;
	provider: string;
	requestCount: number;
	totalRequests: number;
	lastUsed: string | null;
	created: string;
	tier: number;
	paused: boolean;
	tokenStatus: "valid" | "expired";
	tokenExpiresAt: string | null; // ISO timestamp of token expiration
	rateLimitStatus: string;
	rateLimitReset: string | null;
	rateLimitRemaining: number | null;
	sessionInfo: string;
}
⋮----
tokenExpiresAt: string | null; // ISO timestamp of token expiration
⋮----
// UI display type - used in TUI and web dashboard
export interface AccountDisplay {
	id: string;
	name: string;
	provider: string;
	tierDisplay: string;
	created: Date;
	lastUsed: Date | null;
	requestCount: number;
	totalRequests: number;
	tokenStatus: "valid" | "expired";
	rateLimitStatus: string;
	sessionInfo: string;
	paused: boolean;
	tier?: number;
	account_tier?: number;
	rate_limited_until?: number | null;
	session_start?: number | null;
	session_request_count?: number;
	access_token?: string | null;
}
⋮----
// CLI list item type
export interface AccountListItem {
	id: string;
	name: string;
	provider: string;
	tier: number;
	tierDisplay: string;
	created: Date;
	lastUsed: Date | null;
	requestCount: number;
	totalRequests: number;
	paused: boolean;
	tokenStatus: "valid" | "expired";
	rateLimitStatus: string;
	sessionInfo: string;
	mode: "max" | "console";
}
⋮----
// Account creation types
export interface AddAccountOptions {
	name: string;
	mode?: "max" | "console";
	tier?: 1 | 5 | 20;
}
⋮----
export interface AccountDeleteRequest {
	confirm: string;
}
⋮----
// Type mappers
export function toAccount(row: AccountRow): Account
⋮----
export function toAccountResponse(account: Account): AccountResponse
⋮----
export function toAccountDisplay(account: Account): AccountDisplay

================
File: packages/types/src/agent-constants.ts
================
import type { AgentTool } from "./agent";
⋮----
all: [] as AgentTool[], // empty means don't set tools property

================
File: packages/types/src/conversation.ts
================
export type Role = "user" | "assistant" | "system";
⋮----
export interface ToolUse {
	id?: string;
	name: string;
	input?: Record<string, unknown>;
}
⋮----
export interface ToolResult {
	tool_use_id: string;
	content: string;
}
⋮----
export enum ContentBlockType {
	Text = "text",
	ToolUse = "tool_use",
	ToolResult = "tool_result",
	Thinking = "thinking",
}
⋮----
export interface ContentBlock {
	type: ContentBlockType;
	text?: string;
	thinking?: string;
	id?: string;
	name?: string;
	input?: Record<string, unknown>;
	tool_use_id?: string;
	content?: string;
}
⋮----
export interface MessageData {
	role: Role;
	content: string;
	contentBlocks?: ContentBlock[];
	tools?: ToolUse[];
	toolResults?: ToolResult[];
}

================
File: packages/ui-common/src/utils/generate-message-key.ts
================
import type { MessageData } from "@ccflare/types";
⋮----
export const genMessageKey = (msg: MessageData, index: number): string =>

================
File: packages/ui-common/src/presenters.ts
================
import type {
	Account,
	AccountDisplay,
	AccountResponse,
	Request,
	RequestResponse,
	StatsResponse,
	StatsWithAccounts,
} from "@ccflare/types";
import {
	formatCost,
	formatDuration,
	formatPercentage,
	formatTimestamp,
	formatTokens,
} from "./formatters";
⋮----
/**
 * Account presenter - formats account data for display
 */
export class AccountPresenter
⋮----
constructor(private account: Account | AccountResponse | AccountDisplay)
⋮----
get tierDisplay(): string
⋮----
get tokenStatus(): "valid" | "expired"
⋮----
get rateLimitStatus(): string
⋮----
get sessionInfo(): string
⋮----
get requestCount(): number
⋮----
get totalRequests(): number
⋮----
get isPaused(): boolean
⋮----
get isRateLimited(): boolean
⋮----
/**
 * Request presenter - formats request data for display
 */
export class RequestPresenter
⋮----
constructor(private request: Request | RequestResponse)
⋮----
get statusDisplay(): string
⋮----
get responseTimeDisplay(): string
⋮----
get tokensDisplay(): string
⋮----
get costDisplay(): string
⋮----
get isSuccess(): boolean
⋮----
get hasTokenUsage(): boolean
⋮----
/**
 * Stats presenter - formats stats data for display
 */
export class StatsPresenter
⋮----
constructor(private stats: StatsResponse | StatsWithAccounts)
⋮----
get successRateDisplay(): string
⋮----
get avgResponseTimeDisplay(): string
⋮----
get totalTokensDisplay(): string
⋮----
get totalCostDisplay(): string
⋮----
get topModel(): string | null
⋮----
get hasAccounts(): boolean

================
File: tsconfig.json
================
{
	"compilerOptions": {
		"lib": ["ESNext", "DOM", "DOM.Iterable"],
		"module": "esnext",
		"target": "esnext",
		"moduleResolution": "bundler",
		"moduleDetection": "force",
		"allowImportingTsExtensions": true,
		"noEmit": true,
		"strict": true,
		"skipLibCheck": true,
		"allowSyntheticDefaultImports": true,
		"forceConsistentCasingInFileNames": true,
		"allowJs": true,
		"types": ["bun-types"],
		"jsx": "react-jsx",
		"baseUrl": ".",
		"paths": {
			"@ccflare/*": ["packages/*/src"]
		}
	},
	"include": ["packages/*/src/**/*", "apps/*/src/**/*"]
}

================
File: apps/server/src/server.ts
================
import { dirname } from "node:path";
import { Config, type RuntimeConfig } from "@ccflare/config";
import {
	CACHE,
	DEFAULT_STRATEGY,
	HTTP_STATUS,
	NETWORK,
	registerDisposable,
	setPricingLogger,
	shutdown,
	TIME_CONSTANTS,
} from "@ccflare/core";
import { container, SERVICE_KEYS } from "@ccflare/core-di";
// Import React dashboard assets
import dashboardManifest from "@ccflare/dashboard-web/dist/manifest.json";
import type { DatabaseOperations } from "@ccflare/database";
import { AsyncDbWriter, DatabaseFactory } from "@ccflare/database";
import { APIRouter } from "@ccflare/http-api";
import { SessionStrategy } from "@ccflare/load-balancer";
import { Logger } from "@ccflare/logger";
import { getProvider } from "@ccflare/providers";
import {
	getUsageWorker,
	handleProxy,
	type ProxyContext,
	terminateUsageWorker,
} from "@ccflare/proxy";
import { serve } from "bun";
⋮----
// Helper function to resolve dashboard assets with fallback
function resolveDashboardAsset(assetPath: string): string | null
⋮----
// Try resolving as a package first
⋮----
// Fallback to relative path within the repo (development / mono-repo usage)
⋮----
// Helper function to serve dashboard files with proper headers
function serveDashboardFile(
	assetPath: string,
	contentType?: string,
	cacheControl?: string,
): Response
⋮----
// Auto-detect content type if not provided
⋮----
// Module-level server instance
⋮----
// Startup maintenance (one-shot): cleanup + compact
function runStartupMaintenance(config: Config, dbOps: DatabaseOperations)
⋮----
// Return a no-op stopper for compatibility
⋮----
// Export for programmatic use
export default function startServer(options?: {
	port?: number;
	withDashboard?: boolean;
})
⋮----
// Return existing server if already running
⋮----
// Initialize DI container
⋮----
// Initialize components
⋮----
// Override port if provided
⋮----
// Initialize async DB writer
⋮----
// Initialize pricing logger
⋮----
// Run startup maintenance once (cleanup + compact)
⋮----
// Initialize load balancing strategy (will be created after runtime config)
⋮----
// Get the provider
⋮----
// Create runtime config
⋮----
// Now create the strategy with runtime config
⋮----
// Proxy context
⋮----
// Hot reload strategy configuration
⋮----
// For now, only SessionStrategy is supported
⋮----
// Main server
⋮----
idleTimeout: NETWORK.IDLE_TIMEOUT_MAX, // Max allowed by Bun
async fetch(req)
⋮----
// Try API routes first
⋮----
// Dashboard routes (only if enabled)
⋮----
// Serve dashboard static assets
⋮----
// For all non-API routes, serve the dashboard index.html (client-side routing)
// This allows React Router to handle all dashboard routes without maintaining a list
⋮----
// All other paths go to proxy
⋮----
// Log server startup
⋮----
// Log configuration
⋮----
// Log initial account status
⋮----
// Graceful shutdown handler
async function handleGracefulShutdown(signal: string)
⋮----
// Register signal handlers
⋮----
// Run server if this is the main entry point

================
File: apps/tui/src/components/AnalyticsScreen.tsx
================
import { getModelShortName } from "@ccflare/core";
⋮----
import { formatCost, formatNumber, formatPercentage } from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import SelectInput from "ink-select-input";
import Spinner from "ink-spinner";
import { useCallback, useEffect, useState } from "react";
import { BarChart, LineChart, PieChart, SparklineChart } from "./charts";
⋮----
interface AnalyticsScreenProps {
	onBack: () => void;
}
⋮----
type TimeRange = "1h" | "6h" | "24h" | "7d";
type ChartView = "overview" | "tokens" | "performance" | "costs" | "models";
⋮----
interface TimeSeriesDataPoint {
		time: string;
		requests: number;
		tokens: number;
		cost: number;
		responseTime: number;
		errorRate: number;
		cacheHitRate: number;
		successRate: number;
	}
⋮----
// Time range shortcuts
⋮----
// View shortcuts
⋮----
// Get basic stats
⋮----
// Get analytics with time series data
⋮----
// Transform time series data for display
⋮----
const interval = setInterval(loadData, 30000); // Refresh every 30 seconds
⋮----
// Menu for selecting time range
⋮----
// Prepare data for charts
⋮----
// Model distribution for pie chart
⋮----
// Account performance for bar chart
⋮----
{/* Sparklines */}
⋮----
{/* Response time line chart */}
⋮----
{/* Token breakdown bar chart */}
⋮----
{/* Account performance bar chart */}
⋮----
{/* Cost trend sparkline */}
⋮----
{/* Cost breakdown */}
⋮----
{/* Model distribution pie chart */}
⋮----

⋮----
{/* Header */}
⋮----
{/* Time range selector */}
⋮----
{/* Chart content */}
⋮----
{/* Controls */}

================
File: packages/cli-commands/src/commands/account.ts
================
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import { createOAuthFlow } from "@ccflare/oauth-flow";
import type { AccountListItem } from "@ccflare/types";
import {
	type PromptAdapter,
	promptAccountRemovalConfirmation,
	stdPromptAdapter,
} from "../prompts/index";
import { openBrowser } from "../utils/browser";
⋮----
// Re-export types with adapter extension for CLI-specific options
export interface AddAccountOptions {
	name: string;
	mode?: "max" | "console";
	tier?: 1 | 5 | 20;
	adapter?: PromptAdapter;
}
⋮----
// Re-export AccountListItem from types for backward compatibility
⋮----
// Add mode property to AccountListItem for CLI display
export interface AccountListItemWithMode extends AccountListItem {
	mode: "max" | "console";
}
⋮----
/**
 * Add a new account using OAuth flow
 */
export async function addAccount(
	dbOps: DatabaseOperations,
	config: Config,
	options: AddAccountOptions,
): Promise<void>
⋮----
// Create OAuth flow instance
⋮----
// Prompt for mode if not provided
⋮----
// Begin OAuth flow
⋮----
// Open browser and prompt for code
⋮----
// Get authorization code
⋮----
// Get tier for Max accounts
⋮----
// Complete OAuth flow
⋮----
/**
 * Get list of all accounts with formatted information
 */
export function getAccountsList(dbOps: DatabaseOperations): AccountListItem[]
⋮----
/**
 * Remove an account by name
 */
export function removeAccount(
	dbOps: DatabaseOperations,
	name: string,
):
⋮----
/**
 * Remove an account by name with confirmation prompt (for CLI)
 */
export async function removeAccountWithConfirmation(
	dbOps: DatabaseOperations,
	name: string,
	force?: boolean,
): Promise<
⋮----
// Check if account exists first
⋮----
// Skip confirmation if force flag is set
⋮----
/**
 * Toggle account pause state (shared logic for pause/resume)
 */
function toggleAccountPause(
	dbOps: DatabaseOperations,
	name: string,
	shouldPause: boolean,
):
⋮----
// Get account ID by name
⋮----
/**
 * Pause an account by name
 */
export function pauseAccount(
	dbOps: DatabaseOperations,
	name: string,
):
⋮----
/**
 * Resume a paused account by name
 */
export function resumeAccount(
	dbOps: DatabaseOperations,
	name: string,
):

================
File: packages/core/src/index.ts
================
// Re-export only used items from each module

================
File: packages/core/src/models.ts
================
/**
 * Centralized model definitions and constants
 * All Claude model IDs and metadata should be defined here
 */
⋮----
// Full model IDs as used by the Anthropic API
⋮----
// Claude 3.5 models
⋮----
// Claude 4 models
⋮----
// Legacy Claude 3 models (for documentation/API examples)
⋮----
// Model display names
⋮----
// Short model names used in UI (for color mapping, etc.)
⋮----
// Default model for various contexts
⋮----
// Type for all valid model IDs
export type ClaudeModelId =
	(typeof CLAUDE_MODEL_IDS)[keyof typeof CLAUDE_MODEL_IDS];
⋮----
// Helper function to get short name from full model ID
export function getModelShortName(modelId: string): string
⋮----
// Helper function to get display name from model ID
export function getModelDisplayName(modelId: string): string
⋮----
// Helper function to validate if a string is a valid model ID
export function isValidModelId(modelId: string): modelId is ClaudeModelId

================
File: packages/dashboard-web/src/components/accounts/AccountList.tsx
================
import type { Account } from "../../api";
import { AccountListItem } from "./AccountListItem";
⋮----
interface AccountListProps {
	accounts: Account[] | undefined;
	onPauseToggle: (account: Account) => void;
	onRemove: (name: string) => void;
	onRename: (account: Account) => void;
}
⋮----
export function AccountList({
	accounts,
	onPauseToggle,
	onRemove,
	onRename,
}: AccountListProps)
⋮----
// Find the most recently used account

================
File: packages/dashboard-web/src/components/accounts/index.ts
================


================
File: packages/dashboard-web/src/components/charts/index.ts
================


================
File: packages/dashboard-web/src/components/charts/ModelPerformanceComparison.tsx
================
import { getModelShortName } from "@ccflare/core";
import { formatCost, formatTokensPerSecond } from "@ccflare/ui-common";
import {
	Area,
	AreaChart,
	Bar,
	CartesianGrid,
	ComposedChart,
	Legend,
	Line,
	ResponsiveContainer,
	Scatter,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_HEIGHTS, CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import { getTooltipStyles } from "./chart-utils";
⋮----
interface ModelComparisonData {
	model: string;
	avgTokensPerSecond: number | null;
	costPer1kTokens: number;
	avgResponseTime: number;
	errorRate: number;
	totalRequests: number;
}
⋮----
interface ModelPerformanceComparisonProps {
	data: ModelComparisonData[];
	loading?: boolean;
	height?: number;
	viewMode?: "speed-cost" | "performance" | "efficiency";
}
⋮----
// Model-based color palette
⋮----
function getModelColor(model: string): string
⋮----
// Try to find color by short name first
⋮----
// Check for exact match
⋮----
// Check for partial matches
⋮----
// Filter and prepare data
⋮----
// Efficiency view: Speed vs Cost scatter plot
⋮----
Speed:

================
File: packages/dashboard-web/src/components/conversation/MessageBubble.tsx
================
import type { Role } from "@ccflare/types";
import React from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";
⋮----
interface MessageBubbleProps {
	role: Role;
	content: string;
}

================
File: packages/dashboard-web/src/components/navigation.tsx
================
import {
	Activity,
	BarChart3,
	Bot,
	FileText,
	GitBranch,
	LayoutDashboard,
	Menu,
	Shield,
	Users,
	Wrench,
	X,
	Zap,
} from "lucide-react";
import { useState } from "react";
import { Link, useLocation } from "react-router-dom";
import { cn } from "../lib/utils";
import { ThemeToggle } from "./theme-toggle";
import { Button } from "./ui/button";
import { Separator } from "./ui/separator";
⋮----
interface NavItem {
	label: string;
	icon: React.ComponentType<{ className?: string }>;
	path: string;
	badge?: string;
}
⋮----
export function Navigation()
⋮----
{/* Mobile header */}
⋮----
{/* Mobile menu overlay */}
⋮----
{/* Sidebar */}
⋮----
{/* Logo */}
⋮----
{/* Navigation */}
⋮----
className=
⋮----
{/* Footer */}

================
File: packages/dashboard-web/src/components/ToolsTab.tsx
================
import { SystemPromptInterceptorCard } from "./tools/SystemPromptInterceptorCard";
⋮----
export function ToolsTab()

================
File: packages/dashboard-web/src/constants/index.ts
================
// Re-export all shared constants from ui-constants
⋮----
// Re-export agent constants from types

================
File: packages/dashboard-web/src/App.tsx
================
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Navigate, Route, Routes, useLocation } from "react-router-dom";
import { AccountsTab } from "./components/AccountsTab";
import { AgentsTab } from "./components/AgentsTab";
import { AnalyticsTab } from "./components/AnalyticsTab";
import { LogsTab } from "./components/LogsTab";
import { Navigation } from "./components/navigation";
import { OverviewTab } from "./components/OverviewTab";
import { RequestsTab } from "./components/RequestsTab";
import { ToolsTab } from "./components/ToolsTab";
import { QUERY_CONFIG, REFRESH_INTERVALS } from "./constants";
import { ThemeProvider } from "./contexts/theme-context";
⋮----
refetchInterval: REFRESH_INTERVALS.default, // Refetch every 30 seconds
staleTime: QUERY_CONFIG.staleTime, // Consider data stale after 10 seconds
⋮----
{/* Main Content */}
⋮----
{/* Mobile spacer */}
⋮----
{/* Page Content */}
⋮----
{/* Page Header */}
⋮----
{/* Tab Content */}

================
File: packages/dashboard-web/package.json
================
{
	"name": "@ccflare/dashboard-web",
	"version": "1.0.0",
	"private": true,
	"type": "module",
	"scripts": {
		"dev": "bun --hot src/index.tsx",
		"build": "bun run build.ts",
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/errors": "workspace:*",
		"@ccflare/ui-common": "workspace:*",
		"@ccflare/ui-constants": "workspace:*",
		"@radix-ui/react-dialog": "^1.1.14",
		"@radix-ui/react-dropdown-menu": "^2.1.15",
		"@radix-ui/react-label": "^2.1.0",
		"@radix-ui/react-popover": "^1.1.14",
		"@radix-ui/react-progress": "^1.1.7",
		"@radix-ui/react-select": "^2.1.2",
		"@radix-ui/react-separator": "^1.1.7",
		"@radix-ui/react-slot": "^1.1.0",
		"@radix-ui/react-switch": "^1.2.5",
		"@radix-ui/react-tabs": "^1.1.1",
		"@radix-ui/react-tooltip": "^1.2.7",
		"@tanstack/react-query": "^5.83.0",
		"@types/react-router-dom": "^5.3.3",
		"bun-plugin-tailwind": "^0.0.15",
		"class-variance-authority": "^0.7.1",
		"clsx": "^2.1.1",
		"cmdk": "^1.1.1",
		"date-fns": "^4.1.0",
		"framer-motion": "^12.23.9",
		"lucide-react": "^0.525.0",
		"react": "^19.0.0",
		"react-dom": "^19.0.0",
		"react-router-dom": "^7.8.1",
		"recharts": "^3.1.0",
		"tailwind-merge": "^2.6.0",
		"tailwindcss": "^4.0.0",
		"tailwindcss-animate": "^1.0.7"
	},
	"devDependencies": {
		"@types/react": "^19.0.0",
		"@types/react-dom": "^19.0.0",
		"@types/bun": "latest"
	}
}

================
File: packages/database/src/migrations.ts
================
import type { Database } from "bun:sqlite";
import { Logger } from "@ccflare/logger";
import { addPerformanceIndexes } from "./performance-indexes";
⋮----
export function ensureSchema(db: Database): void
⋮----
// Create accounts table
⋮----
// Create requests table
⋮----
// Create index for faster queries
⋮----
// Create request_payloads table for storing full request/response data
⋮----
// Create oauth_sessions table for secure PKCE verifier storage
⋮----
// Create index for faster cleanup of expired sessions
⋮----
// Create agent_preferences table for storing user-defined agent settings
⋮----
// Create interceptors table for storing tool configurations
⋮----
// Create system_kv_store table for storing system-wide key-value pairs
⋮----
export function runMigrations(db: Database): void
⋮----
// Ensure base schema exists first
⋮----
// Check if columns exist before adding them
⋮----
// biome-ignore lint/suspicious/noExplicitAny: SQLite pragma can return various default value types
⋮----
// Add rate_limited_until column if it doesn't exist
⋮----
// Add session_start column if it doesn't exist
⋮----
// Add session_request_count column if it doesn't exist
⋮----
// Add account_tier column if it doesn't exist
⋮----
// Add paused column if it doesn't exist
⋮----
// Add rate_limit_reset column if it doesn't exist
⋮----
// Add rate_limit_status column if it doesn't exist
⋮----
// Add rate_limit_remaining column if it doesn't exist
⋮----
// Check columns in requests table
⋮----
// biome-ignore lint/suspicious/noExplicitAny: SQLite pragma can return various default value types
⋮----
// Add model column if it doesn't exist
⋮----
// Add prompt_tokens column if it doesn't exist
⋮----
// Add completion_tokens column if it doesn't exist
⋮----
// Add total_tokens column if it doesn't exist
⋮----
// Add cost_usd column if it doesn't exist
⋮----
// Add input_tokens column if it doesn't exist
⋮----
// Add cache_read_input_tokens column if it doesn't exist
⋮----
// Add cache_creation_input_tokens column if it doesn't exist
⋮----
// Add output_tokens column if it doesn't exist
⋮----
// Add agent_used column if it doesn't exist
⋮----
// Add output_tokens_per_second column if it doesn't exist
⋮----
// Add performance indexes

================
File: packages/http-api/src/handlers/accounts.ts
================
import type { Database } from "bun:sqlite";
⋮----
import type { Config } from "@ccflare/config";
import {
	patterns,
	sanitizers,
	validateNumber,
	validateString,
} from "@ccflare/core";
import type { DatabaseOperations } from "@ccflare/database";
import {
	BadRequest,
	errorResponse,
	InternalServerError,
	jsonResponse,
	NotFound,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import type { AccountResponse } from "../types";
⋮----
/**
 * Create an accounts list handler
 */
export function createAccountsListHandler(db: Database)
⋮----
const sessionDuration = 5 * 60 * 60 * 1000; // 5 hours
⋮----
// Use unified rate limit status if available
⋮----
// Fall back to legacy rate limit check
⋮----
/**
 * Create an account tier update handler
 */
export function createAccountTierUpdateHandler(dbOps: DatabaseOperations)
⋮----
// Validate tier input
⋮----
/**
 * Create an account add handler (manual token addition)
 * This is primarily used for adding accounts with existing tokens
 * For OAuth flow, use the OAuth handlers
 */
export function createAccountAddHandler(
	dbOps: DatabaseOperations,
	_config: Config,
)
⋮----
// Validate account name
⋮----
// Validate tokens
⋮----
// Validate provider
⋮----
// Validate tier
⋮----
// Add account directly to database
⋮----
/**
 * Create an account remove handler
 */
export function createAccountRemoveHandler(dbOps: DatabaseOperations)
⋮----
// Parse and validate confirmation
⋮----
// Validate confirmation string
⋮----
/**
 * Create an account pause handler
 */
export function createAccountPauseHandler(dbOps: DatabaseOperations)
⋮----
// Get account name by ID
⋮----
/**
 * Create an account resume handler
 */
export function createAccountResumeHandler(dbOps: DatabaseOperations)
⋮----
// Get account name by ID
⋮----
/**
 * Create an account rename handler
 */
export function createAccountRenameHandler(dbOps: DatabaseOperations)
⋮----
// Validate new name
⋮----
// Check if account exists
⋮----
// Check if new name is already taken
⋮----
// Rename the account

================
File: packages/http-api/src/handlers/analytics.ts
================
import {
	errorResponse,
	InternalServerError,
	jsonResponse,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import { NO_ACCOUNT_ID } from "@ccflare/types";
import type { AnalyticsResponse, APIContext } from "../types";
⋮----
interface BucketConfig {
	bucketMs: number;
	displayName: string;
}
⋮----
interface TotalsResult {
	total_requests: number;
	success_rate: number;
	avg_response_time: number;
	total_tokens: number;
	total_cost_usd: number;
	avg_tokens_per_second: number;
}
⋮----
interface ActiveAccountsResult {
	active_accounts: number;
}
⋮----
interface TokenBreakdownResult {
	input_tokens: number;
	cache_read_input_tokens: number;
	cache_creation_input_tokens: number;
	output_tokens: number;
}
⋮----
function getRangeConfig(range: string):
⋮----
export function createAnalyticsHandler(context: APIContext)
⋮----
// Extract filters
⋮----
// Build filter conditions
⋮----
// Handle account filter - map account names to IDs via join
⋮----
// Get totals
⋮----
// Get active accounts count (including no_account for unauthenticated requests)
⋮----
// Check if we need per-model time series
⋮----
// Get time series data
⋮----
// Get token breakdown
⋮----
// Get model distribution
⋮----
// Get account performance (including unauthenticated requests)
⋮----
// Get model performance metrics
⋮----
// Calculate p95 for each model using SQL window functions
⋮----
// Use SQLite's NTILE or manual percentile calculation
// SQLite doesn't have built-in percentile functions, but we can use a more efficient query
⋮----
// Get cost by model
⋮----
// Transform timeSeries data
⋮----
// Apply cumulative transformation if requested
⋮----
// Keep rates as-is (not cumulative)
⋮----
// For per-model cumulative, track running totals per model

================
File: packages/http-api/src/handlers/requests-stream.ts
================
import { type RequestEvt, requestEvents } from "@ccflare/core";
⋮----
export function createRequestsStreamHandler()
⋮----
// Store the write handler outside to access it in cancel
⋮----
start(controller)
⋮----
// Helper to send SSE formatted data
writeHandler = (data: RequestEvt) =>
⋮----
// Send initial connection message
⋮----
// Listen for events
⋮----
cancel()
⋮----
// Cleanup only this specific listener

================
File: packages/http-common/src/headers.ts
================
/**
 * Sanitizes proxy headers by removing hop-by-hop headers that should not be forwarded
 * after Bun has automatically decompressed the response body.
 *
 * Removes: content-encoding, content-length, transfer-encoding
 */
export function sanitizeProxyHeaders(original: Headers): Headers
⋮----
// Remove headers that are invalidated by automatic decompression
⋮----
/**
 * Removes hop-by-hop + compression negotiation headers from the ORIGINAL
 * client request before it is persisted for analytics. Does **not** add /
 * remove auth headers.
 *
 * Removes: accept-encoding, content-encoding, transfer-encoding, content-length
 */
export function sanitizeRequestHeaders(original: Headers): Headers
⋮----
/**
 * Return a new Response with hop-by-hop / compression headers stripped.
 * Body & status are preserved.
 */
export function withSanitizedProxyHeaders(res: Response): Response

================
File: packages/oauth-flow/src/index.ts
================
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import {
	generatePKCE,
	getOAuthProvider,
	type OAuthProviderConfig,
	type OAuthTokens,
	type PKCEChallenge,
} from "@ccflare/providers";
import type { AccountTier } from "@ccflare/types";
⋮----
export interface BeginOptions {
	name: string;
	mode: "max" | "console";
}
⋮----
export interface BeginResult {
	sessionId: string;
	authUrl: string;
	pkce: PKCEChallenge;
	oauthConfig: OAuthProviderConfig;
	mode: "max" | "console"; // Track mode to handle differently in complete()
}
⋮----
mode: "max" | "console"; // Track mode to handle differently in complete()
⋮----
export interface CompleteOptions {
	sessionId: string;
	code: string;
	tier?: AccountTier;
	name: string; // Required to properly create the account
}
⋮----
name: string; // Required to properly create the account
⋮----
export interface AccountCreated {
	id: string;
	name: string;
	tier: number;
	provider: "anthropic";
	authType: "oauth" | "api_key"; // Track authentication type
}
⋮----
authType: "oauth" | "api_key"; // Track authentication type
⋮----
export interface OAuthFlowResult {
	success: boolean;
	message: string;
	data?: AccountCreated;
}
⋮----
/**
 * Handles the Anthropic OAuth flow for both "max" and "console" authentication modes.
 *
 * - "max" mode: Standard OAuth with refresh tokens for Claude Max accounts
 * - "console" mode: OAuth flow that creates a static API key
 *
 * This class does not persist session data. The caller must handle storage
 * between {@link begin} and {@link complete} calls.
 */
export class OAuthFlow
⋮----
constructor(
⋮----
/**
	 * Starts an Anthropic OAuth flow.
	 *
	 * The caller MUST persist the returned `sessionId`, `pkce.verifier`,
	 * `mode`, and `tier` so that {@link complete} can validate the callback.
	 *
	 * @param opts - OAuth flow options
	 * @param opts.name - Unique account name
	 * @param opts.mode - Authentication mode ("max" for Claude Max, "console" for API key)
	 * @returns OAuth flow data including auth URL and session info
	 * @throws {Error} If account name already exists
	 */
async begin(opts: BeginOptions): Promise<BeginResult>
⋮----
// Check if account already exists
⋮----
// Get OAuth provider
⋮----
// Generate PKCE challenge
⋮----
// Get OAuth config with runtime client ID
⋮----
// Generate auth URL
⋮----
// Create session ID for this OAuth flow
⋮----
// NOTE: OAuthFlow itself does not persist the session.
//       The caller (HTTP-API oauth-init handler) must
//       store {sessionId, verifier, mode, tier} – typically
//       via DatabaseOperations.createOAuthSession().
⋮----
/**
	 * Completes the Anthropic OAuth flow after user authorization.
	 *
	 * Exchanges the authorization code for tokens and creates the account.
	 * For "console" mode, creates an API key instead of storing OAuth tokens.
	 *
	 * @param opts - Completion options
	 * @param opts.sessionId - Session ID from {@link begin}
	 * @param opts.code - Authorization code from OAuth callback
	 * @param opts.tier - Account tier (1, 5, or 20)
	 * @param opts.name - Account name (must match the one from begin)
	 * @param flowData - Flow data returned from {@link begin}
	 * @returns Created account information
	 * @throws {Error} If OAuth provider not found or token exchange fails
	 */
async complete(
		opts: CompleteOptions,
		flowData: BeginResult,
): Promise<AccountCreated>
⋮----
// Get OAuth provider
⋮----
// Exchange authorization code for tokens
⋮----
// Handle console mode - create API key
⋮----
// Handle max mode - standard OAuth flow
⋮----
/**
	 * Creates an API key using the Anthropic console endpoint.
	 *
	 * This is used for "console" mode accounts where users want a static API key
	 * instead of OAuth tokens that need refreshing.
	 *
	 * @param accessToken - Temporary access token from OAuth flow
	 * @returns The newly created API key
	 * @throws {Error} If API key creation fails
	 */
private async createAnthropicApiKey(accessToken: string): Promise<string>
⋮----
/**
	 * Creates an account with OAuth tokens (max mode).
	 *
	 * Stores refresh token, access token, and expiration for automatic token refresh.
	 *
	 * @param id - Unique account ID
	 * @param name - Account name
	 * @param tokens - OAuth tokens from token exchange
	 * @param tier - Account tier (1, 5, or 20)
	 * @returns Created account information
	 */
private createAccountWithOAuth(
		id: string,
		name: string,
		tokens: OAuthTokens,
		tier: AccountTier,
): AccountCreated
⋮----
/**
	 * Creates an account with API key (console mode).
	 *
	 * Stores only the API key, no OAuth tokens. These accounts don't require
	 * token refresh but cannot be refreshed if the API key is revoked.
	 *
	 * @param id - Unique account ID
	 * @param name - Account name
	 * @param apiKey - API key from Anthropic console
	 * @param tier - Account tier (1, 5, or 20)
	 * @returns Created account information
	 */
private createAccountWithApiKey(
		id: string,
		name: string,
		apiKey: string,
		tier: AccountTier,
): AccountCreated
⋮----
// Helper function for simpler usage
export async function createOAuthFlow(
	dbOps: DatabaseOperations,
	config: Config,
): Promise<OAuthFlow>

================
File: packages/providers/src/providers/anthropic/provider.ts
================
import { BUFFER_SIZES } from "@ccflare/core";
import { sanitizeProxyHeaders } from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import type { Account } from "@ccflare/types";
import { BaseProvider } from "../../base";
import type { RateLimitInfo, TokenRefreshResult } from "../../types";
⋮----
// Hard rate limit statuses that should block account usage
⋮----
// Soft warning statuses that should not block account usage
⋮----
export class AnthropicProvider extends BaseProvider
⋮----
canHandle(_path: string): boolean
⋮----
// Handle all paths for now since this is Anthropic-specific
⋮----
async refreshToken(
		account: Account,
		clientId: string,
): Promise<TokenRefreshResult>
⋮----
// If we can't parse the error response, use the status text
⋮----
// Ensure we always return a refresh token
⋮----
buildUrl(path: string, query: string): string
⋮----
prepareHeaders(
		headers: Headers,
		accessToken?: string,
		apiKey?: string,
): Headers
⋮----
// Set authentication header
⋮----
// Remove host header
⋮----
// Remove compression headers to avoid decompression issues
⋮----
parseRateLimit(response: Response): RateLimitInfo
⋮----
// Check for unified rate limit headers
⋮----
const resetTime = resetHeader ? Number(resetHeader) * 1000 : undefined; // Convert to ms
⋮----
// Only mark as rate limited for hard limit statuses or 429
⋮----
// Fall back to 429 status with x-ratelimit-reset header
⋮----
: Date.now() + 60000; // Default to 1 minute
⋮----
async processResponse(
		response: Response,
		_account: Account | null,
): Promise<Response>
⋮----
// Sanitize headers by removing hop-by-hop headers
⋮----
async extractTierInfo(response: Response): Promise<number | null>
⋮----
// Check for tier information in response
⋮----
// Ignore JSON parsing errors
⋮----
async extractUsageInfo(response: Response): Promise<
⋮----
// Handle streaming responses (SSE)
⋮----
// Use bounded reader to avoid consuming entire stream
⋮----
// Check if we have the message_start event
⋮----
// Read a bit more to ensure we get the data line
⋮----
// Cancel the reader to prevent hanging
⋮----
// Parse the buffered content
⋮----
// Parse SSE events
⋮----
// Next line should be the data
⋮----
const jsonStr = dataLine.slice(6); // Remove "data: " prefix
⋮----
// Extract cost from header if available
⋮----
// Ignore parse errors
⋮----
// For streaming responses, we only extract initial usage
// Output tokens will be accumulated during streaming but we can't capture that here
⋮----
// Handle non-streaming JSON responses
⋮----
// Extract cost from header if available
⋮----
// Ignore parsing errors
⋮----
/**
	 * Check if this provider supports OAuth
	 */
supportsOAuth(): boolean
⋮----
/**
	 * Get the OAuth provider for this provider
	 */
getOAuthProvider()
⋮----
// Lazy load to avoid circular dependencies

================
File: packages/proxy/src/worker-messages.ts
================
/**
 * Unified message protocol for main thread <-> worker communication
 * Handles both streaming and non-streaming responses
 */
⋮----
export interface StartMessage {
	type: "start";
	requestId: string;
	accountId: string | null;
	method: string;
	path: string;
	timestamp: number;

	// Request details
	requestHeaders: Record<string, string>;
	requestBody: string | null; // base64 encoded

	// Response details
	responseStatus: number;
	responseHeaders: Record<string, string>;
	isStream: boolean;

	// Provider info for rate limit parsing
	providerName: string;

	// Agent info
	agentUsed: string | null;

	// Retry info
	retryAttempt: number;
	failoverAttempts: number;
}
⋮----
// Request details
⋮----
requestBody: string | null; // base64 encoded
⋮----
// Response details
⋮----
// Provider info for rate limit parsing
⋮----
// Agent info
⋮----
// Retry info
⋮----
export interface ChunkMessage {
	type: "chunk";
	requestId: string;
	data: Uint8Array;
}
⋮----
export interface EndMessage {
	type: "end";
	requestId: string;
	responseBody?: string | null; // base64 encoded, for non-streaming
	success: boolean;
	error?: string;
}
⋮----
responseBody?: string | null; // base64 encoded, for non-streaming
⋮----
export interface ControlMessage {
	type: "shutdown";
}
⋮----
export type WorkerMessage =
	| StartMessage
	| ChunkMessage
	| EndMessage
	| ControlMessage
	| SummaryMessage
	| PayloadMessage;
⋮----
// Response from worker (if needed in future)
export interface WorkerResponse {
	type: "ack" | "error";
	requestId?: string;
	message?: string;
}
⋮----
// Worker to main thread messages
export interface SummaryMessage {
	type: "summary";
	summary: import("@ccflare/types").RequestResponse;
}
⋮----
export interface PayloadMessage {
	type: "payload";
	payload: import("@ccflare/types").RequestPayload;
}
⋮----
export type OutgoingWorkerMessage = SummaryMessage | PayloadMessage;

================
File: packages/types/src/index.ts
================
// Re-export all types organized by domain
⋮----
// Keep existing exports for backward compatibility

================
File: packages/types/src/request.ts
================
// Database row type
export interface RequestRow {
	id: string;
	timestamp: number;
	method: string;
	path: string;
	account_used: string | null;
	status_code: number | null;
	success: 0 | 1;
	error_message: string | null;
	response_time_ms: number | null;
	failover_attempts: number;
	model: string | null;
	prompt_tokens: number | null;
	completion_tokens: number | null;
	total_tokens: number | null;
	cost_usd: number | null;
	input_tokens: number | null;
	cache_read_input_tokens: number | null;
	cache_creation_input_tokens: number | null;
	output_tokens: number | null;
	agent_used: string | null;
	output_tokens_per_second: number | null;
}
⋮----
// Domain model
export interface Request {
	id: string;
	timestamp: number;
	method: string;
	path: string;
	accountUsed: string | null;
	statusCode: number | null;
	success: boolean;
	errorMessage: string | null;
	responseTimeMs: number | null;
	failoverAttempts: number;
	model?: string;
	promptTokens?: number;
	completionTokens?: number;
	totalTokens?: number;
	costUsd?: number;
	inputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	outputTokens?: number;
	agentUsed?: string;
	tokensPerSecond?: number;
}
⋮----
// API response type
export interface RequestResponse {
	id: string;
	timestamp: string;
	method: string;
	path: string;
	accountUsed: string | null;
	statusCode: number | null;
	success: boolean;
	errorMessage: string | null;
	responseTimeMs: number | null;
	failoverAttempts: number;
	model?: string;
	promptTokens?: number;
	completionTokens?: number;
	totalTokens?: number;
	inputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	outputTokens?: number;
	costUsd?: number;
	agentUsed?: string;
	tokensPerSecond?: number;
}
⋮----
// Detailed request with payload
export interface RequestPayload {
	id: string;
	request: {
		headers: Record<string, string>;
		body: string | null;
	};
	response: {
		status: number;
		headers: Record<string, string>;
		body: string | null;
	} | null;
	error?: string;
	meta: {
		accountId?: string;
		accountName?: string;
		retry?: number;
		timestamp: number;
		success?: boolean;
		rateLimited?: boolean;
		accountsAttempted?: number;
		pending?: boolean;
		path?: string;
		method?: string;
		agentUsed?: string;
	};
}
⋮----
// Type mappers
export function toRequest(row: RequestRow): Request
⋮----
export function toRequestResponse(request: Request): RequestResponse
⋮----
// Special account ID for requests without an account

================
File: packages/ui-common/src/utils/clean-line-numbers.ts
================
/**
 * Replace leading numeric line markers such as "123→" or "123â" by "123: ".
 */
export const cleanLineNumbers = (str: string): string =>
⋮----
// Be defensive at runtime: only operate on real strings

================
File: packages/ui-common/src/utils/normalize-text.ts
================
/**
 * Normalize tool/text content that may arrive with mojibake (UTF-8 seen as Latin-1),
 * and optionally strip a single pair of wrapping quotes.
 */
export function normalizeText(input: unknown): string
⋮----
// 1) If it's a JSON-encoded string (e.g., "...\n..."), try to parse directly
⋮----
// If JSON.parse fails, fall back to manual unquoting
⋮----
// 2) If it contains escaped sequences, decode them via JSON.parse wrapper
⋮----
// Ignore if decoding fails
⋮----
// 3) Heuristic: repair mojibake (UTF-8 mis-decoded as Latin-1)
⋮----
// Ignore decoding errors

================
File: packages/ui-common/src/index.ts
================
// Export all formatters
⋮----
// Export all components
⋮----
// Export parsers
⋮----
// Export all presenters
⋮----
// Export utilities

================
File: apps/tui/src/main.ts
================
import { Config } from "@ccflare/config";
import { CLAUDE_MODEL_IDS, NETWORK, shutdown } from "@ccflare/core";
import { container, SERVICE_KEYS } from "@ccflare/core-di";
import { DatabaseFactory } from "@ccflare/database";
import { Logger } from "@ccflare/logger";
// Import server
import startServer from "@ccflare/server";
⋮----
import { parseArgs } from "@ccflare/tui-core";
import { render } from "ink";
import React from "react";
import { App } from "./App";
⋮----
// Global singleton for auto-started server
⋮----
async function ensureServer(port: number)
⋮----
async function main()
⋮----
// Initialize DI container and services
⋮----
// Initialize database factory
⋮----
// Handle help
⋮----
// Handle non-interactive commands
⋮----
// Keep process alive
⋮----
// First print historical logs if limit was specified
⋮----
// Then stream live logs
⋮----
// Validate the model
⋮----
// Default: Launch interactive TUI with auto-started server
⋮----
// Cleanup server when TUI exits
⋮----
// Shutdown all resources
⋮----
// Run main and handle errors
⋮----
// Handle process termination

================
File: packages/agents/src/discovery.ts
================
import { existsSync } from "node:fs";
import { readdir, readFile, writeFile } from "node:fs/promises";
import { basename, join, resolve } from "node:path";
import { Config } from "@ccflare/config";
import { Logger } from "@ccflare/logger";
import {
	type Agent,
	type AgentTool,
	type AgentWorkspace,
	ALLOWED_MODELS,
	type AllowedModel,
} from "@ccflare/types";
import { getAgentsDirectory } from "./paths";
import { workspacePersistence } from "./workspace-persistence";
⋮----
interface AgentCache {
	agents: Agent[];
	timestamp: number;
}
⋮----
const CACHE_TTL_MS = 30 * 1000; // 30 seconds
⋮----
export class AgentRegistry
⋮----
constructor()
⋮----
// Initialize the registry (load persisted workspaces)
async initialize(): Promise<void>
⋮----
// Load agents from all workspaces
⋮----
this.initialized = true; // Mark as initialized even on error
⋮----
private isValidModel(model: string): model is AllowedModel
⋮----
private async loadAgentFromFile(
		filePath: string,
		source: "global" | "workspace",
		workspace?: string,
): Promise<Agent | null>
⋮----
// Extract frontmatter manually
⋮----
// Parse frontmatter into a data object
⋮----
// Check if this line starts a new key-value pair
⋮----
// Save previous key-value pair if exists
⋮----
// Start new key-value pair
⋮----
// This is a continuation of the previous value
⋮----
// Save the last key-value pair
⋮----
// Validate required fields
⋮----
// Parse and validate model
⋮----
// Handle shorthand model names
⋮----
model = ALLOWED_MODELS[0]; // claude-opus-4-20250514
⋮----
model = ALLOWED_MODELS[1]; // claude-sonnet-4-20250514
⋮----
// Parse tools from frontmatter
⋮----
async loadAgents(): Promise<void>
⋮----
// Load global agents
⋮----
// Load workspace agents
⋮----
// For workspace agents, prefix the ID with workspace path to ensure uniqueness
⋮----
// Update the agent ID to include workspace prefix
⋮----
async getAgents(): Promise<Agent[]>
⋮----
// Ensure we're initialized
⋮----
// Check if cache is valid
⋮----
// Reload agents
⋮----
async findAgentByPrompt(systemPrompt: string): Promise<Agent | undefined>
⋮----
// Normalize the prompt for comparison
⋮----
// Check if the agent's system prompt is contained within the provided prompt
// This handles cases where the agent prompt is part of a larger system prompt
⋮----
// Force reload agents (useful for testing or manual refresh)
async refresh(): Promise<void>
⋮----
// Register a workspace
async registerWorkspace(workspacePath: string): Promise<void>
⋮----
// Check if this workspace is already registered
⋮----
// Update last seen time
⋮----
// Extract workspace name from path
⋮----
// Create new workspace entry
⋮----
// Save workspaces to disk
⋮----
// Refresh to load agents from the new workspace
⋮----
// Get current workspaces
getWorkspaces(): AgentWorkspace[]
⋮----
// Save workspaces to disk
private async saveWorkspaces(): Promise<void>
⋮----
// Clear all workspaces (useful for testing)
async clearWorkspaces(): Promise<void>
⋮----
// Remove old workspaces that haven't been seen recently (e.g., 7 days)
async pruneOldWorkspaces(
		maxAgeMs: number = 7 * 24 * 60 * 60 * 1000,
): Promise<void>
⋮----
this.cache = null; // Clear cache to force reload
⋮----
// Update an agent in the filesystem
async updateAgent(
		agentId: string,
		updates: Partial<
			Pick<Agent, "description" | "model" | "tools" | "color" | "systemPrompt">
		>,
		dbOps?: { deleteAgentPreference: (agentId: string) => boolean },
): Promise<Agent>
⋮----
// Ensure we're initialized
⋮----
// Find the agent
⋮----
// Prepare front-matter updates
⋮----
// Remove tools property entirely for "all" mode
⋮----
// Reconstruct the agent file
⋮----
// Parse existing frontmatter
⋮----
// Apply updates to frontmatter
⋮----
// Reconstruct frontmatter with proper formatting
⋮----
// Use updated system prompt or existing one
⋮----
// Write the updated file
⋮----
// If model was updated, clear any database preference to avoid conflicts
⋮----
// Force cache refresh
⋮----
// Return updated agent
⋮----
// Create singleton instance

================
File: packages/config/src/index.ts
================
import { EventEmitter } from "node:events";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname } from "node:path";
import {
	DEFAULT_AGENT_MODEL,
	DEFAULT_STRATEGY,
	isValidStrategy,
	NETWORK,
	type StrategyName,
	TIME_CONSTANTS,
} from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import { resolveConfigPath } from "./paths";
⋮----
export interface RuntimeConfig {
	clientId: string;
	retry: { attempts: number; delayMs: number; backoff: number };
	sessionDurationMs: number;
	port: number;
}
⋮----
export interface ConfigData {
	lb_strategy?: StrategyName;
	client_id?: string;
	retry_attempts?: number;
	retry_delay_ms?: number;
	retry_backoff?: number;
	session_duration_ms?: number;
	port?: number;
	default_agent_model?: string;
	data_retention_days?: number;
	request_retention_days?: number;
	[key: string]: string | number | boolean | undefined;
}
⋮----
export class Config extends EventEmitter
⋮----
constructor(configPath?: string)
⋮----
private loadConfig(): void
⋮----
// Create config directory if it doesn't exist
⋮----
// Initialize with default config
⋮----
private saveConfig(): void
⋮----
get(
		key: string,
		defaultValue?: string | number | boolean,
): string | number | boolean | undefined
⋮----
set(key: string, value: string | number | boolean): void
⋮----
// Emit change event
⋮----
getStrategy(): StrategyName
⋮----
// First check environment variable
⋮----
// Then check config file
⋮----
setStrategy(strategy: StrategyName): void
⋮----
getDefaultAgentModel(): string
⋮----
// First check environment variable
⋮----
// Then check config file
⋮----
// Default to the centralized default agent model
⋮----
setDefaultAgentModel(model: string): void
⋮----
private clamp(n: number, min: number, max: number): number
⋮----
getDataRetentionDays(): number
⋮----
setDataRetentionDays(days: number): void
⋮----
getRequestRetentionDays(): number
⋮----
return 365; // default metadata retention
⋮----
setRequestRetentionDays(days: number): void
⋮----
getAllSettings(): Record<string, string | number | boolean | undefined>
⋮----
// Include current strategy (which might come from env)
⋮----
getRuntime(): RuntimeConfig
⋮----
// Default values
⋮----
// Override with environment variables if present
⋮----
// Override with config file settings if present
⋮----
// Re-export types

================
File: packages/core/src/pricing.ts
================
import { promises as fs } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { TIME_CONSTANTS } from "./constants";
import { CLAUDE_MODEL_IDS, MODEL_DISPLAY_NAMES } from "./models";
⋮----
export interface TokenBreakdown {
	inputTokens?: number;
	outputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
}
⋮----
interface ModelCost {
	input: number;
	output: number;
	cache_read?: number;
	cache_write?: number;
}
⋮----
interface ModelDef {
	id: string;
	name: string;
	cost?: ModelCost;
}
⋮----
interface ApiResponse {
	[provider: string]: {
		models?: {
			[modelId: string]: ModelDef;
		};
	};
}
⋮----
// Bundled fallback pricing for Anthropic models (dollars per 1M tokens)
⋮----
interface Logger {
	warn(message: string, ...args: unknown[]): void;
}
⋮----
warn(message: string, ...args: unknown[]): void;
⋮----
class PriceCatalogue
⋮----
private constructor()
⋮----
setLogger(logger: Logger): void
⋮----
static get(): PriceCatalogue
⋮----
private getCacheDir(): string
⋮----
private getCachePath(): string
⋮----
private getCacheDurationMs(): number
⋮----
private async ensureCacheDir(): Promise<void>
⋮----
private async loadFromCache(): Promise<ApiResponse | null>
⋮----
// Cache miss or error - that's ok
⋮----
private async saveToCache(data: ApiResponse): Promise<void>
⋮----
private async fetchRemote(): Promise<ApiResponse | null>
⋮----
async getPricing(): Promise<ApiResponse>
⋮----
// Return cached data if available
⋮----
// Always attempt to fetch fresh pricing first (once per process start)
⋮----
// If remote fetch failed (offline or error), fall back to disk cache
⋮----
// Fall back to bundled pricing
⋮----
warnOnce(modelId: string): void
⋮----
/**
 * Set the logger for pricing warnings
 */
export function setPricingLogger(logger: Logger): void
⋮----
/**
 * Get the cost rate for a specific model and token type
 * @returns Cost in dollars per token (NOT per million)
 * @throws If model or cost type is unknown
 */
async function getCostRate(
	modelId: string,
	kind: "input" | "output" | "cache_read" | "cache_write",
): Promise<number>
⋮----
// Search all providers for the model
⋮----
// Convert from per-million to per-token
⋮----
/**
 * Estimate the total cost in USD for a request based on token counts
 * @returns Cost in dollars (NOT per million)
 */
export async function estimateCostUSD(
	modelId: string,
	tokens: TokenBreakdown,
): Promise<number>

================
File: packages/core/src/request-events.ts
================
import { EventEmitter } from "node:events";
⋮----
export type RequestStartEvt = {
	type: "start";
	id: string;
	timestamp: number;
	method: string;
	path: string;
	accountId: string | null;
	statusCode: number;
	agentUsed: string | null;
};
⋮----
export type RequestSummaryEvt = {
	type: "summary";
	payload: import("@ccflare/types").RequestResponse;
};
⋮----
export type RequestPayloadEvt = {
	type: "payload";
	payload: import("@ccflare/types").RequestPayload;
};
⋮----
export type RequestEvt =
	| RequestStartEvt
	| RequestSummaryEvt
	| RequestPayloadEvt;
⋮----
class RequestEventBus extends EventEmitter

================
File: packages/dashboard-web/src/components/accounts/AccountListItem.tsx
================
import { AccountPresenter } from "@ccflare/ui-common";
import {
	AlertCircle,
	CheckCircle,
	Edit2,
	Pause,
	Play,
	Trash2,
} from "lucide-react";
import type { Account } from "../../api";
import { Button } from "../ui/button";
import { RateLimitProgress } from "./RateLimitProgress";
⋮----
interface AccountListItemProps {
	account: Account;
	isActive?: boolean;
	onPauseToggle: (account: Account) => void;
	onRemove: (name: string) => void;
	onRename: (account: Account) => void;
}

================
File: packages/dashboard-web/src/components/charts/ModelTokenSpeedChart.tsx
================
import { getModelShortName } from "@ccflare/core";
import { formatTokensPerSecond } from "@ccflare/ui-common";
import {
	Bar,
	BarChart,
	CartesianGrid,
	Cell,
	ErrorBar,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { getTooltipStyles } from "./chart-utils";
⋮----
interface ModelTokenSpeedData {
	model: string;
	avgTokensPerSecond: number | null;
	minTokensPerSecond: number | null;
	maxTokensPerSecond: number | null;
}
⋮----
interface ModelTokenSpeedChartProps {
	data: ModelTokenSpeedData[];
	loading?: boolean;
	height?: number;
}
⋮----
// Model-based color palette
⋮----
// Add more models as needed
⋮----
function getModelColor(model: string): string
⋮----
// Try to find color by short name first
⋮----
// Check for exact match
⋮----
// Check for partial matches
⋮----
// Default color
⋮----
// Filter out models without token speed data and prepare chart data
⋮----
// Calculate error bars (distance from avg to min/max)
⋮----
.sort((a, b) => b.avgSpeed - a.avgSpeed); // Sort by average speed
⋮----
fill=

================
File: packages/dashboard-web/src/components/conversation/Message.tsx
================
import {
	type ContentBlock,
	ContentBlockType,
	type Role,
	type ToolResult,
	type ToolUse,
} from "@ccflare/types";
import type { LucideIcon } from "lucide-react";
import { Bot, FileText, Terminal, User } from "lucide-react";
import React from "react";
import { Badge } from "../ui/badge";
import { MessageBubble } from "./MessageBubble";
import { ThinkingBlock } from "./ThinkingBlock";
import { ToolResultBlock } from "./ToolResultBlock";
import { ToolUsageBlock } from "./ToolUsageBlock";
⋮----
interface MessageProps {
	role: Role;
	content: string;
	contentBlocks?: ContentBlock[];
	tools?: ToolUse[];
	toolResults?: ToolResult[];
	cleanLineNumbers: (content: string) => string;
}
⋮----
{/* Thinking block */}
⋮----
<ThinkingBlock content=
⋮----
{/* Main content */}
⋮----
{/* Tool usage */}
⋮----
{/* Tool results */}

================
File: packages/dashboard-web/src/components/tools/SystemPromptInterceptorCard.tsx
================
import { useEffect, useState } from "react";
import {
	useResetSystemPromptOverride,
	useSetSystemPromptOverride,
	useSystemPromptOverride,
} from "../../hooks/queries";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardFooter,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Label } from "../ui/label";
import { Switch } from "../ui/switch";
import { Textarea } from "../ui/textarea";
⋮----
export function SystemPromptInterceptorCard()
⋮----
// Local form state
⋮----
// Sync server data to local state
⋮----
const handleSave = () =>

================
File: packages/dashboard-web/src/components/OverviewTab.tsx
================
import {
	formatCost,
	formatNumber,
	formatPercentage,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import { format } from "date-fns";
import { Activity, CheckCircle, Clock, DollarSign, Zap } from "lucide-react";
import { useMemo, useState } from "react";
import { REFRESH_INTERVALS } from "../constants";
import { useAccounts, useAnalytics, useStats } from "../hooks/queries";
import { ChartsSection } from "./overview/ChartsSection";
import { DataRetentionCard } from "./overview/DataRetentionCard";
import { LoadingSkeleton } from "./overview/LoadingSkeleton";
import { MetricCard } from "./overview/MetricCard";
import { RateLimitInfo } from "./overview/RateLimitInfo";
import { SystemStatus } from "./overview/SystemStatus";
import { TimeRangeSelector } from "./overview/TimeRangeSelector";
import { StrategyCard } from "./StrategyCard";
⋮----
// Fetch all data using React Query hooks
⋮----
// Transform time series data
⋮----
// Helper function to calculate percentage change
⋮----
if (previous === 0) return null; // avoid division by zero
⋮----
// Get trend period description based on time range
function getTrendPeriod(range: string): string
⋮----
// Calculate percentage changes from time series data
⋮----
// Calculate deltas
⋮----
// For response time, calculate normal percentage change
⋮----
// Determine trends
⋮----
// For response time, higher is worse (positive change is bad)
⋮----
// For cost, higher is bad (positive change is bad)
⋮----
// For output speed, higher is better
⋮----
// Use analytics data for model distribution
⋮----
// Use analytics data for account health
⋮----
{/* Header with Time Range Selector */}
⋮----
{/* Metrics Grid */}
⋮----
{/* Configuration Row */}

================
File: packages/database/src/repositories/interceptor.repository.ts
================
import { BaseRepository } from "./base.repository";
⋮----
export interface InterceptorConfig {
	targetPrompt: string;
	replacementPrompt: string;
	toolsEnabled: boolean;
}
⋮----
interface InterceptorRow {
	id: string;
	is_enabled: number;
	config: string;
}
⋮----
export class InterceptorRepository extends BaseRepository<InterceptorRow>
⋮----
getConfig(
		id: string,
):
⋮----
setConfig(id: string, isEnabled: boolean, config: InterceptorConfig): void
⋮----
/**
	 * Delete an interceptor configuration
	 */
delete(id: string): boolean

================
File: packages/http-api/src/handlers/agents-update.ts
================
import { agentRegistry } from "@ccflare/agents";
import type { DatabaseOperations } from "@ccflare/database";
import { errorResponse, jsonResponse } from "@ccflare/http-common";
import type { AgentTool, AllowedModel } from "@ccflare/types";
import { ALLOWED_MODELS, TOOL_PRESETS } from "@ccflare/types";
⋮----
type ToolMode = keyof typeof TOOL_PRESETS | "custom";
⋮----
interface AgentUpdateRequest {
	description?: string;
	model?: AllowedModel;
	tools?: AgentTool[];
	color?: string;
	systemPrompt?: string;
	mode?: ToolMode;
}
⋮----
export function createAgentUpdateHandler(dbOps: DatabaseOperations)
⋮----
// Validate individual pieces
⋮----
// Handle tools - either from mode or explicit tools array
⋮----
// Update agent using the registry

================
File: packages/http-api/src/handlers/config.ts
================
import type { Config } from "@ccflare/config";
import {
	DEFAULT_AGENT_MODEL,
	NETWORK,
	STRATEGIES,
	type StrategyName,
	TIME_CONSTANTS,
	validateNumber,
	validateString,
} from "@ccflare/core";
import { BadRequest, errorResponse, jsonResponse } from "@ccflare/http-common";
import type { ConfigResponse, RetentionSetRequest } from "../types";
⋮----
/**
 * Create config handlers
 */
export function createConfigHandlers(config: Config)
⋮----
/**
		 * Get all configuration settings
		 */
⋮----
/**
		 * Get current strategy
		 */
⋮----
/**
		 * Update strategy
		 */
⋮----
// Validate strategy input
⋮----
/**
		 * Get available strategies
		 */
⋮----
/**
		 * Get default agent model
		 */
⋮----
/**
		 * Set default agent model
		 */
⋮----
// Validate model input
⋮----
/**
		 * Get current data retention in days
		 */
⋮----
/**
		 * Set data retention in days
		 */

================
File: packages/proxy/src/post-processor.worker.ts
================
import { BUFFER_SIZES, estimateCostUSD, TIME_CONSTANTS } from "@ccflare/core";
import { AsyncDbWriter, DatabaseOperations } from "@ccflare/database";
import { Logger } from "@ccflare/logger";
import {
	NO_ACCOUNT_ID,
	type RequestPayload,
	type RequestResponse,
} from "@ccflare/types";
import { formatCost } from "@ccflare/ui-common";
import { get_encoding } from "@dqbd/tiktoken";
import { combineChunks } from "./stream-tee";
import type {
	ChunkMessage,
	EndMessage,
	PayloadMessage,
	StartMessage,
	SummaryMessage,
	WorkerMessage,
} from "./worker-messages";
⋮----
interface RequestState {
	startMessage: StartMessage;
	buffer: string;
	chunks: Uint8Array[];
	usage: {
		model?: string;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
		outputTokensComputed?: number;
		totalTokens?: number;
		costUsd?: number;
		tokensPerSecond?: number;
	};
	lastActivity: number;
	agentUsed?: string;
	firstTokenTimestamp?: number;
	lastTokenTimestamp?: number;
	providerFinalOutputTokens?: number;
	shouldSkipLogging?: boolean;
}
⋮----
// Initialize tiktoken encoder (cl100k_base is used for Claude models)
⋮----
// Initialize database connection for worker
⋮----
// Environment variables
⋮----
// Check if a request should be logged
function shouldLogRequest(path: string, status: number): boolean
⋮----
// Skip logging .well-known 404s
⋮----
// Extract system prompt from request body
function _extractSystemPrompt(requestBody: string | null): string | null
⋮----
// Decode base64 request body
⋮----
// Check if there's a system property in the request
⋮----
// Handle both string and array formats
⋮----
// Concatenate all text from system messages
⋮----
// Parse SSE lines to extract usage (reuse existing logic)
function parseSSELine(line: string):
⋮----
// Extract usage data from non-stream JSON response bodies
function extractUsageFromJson(
	json: {
		model?: string;
		usage?: {
			input_tokens?: number;
			cache_read_input_tokens?: number;
			cache_creation_input_tokens?: number;
			output_tokens?: number;
		};
	},
	state: RequestState,
): void
⋮----
// Calculate total tokens
⋮----
function extractUsageFromData(data: string, state: RequestState): void
⋮----
// Handle message_start
⋮----
// Track streaming start time on first content block
⋮----
// Handle message_delta - provider's authoritative output token count AND end time
⋮----
return; // No further processing needed
⋮----
// Count tokens locally as fallback (but provider's count takes precedence)
⋮----
state.providerFinalOutputTokens === undefined // Avoid double counting
⋮----
// Extract text from different delta types
⋮----
// Count tokens using tiktoken
⋮----
// Handle any usage field in the data
⋮----
// Silent fail for non-JSON lines
⋮----
function processStreamChunk(chunk: Uint8Array, state: RequestState): void
⋮----
// Limit buffer size
⋮----
// Process complete lines
⋮----
async function handleStart(msg: StartMessage): Promise<void>
⋮----
// Check if we should skip logging this request
⋮----
// Create request state
⋮----
// Use agent from message if provided
⋮----
// Skip all database operations for ignored requests
⋮----
// Save minimal request info immediately
⋮----
// Update account usage if authenticated
⋮----
const accountId = msg.accountId; // Capture for closure
⋮----
function handleChunk(msg: ChunkMessage): void
⋮----
// Store chunk for later payload saving
⋮----
// Process for usage extraction
⋮----
async function handleEnd(msg: EndMessage): Promise<void>
⋮----
// Skip all database operations for ignored requests
⋮----
// Clean up state without logging
⋮----
// For non-stream responses, extract usage data from response body
⋮----
// Ignore parse errors
⋮----
// Calculate total tokens and cost
⋮----
// Use provider's authoritative count if available, fallback to computed
⋮----
// Update usage with final values
⋮----
state.usage.outputTokensComputed = undefined; // Clear to avoid confusion
⋮----
// Calculate tokens per second using actual streaming duration
⋮----
// If tokens were generated instantly, use a very small duration
⋮----
// Update request with final data
⋮----
// Keep original breakdown for payload
⋮----
// Save payload
⋮----
// Non-streaming response
⋮----
// Streaming response - combine chunks
⋮----
// Log if we have usage
⋮----
// Post summary to main thread for real-time updates
⋮----
// Post full payload to main thread
⋮----
// Clean up
⋮----
async function handleShutdown(): Promise<void>
⋮----
// Worker will be terminated by main thread
⋮----
// Periodic cleanup of stale requests (safety net for orphaned requests)
// This should rarely trigger as the main app handles timeouts
⋮----
}, TIMEOUT_MS); // Check every TIMEOUT_MS
⋮----
// Message handler

================
File: packages/proxy/src/proxy.ts
================
import { requestEvents, ServiceUnavailableError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import {
	createRequestMetadata,
	ERROR_MESSAGES,
	interceptAndModifyRequest,
	type ProxyContext,
	prepareRequestBody,
	proxyUnauthenticated,
	proxyWithAccount,
	selectAccountsForRequest,
	TIMING,
	validateProviderPath,
} from "./handlers";
import type { ControlMessage, OutgoingWorkerMessage } from "./worker-messages";
⋮----
// ===== WORKER MANAGEMENT =====
⋮----
// Create usage worker instance
⋮----
/**
 * Gets or creates the usage worker instance
 * @returns The usage worker instance
 */
export function getUsageWorker(): Worker
⋮----
// Bun extends Worker with unref method
⋮----
usageWorkerInstance.unref(); // Don't keep process alive
⋮----
// Listen for summary messages from worker
⋮----
/**
 * Gracefully terminates the usage worker
 */
export function terminateUsageWorker(): void
⋮----
// Send shutdown message to allow worker to flush
⋮----
// Give worker time to flush before terminating
⋮----
// ===== MAIN HANDLER =====
⋮----
/**
 * Main proxy handler - orchestrates the entire proxy flow
 *
 * This function coordinates the proxy process by:
 * 1. Creating request metadata for tracking
 * 2. Validating the provider can handle the path
 * 3. Preparing the request body for reuse
 * 4. Selecting accounts based on load balancing strategy
 * 5. Attempting to proxy with each account in order
 * 6. Falling back to unauthenticated proxy if no accounts available
 *
 * @param req - The incoming request
 * @param url - The parsed URL
 * @param ctx - The proxy context containing strategy, database, and provider
 * @returns Promise resolving to the proxied response
 * @throws {ValidationError} If the provider cannot handle the path
 * @throws {ServiceUnavailableError} If all accounts fail to proxy the request
 * @throws {ProviderError} If unauthenticated proxy fails
 */
export async function handleProxy(
	req: Request,
	url: URL,
	ctx: ProxyContext,
): Promise<Response>
⋮----
// 1. Validate provider can handle path
⋮----
// 2. Prepare request body
⋮----
// 3. Intercept and modify request for agent model preferences and system prompt
⋮----
// Use modified body if available
⋮----
const finalCreateBodyStream = () =>
⋮----
// 4. Create request metadata with agent info
⋮----
// 5. Select accounts
⋮----
// 6. Handle no accounts case
⋮----
// 7. Log selected accounts
⋮----
// 8. Try each account
⋮----
// 9. All accounts failed

================
File: packages/proxy/src/response-handler.ts
================
import { requestEvents } from "@ccflare/core";
import {
	sanitizeRequestHeaders,
	withSanitizedProxyHeaders,
} from "@ccflare/http-common";
import type { Account } from "@ccflare/types";
import type { ProxyContext } from "./handlers";
import type { ChunkMessage, EndMessage, StartMessage } from "./worker-messages";
⋮----
/**
 * Check if a response should be considered successful/expected
 * Treats certain well-known paths that return 404 as expected
 */
function isExpectedResponse(path: string, response: Response): boolean
⋮----
// Any .well-known path returning 404 is expected
⋮----
// Otherwise use standard HTTP success logic
⋮----
export interface ResponseHandlerOptions {
	requestId: string;
	method: string;
	path: string;
	account: Account | null;
	requestHeaders: Headers;
	requestBody: ArrayBuffer | null;
	response: Response;
	timestamp: number;
	retryAttempt: number;
	failoverAttempts: number;
	agentUsed?: string | null;
}
⋮----
/**
 * Unified response handler that immediately streams responses
 * while forwarding data to worker for async processing
 */
// Forward response to client while streaming analytics to worker
export async function forwardToClient(
	options: ResponseHandlerOptions,
	ctx: ProxyContext,
): Promise<Response>
⋮----
retryAttempt, // Always 0 in new flow, but kept for message compatibility
⋮----
// Always strip compression headers *before* we do anything else
⋮----
// Prepare objects once for serialisation - sanitize headers before storing
⋮----
// Send START message immediately
⋮----
// Emit request start event for real-time dashboard
⋮----
/*********************************************************************
	 *  STREAMING RESPONSES — tee with Response.clone() and send chunks
	 *********************************************************************/
⋮----
// Clone response once for background consumption.
⋮----
if (!reader) return; // Safety check
// eslint-disable-next-line no-constant-condition
⋮----
// Finished without errors
⋮----
// Return the sanitized response
⋮----
/*********************************************************************
	 *  NON-STREAMING RESPONSES — read body in background, send END once
	 *********************************************************************/
⋮----
// Return the sanitized response

================
File: packages/types/src/agent.ts
================
import { CLAUDE_MODEL_IDS } from "@ccflare/core";
⋮----
export type AgentSource = "global" | "workspace";
⋮----
export type AgentTool =
	| "Bash"
	| "Glob"
	| "Grep"
	| "LS"
	| "Read"
	| "Edit"
	| "MultiEdit"
	| "Write"
	| "NotebookRead"
	| "NotebookEdit"
	| "WebFetch"
	| "TodoWrite"
	| "WebSearch";
⋮----
export interface AgentWorkspace {
	path: string;
	name: string;
	lastSeen: number; // timestamp
}
⋮----
lastSeen: number; // timestamp
⋮----
export interface Agent {
	id: string;
	name: string;
	description: string;
	color: string;
	model: AllowedModel;
	systemPrompt: string;
	source: AgentSource;
	workspace?: string; // workspace path if source is "workspace"
	tools?: AgentTool[]; // parsed from tools: front-matter
	filePath: string; // absolute path of the markdown file
}
⋮----
workspace?: string; // workspace path if source is "workspace"
tools?: AgentTool[]; // parsed from tools: front-matter
filePath: string; // absolute path of the markdown file
⋮----
export type AgentResponse = Agent[];
⋮----
export type AllowedModel = (typeof ALLOWED_MODELS)[number];

================
File: packages/types/src/api.ts
================
export interface RequestMeta {
	id: string;
	method: string;
	path: string;
	timestamp: number;
	agentUsed?: string | null;
}
⋮----
export interface AgentUpdatePayload {
	description?: string;
	model?: string;
	tools?: string[];
	color?: string;
	systemPrompt?: string;
	mode?: "all" | "edit" | "read-only" | "execution" | "custom";
}
⋮----
// Retention and maintenance API shapes
export interface RetentionGetResponse {
	payloadDays: number;
	requestDays: number;
}
⋮----
export interface RetentionSetRequest {
	payloadDays?: number;
	requestDays?: number;
}
⋮----
export interface CleanupResponse {
	removedRequests: number;
	removedPayloads: number;
	cutoffIso: string;
}
⋮----
export interface CompactResponse {
	ok: boolean;
}

================
File: packages/types/src/stats.ts
================
// Stats types
export interface Stats {
	totalRequests: number;
	successRate: number;
	activeAccounts: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	topModels: Array<{ model: string; count: number }>;
	avgTokensPerSecond: number | null;
}
⋮----
export interface StatsResponse {
	totalRequests: number;
	successRate: number;
	activeAccounts: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	topModels: Array<{ model: string; count: number }>;
	avgTokensPerSecond: number | null;
}
⋮----
export interface StatsWithAccounts extends Stats {
	accounts: Array<{
		name: string;
		requestCount: number;
		successRate: number;
	}>;
	recentErrors: string[];
}
⋮----
// Analytics types
export interface TimePoint {
	ts: number; // period start (ms)
	model?: string; // Optional model name for per-model time series
	requests: number;
	tokens: number;
	costUsd: number;
	successRate: number; // 0-100
	errorRate: number; // 0-100
	cacheHitRate: number; // 0-100
	avgResponseTime: number; // ms
	avgTokensPerSecond: number | null;
}
⋮----
ts: number; // period start (ms)
model?: string; // Optional model name for per-model time series
⋮----
successRate: number; // 0-100
errorRate: number; // 0-100
cacheHitRate: number; // 0-100
avgResponseTime: number; // ms
⋮----
export interface TokenBreakdown {
	inputTokens: number;
	cacheReadInputTokens: number;
	cacheCreationInputTokens: number;
	outputTokens: number;
}
⋮----
export interface ModelPerformance {
	model: string;
	avgResponseTime: number;
	p95ResponseTime: number;
	errorRate: number;
	avgTokensPerSecond: number | null;
	minTokensPerSecond: number | null;
	maxTokensPerSecond: number | null;
}
⋮----
export interface AnalyticsResponse {
	meta?: {
		range: string;
		bucket: string;
		cumulative?: boolean;
	};
	totals: {
		requests: number;
		successRate: number;
		activeAccounts: number;
		avgResponseTime: number;
		totalTokens: number;
		totalCostUsd: number;
		avgTokensPerSecond: number | null;
	};
	timeSeries: TimePoint[];
	tokenBreakdown: TokenBreakdown;
	modelDistribution: Array<{ model: string; count: number }>;
	accountPerformance: Array<{
		name: string;
		requests: number;
		successRate: number;
	}>;
	costByModel: Array<{
		model: string;
		costUsd: number;
		requests: number;
		totalTokens?: number;
	}>;
	modelPerformance: ModelPerformance[];
}
⋮----
// Health check response
export interface HealthResponse {
	status: string;
	accounts: number;
	timestamp: string;
	strategy: string;
}
⋮----
// Config types
export interface ConfigResponse {
	lb_strategy: string;
	port: number;
	sessionDurationMs: number;
	default_agent_model: string;
}
⋮----
export interface StrategyUpdateRequest {
	strategy: string;
}
⋮----
export interface TierUpdateRequest {
	tier: number;
}

================
File: packages/ui-common/src/parsers/parse-conversation.ts
================
import {
	ContentBlockType,
	type MessageData,
	type ToolUse,
} from "@ccflare/types";
import { normalizeText } from "../utils/normalize-text";
⋮----
export function parseRequestMessages(body: string | null): MessageData[]
⋮----
// Process content blocks
⋮----
// Filter out system reminders
⋮----
export function parseAssistantMessage(body: string | null): MessageData | null
⋮----
// Handle different event types
⋮----
// Thinking block will be added when content is received
⋮----
// Update tool input
⋮----
// This is a simplified approach - in production you'd want proper JSON streaming
⋮----
// Try to parse the partial JSON, fallback to empty object
⋮----
// If parsing fails, store raw string in a temporary field
⋮----
// Ignore JSON parsing errors for partial data
⋮----
// Skip invalid JSON
⋮----
// If no streaming data found, try parsing as direct response
⋮----
// Not JSON, might be plain text

================
File: packages/dashboard-web/src/components/charts/MultiModelChart.tsx
================
import { getModelShortName } from "@ccflare/core";
import {
	formatCost,
	formatNumber,
	formatTokens,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import {
	CartesianGrid,
	Legend,
	Line,
	LineChart,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import {
	CHART_COLORS,
	CHART_HEIGHTS,
	CHART_PROPS,
	COLORS,
} from "../../constants";
import {
	formatCompactCurrency,
	formatCompactNumber,
} from "../../lib/chart-utils";
import { ChartContainer } from "./ChartContainer";
import { getTooltipStyles } from "./chart-utils";
⋮----
interface MultiModelChartProps {
	data: Array<{
		time: string;
		[model: string]: string | number;
	}>;
	models: string[];
	metric:
		| "requests"
		| "tokens"
		| "cost"
		| "responseTime"
		| "tokensPerSecond"
		| "errorRate"
		| "cacheHitRate";
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
}
⋮----
// Model-based color palette
⋮----
function getModelColor(model: string, index: number): string
⋮----
// Try to find color by short name first
⋮----
// Check for exact match
⋮----
// Check for partial matches
⋮----
// Use chart colors array as fallback
⋮----
function getMetricLabel(metric: string): string
⋮----
function formatValue(value: number, metric: string): string
⋮----
function formatAxisValue(value: number, metric: string): string
⋮----
tickFormatter=
⋮----
stroke=

================
File: packages/dashboard-web/src/components/AgentsTab.tsx
================
import { DEFAULT_AGENT_MODEL, getModelDisplayName } from "@ccflare/core";
import { ALLOWED_MODELS } from "@ccflare/types";
import {
	AlertCircle,
	Bot,
	Folder,
	FolderOpen,
	Globe,
	Info,
	Package,
	RefreshCw,
	Settings,
} from "lucide-react";
import { useState } from "react";
import {
	useAgents,
	useBulkUpdateAgentPreferences,
	useDefaultAgentModel,
	useSetDefaultAgentModel,
	useUpdateAgentPreference,
} from "../hooks/queries";
import { AgentCard, WorkspaceCard } from "./agents";
import { Badge } from "./ui/badge";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
	DialogTrigger,
} from "./ui/dialog";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "./ui/select";
import { Separator } from "./ui/separator";
import { Skeleton } from "./ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/tabs";
⋮----
const handleModelChange = (agentId: string, model: string) =>
⋮----
const handleDefaultModelChange = (model: string) =>
⋮----
const handleBulkUpdate = () =>
⋮----
// You could add a toast notification here
⋮----
// biome-ignore lint/suspicious/noArrayIndexKey: Static skeleton elements
⋮----
// Add agent counts to workspaces
⋮----
{/* Header */}
⋮----
{/* Default Model Settings */}
⋮----
{/* Workspaces Section */}
⋮----
{/* Agents Tabs */}

================
File: packages/dashboard-web/src/components/AnalyticsTab.tsx
================
import { format } from "date-fns";
import { useMemo, useState } from "react";
import type { TimeRange } from "../constants";
import { useAnalytics } from "../hooks/queries";
import {
	AnalyticsControls,
	CumulativeGrowthChart,
	CumulativeTokenComposition,
	type FilterState,
	MainMetricsChart,
	ModelAnalytics,
	PerformanceIndicatorsChart,
	TokenSpeedAnalytics,
	TokenUsageBreakdown,
} from "./analytics";
⋮----
// Fetch analytics data with automatic refetch on dependency changes
⋮----
// Get unique accounts and models from analytics data
⋮----
// Apply filters to data
const filterData = <T extends { errorRate?: number | string }>(
		data: T[],
): T[] =>
⋮----
// Status filter
⋮----
// For time series data, we can't filter by specific accounts/models
// Those filters will be applied to the other charts
⋮----
// Transform time series data for charts
⋮----
// Calculate token usage breakdown
⋮----
// Use real model performance data from backend with filters
⋮----
// Use real cost by model data with filters
⋮----
// Count active filters
⋮----
{/* Controls */}
⋮----
// Disable per-model breakdown when switching to cumulative
⋮----
{/* Cumulative View - Show cumulative charts first */}
⋮----
{/* Beautiful Cumulative Chart */}
⋮----
{/* Cumulative Token Breakdown Ribbon Chart */}
⋮----
{/* Main Metrics Chart */}
⋮----
{/* Normal View Charts - Only show in normal mode */}
⋮----
{/* Secondary Charts Row */}
⋮----
{/* Enhanced Model Analytics */}
⋮----
{/* Token Speed Analytics */}

================
File: packages/dashboard-web/src/components/ConversationView.tsx
================
import type { MessageData } from "@ccflare/types";
import {
	cleanLineNumbers,
	genMessageKey,
	parseAssistantMessage,
	parseRequestMessages,
} from "@ccflare/ui-common";
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { Message } from "./conversation";
⋮----
interface ConversationViewProps {
	requestBody: string | null;
	responseBody: string | null;
}
⋮----
// Create stable cleanLineNumbers function
⋮----
// Parse request body to extract conversation messages
⋮----
// Parse streaming response to extract assistant message
⋮----
// Combine messages
⋮----
key=

================
File: packages/dashboard-web/src/hooks/useRequestStream.ts
================
import { useQueryClient } from "@tanstack/react-query";
import { useEffect } from "react";
import type { Account, RequestPayload, RequestResponse } from "../api";
import { queryKeys } from "../lib/query-keys";
⋮----
export function useRequestStream(limit = 200)
⋮----
const connect = () =>
⋮----
// Clear any existing timeout
⋮----
// Reset retry count on successful connection
⋮----
// Ensure detailsMap is a Map
⋮----
// Look up account name from cache
⋮----
// Create a lightweight placeholder payload
⋮----
// Check if this request already exists
⋮----
// Update existing placeholder
⋮----
// Add new placeholder at the beginning
⋮----
// Replace placeholder or insert if missing
⋮----
// Update details map with summary
⋮----
// Update the request if it exists
⋮----
// Update meta to remove pending status
⋮----
// Calculate exponential backoff delay (max 30 seconds)
⋮----
// Initial connection
⋮----
// Cleanup function

================
File: packages/dashboard-web/src/lib/query-keys.ts
================


================
File: packages/http-api/src/handlers/tools.ts
================
import type { DatabaseOperations } from "@ccflare/database";
import { BadRequest, errorResponse, jsonResponse } from "@ccflare/http-common";
⋮----
/**
 * Create system prompt interceptor handlers
 */
export function createSystemPromptInterceptorHandler(
	dbOps: DatabaseOperations,
)
⋮----
/**
		 * Get system prompt interceptor configuration
		 */
⋮----
// Return default configuration if none exists
⋮----
// Try to get the last-seen system prompt as the default target
⋮----
/**
		 * Set system prompt interceptor configuration
		 */
⋮----
// Validate required fields exist and have correct types
⋮----
// Save configuration to database
⋮----
/**
		 * Reset system prompt interceptor configuration
		 */
⋮----
// Delete the interceptor config, which will cause the GET endpoint
// to return the default state with last-seen prompt
⋮----
// Return 204 No Content to indicate successful deletion

================
File: packages/dashboard-web/src/components/agents/AgentCard.tsx
================
import { getModelDisplayName } from "@ccflare/core";
import type { Agent } from "@ccflare/types";
import { ALLOWED_MODELS } from "@ccflare/types";
import { Bot, Cpu, Edit3, Folder, Globe, Sparkles } from "lucide-react";
import { useState } from "react";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { AgentEditDialog } from "./AgentEditDialog";
⋮----
interface AgentCardProps {
	agent: Agent;
	onModelChange?: (agentId: string, model: string) => void;
	isUpdating?: boolean;
}
⋮----
// Map color names to more sophisticated gradient classes
⋮----
// Get clean agent name (remove workspace prefix for workspace agents)
⋮----
// Get workspace name from ID if it's a workspace agent
⋮----
{/* Gradient background overlay */}
⋮----

================
File: packages/dashboard-web/src/components/analytics/AnalyticsCharts.tsx
================
import type { TimePoint } from "@ccflare/types";
import { formatCost, formatNumber, formatTokens } from "@ccflare/ui-common";
import { useState } from "react";
import {
	Area,
	AreaChart,
	CartesianGrid,
	Legend,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import {
	CHART_HEIGHTS,
	CHART_PROPS,
	COLORS,
	type TimeRange,
} from "../../constants";
import {
	formatCompactCurrency,
	formatCompactNumber,
} from "../../lib/chart-utils";
import {
	BaseAreaChart,
	BaseBarChart,
	BaseLineChart,
	CostChart,
	ModelPerformanceChart,
	MultiModelChart,
	RequestVolumeChart,
	ResponseTimeChart,
	TokenSpeedChart,
	TokenUsageChart,
} from "../charts";
import { Badge } from "../ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Switch } from "../ui/switch";
⋮----
interface ChartData {
	time: string;
	requests: number;
	tokens: number;
	cost: number;
	responseTime: number;
	errorRate: number;
	cacheHitRate: number;
	avgTokensPerSecond: number;
	[key: string]: string | number;
}
⋮----
interface MainMetricsChartProps {
	data: ChartData[];
	rawTimeSeries?: TimePoint[];
	loading: boolean;
	viewMode: "normal" | "cumulative";
	timeRange: TimeRange;
	selectedMetric: string;
	setSelectedMetric: (metric: string) => void;
	modelBreakdown?: boolean;
	onModelBreakdownChange?: (enabled: boolean) => void;
}
⋮----
// Process data for multi-model chart if model breakdown is enabled (not in cumulative mode)
⋮----
// Group by timestamp and pivot models
⋮----
// First pass: collect all time points and models
⋮----
// Sort time points chronologically using the original timestamps
⋮----
// Initialize data structure
⋮----
// Process time points in order
⋮----
// Initialize all models for this time point
⋮----
// Default to 0 for missing data points
⋮----
// Fill in actual values
⋮----
// Map the metric value
⋮----
// Sort and return the data
⋮----
// Show multi-model chart if breakdown is enabled
⋮----
// Otherwise show normal charts
⋮----
switch (selectedMetric)
⋮----
interface PerformanceIndicatorsChartProps {
	data: ChartData[];
	loading: boolean;
	modelBreakdown?: boolean;
	rawTimeSeries?: TimePoint[];
	selectedMetric?: "errorRate" | "cacheHitRate";
	timeRange?: TimeRange;
}
⋮----
// Process data for multi-model chart if model breakdown is enabled
⋮----
// Group by timestamp and pivot models
⋮----
// Sort time points chronologically
⋮----
// Initialize all time points with all models
⋮----
// Fill in actual values
⋮----
// Map the metric value
⋮----
{/* Model Performance */}
⋮----
{/* Cost by Model */}

================
File: packages/proxy/src/handlers/agent-interceptor.ts
================
import { existsSync } from "node:fs";
import { join, resolve } from "node:path";
import { agentRegistry } from "@ccflare/agents";
import type { DatabaseOperations } from "@ccflare/database";
import { Logger } from "@ccflare/logger";
import type { Agent } from "@ccflare/types";
⋮----
export interface AgentInterceptResult {
	modifiedBody: ArrayBuffer | null;
	agentUsed: string | null;
	originalModel: string | null;
	appliedModel: string | null;
	systemPromptModified?: boolean;
	toolsRemoved?: boolean;
}
⋮----
/**
 * Detects agent usage, modifies the request body to use the preferred model,
 * and applies system prompt interception if configured
 * @param requestBodyBuffer - The buffered request body
 * @param dbOps - Database operations instance
 * @returns Modified request body and agent/system prompt modification information
 */
export async function interceptAndModifyRequest(
	requestBodyBuffer: ArrayBuffer | null,
	dbOps: DatabaseOperations,
): Promise<AgentInterceptResult>
⋮----
// If no body, nothing to intercept
⋮----
// Parse the request body
⋮----
// Extract original model
⋮----
// Extract system prompt to detect agent usage
⋮----
// No system prompt, no agent detection possible
⋮----
// Register additional agent directories from system prompt
⋮----
// Look specifically for the Contents pattern
⋮----
// Show a sample of what we do have
⋮----
// Count all CLAUDE.md occurrences
⋮----
// Extract workspace path from agents directory
// Convert /path/to/project/.claude/agents to /path/to/project
⋮----
// Only register if the workspace exists
⋮----
// Detect agent usage
⋮----
// No agent detected, but still apply system prompt interception
⋮----
// If system prompt was modified, create new buffer
⋮----
// Look up model preference
⋮----
// If the preferred model is the same as original, still check system prompt interception
⋮----
// If system prompt was modified, create new buffer
⋮----
// Modify the request body with the preferred model
⋮----
// Apply system prompt interception
⋮----
// Convert back to buffer
⋮----
// Create a new ArrayBuffer to ensure compatibility
⋮----
// On error, return original body unmodified
⋮----
interface MessageContent {
	type?: string;
	text?: string;
}
⋮----
interface Message {
	role?: string;
	content?: string | MessageContent[];
}
⋮----
interface SystemMessage {
	type: string;
	text: string;
	cache_control?: {
		type: string;
	};
}
⋮----
// Tool definition based on Anthropic API specification
interface Tool {
	type: string;
	name: string;
	description?: string;
	input_schema?: {
		type: string;
		properties?: Record<string, unknown>;
		required?: string[];
	};
}
⋮----
interface RequestBody {
	messages?: Message[];
	model?: string;
	system?: string | SystemMessage[];
	tools?: Tool[];
}
⋮----
/**
 * Extracts system prompt from request body
 * This will extract system messages and user messages that contain system-like content
 * @param requestBody - Parsed request body
 * @returns System prompt string or null
 */
function extractSystemPrompt(requestBody: RequestBody): string | null
⋮----
// First check for system field at root level (Claude Code pattern)
⋮----
// Concatenate all text from system messages
⋮----
// Then check messages array
⋮----
// Look for system messages
⋮----
// Also check for system prompt in user messages
⋮----
// Concatenate all text content from the user message
⋮----
// Combine all system content
⋮----
/**
 * Extracts agent directories from system prompt
 * @param systemPrompt - The system prompt text
 * @returns Array of agent directory paths
 */
function extractAgentDirectories(systemPrompt: string): string[]
⋮----
// Regex #1: Look for explicit /.claude/agents paths
⋮----
// Regex #2: Look for repo root pattern "Contents of (.*?)/CLAUDE.md"
⋮----
// Clean up any escaped slashes
⋮----
/**
 * Type guard to check if a system array element is a SystemMessage with text
 */
function isSystemMessageWithText(
	item: unknown,
): item is SystemMessage &
⋮----
/**
 * Applies system prompt interception if configured.
 *
 * This function extends the agent interceptor to provide template-based system prompt
 * replacement. It was implemented here rather than as a separate handler to maintain
 * cleaner architecture and ensure both features work together seamlessly.
 *
 * Note: This function is synchronous as dbOps.getInterceptorConfig is synchronous.
 *
 * @param requestBody - The parsed request body
 * @param dbOps - Database operations instance
 * @returns Object indicating if modifications were made
 */
function applySystemPromptInterception(
	requestBody: RequestBody,
	dbOps: DatabaseOperations,
):
⋮----
// Early check: Fetch interceptor configuration before any processing
⋮----
// If not enabled or config missing, return unchanged
⋮----
// Check if this is a main agent request
⋮----
// Check first system message for main agent identification with type guard
⋮----
// Check if it's the main Claude Code agent (not a subagent)
⋮----
// Extract the second system message (contains env block and other dynamic content)
⋮----
// Capture the original system prompt before any modifications
⋮----
// Update last-seen prompt in next tick (truly non-blocking)
⋮----
// Extract the <env> block(s) from the original system prompt
// Using global regex to find all env blocks
⋮----
// Multiple env blocks found - concatenate them
⋮----
// Validate and apply the template
⋮----
// Validate replacementPrompt is a non-empty string
⋮----
// Check if the current prompt matches the target (simplified check - could be enhanced)
// For now, we'll always apply the replacement if the interceptor is enabled
// Future enhancement: actually compare originalPrompt with targetPrompt
⋮----
// Validate template has the placeholder
⋮----
// Apply template with all occurrences replaced
⋮----
// Verify replacement actually happened
⋮----
// Update the second system message
⋮----
// Handle tools toggle
⋮----
/**
 * Updates the last-seen system prompt in the database if it has changed.
 * This is a non-critical synchronous operation that logs errors but doesn't throw.
 * Should be called via setImmediate to avoid blocking the request.
 *
 * @param prompt - The original system prompt to store
 * @param dbOps - Database operations instance
 */
function _updateLastSeenPrompt(
	prompt: string,
	dbOps: DatabaseOperations,
): void
⋮----
// Only update if the prompt has changed
⋮----
// Log error but don't throw - this is a non-critical background operation

================
File: packages/database/src/database-operations.ts
================
import { Database } from "bun:sqlite";
import { mkdirSync } from "node:fs";
import { dirname } from "node:path";
import type { Disposable } from "@ccflare/core";
import type { Account, StrategyStore } from "@ccflare/types";
import { ensureSchema, runMigrations } from "./migrations";
import { resolveDbPath } from "./paths";
import { AccountRepository } from "./repositories/account.repository";
import { AgentPreferenceRepository } from "./repositories/agent-preference.repository";
import {
	type InterceptorConfig,
	InterceptorRepository,
} from "./repositories/interceptor.repository";
import { OAuthRepository } from "./repositories/oauth.repository";
import {
	type RequestData,
	RequestRepository,
} from "./repositories/request.repository";
import { StatsRepository } from "./repositories/stats.repository";
import { StrategyRepository } from "./repositories/strategy.repository";
import { SystemKVRepository } from "./repositories/system-kv.repository";
⋮----
export interface RuntimeConfig {
	sessionDurationMs?: number;
}
⋮----
/**
 * DatabaseOperations using Repository Pattern
 * Provides a clean, organized interface for database operations
 */
export class DatabaseOperations implements StrategyStore, Disposable
⋮----
// Repositories
⋮----
constructor(dbPath?: string)
⋮----
// Ensure the directory exists
⋮----
// Configure SQLite for better concurrency
this.db.exec("PRAGMA journal_mode = WAL"); // Enable Write-Ahead Logging
this.db.exec("PRAGMA busy_timeout = 5000"); // Wait up to 5 seconds before throwing "database is locked"
this.db.exec("PRAGMA synchronous = NORMAL"); // Better performance while maintaining safety
⋮----
// Initialize repositories
⋮----
setRuntimeConfig(runtime: RuntimeConfig): void
⋮----
getDatabase(): Database
⋮----
// Account operations delegated to repository
getAllAccounts(): Account[]
⋮----
getAccount(accountId: string): Account | null
⋮----
updateAccountTokens(
		accountId: string,
		accessToken: string,
		expiresAt: number,
		refreshToken?: string,
): void
⋮----
updateAccountUsage(accountId: string): void
⋮----
markAccountRateLimited(accountId: string, until: number): void
⋮----
updateAccountRateLimitMeta(
		accountId: string,
		status: string,
		reset: number | null,
		remaining?: number | null,
): void
⋮----
updateAccountTier(accountId: string, tier: number): void
⋮----
pauseAccount(accountId: string): void
⋮----
resumeAccount(accountId: string): void
⋮----
renameAccount(accountId: string, newName: string): void
⋮----
resetAccountSession(accountId: string, timestamp: number): void
⋮----
updateAccountRequestCount(accountId: string, count: number): void
⋮----
// Request operations delegated to repository
saveRequestMeta(
		id: string,
		method: string,
		path: string,
		accountUsed: string | null,
		statusCode: number | null,
		timestamp?: number,
): void
⋮----
saveRequest(
		id: string,
		method: string,
		path: string,
		accountUsed: string | null,
		statusCode: number | null,
		success: boolean,
		errorMessage: string | null,
		responseTime: number,
		failoverAttempts: number,
		usage?: RequestData["usage"],
		agentUsed?: string,
): void
⋮----
updateRequestUsage(requestId: string, usage: RequestData["usage"]): void
⋮----
saveRequestPayload(id: string, data: unknown): void
⋮----
getRequestPayload(id: string): unknown | null
⋮----
listRequestPayloads(limit = 50): Array<
⋮----
listRequestPayloadsWithAccountNames(
		limit = 50,
): Array<
⋮----
// OAuth operations delegated to repository
createOAuthSession(
		sessionId: string,
		accountName: string,
		verifier: string,
		mode: "console" | "max",
		tier: number,
		ttlMinutes = 10,
): void
⋮----
getOAuthSession(sessionId: string):
⋮----
deleteOAuthSession(sessionId: string): void
⋮----
cleanupExpiredOAuthSessions(): number
⋮----
// Strategy operations delegated to repository
getStrategy(name: string):
⋮----
setStrategy(name: string, config: Record<string, unknown>): void
⋮----
listStrategies(): Array<
⋮----
deleteStrategy(name: string): boolean
⋮----
// Analytics methods delegated to request repository
getRecentRequests(limit = 100): Array<
⋮----
getRequestStats(since?: number):
⋮----
aggregateStats(rangeMs?: number)
⋮----
getRecentErrors(limit?: number): string[]
⋮----
getTopModels(limit?: number): Array<
⋮----
getRequestsByAccount(since?: number): Array<
⋮----
// Cleanup operations (payload by age; request metadata by age; plus orphan sweep)
cleanupOldRequests(
		payloadRetentionMs: number,
		requestRetentionMs?: number,
):
⋮----
// Agent preference operations delegated to repository
getAgentPreference(agentId: string):
⋮----
getAllAgentPreferences(): Array<
⋮----
setAgentPreference(agentId: string, model: string): void
⋮----
deleteAgentPreference(agentId: string): boolean
⋮----
setBulkAgentPreferences(agentIds: string[], model: string): void
⋮----
// Interceptor operations delegated to repository
getInterceptorConfig(
		id: string,
):
⋮----
setInterceptorConfig(
		id: string,
		isEnabled: boolean,
		config: InterceptorConfig,
): void
⋮----
deleteInterceptorConfig(id: string): boolean
⋮----
// System KV operations delegated to repository
getSystemKV(key: string): string | null
⋮----
setSystemKV(key: string, value: string): void
⋮----
close(): void
⋮----
// Ensure all write operations are flushed before closing
⋮----
dispose(): void
⋮----
// Optimize database periodically to maintain performance
optimize(): void
⋮----
/** Compact and reclaim disk space (blocks DB during operation) */
compact(): void
⋮----
// Ensure WAL is checkpointed and truncated, then VACUUM to rebuild file
⋮----
/**
	 * Get the stats repository for consolidated stats access
	 */
getStatsRepository(): StatsRepository

================
File: packages/dashboard-web/src/components/RequestsTab.tsx
================
import {
	formatCost,
	formatDuration,
	formatTokens,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import {
	Bot,
	Calendar,
	ChevronDown,
	ChevronRight,
	Clock,
	Eye,
	Filter,
	Hash,
	RefreshCw,
	User,
	X,
} from "lucide-react";
import { useState } from "react";
import type { RequestPayload, RequestSummary } from "../api";
import { useRequests } from "../hooks/queries";
import { useRequestStream } from "../hooks/useRequestStream";
import { CopyButton } from "./CopyButton";
import { RequestDetailsModal } from "./RequestDetailsModal";
import { TokenUsageDisplay } from "./TokenUsageDisplay";
import { Badge } from "./ui/badge";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuTrigger,
} from "./ui/dropdown-menu";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "./ui/select";
⋮----
// Enable real-time updates
⋮----
// Transform the data to match the expected structure
⋮----
// Extract unique accounts for filter dropdown
⋮----
// Extract unique status codes for filter
⋮----
// Extract unique agents for filter
⋮----
// Filter requests based on selected filters
⋮----
// Account filter
⋮----
// Agent filter
⋮----
// Status code filter
⋮----
// Date range filter
⋮----
const toggleExpanded = (id: string) =>
⋮----
// Date preset helpers
const applyDatePreset = (preset: string) =>
⋮----
const toggleStatusCode = (code: string) =>
⋮----
const getStatusCodeColor = (code: number) =>
⋮----
const clearAllFilters = () =>
⋮----
const decodeBase64 = (str: string | null): string =>
⋮----
// Handle edge cases like "[streamed]" from older data
⋮----
/**
	 * Copy the given request to the clipboard as pretty-printed JSON, with
	 * any base64-encoded bodies already decoded for easier debugging.
	 */
// copyRequest helper removed – handled inline by CopyButton
⋮----
{/* Active Filters Display */}
⋮----
{/* Filters Panel */}
⋮----
{/* Time Range Section */}
⋮----
{/* Resource Filters */}
⋮----
{/* Account Filter */}
⋮----
{/* Agent Filter */}
⋮----
{/* Status Code Filter */}
⋮----

⋮----
{/* Action buttons */}
⋮----
return JSON.stringify(decoded, null, 2);

================
File: packages/http-api/src/router.ts
================
import { validateNumber } from "@ccflare/core";
import {
	createAccountAddHandler,
	createAccountPauseHandler,
	createAccountRemoveHandler,
	createAccountRenameHandler,
	createAccountResumeHandler,
	createAccountsListHandler,
	createAccountTierUpdateHandler,
} from "./handlers/accounts";
import {
	createAgentPreferenceUpdateHandler,
	createAgentsListHandler,
	createBulkAgentPreferenceUpdateHandler,
	createWorkspacesListHandler,
} from "./handlers/agents";
import { createAgentUpdateHandler } from "./handlers/agents-update";
import { createAnalyticsHandler } from "./handlers/analytics";
import { createConfigHandlers } from "./handlers/config";
import { createHealthHandler } from "./handlers/health";
import { createLogsStreamHandler } from "./handlers/logs";
import { createLogsHistoryHandler } from "./handlers/logs-history";
import {
	createCleanupHandler,
	createCompactHandler,
} from "./handlers/maintenance";
import {
	createOAuthCallbackHandler,
	createOAuthInitHandler,
} from "./handlers/oauth";
import {
	createRequestsDetailHandler,
	createRequestsSummaryHandler,
} from "./handlers/requests";
import { createRequestsStreamHandler } from "./handlers/requests-stream";
import { createStatsHandler, createStatsResetHandler } from "./handlers/stats";
import { createSystemPromptInterceptorHandler } from "./handlers/tools";
import type { APIContext } from "./types";
import { errorResponse } from "./utils/http-error";
⋮----
/**
 * API Router that handles all API endpoints
 */
export class APIRouter
⋮----
constructor(context: APIContext)
⋮----
private registerHandlers(): void
⋮----
// Create handlers
⋮----
// Register routes
⋮----
/**
	 * Wrap a handler with error handling
	 */
private wrapHandler(
		handler: (req: Request, url: URL) => Response | Promise<Response>,
): (req: Request, url: URL) => Promise<Response>
⋮----
/**
	 * Handle an incoming request
	 */
async handleRequest(url: URL, req: Request): Promise<Response | null>
⋮----
// Check for exact match
⋮----
// Check for dynamic account endpoints
⋮----
// Account tier update
⋮----
// Account pause
⋮----
// Account resume
⋮----
// Account rename
⋮----
// Account removal
⋮----
// Check for dynamic agent endpoints
⋮----
// Agent preference update
⋮----
// Agent update (PATCH /api/agents/:id)
⋮----
// No matching route

================
File: packages/dashboard-web/src/components/agents/AgentEditDialog.tsx
================
import { getModelDisplayName } from "@ccflare/core";
import type {
	Agent,
	AgentTool,
	AgentUpdatePayload,
	AllowedModel,
} from "@ccflare/types";
import { ALL_TOOLS, ALLOWED_MODELS } from "@ccflare/types";
import { Cpu, Edit3, FileText, Palette, Save, Shield, X } from "lucide-react";
import { useMemo, useState } from "react";
import { TOOL_PRESETS } from "../../constants";
import { useUpdateAgent } from "../../hooks/queries";
import { cn } from "../../lib/utils";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "../ui/dialog";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../ui/tabs";
⋮----
interface AgentEditDialogProps {
	agent: Agent;
	open: boolean;
	onOpenChange: (open: boolean) => void;
}
⋮----
type ToolPresetMode = keyof typeof TOOL_PRESETS;
⋮----
// Helper function to get all combinations of array elements
function getCombinations<T>(arr: T[], size: number): T[][]
⋮----
function combine(start: number, combo: T[])
⋮----
// Initialize selected modes based on current tools
⋮----
// First, try to find exact matches with single presets
⋮----
// If we found exact single preset matches, return them
⋮----
// Otherwise, find the combination of presets that exactly matches our tools
⋮----
// Try all combinations of presets to find exact matches
⋮----
// Check if this combination exactly matches our tools
⋮----
// If no exact combination found, return empty set (will trigger custom mode)
⋮----
// Start in custom mode if:
// 1. No modes are selected (tools don't match any preset combination)
// 2. Or if we have the "all" preset selected and there are tools
⋮----
// Compute effective tools based on selected modes
⋮----
const handleModeToggle = (mode: ToolPresetMode) =>
⋮----
// If selecting "all", clear other selections
⋮----
// Toggle the mode
⋮----
// Remove "all" if selecting specific modes
⋮----
// Calculate the tools from the new preset selection
⋮----
// Check if custom tools match the new preset selection
⋮----
// Only stay in custom mode if we have extra tools that aren't in the presets
⋮----
// Stay in custom mode but update the selection
⋮----
// Switch to preset mode
⋮----
const handleCustomModeToggle = () =>
⋮----
// Entering custom mode - keep current tools
⋮----
// Exiting custom mode - try to find matching presets
⋮----
// Try to find matching preset combinations
⋮----
// Check if this combination exactly matches our tools
⋮----
// Found a matching preset combination
⋮----
// If no exact match found, just exit custom mode with empty selection
⋮----
const handleSave = async () =>
⋮----
// Determine mode for API - only send if it's a single exact match
⋮----
const handleToolToggle = (tool: AgentTool) =>
⋮----
// Check if the new tool selection matches any preset combination
⋮----
// Try to find matching preset combinations
⋮----
// Check if this combination exactly matches our tools
⋮----
// Found a matching preset combination
⋮----
// No matching preset combination found, stay in custom mode
⋮----
{/* Model */}
⋮----
{/* Color */}
⋮----
{/* Custom Mode Toggle */}
⋮----
{/* Custom Tools Selection */}

================
File: packages/dashboard-web/src/api.ts
================
import { HttpClient, HttpError } from "@ccflare/http-common";
import type {
	AccountResponse,
	Agent,
	AgentUpdatePayload,
	AgentWorkspace,
	AnalyticsResponse,
	LogEvent,
	RequestPayload,
	RequestResponse,
	StatsWithAccounts,
} from "@ccflare/types";
import { API_LIMITS, API_TIMEOUT } from "./constants";
⋮----
// Re-export types with dashboard-specific aliases for backward compatibility
export type Account = AccountResponse;
export type Stats = StatsWithAccounts;
export type LogEntry = LogEvent;
export type RequestSummary = RequestResponse;
⋮----
// Re-export types directly
⋮----
// Agent response interface
export interface AgentsResponse {
	agents: Agent[];
	globalAgents: Agent[];
	workspaceAgents: Agent[];
	workspaces: AgentWorkspace[];
}
⋮----
/**
 * Configuration for the system prompt interceptor feature
 * Controls how system prompts are intercepted and modified
 */
export interface SystemPromptConfig {
	/** Whether the system prompt interceptor is enabled */
	isEnabled: boolean;
	/** The target prompt to look for and replace */
	targetPrompt: string;
	/** The replacement prompt with {{env_block}} placeholder for environment variables */
	replacementPrompt: string;
	/** Whether tools are enabled in the intercepted system prompt */
	toolsEnabled: boolean;
}
⋮----
/** Whether the system prompt interceptor is enabled */
⋮----
/** The target prompt to look for and replace */
⋮----
/** The replacement prompt with {{env_block}} placeholder for environment variables */
⋮----
/** Whether tools are enabled in the intercepted system prompt */
⋮----
class API extends HttpClient
⋮----
constructor()
⋮----
async getStats(): Promise<Stats>
⋮----
async getAccounts(): Promise<Account[]>
⋮----
async initAddAccount(data: {
		name: string;
		mode: "max" | "console";
		tier: number;
}): Promise<
⋮----
async completeAddAccount(data: {
		sessionId: string;
		code: string;
}): Promise<
⋮----
async removeAccount(name: string, confirm: string): Promise<void>
⋮----
async resetStats(): Promise<void>
⋮----
async getLogHistory(): Promise<LogEntry[]>
⋮----
// SSE streaming requires special handling, keep as-is
streamLogs(onLog: (log: LogEntry) => void): EventSource
⋮----
// Skip non-log messages (like the initial "connected" message)
⋮----
async getRequestsDetail(
		limit: number = API_LIMITS.requestsDetail,
): Promise<RequestPayload[]>
⋮----
async getRequestsSummary(
		limit: number = API_LIMITS.requestsSummary,
): Promise<RequestSummary[]>
⋮----
async getAnalytics(
		range = "24h",
		filters?: {
			accounts?: string[];
			models?: string[];
			status?: "all" | "success" | "error";
		},
		mode: "normal" | "cumulative" = "normal",
		modelBreakdown?: boolean,
): Promise<AnalyticsResponse>
⋮----
async pauseAccount(accountId: string): Promise<void>
⋮----
async resumeAccount(accountId: string): Promise<void>
⋮----
async renameAccount(
		accountId: string,
		newName: string,
): Promise<
⋮----
async getStrategy(): Promise<string>
⋮----
async listStrategies(): Promise<string[]>
⋮----
async setStrategy(strategy: string): Promise<void>
⋮----
async getAgents(): Promise<AgentsResponse>
⋮----
async updateAgentPreference(agentId: string, model: string): Promise<void>
⋮----
async updateAgent(
		agentId: string,
		payload: AgentUpdatePayload,
): Promise<Agent>
⋮----
async getDefaultAgentModel(): Promise<string>
⋮----
async setDefaultAgentModel(model: string): Promise<void>
⋮----
async setBulkAgentPreferences(
		model: string,
): Promise<
⋮----
// Retention settings
async getRetention(): Promise<
⋮----
async setRetention(partial: {
		payloadDays?: number;
		requestDays?: number;
}): Promise<void>
⋮----
async cleanupNow(): Promise<
⋮----
async compactDb(): Promise<
⋮----
// System prompt interceptor
async getSystemPromptOverride(): Promise<
⋮----
async setSystemPromptOverride(data: {
		isEnabled: boolean;
		targetPrompt: string;
		replacementPrompt: string;
		toolsEnabled: boolean;
}): Promise<
⋮----
async resetSystemPromptOverride(): Promise<void>

================
File: packages/dashboard-web/src/hooks/queries.ts
================
import type { AgentUpdatePayload } from "@ccflare/types";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { api } from "../api";
import { REFRESH_INTERVALS } from "../constants";
import { queryKeys } from "../lib/query-keys";
⋮----
export const useAccounts = () =>
⋮----
refetchInterval: REFRESH_INTERVALS.fast, // Refresh every 10 seconds for rate limit updates
⋮----
export const useAgents = () =>
⋮----
refetchInterval: 30000, // Poll every 30 seconds for new agents
refetchIntervalInBackground: true, // Continue polling when tab is not focused
⋮----
export const useStats = (refetchInterval?: number) =>
⋮----
export const useAnalytics = (
	timeRange: string,
	filters: {
		accounts?: string[];
		models?: string[];
		status?: "all" | "success" | "error";
	},
	viewMode: "normal" | "cumulative",
	modelBreakdown?: boolean,
) =>
⋮----
export const useRequests = (limit: number, refetchInterval?: number) =>
⋮----
export const useRequestDetails = (id: string) =>
⋮----
export const useLogHistory = () =>
⋮----
// Mutations
export const useRemoveAccount = () =>
⋮----
export const useRenameAccount = () =>
⋮----
export const useResetStats = () =>
⋮----
export const useUpdateAgentPreference = () =>
⋮----
export const useDefaultAgentModel = () =>
⋮----
refetchInterval: REFRESH_INTERVALS.slow, // Poll for config changes
refetchIntervalInBackground: true, // Continue polling when tab is not focused
⋮----
export const useSetDefaultAgentModel = () =>
⋮----
export const useBulkUpdateAgentPreferences = () =>
⋮----
export const useUpdateAgent = () =>
⋮----
// Note: Clear logs functionality appears to be removed from the API
⋮----
// Retention settings
export const useRetention = () =>
⋮----
export const useSetRetention = () =>
⋮----
export const useCleanupNow = () =>
⋮----
export const useCompactDb = () =>
⋮----
/**
 * Hook to fetch the current system prompt interceptor configuration
 * Polls for changes at a slow interval and continues in background
 */
⋮----
export const useSystemPromptOverride = () =>
⋮----
refetchInterval: REFRESH_INTERVALS.slow, // Poll for config changes
⋮----
export const useSetSystemPromptOverride = () =>
⋮----
export const useResetSystemPromptOverride = () =>





================================================================
End of Codebase
================================================================
