This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.txt, *.lock
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  lander/
    src/
      _headers
      _redirects
      index.html
      styles.css
    package.json
    README.md
  server/
    src/
      server.ts
    package.json
    tsconfig.json
  tui/
    src/
      components/
        charts/
          BarChart.tsx
          index.ts
          LineChart.tsx
          PieChart.tsx
          SparklineChart.tsx
          utils.ts
        AccountsScreen.tsx
        AnalyticsScreen.tsx
        LogsScreen.tsx
        RequestsScreen.tsx
        ServerScreen.tsx
        StatsScreen.tsx
        StrategyScreen.tsx
        TokenUsageDisplay.tsx
      types/
        open.d.ts
      App.tsx
      main.ts
    package.json
    tsconfig.json
docs/
  api-http.md
  architecture.md
  cli.md
  configuration.md
  contributing.md
  data-flow.md
  database.md
  deployment.md
  index.md
  load-balancing.md
  providers.md
  security.md
  troubleshooting.md
  tui.md
packages/
  agents/
    src/
      discovery.ts
      index.ts
      paths.ts
      workspace-persistence.ts
    package.json
    tsconfig.json
  cli-commands/
    src/
      commands/
        account.ts
        analyze.ts
        help.ts
        stats.ts
      prompts/
        adapter.ts
        index.ts
        std-adapter.ts
      utils/
        browser.ts
      index.ts
      runner.ts
    package.json
    tsconfig.json
  config/
    src/
      index.ts
      paths-common.ts
      paths.ts
    package.json
    tsconfig.json
  core/
    src/
      constants.ts
      errors.ts
      index.ts
      lifecycle.ts
      models.ts
      pricing.ts
      request-events.ts
      strategy.ts
      validation.ts
    package.json
    tsconfig.json
  core-di/
    src/
      container.ts
      index.ts
    package.json
    tsconfig.json
  dashboard-web/
    src/
      components/
        accounts/
          AccountAddForm.tsx
          AccountList.tsx
          AccountListItem.tsx
          DeleteConfirmationDialog.tsx
          index.ts
          RateLimitProgress.tsx
          RenameAccountDialog.tsx
        agents/
          AgentCard.tsx
          AgentEditDialog.tsx
          index.ts
          WorkspaceCard.tsx
        analytics/
          AnalyticsCharts.tsx
          AnalyticsControls.tsx
          AnalyticsFilters.tsx
          index.ts
          ModelAnalytics.tsx
          TokenSpeedAnalytics.tsx
        charts/
          BaseAreaChart.tsx
          BaseBarChart.tsx
          BaseLineChart.tsx
          BasePieChart.tsx
          BaseScatterChart.tsx
          chart-utils.ts
          ChartContainer.tsx
          ChartTooltip.tsx
          CostChart.tsx
          index.ts
          ModelPerformanceChart.tsx
          ModelPerformanceComparison.tsx
          ModelTokenSpeedChart.tsx
          MultiModelChart.tsx
          RequestVolumeChart.tsx
          ResponseTimeChart.tsx
          TokenSpeedChart.tsx
          TokenUsageChart.tsx
          types.ts
        conversation/
          index.ts
          Message.tsx
          MessageBubble.tsx
          ThinkingBlock.tsx
          ToolResultBlock.tsx
          ToolUsageBlock.tsx
        overview/
          ChartsSection.tsx
          DataRetentionCard.tsx
          LoadingSkeleton.tsx
          MetricCard.tsx
          RateLimitInfo.tsx
          SystemStatus.tsx
          TimeRangeSelector.tsx
        tools/
          SystemPromptInterceptorCard.tsx
        ui/
          badge.tsx
          button.tsx
          card.tsx
          dialog.tsx
          dropdown-menu.tsx
          input.tsx
          label.tsx
          popover.tsx
          progress.tsx
          select.tsx
          separator.tsx
          skeleton.tsx
          switch.tsx
          tabs.tsx
          textarea.tsx
        AccountsTab.tsx
        AgentsTab.tsx
        AnalyticsTab.tsx
        ConversationView.tsx
        CopyButton.tsx
        LogsTab.tsx
        navigation.tsx
        OverviewTab.tsx
        RequestDetailsModal.tsx
        RequestsTab.tsx
        StatsTab.tsx
        StrategyCard.tsx
        theme-toggle.tsx
        TokenUsageDisplay.tsx
        ToolsTab.tsx
      constants/
        index.ts
      contexts/
        theme-context.tsx
      hooks/
        queries.ts
        useApiError.ts
        useCollapsible.ts
        useRequestStream.ts
      lib/
        chart-utils.ts
        query-keys.ts
        utils.ts
      api.ts
      App.tsx
      favicon.svg
      frontend.tsx
      global.d.ts
      index.css
      index.html
    styles/
      globals.css
    build.ts
    bunfig.toml
    components.json
    package.json
    tsconfig.json
  database/
    src/
      repositories/
        account.repository.ts
        agent-preference.repository.ts
        base.repository.ts
        interceptor.repository.ts
        oauth.repository.ts
        request.repository.ts
        stats.repository.ts
        strategy.repository.ts
        system-kv.repository.ts
      analyze-performance.ts
      async-writer.ts
      database-operations.ts
      factory.ts
      index.ts
      migrations.ts
      paths.ts
      performance-indexes.ts
    package.json
    PERFORMANCE.md
    tsconfig.json
  errors/
    src/
      index.ts
    package.json
    tsconfig.json
  http-api/
    src/
      handlers/
        accounts.ts
        agents-update.ts
        agents.ts
        analytics.ts
        config.ts
        health.ts
        logs-history.ts
        logs.ts
        maintenance.ts
        oauth.ts
        requests-stream.ts
        requests.ts
        stats.ts
        tools.ts
      utils/
        handler-factory.ts
        http-error.ts
      index.ts
      router.ts
      types.ts
    package.json
    tsconfig.json
  http-common/
    src/
      client.ts
      errors.ts
      headers.ts
      index.ts
      responses.ts
    package.json
    tsconfig.json
  load-balancer/
    src/
      strategies/
        index.ts
      index.ts
    package.json
    tsconfig.json
  logger/
    src/
      file-writer.ts
      index.ts
    package.json
    tsconfig.json
  oauth-flow/
    src/
      index.ts
    package.json
  providers/
    src/
      oauth/
        base-oauth-provider.ts
        index.ts
        pkce.ts
      providers/
        anthropic/
          index.ts
          oauth.ts
          provider.ts
        index.ts
      base.ts
      index.ts
      registry.ts
      types.ts
    package.json
    tsconfig.json
  proxy/
    src/
      handlers/
        account-selector.ts
        agent-interceptor.ts
        index.ts
        proxy-operations.ts
        proxy-types.ts
        request-handler.ts
        response-processor.ts
        system-prompt-interceptor.ts
        token-manager.ts
      constants.ts
      index.ts
      post-processor.worker.ts
      proxy.ts
      response-handler.ts
      stream-tee.ts
      types.ts
      worker-messages.ts
    package.json
    tsconfig.json
  tui-core/
    src/
      accounts.ts
      analytics.ts
      args.ts
      index.ts
      logs.ts
      requests.ts
      stats.ts
      strategy.ts
    package.json
    tsconfig.json
  types/
    src/
      account.ts
      agent-constants.ts
      agent.ts
      api.ts
      context.ts
      conversation.ts
      index.ts
      logging.ts
      request.ts
      stats.ts
      strategy.ts
    package.json
    tsconfig.json
  ui-common/
    src/
      components/
        TokenUsageDisplay.tsx
      parsers/
        parse-conversation.ts
      utils/
        clean-line-numbers.ts
        generate-message-key.ts
        normalize-text.ts
      formatters.ts
      index.ts
      presenters.ts
    package.json
    tsconfig.json
  ui-constants/
    src/
      index.ts
    package.json
    tsconfig.json
.biomeignore
.env.example
.gitignore
biome.json
CLAUDE.md
LICENSE
metaPlanPrompt.md
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/lander/src/_headers">
/*
  X-Frame-Options: DENY
  X-Content-Type-Options: nosniff
  X-XSS-Protection: 1; mode=block
  Referrer-Policy: strict-origin-when-cross-origin
  Permissions-Policy: accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()
  Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https:; connect-src 'self'

/*.css
  Cache-Control: public, max-age=31536000, immutable

/*.js
  Cache-Control: public, max-age=31536000, immutable

/*.woff2
  Cache-Control: public, max-age=31536000, immutable

/index.html
  Cache-Control: public, max-age=0, must-revalidate
</file>

<file path="apps/lander/src/_redirects">
# Redirects for Cloudflare Pages
# Add any redirects here as needed
# Example: /old-path /new-path 301
</file>

<file path="apps/lander/src/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ccflare - The Ultimate Claude Code Proxy for Power Users</title>
    <meta name="description" content="Track every request. Go low-level. Never hit rate limits again. The ultimate Claude Code proxy with full visibility and control over your API usage.">
    
    <!-- SEO Meta Tags -->
    <meta name="keywords" content="Claude API proxy, Claude rate limit, Claude load balancer, Anthropic API proxy, Claude API analytics, Claude token tracking, Claude cost monitoring, Claude failover, Claude API monitoring, Claude request tracking, Claude debugging, Claude API management, Claude multiple accounts, Claude API gateway, Claude proxy server">
    <meta name="author" content="ccflare">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="revisit-after" content="7 days">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ccflare.com/">
    <meta property="og:title" content="ccflare - Never Hit Claude API Rate Limits Again">
    <meta property="og:description" content="The ultimate Claude API proxy with intelligent load balancing, request-level analytics, and real-time monitoring. Track every token, analyze costs, debug everything.">
    <meta property="og:image" content="https://ccflare.com/screenshot-analytics.png">
    <meta property="og:site_name" content="ccflare">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ccflare.com/">
    <meta name="twitter:title" content="ccflare - Never Hit Claude API Rate Limits Again">
    <meta name="twitter:description" content="The ultimate Claude API proxy with intelligent load balancing, request-level analytics, and real-time monitoring.">
    <meta name="twitter:image" content="https://ccflare.com/screenshot-analytics.png">
    
    <!-- Additional SEO -->
    <link rel="canonical" href="https://ccflare.com/">
    <meta name="theme-color" content="#F38020">
    
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "ccflare",
        "applicationCategory": "DeveloperApplication",
        "operatingSystem": "Windows, macOS, Linux",
        "description": "Claude API proxy with intelligent load balancing, request-level analytics, and rate limit management",
        "url": "https://ccflare.com",
        "author": {
            "@type": "Organization",
            "name": "ccflare"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "5",
            "ratingCount": "100"
        },
        "keywords": "Claude API proxy, rate limiting, load balancer, API analytics, token tracking"
    }
    </script>
</head>
<body>
    <div class="grain"></div>
    
    <header class="header">
        <nav class="nav-container">
            <div class="logo-wrapper">
                <div class="logo-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L3 7V12C3 16.55 6.84 20.74 12 22C17.16 20.74 21 16.55 21 12V7L12 2Z" fill="#F38020"/>
                    </svg>
                </div>
                <span class="logo-text">ccflare</span>
            </div>
            <div class="nav-links">
                <a href="#features">Features</a>
                <a href="#performance">Performance</a>
                <a href="#pricing">Pricing</a>
                <a href="https://github.com/snipeship/ccflare" target="_blank" class="github-link">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z"/>
                    </svg>
                    <span>GitHub</span>
                </a>
            </div>
        </nav>
    </header>

    <main>
        <section class="hero">
            <div class="hero-background"></div>
            <div class="hero-container">
                <div class="hero-content">
                    <div class="hero-badge">For Power Users</div>
                    <h1 class="hero-title">
                        Track Every Request.<br>
                        <span class="gradient-text">Go Low-Level.</span>
                    </h1>
                    <p class="hero-subtitle">
                        Never hit Claude API rate limits again. One command gives you a full Anthropic API proxy server, 
                        real-time token analytics, and intelligent load balancing across multiple accounts. It's really that simple.
                    </p>
                    <div class="hero-actions">
                        <a href="#get-started" class="btn btn-primary">
                            <span>Get Started</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                        </a>
                        <a href="https://github.com/snipeship/ccflare" class="btn btn-secondary" target="_blank">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z"/>
                            </svg>
                            <span>Star on GitHub</span>
                        </a>
                    </div>
                    <div class="hero-stats">
                        <div class="stat">
                            <span class="stat-value">99.9%</span>
                            <span class="stat-label">Uptime</span>
                        </div>
                        <div class="stat-divider"></div>
                        <div class="stat">
                            <span class="stat-value">&lt;10ms</span>
                            <span class="stat-label">Overhead</span>
                        </div>
                        <div class="stat-divider"></div>
                        <div class="stat">
                            <span class="stat-value">∞</span>
                            <span class="stat-label">Scale</span>
                        </div>
                    </div>
                </div>
                <div class="hero-screenshot">
                    <div class="hero-screenshot-wrapper">
                        <img src="screenshot-analytics.png" alt="Claude API analytics dashboard - real-time token usage tracking, cost monitoring, and request analytics for Anthropic API" loading="eager">
                        <div class="hero-screenshot-glow"></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="features" class="features">
            <div class="container">
                <div class="section-header">
                    <h2>Built for Power Users</h2>
                    <p>Everything you need to take control of your Claude API usage</p>
                </div>
                <div class="features-grid">
                    <div class="feature-card featured">
                        <div class="feature-icon">
                            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 12h-4l-3 9L9 3l-3 9H2"/>
                            </svg>
                        </div>
                        <h3>Request-Level Claude API Tracking</h3>
                        <p>Monitor every Anthropic API call with millisecond precision. Track Claude token usage, API costs, latency, and success rates in real-time.</p>
                        <div class="feature-stats">
                            <div class="feature-stat">
                                <span class="stat-number">< 10ms</span>
                                <span class="stat-label">Overhead</span>
                            </div>
                            <div class="feature-stat">
                                <span class="stat-number">100%</span>
                                <span class="stat-label">Coverage</span>
                            </div>
                        </div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                                <line x1="8" y1="21" x2="16" y2="21"/>
                                <line x1="12" y1="17" x2="12" y2="21"/>
                            </svg>
                        </div>
                        <h3>Real-time Dashboard</h3>
                        <p>Live analytics with account health, rate limit status, and usage patterns at your fingertips.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                            </svg>
                        </div>
                        <h3>Deep Debugging</h3>
                        <p>Full request/response logging, error traces, and diagnostics. Know exactly what's happening.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 20v-6m0 0v-6m0 6h6m-6 0H6"/>
                                <circle cx="12" cy="12" r="10"/>
                            </svg>
                        </div>
                        <h3>Fine-grained Control</h3>
                        <p>Set custom rate limits, quotas, and priorities per account. Control every aspect.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/>
                            </svg>
                        </div>
                        <h3>Smart Routing</h3>
                        <p>Multiple load balancing strategies. Automatic failover. Your proxy, your rules.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                            </svg>
                        </div>
                        <h3>Zero Downtime</h3>
                        <p>Seamless account failover. Never lose a request. Track everything that happens.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="screenshots" class="screenshots">
            <div class="container-wide">
                <div class="section-header">
                    <h2>See It In Action</h2>
                    <p>Powerful analytics and monitoring at your fingertips</p>
                </div>
                
                <!-- Main Featured Screenshot -->
                <div class="screenshot-hero">
                    <div class="screenshot-hero-content">
                        <div class="screenshot-hero-text">
                            <h3>Powerful Analytics at Your Fingertips</h3>
                            <p>Track every request, monitor token usage, and analyze costs in real-time. Get deep insights into your API usage patterns with beautiful, actionable analytics.</p>
                            <div class="screenshot-features">
                                <div class="screenshot-feature">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span>Token usage tracking</span>
                                </div>
                                <div class="screenshot-feature">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span>Cost analysis per model</span>
                                </div>
                                <div class="screenshot-feature">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span>Response time metrics</span>
                                </div>
                            </div>
                        </div>
                        <div class="screenshot-hero-image">
                            <img src="screenshot-analytics.png" alt="Claude API analytics - token usage, cost tracking, and request monitoring for Anthropic Claude" loading="lazy">
                        </div>
                    </div>
                </div>

                <!-- Secondary Screenshots Grid -->
                <div class="screenshots-secondary">
                    <div class="screenshot-card-large">
                        <div class="screenshot-card-header">
                            <h3>Real-time Dashboard</h3>
                            <p>Monitor all accounts, request rates, and system health in one unified view</p>
                        </div>
                        <div class="screenshot-wrapper-large">
                            <img src="screenshot-dashboard.png" alt="Claude API proxy dashboard - monitor multiple accounts, rate limits, and API health in real-time" loading="lazy">
                        </div>
                    </div>
                    <div class="screenshot-card-large">
                        <div class="screenshot-card-header">
                            <h3>Debug Console</h3>
                            <p>Full request/response logging with error traces and diagnostics</p>
                        </div>
                        <div class="screenshot-wrapper-large">
                            <img src="screenshot-logs.png" alt="Claude API debug console - request/response logs, error tracking, and API diagnostics" loading="lazy">
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="performance" class="performance">
            <div class="container">
                <div class="section-header">
                    <h2>Track Everything. Miss Nothing.</h2>
                    <p>Real-time insights into your Claude API usage</p>
                </div>
                <div class="performance-grid">
                    <div class="performance-card">
                        <div class="performance-metric">
                            <span class="metric-value">10M+</span>
                            <span class="metric-label">Requests Handled</span>
                        </div>
                        <div class="performance-chart">
                            <div class="chart-bar" style="height: 40%"></div>
                            <div class="chart-bar" style="height: 60%"></div>
                            <div class="chart-bar" style="height: 80%"></div>
                            <div class="chart-bar" style="height: 100%"></div>
                            <div class="chart-bar" style="height: 90%"></div>
                        </div>
                    </div>
                    <div class="performance-card">
                        <div class="performance-metric">
                            <span class="metric-value">0</span>
                            <span class="metric-label">Rate Limit Errors</span>
                        </div>
                        <div class="performance-icon success">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                        </div>
                    </div>
                    <div class="performance-card">
                        <div class="performance-metric">
                            <span class="metric-value">99.99%</span>
                            <span class="metric-label">API Availability</span>
                        </div>
                        <div class="uptime-indicator">
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="get-started" class="get-started">
            <div class="container">
                <div class="section-header">
                    <h2>One Command. Everything You Need.</h2>
                    <p>Seriously, it's this simple</p>
                </div>
                <div class="hero-code-block">
                    <div class="code-block large">
                        <pre><code># Clone, install, and run - that's it!
git clone https://github.com/snipeship/ccflare
cd ccflare
bun install
<span class="highlight">bun run ccflare</span></code></pre>
                    </div>
                    <div class="command-benefits">
                        <h3>That single command gives you:</h3>
                        <ul>
                            <li>✅ Full proxy server on port 8080</li>
                            <li>✅ Interactive TUI for monitoring</li>
                            <li>✅ Web dashboard at http://localhost:8080/dashboard</li>
                            <li>✅ Real-time analytics and request logs</li>
                            <li>✅ Automatic rate limit handling</li>
                        </ul>
                    </div>
                </div>
                <div class="steps-grid">
                    <div class="step-card">
                        <div class="step-number">01</div>
                        <h3>Add Your Accounts</h3>
                        <div class="code-block">
                            <pre><code># In another terminal
bun cli add work-account
bun cli add personal-account</code></pre>
                        </div>
                    </div>
                    <div class="step-card">
                        <div class="step-number">02</div>
                        <h3>Configure Claude</h3>
                        <div class="code-block">
                            <pre><code># Point Claude to your proxy
export ANTHROPIC_BASE_URL=http://localhost:8080</code></pre>
                        </div>
                    </div>
                    <div class="step-card">
                        <div class="step-number">03</div>
                        <h3>Never Hit Rate Limits</h3>
                        <div class="code-block">
                            <pre><code># Just use Claude normally
# ccflare handles the rest! 🚀</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="pricing" class="pricing">
            <div class="container">
                <div class="section-header">
                    <h2>Open Source. Full Control.</h2>
                    <p>Run it yourself. Modify it. Own your infrastructure.</p>
                </div>
                <div class="pricing-card">
                    <div class="pricing-header">
                        <h3>No Bullshit Edition</h3>
                        <div class="price">
                            <span class="currency">$</span>
                            <span class="amount">0</span>
                            <span class="period">/forever</span>
                        </div>
                    </div>
                    <ul class="pricing-features">
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Unlimited accounts</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Request-level tracking and analytics</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Low-level debugging and monitoring tools</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Full source code access. MIT licensed. No strings attached.</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Claude support (why do you need customer support when you can fix it yourself?)</span>
                        </li>
                    </ul>
                    <a href="https://github.com/snipeship/ccflare" class="btn btn-primary btn-block" target="_blank">
                        Get Started Now
                    </a>
                </div>
            </div>
        </section>

        <section class="cta">
            <div class="container">
                <div class="cta-content">
                    <h2>Take Control of Your Claude API Usage</h2>
                    <p>Track every Anthropic API request. Monitor rate limits. Never get blocked again with intelligent load balancing.</p>
                    <div class="cta-actions">
                        <a href="https://github.com/snipeship/ccflare" class="btn btn-primary" target="_blank">
                            <span>Get ccflare</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <div class="logo-wrapper">
                        <div class="logo-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 2L3 7V12C3 16.55 6.84 20.74 12 22C17.16 20.74 21 16.55 21 12V7L12 2Z" fill="#F38020"/>
                            </svg>
                        </div>
                        <span class="logo-text">ccflare</span>
                    </div>
                    <p class="footer-tagline">The open-source Claude API proxy for rate limit management and request analytics.</p>
                </div>
                <div class="footer-links">
                    <a href="https://github.com/snipeship/ccflare" target="_blank">GitHub</a>
                    <a href="https://github.com/snipeship/ccflare/issues" target="_blank">Issues</a>
                    <a href="https://github.com/snipeship/ccflare/blob/main/LICENSE" target="_blank">License</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 ccflare. Built with ❤️ for developers who ship.</p>
            </div>
        </div>
    </footer>
</body>
</html>
</file>

<file path="apps/lander/src/styles.css">
:root {
	--cf-orange: #f38020;
	--background: hsl(220 13% 8%);
	--foreground: hsl(0 0% 95%);
	--card: hsl(220 13% 12%);
	--card-foreground: hsl(0 0% 95%);
	--secondary: hsl(220 13% 18%);
	--muted: hsl(220 13% 18%);
	--muted-foreground: hsl(220 9% 55%);
	--border: hsl(220 13% 20%);
	--radius: 0.5rem;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body {
	font-family:
		"Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
		Ubuntu, sans-serif;
	background-color: var(--background);
	color: var(--foreground);
	line-height: 1.6;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
	overflow-x: hidden;
}

/* Grain overlay */
.grain {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
	opacity: 0.03;
	z-index: 1;
	background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
}

/* Header */
.header {
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	z-index: 50;
	background: rgba(17, 18, 23, 0.8);
	backdrop-filter: blur(10px);
	border-bottom: 1px solid var(--border);
}

.nav-container {
	max-width: 1200px;
	margin: 0 auto;
	padding: 1rem 2rem;
	display: flex;
	justify-content: space-between;
	align-items: center;
}

.logo-wrapper {
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

.logo-icon {
	display: flex;
	align-items: center;
	justify-content: center;
}

.logo-text {
	font-size: 1.25rem;
	font-weight: 600;
	letter-spacing: -0.02em;
}

.nav-links {
	display: flex;
	align-items: center;
	gap: 2rem;
}

.nav-links a {
	color: var(--muted-foreground);
	text-decoration: none;
	font-size: 0.875rem;
	font-weight: 500;
	transition: color 0.2s;
}

.nav-links a:hover {
	color: var(--foreground);
}

.github-link {
	display: flex;
	align-items: center;
	gap: 0.5rem;
	padding: 0.5rem 1rem;
	border: 1px solid var(--border);
	border-radius: var(--radius);
	transition: all 0.2s;
}

.github-link:hover {
	border-color: var(--cf-orange);
	color: var(--cf-orange) !important;
}

/* Hero Section */
.hero {
	position: relative;
	min-height: 100vh;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 6rem 2rem 4rem;
}

.hero-background {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: radial-gradient(
		ellipse at top,
		rgba(243, 128, 32, 0.1) 0%,
		transparent 50%
	);
	pointer-events: none;
}

.hero-container {
	max-width: 1400px;
	width: 100%;
	display: grid;
	grid-template-columns: 1fr 1.2fr;
	gap: 4rem;
	align-items: center;
	z-index: 2;
	margin: 0 auto;
}

.hero-content {
	text-align: left;
}

/* Hero Screenshot */
.hero-screenshot {
	position: relative;
	width: 100%;
}

.hero-screenshot-wrapper {
	position: relative;
	width: 100%;
	border-radius: var(--radius);
	overflow: hidden;
	box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
	transition: transform 0.3s ease;
	border: 2px solid var(--border);
}

.hero-screenshot-wrapper:hover {
	transform: translateY(-4px) scale(1.02);
	border-color: rgba(243, 128, 32, 0.3);
	box-shadow: 0 30px 60px -15px rgba(0, 0, 0, 0.6);
}

.hero-screenshot-wrapper img {
	width: 100%;
	height: auto;
	display: block;
}

.hero-screenshot-glow {
	position: absolute;
	inset: -50%;
	background: radial-gradient(
		circle,
		rgba(243, 128, 32, 0.4) 0%,
		transparent 70%
	);
	opacity: 0.3;
	pointer-events: none;
	animation: pulse 4s ease-in-out infinite;
}

@keyframes pulse {
	0%,
	100% {
		opacity: 0.2;
		transform: scale(0.8);
	}
	50% {
		opacity: 0.4;
		transform: scale(1);
	}
}

.hero-badge {
	display: inline-block;
	padding: 0.25rem 0.75rem;
	background: rgba(243, 128, 32, 0.2);
	border: 1px solid rgba(243, 128, 32, 0.3);
	border-radius: 9999px;
	font-size: 0.75rem;
	font-weight: 500;
	color: var(--cf-orange);
	margin-bottom: 1.5rem;
}

.hero-title {
	font-size: clamp(3rem, 8vw, 5rem);
	font-weight: 700;
	line-height: 1.1;
	letter-spacing: -0.03em;
	margin-bottom: 1.5rem;
}

.gradient-text {
	background: linear-gradient(135deg, var(--cf-orange) 0%, #f97316 100%);
	-webkit-background-clip: text;
	-webkit-text-fill-color: transparent;
	background-clip: text;
}

.hero-subtitle {
	font-size: 1.25rem;
	color: var(--muted-foreground);
	max-width: 600px;
	margin: 0 0 2.5rem;
	line-height: 1.7;
}

.hero-actions {
	display: flex;
	gap: 1rem;
	justify-content: flex-start;
	margin-bottom: 3rem;
	flex-wrap: wrap;
}

/* Buttons */
.btn {
	display: inline-flex;
	align-items: center;
	gap: 0.5rem;
	padding: 0.75rem 1.5rem;
	border-radius: var(--radius);
	font-weight: 500;
	font-size: 0.875rem;
	text-decoration: none;
	transition: all 0.2s;
	cursor: pointer;
	border: none;
}

.btn-primary {
	background: var(--cf-orange);
	color: white;
}

.btn-primary:hover {
	background: #e67119;
	transform: translateY(-2px);
	box-shadow: 0 10px 20px rgba(243, 128, 32, 0.3);
}

.btn-secondary {
	background: var(--secondary);
	color: var(--foreground);
}

.btn-secondary:hover {
	background: var(--muted);
}

.btn-block {
	width: 100%;
	justify-content: center;
}

/* Hero Stats */
.hero-stats {
	display: flex;
	gap: 3rem;
	justify-content: flex-start;
	align-items: center;
}

.stat {
	text-align: center;
}

.stat-value {
	display: block;
	font-size: 2rem;
	font-weight: 700;
	color: var(--foreground);
	letter-spacing: -0.02em;
}

.stat-label {
	display: block;
	font-size: 0.875rem;
	color: var(--muted-foreground);
	margin-top: 0.25rem;
}

.stat-divider {
	width: 1px;
	height: 40px;
	background: var(--border);
}

/* Container */
.container {
	max-width: 1200px;
	margin: 0 auto;
	padding: 0 2rem;
}

/* Section Header */
.section-header {
	text-align: center;
	margin-bottom: 4rem;
}

.section-header h2 {
	font-size: 2.5rem;
	font-weight: 700;
	margin-bottom: 1rem;
	letter-spacing: -0.02em;
}

.section-header p {
	font-size: 1.125rem;
	color: var(--muted-foreground);
}

/* Features Section */
.features {
	padding: 6rem 0;
}

.features-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
	gap: 2rem;
}

.feature-card {
	background: var(--card);
	padding: 2rem;
	border-radius: var(--radius);
	border: 1px solid var(--border);
	transition: all 0.2s;
}

.feature-card:hover {
	transform: translateY(-4px);
	border-color: rgba(243, 128, 32, 0.3);
	box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
}

.feature-icon {
	width: 48px;
	height: 48px;
	background: rgba(243, 128, 32, 0.1);
	border-radius: var(--radius);
	display: flex;
	align-items: center;
	justify-content: center;
	margin-bottom: 1.5rem;
	color: var(--cf-orange);
}

.feature-card h3 {
	font-size: 1.25rem;
	font-weight: 600;
	margin-bottom: 0.75rem;
}

.feature-card p {
	color: var(--muted-foreground);
	line-height: 1.6;
}

/* Featured Feature Card */
.feature-card.featured {
	grid-column: span 2;
	background: linear-gradient(
		135deg,
		rgba(243, 128, 32, 0.1) 0%,
		rgba(243, 128, 32, 0.05) 100%
	);
	border: 2px solid rgba(243, 128, 32, 0.2);
	position: relative;
	overflow: hidden;
}

.feature-card.featured::before {
	content: "";
	position: absolute;
	top: -2px;
	left: -2px;
	right: -2px;
	bottom: -2px;
	background: linear-gradient(135deg, var(--cf-orange), transparent);
	opacity: 0;
	transition: opacity 0.3s;
	z-index: -1;
}

.feature-card.featured:hover::before {
	opacity: 0.1;
}

.feature-card.featured .feature-icon {
	width: 64px;
	height: 64px;
	background: rgba(243, 128, 32, 0.2);
}

.feature-stats {
	display: flex;
	gap: 2rem;
	margin-top: 1.5rem;
	padding-top: 1.5rem;
	border-top: 1px solid var(--border);
}

.feature-stat {
	display: flex;
	flex-direction: column;
	gap: 0.25rem;
}

.stat-number {
	font-size: 1.5rem;
	font-weight: 700;
	color: var(--cf-orange);
}

.stat-label {
	font-size: 0.875rem;
	color: var(--muted-foreground);
}

/* Screenshots Section */
.screenshots {
	padding: 6rem 0;
	background: rgba(243, 128, 32, 0.03);
}

.container-wide {
	max-width: 1400px;
	margin: 0 auto;
	padding: 0 2rem;
}

/* Featured Screenshot Hero */
.screenshot-hero {
	margin-top: 3rem;
	margin-bottom: 4rem;
}

.screenshot-hero-content {
	display: grid;
	grid-template-columns: 1fr 2fr;
	gap: 4rem;
	align-items: center;
}

.screenshot-hero-text h3 {
	font-size: 2rem;
	font-weight: 700;
	margin-bottom: 1rem;
	color: var(--foreground);
}

.screenshot-hero-text p {
	font-size: 1.125rem;
	color: var(--muted-foreground);
	line-height: 1.8;
	margin-bottom: 2rem;
}

.screenshot-features {
	display: flex;
	flex-direction: column;
	gap: 1rem;
}

.screenshot-feature {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	color: var(--muted-foreground);
}

.screenshot-feature svg {
	color: var(--primary);
	flex-shrink: 0;
}

.screenshot-hero-image {
	position: relative;
	background: var(--card);
	border: 2px solid var(--border);
	border-radius: var(--radius);
	overflow: hidden;
	box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
	transition: all 0.3s ease;
}

.screenshot-hero-image:hover {
	transform: translateY(-4px);
	border-color: rgba(243, 128, 32, 0.3);
	box-shadow: 0 30px 60px -15px rgba(0, 0, 0, 0.6);
}

.screenshot-hero-image img {
	width: 100%;
	height: auto;
	display: block;
}

/* Secondary Screenshots */
.screenshots-secondary {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
	gap: 3rem;
}

.screenshot-card-large {
	background: var(--card);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	overflow: hidden;
	transition: all 0.3s ease;
}

.screenshot-card-large:hover {
	transform: translateY(-4px);
	border-color: rgba(243, 128, 32, 0.3);
	box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
}

.screenshot-card-header {
	padding: 2rem;
	background: rgba(243, 128, 32, 0.05);
	border-bottom: 1px solid var(--border);
}

.screenshot-card-header h3 {
	font-size: 1.5rem;
	font-weight: 600;
	margin-bottom: 0.5rem;
}

.screenshot-card-header p {
	color: var(--muted-foreground);
	font-size: 1rem;
	margin: 0;
}

.screenshot-wrapper-large {
	position: relative;
	background: var(--secondary);
	overflow: hidden;
}

.screenshot-wrapper-large img {
	width: 100%;
	height: auto;
	display: block;
	object-fit: cover;
}

/* Legacy styles for compatibility */
.screenshots-grid {
	display: none;
}

/* Performance Section */
.performance {
	padding: 6rem 0;
}

.performance-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
	gap: 2rem;
}

.performance-card {
	background: var(--card);
	padding: 2.5rem;
	border-radius: var(--radius);
	border: 1px solid var(--border);
	text-align: center;
}

.performance-metric {
	margin-bottom: 2rem;
}

.metric-value {
	display: block;
	font-size: 3rem;
	font-weight: 700;
	color: var(--cf-orange);
	letter-spacing: -0.02em;
}

.metric-label {
	display: block;
	font-size: 0.875rem;
	color: var(--muted-foreground);
	margin-top: 0.5rem;
}

.performance-chart {
	display: flex;
	gap: 0.5rem;
	align-items: flex-end;
	justify-content: center;
	height: 80px;
}

.chart-bar {
	width: 20px;
	background: var(--cf-orange);
	border-radius: 4px 4px 0 0;
	opacity: 0.8;
}

.performance-icon {
	display: flex;
	justify-content: center;
}

.performance-icon.success {
	color: #10b981;
}

.uptime-indicator {
	display: flex;
	gap: 0.25rem;
	justify-content: center;
}

.uptime-bar {
	width: 8px;
	height: 40px;
	background: #10b981;
	border-radius: 2px;
}

/* Get Started Section */
.get-started {
	padding: 6rem 0;
}

.steps-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
	gap: 2rem;
}

.step-card {
	position: relative;
	padding: 2rem;
}

.step-number {
	font-size: 4rem;
	font-weight: 700;
	color: rgba(243, 128, 32, 0.2);
	line-height: 1;
	margin-bottom: 1rem;
}

.step-card h3 {
	font-size: 1.25rem;
	font-weight: 600;
	margin-bottom: 1rem;
}

.code-block {
	background: var(--card);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: 1rem;
	overflow-x: auto;
}

.code-block pre {
	margin: 0;
	font-family: "SF Mono", "Monaco", "Inconsolata", "Fira Code", monospace;
	font-size: 0.875rem;
	line-height: 1.5;
	color: var(--foreground);
}

/* Pricing Section */
.pricing {
	padding: 6rem 0;
	background: rgba(243, 128, 32, 0.03);
}

.pricing-card {
	max-width: 480px;
	margin: 0 auto;
	background: var(--card);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: 3rem;
	text-align: center;
}

.pricing-header {
	margin-bottom: 2rem;
}

.pricing-header h3 {
	font-size: 1.5rem;
	font-weight: 600;
	margin-bottom: 1.5rem;
}

.price {
	display: flex;
	align-items: baseline;
	justify-content: center;
	gap: 0.25rem;
}

.pricing-tagline {
	text-align: center;
	color: var(--muted-foreground);
	font-size: 1.125rem;
	font-weight: 500;
	margin-top: 0.75rem;
	letter-spacing: -0.01em;
}

.currency {
	font-size: 1.5rem;
	color: var(--muted-foreground);
}

.amount {
	font-size: 4rem;
	font-weight: 700;
	letter-spacing: -0.02em;
}

.period {
	font-size: 1.125rem;
	color: var(--muted-foreground);
}

.pricing-features {
	list-style: none;
	margin: 2rem 0;
	text-align: left;
}

.pricing-features li {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border);
}

.pricing-features li:last-child {
	border-bottom: none;
}

.pricing-features svg {
	color: #10b981;
	flex-shrink: 0;
}

/* CTA Section */
.cta {
	padding: 6rem 0;
	background: linear-gradient(
		135deg,
		rgba(243, 128, 32, 0.1) 0%,
		transparent 100%
	);
}

.cta-content {
	text-align: center;
	max-width: 600px;
	margin: 0 auto;
}

.cta-content h2 {
	font-size: 2.5rem;
	font-weight: 700;
	margin-bottom: 1rem;
	letter-spacing: -0.02em;
}

.cta-content p {
	font-size: 1.125rem;
	color: var(--muted-foreground);
	margin-bottom: 2rem;
}

.cta-actions {
	display: flex;
	gap: 1rem;
	justify-content: center;
}

/* Footer */
.footer {
	background: var(--card);
	border-top: 1px solid var(--border);
	padding: 3rem 0 2rem;
}

.footer-content {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 2rem;
}

.footer-brand {
	display: flex;
	flex-direction: column;
	gap: 0.5rem;
}

.footer-tagline {
	color: var(--muted-foreground);
	font-size: 0.875rem;
}

.footer-links {
	display: flex;
	gap: 2rem;
}

.footer-links a {
	color: var(--muted-foreground);
	text-decoration: none;
	font-size: 0.875rem;
	transition: color 0.2s;
}

.footer-links a:hover {
	color: var(--foreground);
}

.footer-bottom {
	text-align: center;
	padding-top: 2rem;
	border-top: 1px solid var(--border);
	color: var(--muted-foreground);
	font-size: 0.875rem;
}

/* Hero Code Block */
.hero-code-block {
	display: grid;
	grid-template-columns: 1.5fr 1fr;
	gap: 3rem;
	margin: 3rem 0;
	align-items: start;
}

.code-block.large {
	background: rgba(243, 128, 32, 0.05);
	border: 2px solid rgba(243, 128, 32, 0.2);
	box-shadow: 0 0 40px rgba(243, 128, 32, 0.1);
}

.code-block.large pre {
	font-size: 1rem;
	line-height: 1.8;
}

.code-block .highlight {
	color: var(--primary);
	font-weight: 600;
	text-shadow: 0 0 20px rgba(243, 128, 32, 0.5);
}

.command-benefits {
	padding: 1.5rem 0;
}

.command-benefits h3 {
	font-size: 1.25rem;
	margin-bottom: 1rem;
	color: var(--foreground);
}

.command-benefits ul {
	list-style: none;
	padding: 0;
	margin: 0;
}

.command-benefits li {
	padding: 0.75rem 0;
	font-size: 1rem;
	color: var(--muted-foreground);
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

/* Responsive */
@media (max-width: 1024px) {
	.hero-container {
		grid-template-columns: 1fr;
		gap: 3rem;
	}

	.hero-content {
		text-align: center;
		max-width: 800px;
		margin: 0 auto;
	}

	.hero-subtitle {
		margin: 0 auto 2.5rem;
	}

	.hero-actions {
		justify-content: center;
	}

	.hero-stats {
		justify-content: center;
	}

	.hero-screenshot-wrapper {
		max-width: 600px;
		margin: 0 auto;
	}

	.screenshot-hero-content {
		grid-template-columns: 1fr;
		gap: 3rem;
	}

	.screenshot-hero-text {
		text-align: center;
	}

	.screenshots-secondary {
		grid-template-columns: 1fr;
		gap: 2rem;
	}
}

@media (max-width: 768px) {
	.hero-code-block {
		grid-template-columns: 1fr;
		gap: 2rem;
	}

	.container-wide {
		padding: 0 1rem;
	}

	.screenshot-hero {
		margin-top: 2rem;
		margin-bottom: 3rem;
	}

	.screenshot-hero-text h3 {
		font-size: 1.5rem;
	}

	.screenshot-hero-text p {
		font-size: 1rem;
	}

	.screenshot-card-header {
		padding: 1.5rem;
	}

	.screenshot-card-header h3 {
		font-size: 1.25rem;
	}

	.feature-card.featured {
		grid-column: 1;
	}

	.feature-stats {
		flex-direction: row;
		justify-content: space-around;
	}

	.stat-number {
		font-size: 1.25rem;
	}

	.nav-links {
		gap: 1rem;
	}

	.nav-links a:not(.github-link) {
		display: none;
	}

	.hero-title {
		font-size: 3rem;
	}

	.hero-stats {
		gap: 1.5rem;
	}

	.stat-value {
		font-size: 1.5rem;
	}

	.footer-content {
		flex-direction: column;
		gap: 2rem;
		text-align: center;
	}

	.footer-links {
		justify-content: center;
	}
}
</file>

<file path="apps/lander/package.json">
{
	"name": "@ccflare/lander",
	"version": "1.0.0",
	"description": "Landing page for ccflare - The ultimate Claude Code proxy for power users",
	"private": true,
	"scripts": {
		"build": "mkdir -p dist && cp -r src/* dist/",
		"preview": "bunx serve src"
	},
	"keywords": [
		"ccflare",
		"landing-page",
		"static-site"
	],
	"author": "snipeship",
	"license": "MIT"
}
</file>

<file path="apps/lander/README.md">
# ccflare Landing Page

Static landing page for ccflare - showcasing how simple it is to never hit rate limits again.

## 🚀 Getting Started is This Simple

```bash
# Clone and run - that's it!
git clone https://github.com/snipeship/ccflare
cd ccflare
bun install
bun run ccflare
```

That single `bun run ccflare` command gives you:
- ✅ Full proxy server on port 8080
- ✅ Interactive TUI for monitoring
- ✅ Web dashboard at http://localhost:8080/dashboard
- ✅ Real-time analytics and request logs
- ✅ Automatic rate limit handling

## Landing Page Development

### Local Preview

```bash
# Preview the site locally
bun run preview
```

### Build

```bash
# Build the site (copies src to dist)
bun run build
```

## Deploy to Cloudflare Pages

### Option 1: GitHub Integration

1. Push your code to GitHub
2. Go to [Cloudflare Pages](https://pages.cloudflare.com)
3. Connect your GitHub repository
4. Use these build settings:
   - Build command: `cd apps/lander && bun run build`
   - Build output directory: `apps/lander/dist`
   - Root directory: `/`

### Option 2: Direct Upload

1. Build the site locally:
   ```bash
   cd apps/lander
   bun run build
   ```

2. Upload the `dist` folder to Cloudflare Pages

### Option 3: Wrangler CLI

1. Install Wrangler:
   ```bash
   bun add -g wrangler
   ```

2. Deploy:
   ```bash
   cd apps/lander
   bun run build
   wrangler pages deploy dist --project-name=ccflare-landing
   ```

## Features

- Dark theme matching ccflare dashboard
- Mobile responsive
- Security headers configured
- Optimized for performance
- Static HTML/CSS (no JavaScript framework)
- Real screenshots from actual ccflare usage
</file>

<file path="apps/server/package.json">
{
	"name": "@ccflare/server",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/server.ts",
	"scripts": {
		"dev": "bun run --hot src/server.ts",
		"start": "bun run src/server.ts",
		"build": "bun build src/server.ts --compile --outfile dist/ccflare-server",
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/core-di": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/load-balancer": "workspace:*",
		"@ccflare/proxy": "workspace:*",
		"@ccflare/dashboard-web": "workspace:*",
		"@ccflare/http-api": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}
</file>

<file path="apps/server/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="apps/tui/src/components/charts/BarChart.tsx">
import { Box, Text } from "ink";
import { createBar, formatAxisValue, getColorForValue } from "./utils";

export interface BarChartData {
	label: string;
	value: number;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
}

interface BarChartProps {
	data: BarChartData[];
	width?: number;
	showValues?: boolean;
	title?: string;
	colorThresholds?: { good: number; warning: number };
}

export function BarChart({
	data,
	width = 30,
	showValues = true,
	title,
	colorThresholds,
}: BarChartProps) {
	if (data.length === 0) {
		return (
			<Box flexDirection="column">
				{title && (
					<Text bold underline>
						{title}
					</Text>
				)}
				<Text dimColor>No data available</Text>
			</Box>
		);
	}

	const maxValue = Math.max(...data.map((d) => d.value));
	const maxLabelLength = Math.max(...data.map((d) => d.label.length));

	return (
		<Box flexDirection="column">
			{title && (
				<Box marginBottom={1}>
					<Text bold underline>
						{title}
					</Text>
				</Box>
			)}
			{data.map((item, index) => {
				const bar = createBar(item.value, maxValue, width, false);
				const color =
					item.color ||
					(colorThresholds
						? getColorForValue(item.value, colorThresholds)
						: "cyan");

				return (
					<Box key={`${item.label}-${index}`}>
						<Box width={maxLabelLength + 2}>
							<Text>{item.label}:</Text>
						</Box>
						<Text color={color}>{bar}</Text>
						{showValues && <Text dimColor> {formatAxisValue(item.value)}</Text>}
					</Box>
				);
			})}
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/charts/index.ts">
export { BarChart, type BarChartData } from "./BarChart";
export { LineChart, type LineChartData } from "./LineChart";
export { PieChart, type PieChartData } from "./PieChart";
export { SparklineChart } from "./SparklineChart";
export * from "./utils";
</file>

<file path="apps/tui/src/components/charts/LineChart.tsx">
import { Box, Text } from "ink";
import { formatAxisValue, getSparkChar, normalizeData } from "./utils";

export interface LineChartData {
	x: string;
	y: number;
}

interface LineChartProps {
	data: LineChartData[];
	height?: number;
	width?: number;
	title?: string;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
	showAxes?: boolean;
}

export function LineChart({
	data,
	height = 10,
	width = 40,
	title,
	color = "cyan",
	showAxes = true,
}: LineChartProps) {
	if (data.length === 0) {
		return (
			<Box flexDirection="column">
				{title && (
					<Text bold underline>
						{title}
					</Text>
				)}
				<Text dimColor>No data available</Text>
			</Box>
		);
	}

	const values = data.map((d) => d.y);
	const { normalized, max, min } = normalizeData(values, height - 1);

	// Create the chart grid
	const chart: string[][] = Array(height)
		.fill(null)
		.map(() => Array(width).fill(" "));

	// Plot the points
	const xStep = Math.max(1, Math.floor(data.length / width));
	for (let i = 0; i < width && i * xStep < data.length; i++) {
		const dataIndex = i * xStep;
		const value = normalized[dataIndex];
		const y = height - 1 - Math.round(value);
		const x = i;

		if (y >= 0 && y < height) {
			// Use different characters based on the position in the y-axis
			const char = getSparkChar(values[dataIndex], min, max);
			chart[y][x] = char;
		}
	}

	return (
		<Box flexDirection="column">
			{title && (
				<Box marginBottom={1}>
					<Text bold underline>
						{title}
					</Text>
				</Box>
			)}

			{/* Y-axis labels and chart */}
			{showAxes && (
				<Box>
					<Text dimColor>{formatAxisValue(max).padStart(6)} </Text>
					<Text dimColor>┤</Text>
				</Box>
			)}

			{chart.map((row, y) => (
				<Box key={`chart-row-${y}-${height}`}>
					{showAxes && y === Math.floor(height / 2) && (
						<Text dimColor>
							{formatAxisValue((max + min) / 2).padStart(6)}{" "}
						</Text>
					)}
					{showAxes && y !== Math.floor(height / 2) && (
						<Text>{" ".repeat(6)} </Text>
					)}
					{showAxes && <Text dimColor>│</Text>}
					<Text color={color}>{row.join("")}</Text>
				</Box>
			))}

			{showAxes && (
				<>
					<Box>
						<Text dimColor>{formatAxisValue(min).padStart(6)} </Text>
						<Text dimColor>└{"─".repeat(width)}</Text>
					</Box>
					{/* X-axis labels */}
					<Box marginLeft={8}>
						<Text dimColor>
							{data[0].x}
							{" ".repeat(
								Math.max(
									0,
									width - data[0].x.length - data[data.length - 1].x.length,
								),
							)}
							{data[data.length - 1].x}
						</Text>
					</Box>
				</>
			)}
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/charts/PieChart.tsx">
import { Box, Text } from "ink";
import { formatAxisValue } from "./utils";

export interface PieChartData {
	label: string;
	value: number;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
}

interface PieChartProps {
	data: PieChartData[];
	title?: string;
	showLegend?: boolean;
	size?: "small" | "medium" | "large";
}

const _PIE_CHARS = {
	full: "●",
	three_quarters: "◕",
	half: "◐",
	quarter: "◔",
	empty: "○",
} as const;

const SIZE_CONFIG = {
	small: { radius: 3, chars: ["•", "○"] },
	medium: { radius: 5, chars: ["●", "○"] },
	large: { radius: 7, chars: ["●", "○"] },
} as const;

export function PieChart({
	data,
	title,
	showLegend = true,
	size = "medium",
}: PieChartProps) {
	if (data.length === 0) {
		return (
			<Box flexDirection="column">
				{title && (
					<Text bold underline>
						{title}
					</Text>
				)}
				<Text dimColor>No data available</Text>
			</Box>
		);
	}

	const total = data.reduce((sum, item) => sum + item.value, 0);
	const percentages = data.map((item) => ({
		...item,
		percentage: total > 0 ? (item.value / total) * 100 : 0,
	}));

	// Sort by percentage for better visualization
	percentages.sort((a, b) => b.percentage - a.percentage);

	// Simple ASCII representation
	const { radius } = SIZE_CONFIG[size];
	const diameter = radius * 2 + 1;

	// Create a simple circular visualization
	const createCircle = () => {
		const circle: string[][] = [];
		for (let y = 0; y < diameter; y++) {
			const row: string[] = [];
			for (let x = 0; x < diameter; x++) {
				const dx = x - radius;
				const dy = y - radius;
				const distance = Math.sqrt(dx * dx + dy * dy);

				if (distance <= radius) {
					// Determine which segment this point belongs to
					let angle = Math.atan2(dy, dx) + Math.PI; // 0 to 2π
					angle = angle / (2 * Math.PI); // 0 to 1

					let cumulativePercentage = 0;
					let segmentIndex = 0;
					for (let i = 0; i < percentages.length; i++) {
						cumulativePercentage += percentages[i].percentage / 100;
						if (angle <= cumulativePercentage) {
							segmentIndex = i;
							break;
						}
					}

					const color = percentages[segmentIndex]?.color || "cyan";
					row.push(color);
				} else {
					row.push(" ");
				}
			}
			circle.push(row);
		}
		return circle;
	};

	const circleColors = createCircle();

	return (
		<Box flexDirection="column">
			{title && (
				<Box marginBottom={1}>
					<Text bold underline>
						{title}
					</Text>
				</Box>
			)}

			<Box flexDirection="row">
				{/* Pie visualization */}
				<Box flexDirection="column" marginRight={2}>
					{circleColors.map((row, y) => (
						<Box key={`pie-row-${y}-${radius}`}>
							{row.map((color, x) => (
								<Text
									key={`pie-cell-${x}-${y}-${radius}`}
									color={
										color === " "
											? undefined
											: (color as
													| "green"
													| "yellow"
													| "red"
													| "cyan"
													| "magenta"
													| "blue")
									}
								>
									{color === " " ? " " : "●"}
								</Text>
							))}
						</Box>
					))}
				</Box>

				{/* Legend */}
				{showLegend && (
					<Box flexDirection="column">
						{percentages.map((item, index) => (
							<Box key={`${item.label}-${index}`}>
								<Text color={item.color || "cyan"}>● </Text>
								<Text>{item.label}: </Text>
								<Text bold>{Math.round(item.percentage)}%</Text>
								<Text dimColor> ({formatAxisValue(item.value)})</Text>
							</Box>
						))}
						<Box marginTop={1}>
							<Text dimColor>Total: {formatAxisValue(total)}</Text>
						</Box>
					</Box>
				)}
			</Box>
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/charts/SparklineChart.tsx">
import { Box, Text } from "ink";
import { createSparkline, formatAxisValue } from "./utils";

interface SparklineChartProps {
	data: number[];
	label?: string;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
	showMinMax?: boolean;
	showCurrent?: boolean;
}

export function SparklineChart({
	data,
	label,
	color = "cyan",
	showMinMax = true,
	showCurrent = true,
}: SparklineChartProps) {
	if (data.length === 0) {
		return <Text dimColor>No data</Text>;
	}

	const sparkline = createSparkline(data);
	const min = Math.min(...data);
	const max = Math.max(...data);
	const current = data[data.length - 1];

	return (
		<Box>
			{label && (
				<Box marginRight={1}>
					<Text>{label}:</Text>
				</Box>
			)}
			<Text color={color}>{sparkline}</Text>
			{showMinMax && (
				<Text dimColor>
					{" "}
					[{formatAxisValue(min)} → {formatAxisValue(max)}]
				</Text>
			)}
			{showCurrent && (
				<Text color={color} bold>
					{" "}
					{formatAxisValue(current)}
				</Text>
			)}
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/charts/utils.ts">
// Bar chart characters
export const BAR_CHARS = {
	full: "█",
	seven_eighths: "▇",
	three_quarters: "▆",
	five_eighths: "▅",
	half: "▄",
	three_eighths: "▃",
	quarter: "▂",
	one_eighth: "▁",
	empty: " ",
} as const;

// Line chart characters
export const LINE_CHARS = {
	horizontal: "─",
	vertical: "│",
	cross: "┼",
	bottom_left: "└",
	bottom_right: "┘",
	top_left: "┌",
	top_right: "┐",
	vertical_right: "├",
	vertical_left: "┤",
	horizontal_down: "┬",
	horizontal_up: "┴",
} as const;

// Sparkline characters
export const SPARK_CHARS = ["▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"] as const;

// Get a bar character based on percentage (0-1)
export function getBarChar(percentage: number): string {
	if (percentage >= 1) return BAR_CHARS.full;
	if (percentage >= 0.875) return BAR_CHARS.seven_eighths;
	if (percentage >= 0.75) return BAR_CHARS.three_quarters;
	if (percentage >= 0.625) return BAR_CHARS.five_eighths;
	if (percentage >= 0.5) return BAR_CHARS.half;
	if (percentage >= 0.375) return BAR_CHARS.three_eighths;
	if (percentage >= 0.25) return BAR_CHARS.quarter;
	if (percentage >= 0.125) return BAR_CHARS.one_eighth;
	return BAR_CHARS.empty;
}

// Get a sparkline character based on value position in range
export function getSparkChar(value: number, min: number, max: number): string {
	if (max === min) return SPARK_CHARS[0];
	const percentage = (value - min) / (max - min);
	const index = Math.floor(percentage * (SPARK_CHARS.length - 1));
	return SPARK_CHARS[Math.max(0, Math.min(index, SPARK_CHARS.length - 1))];
}

// Normalize data to fit within a specific range
export function normalizeData(
	data: number[],
	targetMax: number,
): { normalized: number[]; max: number; min: number } {
	const max = Math.max(...data, 0);
	const min = Math.min(...data, 0);
	const range = max - min || 1;

	const normalized = data.map((value) => {
		const percentage = (value - min) / range;
		return percentage * targetMax;
	});

	return { normalized, max, min };
}

// Format a number for display with appropriate units
export function formatAxisValue(value: number): string {
	if (value >= 1000000) {
		return `${(value / 1000000).toFixed(1)}M`;
	}
	if (value >= 1000) {
		return `${(value / 1000).toFixed(1)}K`;
	}
	if (value < 1 && value > 0) {
		return value.toFixed(2);
	}
	return Math.round(value).toString();
}

// Create a horizontal bar
export function createBar(
	value: number,
	maxValue: number,
	width: number,
	showPercentage = true,
): string {
	const percentage = maxValue > 0 ? value / maxValue : 0;
	const filledWidth = Math.floor(percentage * width);
	const remainingWidth = width - filledWidth;

	let bar = "";
	for (let i = 0; i < filledWidth; i++) {
		bar += BAR_CHARS.full;
	}

	// Add partial bar for the remaining percentage
	if (remainingWidth > 0) {
		const remainingPercentage = percentage * width - filledWidth;
		bar += getBarChar(remainingPercentage);
		for (let i = 1; i < remainingWidth; i++) {
			bar += BAR_CHARS.empty;
		}
	}

	if (showPercentage) {
		const percentStr = `${Math.round(percentage * 100)}%`;
		return `${bar} ${percentStr}`;
	}

	return bar;
}

// Create a sparkline from data
export function createSparkline(data: number[]): string {
	if (data.length === 0) return "";

	const max = Math.max(...data);
	const min = Math.min(...data);

	return data.map((value) => getSparkChar(value, min, max)).join("");
}

// Get color based on value and thresholds
export function getColorForValue(
	value: number,
	thresholds: { good: number; warning: number },
	inverse = false,
): "green" | "yellow" | "red" {
	if (inverse) {
		if (value <= thresholds.good) return "green";
		if (value <= thresholds.warning) return "yellow";
		return "red";
	} else {
		if (value >= thresholds.good) return "green";
		if (value >= thresholds.warning) return "yellow";
		return "red";
	}
}
</file>

<file path="apps/tui/src/components/AccountsScreen.tsx">
import * as tuiCore from "@ccflare/tui-core";
import type { AccountDisplay } from "@ccflare/types";
import { AccountPresenter } from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import SelectInput from "ink-select-input";
import TextInput from "ink-text-input";
import { useCallback, useEffect, useState } from "react";

interface AccountsScreenProps {
	onBack: () => void;
}

type Mode = "list" | "add" | "remove" | "confirmRemove" | "waitingForCode";

export function AccountsScreen({ onBack }: AccountsScreenProps) {
	const [mode, setMode] = useState<Mode>("list");
	const [accounts, setAccounts] = useState<AccountDisplay[]>([]);
	const [newAccountName, setNewAccountName] = useState("");
	const [selectedMode, setSelectedMode] = useState<"max" | "console">("max");
	const [selectedTier, setSelectedTier] = useState<1 | 5 | 20>(1);
	const [step, setStep] = useState<"name" | "mode" | "tier" | "confirm">(
		"name",
	);
	const [authCode, setAuthCode] = useState("");
	const [oauthFlowData, setOauthFlowData] =
		useState<tuiCore.OAuthFlowResult | null>(null);
	const [error, setError] = useState<string | null>(null);
	const [accountToRemove, setAccountToRemove] = useState("");
	const [confirmInput, setConfirmInput] = useState("");

	useInput((input, key) => {
		if (key.escape) {
			if (mode === "confirmRemove") {
				setMode("list");
				setAccountToRemove("");
				setConfirmInput("");
			} else if (mode === "add" || mode === "waitingForCode") {
				setMode("list");
				setNewAccountName("");
				setStep("name");
				setAuthCode("");
				setOauthFlowData(null);
				setError(null);
			} else {
				onBack();
			}
		} else if (input === "q" && mode === "list") {
			onBack();
		}
	});

	const loadAccounts = useCallback(async () => {
		const data = await tuiCore.getAccounts();
		setAccounts(data);
	}, []);

	useEffect(() => {
		loadAccounts();
	}, [loadAccounts]);

	const handleBeginAddAccount = async () => {
		try {
			const flowData = await tuiCore.beginAddAccount({
				name: newAccountName,
				mode: selectedMode,
				tier: selectedTier,
			});
			setOauthFlowData(flowData);
			setMode("waitingForCode");
			setError(null);
		} catch (error) {
			setError(
				error instanceof Error ? error.message : "Failed to begin OAuth flow",
			);
		}
	};

	const handleCompleteAddAccount = async () => {
		if (!oauthFlowData || !authCode) return;

		try {
			await tuiCore.completeAddAccount({
				name: newAccountName,
				mode: selectedMode,
				tier: selectedTier,
				code: authCode,
				flowData: oauthFlowData,
			});
			await loadAccounts();
			setMode("list");
			setNewAccountName("");
			setStep("name");
			setAuthCode("");
			setOauthFlowData(null);
			setError(null);
		} catch (error) {
			setError(
				error instanceof Error ? error.message : "Failed to add account",
			);
		}
	};

	const handleRemoveAccount = (name: string) => {
		setAccountToRemove(name);
		setConfirmInput("");
		setMode("confirmRemove");
	};

	const handleConfirmRemove = async () => {
		if (confirmInput !== accountToRemove) {
			return;
		}

		try {
			await tuiCore.removeAccount(accountToRemove);
			await loadAccounts();
			setMode("list");
			setAccountToRemove("");
			setConfirmInput("");
		} catch (_error) {
			// Handle error
		}
	};

	if (mode === "add") {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					Add Account
				</Text>

				{step === "name" && (
					<Box flexDirection="column" marginTop={1}>
						<Text>Account name:</Text>
						<TextInput
							value={newAccountName}
							onChange={setNewAccountName}
							onSubmit={() => {
								if (newAccountName) setStep("mode");
							}}
						/>
					</Box>
				)}

				{step === "mode" && (
					<Box flexDirection="column" marginTop={1}>
						<Text>Select mode:</Text>
						<SelectInput
							items={[
								{ label: "Max (recommended)", value: "max" },
								{ label: "Console", value: "console" },
							]}
							onSelect={(item) => {
								setSelectedMode(item.value as "max" | "console");
								setStep("tier");
							}}
						/>
					</Box>
				)}

				{step === "tier" && (
					<Box flexDirection="column" marginTop={1}>
						<Text>Select tier:</Text>
						<SelectInput
							items={[
								{ label: "Tier 1 (default)", value: 1 },
								{ label: "Tier 5", value: 5 },
								{ label: "Tier 20", value: 20 },
							]}
							onSelect={(item) => {
								setSelectedTier(item.value as 1 | 5 | 20);
								handleBeginAddAccount();
							}}
						/>
					</Box>
				)}

				{error && (
					<Box marginTop={1}>
						<Text color="red">{error}</Text>
					</Box>
				)}

				<Box marginTop={2}>
					<Text dimColor>Press ESC to cancel</Text>
				</Box>
			</Box>
		);
	}

	if (mode === "waitingForCode") {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					Complete Authentication
				</Text>

				<Box flexDirection="column" marginTop={1}>
					<Text>A browser window should have opened for authentication.</Text>
					<Text>After authorizing, enter the code below:</Text>

					<Box marginTop={1}>
						<Text>Authorization code:</Text>
						<TextInput
							value={authCode}
							onChange={setAuthCode}
							onSubmit={() => {
								if (authCode) handleCompleteAddAccount();
							}}
						/>
					</Box>
				</Box>

				{error && (
					<Box marginTop={1}>
						<Text color="red">{error}</Text>
					</Box>
				)}

				<Box marginTop={2}>
					<Text dimColor>Press ESC to cancel</Text>
				</Box>
			</Box>
		);
	}

	if (mode === "confirmRemove") {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="red" bold>
					⚠️ Confirm Account Removal
				</Text>

				<Box marginTop={1} marginBottom={1}>
					<Text>You are about to remove account '{accountToRemove}'.</Text>
					<Text>This action cannot be undone.</Text>
				</Box>

				<Box flexDirection="column">
					<Text>
						Type <Text bold>{accountToRemove}</Text> to confirm:
					</Text>
					<TextInput
						value={confirmInput}
						onChange={setConfirmInput}
						onSubmit={() => {
							handleConfirmRemove();
						}}
					/>
				</Box>

				{confirmInput && confirmInput !== accountToRemove && (
					<Box marginTop={1}>
						<Text color="red">Account name does not match</Text>
					</Box>
				)}

				<Box marginTop={2}>
					<Text dimColor>Press ENTER to confirm, ESC to cancel</Text>
				</Box>
			</Box>
		);
	}

	const menuItems = [
		...accounts.map((acc) => {
			const presenter = new AccountPresenter(acc);
			return {
				label: `${acc.name} (${presenter.tierDisplay})`,
				value: `account:${acc.name}`,
			};
		}),
		{ label: "➕ Add Account", value: "add" },
		{ label: "← Back", value: "back" },
	];

	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					👥 Manage Accounts
				</Text>
			</Box>

			{accounts.length === 0 ? (
				<Text dimColor>No accounts configured</Text>
			) : (
				<Text dimColor>{accounts.length} account(s) configured</Text>
			)}

			<Box marginTop={1}>
				<SelectInput
					items={menuItems}
					onSelect={(item) => {
						if (item.value === "back") {
							onBack();
						} else if (item.value === "add") {
							setMode("add");
						} else if (item.value.startsWith("account:")) {
							const accountName = item.value.replace("account:", "");
							handleRemoveAccount(accountName);
						}
					}}
				/>
			</Box>
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/LogsScreen.tsx">
import * as tuiCore from "@ccflare/tui-core";
import { Box, Text, useInput } from "ink";
import { useEffect, useState } from "react";

interface LogsScreenProps {
	onBack: () => void;
}

interface LogEntry {
	ts: number;
	level: string;
	msg: string;
}

export function LogsScreen({ onBack }: LogsScreenProps) {
	const [logs, setLogs] = useState<LogEntry[]>([]);
	const [paused, setPaused] = useState(false);
	const [loading, setLoading] = useState(true);

	useInput((input, key) => {
		if (key.escape || input === "q") {
			onBack();
		}
		if (input === " ") {
			setPaused(!paused);
		}
		if (input === "c") {
			setLogs([]);
		}
	});

	// Load historical logs on mount
	useEffect(() => {
		const loadHistory = async () => {
			try {
				const history = await tuiCore.getLogHistory();
				setLogs(history.slice(-200)); // Keep last 200 logs
			} catch (error) {
				console.error("Failed to load log history:", error);
			} finally {
				setLoading(false);
			}
		};
		loadHistory();
	}, []);

	useEffect(() => {
		if (!paused && !loading) {
			const unsubscribe = tuiCore.streamLogs((log) => {
				setLogs((prev) => [...prev.slice(-200), log]); // Keep last 200 logs
			});

			return () => {
				unsubscribe();
			};
		}
	}, [paused, loading]);

	const getLogColor = (level: string) => {
		switch (level.toUpperCase()) {
			case "ERROR":
				return "red";
			case "WARN":
				return "yellow";
			case "INFO":
				return "green";
			case "DEBUG":
				return "gray";
			default:
				return "white";
		}
	};

	return (
		<Box flexDirection="column" padding={1} height="100%">
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					📜 Logs {paused && <Text color="yellow">(PAUSED)</Text>}
				</Text>
			</Box>

			<Box flexDirection="column" flexGrow={1}>
				{loading ? (
					<Text dimColor>Loading logs...</Text>
				) : logs.length === 0 ? (
					<Text dimColor>No logs yet...</Text>
				) : (
					logs.map((log, i) => (
						<Box key={`${log.ts}-${i}`}>
							<Text color={getLogColor(log.level)}>
								[{log.level}] {log.msg}
							</Text>
						</Box>
					))
				)}
			</Box>

			<Box marginTop={1}>
				<Text dimColor>
					SPACE: {paused ? "Resume" : "Pause"} • 'c': Clear • 'q'/ESC: Back
				</Text>
			</Box>
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/RequestsScreen.tsx">
import * as tuiCore from "@ccflare/tui-core";
import { formatCost, formatTokens } from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import { useCallback, useEffect, useState } from "react";
import { TokenUsageDisplay } from "./TokenUsageDisplay";

interface RequestsScreenProps {
	onBack: () => void;
}

export function RequestsScreen({ onBack }: RequestsScreenProps) {
	const [requests, setRequests] = useState<tuiCore.RequestPayload[]>([]);
	const [summaries, setSummaries] = useState<
		Map<string, tuiCore.RequestSummary>
	>(new Map());
	const [loading, setLoading] = useState(true);
	const [selectedIndex, setSelectedIndex] = useState(0);
	const [viewDetails, setViewDetails] = useState(false);
	const [page, setPage] = useState(0);
	const pageSize = 10;

	useInput((input, key) => {
		if (key.escape || input === "q") {
			if (viewDetails) {
				setViewDetails(false);
			} else {
				onBack();
			}
		}

		if (!viewDetails) {
			if (key.upArrow) {
				setSelectedIndex((prev) => Math.max(0, prev - 1));
			}
			if (key.downArrow) {
				setSelectedIndex((prev) =>
					Math.min(
						Math.min(requests.length - 1, page * pageSize + pageSize - 1),
						prev + 1,
					),
				);
			}
			if (key.leftArrow && page > 0) {
				setPage(page - 1);
				setSelectedIndex(page * pageSize - pageSize);
			}
			if (key.rightArrow && (page + 1) * pageSize < requests.length) {
				setPage(page + 1);
				setSelectedIndex(page * pageSize + pageSize);
			}
			if (key.return || input === " ") {
				if (requests.length > 0) {
					setViewDetails(true);
				}
			}
			if (input === "r") {
				loadRequests();
			}
		}
	});

	const loadRequests = useCallback(async () => {
		try {
			const [requestData, summaryData] = await Promise.all([
				tuiCore.getRequests(100),
				tuiCore.getRequestSummaries(100),
			]);
			setRequests(requestData);
			setSummaries(summaryData);
			setLoading(false);
		} catch (_error) {
			setLoading(false);
		}
	}, []);

	useEffect(() => {
		loadRequests();
		const interval = setInterval(loadRequests, 10000); // Auto-refresh every 10 seconds
		return () => clearInterval(interval);
	}, [loadRequests]);

	// For TUI, we want to show just time not full timestamp for space reasons
	const formatTime = (ts: number): string => {
		return new Date(ts).toLocaleTimeString();
	};

	const decodeBase64 = (str: string | null): string => {
		if (!str) return "No data";
		try {
			if (str === "[streamed]") {
				return "[Streaming data not captured]";
			}
			return Buffer.from(str, "base64").toString();
		} catch {
			return "Failed to decode";
		}
	};

	const formatJson = (str: string): string => {
		try {
			const parsed = JSON.parse(str);
			return JSON.stringify(parsed, null, 2);
		} catch {
			// If it's not valid JSON, return as-is
			return str;
		}
	};

	if (loading) {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					📜 Request History
				</Text>
				<Text dimColor>Loading...</Text>
			</Box>
		);
	}

	const selectedRequest = requests[selectedIndex];
	const selectedSummary = selectedRequest
		? summaries.get(selectedRequest.id)
		: undefined;

	if (viewDetails && selectedRequest) {
		return (
			<Box flexDirection="column" padding={1}>
				<Box marginBottom={1}>
					<Text color="cyan" bold>
						📜 Request Details
					</Text>
				</Box>

				<Box flexDirection="column">
					<Text bold>ID: {selectedRequest.id}</Text>
					<Text bold>Time: {formatTime(selectedRequest.meta.timestamp)}</Text>

					{selectedRequest.meta.accountName && (
						<Text>Account: {selectedRequest.meta.accountName}</Text>
					)}

					{selectedSummary?.model && (
						<Text>
							Model: <Text color="green">{selectedSummary.model}</Text>
						</Text>
					)}

					{selectedSummary?.responseTimeMs && (
						<Text>
							Response Time:{" "}
							<Text color="yellow">{selectedSummary.responseTimeMs}ms</Text>
						</Text>
					)}

					{selectedRequest.meta.retry !== undefined &&
						selectedRequest.meta.retry > 0 && (
							<Text color="yellow">Retry: {selectedRequest.meta.retry}</Text>
						)}

					{selectedRequest.meta.rateLimited && (
						<Text color="orange">Rate Limited</Text>
					)}

					{selectedRequest.error && (
						<Text color="red">Error: {selectedRequest.error}</Text>
					)}

					{/* Token Usage Section */}
					{selectedSummary &&
						(selectedSummary.inputTokens || selectedSummary.outputTokens) && (
							<Box marginTop={1}>
								<TokenUsageDisplay summary={selectedSummary} />
							</Box>
						)}

					<Box marginTop={1}>
						<Text bold>Request Headers:</Text>
						<Box marginLeft={2} flexDirection="column">
							<Text dimColor>
								{formatJson(JSON.stringify(selectedRequest.request.headers))}
							</Text>
						</Box>
					</Box>

					{selectedRequest.request.body && (
						<Box marginTop={1}>
							<Text bold>Request Body:</Text>
							<Box marginLeft={2}>
								<Text dimColor>
									{formatJson(
										decodeBase64(selectedRequest.request.body),
									).substring(0, 500)}
									{decodeBase64(selectedRequest.request.body).length > 500 &&
										"..."}
								</Text>
							</Box>
						</Box>
					)}

					{selectedRequest.response && (
						<>
							<Box marginTop={1}>
								<Text bold>
									Response Status:{" "}
									<Text
										color={
											selectedRequest.response.status >= 200 &&
											selectedRequest.response.status < 300
												? "green"
												: selectedRequest.response.status >= 400 &&
														selectedRequest.response.status < 500
													? "yellow"
													: "red"
										}
									>
										{selectedRequest.response.status}
									</Text>
								</Text>
							</Box>

							{selectedRequest.response.body && (
								<Box marginTop={1}>
									<Text bold>Response Body:</Text>
									<Box marginLeft={2}>
										<Text dimColor>
											{formatJson(
												decodeBase64(selectedRequest.response.body),
											).substring(0, 500)}
											{decodeBase64(selectedRequest.response.body).length >
												500 && "..."}
										</Text>
									</Box>
								</Box>
							)}
						</>
					)}
				</Box>

				<Box marginTop={2}>
					<Text dimColor>Press 'q' or ESC to go back</Text>
				</Box>
			</Box>
		);
	}

	// Paginated view
	const startIdx = page * pageSize;
	const endIdx = Math.min(startIdx + pageSize, requests.length);
	const pageRequests = requests.slice(startIdx, endIdx);
	const totalPages = Math.ceil(requests.length / pageSize);

	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					📜 Request History
				</Text>
				<Text dimColor>
					Use ↑/↓ to navigate, ←/→ for pages, ENTER to view details
				</Text>
			</Box>

			{requests.length === 0 ? (
				<Text dimColor>No requests found</Text>
			) : (
				<Box flexDirection="column">
					{pageRequests.map((req, idx) => {
						const index = startIdx + idx;
						const isSelected = index === selectedIndex;
						const isError = req.error || !req.meta.success;
						const statusCode = req.response?.status;
						const summary = summaries.get(req.id);

						return (
							<Box key={req.id}>
								<Text
									color={isSelected ? "cyan" : undefined}
									inverse={isSelected}
								>
									{isSelected ? "▶ " : "  "}
									{formatTime(req.meta.timestamp)} -{" "}
									{statusCode ? (
										<Text
											color={
												statusCode >= 200 && statusCode < 300
													? "green"
													: statusCode >= 400 && statusCode < 500
														? "yellow"
														: "red"
											}
										>
											{statusCode}
										</Text>
									) : (
										<Text color="red">ERROR</Text>
									)}
									{" - "}
									{req.meta.accountName ||
										req.meta.accountId?.slice(0, 8) ||
										"No Account"}
									{summary?.model && (
										<>
											{" - "}
											<Text color="magenta">
												{summary.model.split("-").pop()}
											</Text>
										</>
									)}
									{summary?.totalTokens && (
										<>
											{" - "}
											<Text dimColor>
												{formatTokens(summary.totalTokens)} tokens
											</Text>
										</>
									)}
									{summary?.costUsd && summary.costUsd > 0 && (
										<>
											{" - "}
											<Text color="green">{formatCost(summary.costUsd)}</Text>
										</>
									)}
									{req.meta.rateLimited && (
										<Text color="orange"> [RATE LIMITED]</Text>
									)}
									{isError &&
										req.error &&
										` - ${req.error.substring(0, 20)}...`}
								</Text>
							</Box>
						);
					})}

					<Box marginTop={1}>
						<Text dimColor>
							Page {page + 1}/{totalPages} • {requests.length} total requests
						</Text>
					</Box>
				</Box>
			)}

			<Box marginTop={2}>
				<Text dimColor>Press 'r' to refresh • 'q' or ESC to go back</Text>
			</Box>
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/ServerScreen.tsx">
import { NETWORK } from "@ccflare/core";
import { Box, Text, useInput } from "ink";

interface ServerScreenProps {
	onBack: () => void;
}

export function ServerScreen({ onBack }: ServerScreenProps) {
	// Server is auto-started now, so just show the running status
	const port = NETWORK.DEFAULT_PORT;
	const url = `http://localhost:${port}`;

	useInput((input, key) => {
		if (key.escape || input === "q") {
			onBack();
		}
		if (input === "d") {
			// Open dashboard in browser
			import("open")
				.then((module) => {
					const open = module.default as (url: string) => Promise<void>;
					open(url);
				})
				.catch(() => {
					// Fallback if open package is not available
					console.log(`\nOpen dashboard at: ${url}`);
				});
		}
	});

	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					🚀 Server
				</Text>
			</Box>

			<Box flexDirection="column">
				<Text color="green">✓ Server running at {url}</Text>
				<Box marginTop={1}>
					<Text dimColor>Press 'd' to open dashboard in browser</Text>
				</Box>
			</Box>

			<Box marginTop={2}>
				<Text dimColor>Press 'q' or ESC to go back</Text>
			</Box>
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/StatsScreen.tsx">
import * as tuiCore from "@ccflare/tui-core";
import {
	formatCost,
	formatNumber,
	formatPercentage,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import { useCallback, useEffect, useState } from "react";
import { BarChart, PieChart, SparklineChart } from "./charts";

interface StatsScreenProps {
	onBack: () => void;
}

export function StatsScreen({ onBack }: StatsScreenProps) {
	const [stats, setStats] = useState<tuiCore.Stats | null>(null);
	const [loading, setLoading] = useState(true);
	const [lastUpdated, setLastUpdated] = useState<Date>(new Date());
	const [showCharts, setShowCharts] = useState(false);

	useInput((input, key) => {
		if (key.escape || input === "q") {
			onBack();
		}
		if (input === "r") {
			loadStats();
		}
		if (input === "c") {
			setShowCharts(!showCharts);
		}
	});

	const loadStats = useCallback(async () => {
		try {
			const data = await tuiCore.getStats();
			setStats(data);
			setLoading(false);
			setLastUpdated(new Date());
		} catch (_error) {
			setLoading(false);
		}
	}, []);

	useEffect(() => {
		loadStats();
		const interval = setInterval(loadStats, 5000); // Auto-refresh every 5 seconds
		return () => clearInterval(interval);
	}, [loadStats]);

	// For TUI, we want to show just time not full timestamp for space reasons
	const formatTime = (date: Date): string => {
		return date.toLocaleTimeString();
	};

	if (loading) {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					📊 Statistics Dashboard
				</Text>
				<Text dimColor>Loading...</Text>
			</Box>
		);
	}

	if (!stats) {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					📊 Statistics Dashboard
				</Text>
				<Text color="red">Failed to load statistics</Text>
			</Box>
		);
	}

	// Calculate additional metrics
	const avgTokensPerRequest =
		stats.totalRequests > 0
			? Math.round(stats.totalTokens / stats.totalRequests)
			: 0;
	const avgCostPerRequest =
		stats.totalRequests > 0 ? stats.totalCostUsd / stats.totalRequests : 0;

	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					📊 Statistics Dashboard
				</Text>
				<Text dimColor>Last updated: {formatTime(lastUpdated)}</Text>
			</Box>

			{/* Overall Statistics */}
			<Box marginBottom={1}>
				<Text bold underline>
					Overall Statistics
				</Text>
			</Box>

			<Box flexDirection="column" marginBottom={1}>
				<Box>
					<Text>Total Requests: </Text>
					<Text color="yellow" bold>
						{formatNumber(stats.totalRequests)}
					</Text>
				</Box>
				<Box>
					<Text>Success Rate: </Text>
					<Text
						color={
							stats.successRate >= 95
								? "green"
								: stats.successRate >= 80
									? "yellow"
									: "red"
						}
						bold
					>
						{formatPercentage(stats.successRate)}
					</Text>
				</Box>
				<Box>
					<Text>Active Accounts: </Text>
					<Text color="cyan" bold>
						{stats.activeAccounts}
					</Text>
				</Box>
				<Box>
					<Text>Avg Response Time: </Text>
					<Text color="magenta" bold>
						{formatNumber(stats.avgResponseTime)}ms
					</Text>
				</Box>
				{stats.avgTokensPerSecond !== null && (
					<Box>
						<Text>Avg Output Speed: </Text>
						<Text color="blue" bold>
							{formatTokensPerSecond(stats.avgTokensPerSecond)}
						</Text>
					</Box>
				)}
			</Box>

			{/* Token Usage */}
			<Box marginBottom={1}>
				<Text bold underline>
					Token Usage Breakdown
				</Text>
			</Box>

			{stats.tokenDetails ? (
				<Box flexDirection="column" marginBottom={1}>
					<Box marginLeft={2}>
						<Text>├─ Input: </Text>
						<Text color="yellow">
							{formatNumber(stats.tokenDetails.inputTokens)}
						</Text>
					</Box>
					{stats.tokenDetails.cacheReadInputTokens > 0 && (
						<Box marginLeft={2}>
							<Text>├─ Cache Read: </Text>
							<Text color="cyan">
								{formatNumber(stats.tokenDetails.cacheReadInputTokens)}
							</Text>
						</Box>
					)}
					{stats.tokenDetails.cacheCreationInputTokens > 0 && (
						<Box marginLeft={2}>
							<Text>├─ Cache Creation: </Text>
							<Text color="cyan">
								{formatNumber(stats.tokenDetails.cacheCreationInputTokens)}
							</Text>
						</Box>
					)}
					<Box marginLeft={2}>
						<Text>└─ Output: </Text>
						<Text color="yellow">
							{formatNumber(stats.tokenDetails.outputTokens)}
						</Text>
					</Box>
					<Box marginTop={1}>
						<Text bold>Total Tokens: </Text>
						<Text color="green" bold>
							{formatNumber(stats.totalTokens)}
						</Text>
						<Text dimColor>
							{" "}
							({formatNumber(avgTokensPerRequest)} avg/request)
						</Text>
					</Box>
				</Box>
			) : (
				<Box marginBottom={1}>
					<Text>Total Tokens: </Text>
					<Text color="green" bold>
						{formatNumber(stats.totalTokens)}
					</Text>
				</Box>
			)}

			{/* Cost Information */}
			<Box marginBottom={1}>
				<Text bold>Total Cost: </Text>
				<Text color="green" bold>
					{formatCost(stats.totalCostUsd)}
				</Text>
				<Text dimColor> ({formatCost(avgCostPerRequest)} avg/request)</Text>
			</Box>

			{/* Account Usage */}
			{stats.accounts.length > 0 && (
				<>
					<Box marginTop={1} marginBottom={1}>
						<Text bold underline>
							Account Performance
						</Text>
					</Box>
					<Box flexDirection="column">
						{stats.accounts.map((account) => (
							<Box key={account.name}>
								<Text>{account.name}: </Text>
								<Text color="yellow">
									{formatNumber(account.requestCount)} requests
								</Text>
								<Text> (</Text>
								<Text
									color={
										account.successRate >= 95
											? "green"
											: account.successRate >= 80
												? "yellow"
												: "red"
									}
								>
									{formatPercentage(account.successRate)} success
								</Text>
								<Text>)</Text>
							</Box>
						))}
					</Box>
				</>
			)}

			{/* Charts Section - Toggle with 'c' */}
			{showCharts && (
				<>
					<Box marginTop={2} marginBottom={1}>
						<Text bold underline>
							Visual Analytics
						</Text>
					</Box>

					{/* Token Usage Pie Chart */}
					{stats.tokenDetails && (
						<Box marginBottom={2}>
							<PieChart
								title="Token Distribution"
								data={[
									{
										label: "Input",
										value: stats.tokenDetails.inputTokens,
										color: "yellow",
									},
									{
										label: "Cache",
										value:
											stats.tokenDetails.cacheReadInputTokens +
											stats.tokenDetails.cacheCreationInputTokens,
										color: "cyan",
									},
									{
										label: "Output",
										value: stats.tokenDetails.outputTokens,
										color: "green",
									},
								]}
								size="small"
								showLegend={true}
							/>
						</Box>
					)}

					{/* Account Performance Bar Chart */}
					{stats.accounts.length > 0 && (
						<Box marginBottom={2}>
							<BarChart
								title="Account Request Distribution"
								data={stats.accounts.map((account) => ({
									label: account.name,
									value: account.requestCount,
									color:
										account.successRate >= 95
											? "green"
											: account.successRate >= 80
												? "yellow"
												: "red",
								}))}
								width={30}
								showValues={true}
							/>
						</Box>
					)}

					{/* Success Rate Sparkline */}
					<Box marginBottom={2}>
						<Text bold>Performance Trend</Text>
						<Box marginTop={1}>
							<SparklineChart
								data={[85, 88, 90, 92, 91, 93, 95, stats.successRate]}
								label="Success %"
								color={
									stats.successRate >= 95
										? "green"
										: stats.successRate >= 80
											? "yellow"
											: "red"
								}
								showCurrent={true}
							/>
						</Box>
					</Box>
				</>
			)}

			{/* Recent Errors */}
			{stats.recentErrors.length > 0 && !showCharts && (
				<>
					<Box marginTop={1} marginBottom={1}>
						<Text bold underline color="red">
							Recent Errors
						</Text>
					</Box>
					<Box flexDirection="column">
						{stats.recentErrors.slice(0, 5).map((error, idx) => (
							<Box
								key={`error-${idx}-${error.substring(0, 10)}`}
								marginLeft={2}
							>
								<Text color="red" dimColor>
									• {error.length > 60 ? `${error.substring(0, 60)}...` : error}
								</Text>
							</Box>
						))}
					</Box>
				</>
			)}

			<Box marginTop={2}>
				<Text dimColor>
					[c] {showCharts ? "Hide" : "Show"} Charts • [r] Refresh • [q/ESC] Back
				</Text>
			</Box>
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/StrategyScreen.tsx">
import * as tuiCore from "@ccflare/tui-core";
import { Box, Text, useInput } from "ink";
import SelectInput from "ink-select-input";
import { useCallback, useEffect, useState } from "react";

interface StrategyScreenProps {
	onBack: () => void;
}

type Mode = "view" | "select";

export function StrategyScreen({ onBack }: StrategyScreenProps) {
	const [mode, setMode] = useState<Mode>("view");
	const [currentStrategy, setCurrentStrategy] = useState<string>("");
	const [strategies, setStrategies] = useState<string[]>([]);
	const [loading, setLoading] = useState(true);
	const [error, setError] = useState<string | null>(null);
	const [message, setMessage] = useState<string | null>(null);

	const loadData = useCallback(async () => {
		try {
			setLoading(true);
			setError(null);
			const [current, list] = await Promise.all([
				tuiCore.getStrategy(),
				tuiCore.listStrategies(),
			]);
			setCurrentStrategy(current);
			setStrategies(list);
		} catch (err) {
			setError(err instanceof Error ? err.message : "Failed to load data");
		} finally {
			setLoading(false);
		}
	}, []);

	useEffect(() => {
		loadData();
	}, [loadData]);

	useInput((input, key) => {
		if (key.escape || input === "q") {
			if (mode === "select") {
				setMode("view");
			} else {
				onBack();
			}
		} else if (key.return && mode === "view") {
			setMode("select");
			setMessage(null);
		}
	});

	const handleStrategySelect = useCallback(async (item: { value: string }) => {
		try {
			setError(null);
			await tuiCore.setStrategy(item.value);
			setCurrentStrategy(item.value);
			setMessage(`Strategy changed to: ${item.value}`);
			setMode("view");
		} catch (err) {
			setError(
				err instanceof Error ? err.message : "Failed to update strategy",
			);
		}
	}, []);

	if (loading) {
		return (
			<Box flexDirection="column">
				<Text>Loading strategies...</Text>
			</Box>
		);
	}

	if (mode === "select") {
		const items = strategies.map((strategy) => ({
			label: strategy === currentStrategy ? `${strategy} (current)` : strategy,
			value: strategy,
		}));

		return (
			<Box flexDirection="column">
				<Box marginBottom={1}>
					<Text bold>Select Load Balancer Strategy</Text>
				</Box>
				<SelectInput items={items} onSelect={handleStrategySelect} />
				<Box marginTop={1}>
					<Text dimColor>Press ESC to cancel</Text>
				</Box>
				{error && (
					<Box marginTop={1}>
						<Text color="red">Error: {error}</Text>
					</Box>
				)}
			</Box>
		);
	}

	return (
		<Box flexDirection="column">
			<Box marginBottom={1}>
				<Text bold>⚖️ Load Balancer Strategy</Text>
			</Box>

			{message && (
				<Box marginBottom={1}>
					<Text color="green">✓ {message}</Text>
				</Box>
			)}

			<Box marginBottom={1}>
				<Text>Current Strategy: </Text>
				<Text color="yellow" bold>
					{currentStrategy}
				</Text>
			</Box>

			<Box marginBottom={1}>
				<Text bold>Available Strategies:</Text>
			</Box>

			{strategies.map((strategy) => (
				<Box key={strategy} paddingLeft={2}>
					<Text color={strategy === currentStrategy ? "yellow" : undefined}>
						{strategy === currentStrategy ? "→ " : "  "}
						{strategy}
					</Text>
				</Box>
			))}

			<Box marginTop={1} flexDirection="column">
				<Text dimColor>Press ENTER to change strategy</Text>
				<Text dimColor>Press ESC or q to go back</Text>
			</Box>

			{error && (
				<Box marginTop={1}>
					<Text color="red">Error: {error}</Text>
				</Box>
			)}
		</Box>
	);
}
</file>

<file path="apps/tui/src/components/TokenUsageDisplay.tsx">
import type { RequestSummary } from "@ccflare/tui-core";
import { processTokenUsage } from "@ccflare/ui-common";
import { Box, Text } from "ink";

interface TokenUsageDisplayProps {
	summary: RequestSummary;
}

export function TokenUsageDisplay({ summary }: TokenUsageDisplayProps) {
	const usage = processTokenUsage(summary);

	if (!usage.hasData) {
		return (
			<Box flexDirection="column" marginTop={1}>
				<Text dimColor>No token usage data available</Text>
			</Box>
		);
	}

	const { sections } = usage;

	return (
		<Box flexDirection="column" marginTop={1}>
			<Text bold>Token Usage:</Text>
			<Box marginLeft={2} flexDirection="column">
				{sections.inputTokens && (
					<Box>
						<Text>{sections.inputTokens.label}: </Text>
						<Text color="yellow" bold>
							{sections.inputTokens.value}
						</Text>
					</Box>
				)}

				{sections.outputTokens && (
					<Box>
						<Text>{sections.outputTokens.label}: </Text>
						<Text color="yellow" bold>
							{sections.outputTokens.value}
						</Text>
					</Box>
				)}

				{sections.cacheReadTokens && (
					<Box>
						<Text>{sections.cacheReadTokens.label}: </Text>
						<Text color="cyan" bold>
							{sections.cacheReadTokens.value}
						</Text>
					</Box>
				)}

				{sections.cacheCreationTokens && (
					<Box>
						<Text>{sections.cacheCreationTokens.label}: </Text>
						<Text color="cyan" bold>
							{sections.cacheCreationTokens.value}
						</Text>
					</Box>
				)}

				<Box marginTop={1}>
					<Text>─────────────────────</Text>
				</Box>

				{sections.totalTokens && (
					<Box>
						<Text bold>{sections.totalTokens.label}: </Text>
						<Text color="green" bold>
							{sections.totalTokens.value}
						</Text>
					</Box>
				)}

				{sections.cost && (
					<Box>
						<Text bold>{sections.cost.label}: </Text>
						<Text color="green" bold>
							{sections.cost.value}
						</Text>
					</Box>
				)}
			</Box>
		</Box>
	);
}
</file>

<file path="apps/tui/src/types/open.d.ts">
declare module "open" {
	interface OpenOptions {
		wait?: boolean;
		background?: boolean;
		newInstance?: boolean;
		allowNonzeroExitCode?: boolean;
		app?: {
			name: string | readonly string[];
			arguments?: readonly string[];
		};
	}
	function open(target: string, options?: OpenOptions): Promise<void>;
	export default open;
}
</file>

<file path="apps/tui/src/App.tsx">
import { Box, Text, useApp } from "ink";
import SelectInput from "ink-select-input";
import { useState } from "react";
import { AccountsScreen } from "./components/AccountsScreen";
import { AnalyticsScreen } from "./components/AnalyticsScreen";
import { LogsScreen } from "./components/LogsScreen";
import { RequestsScreen } from "./components/RequestsScreen";
import { ServerScreen } from "./components/ServerScreen";
import { StatsScreen } from "./components/StatsScreen";
import { StrategyScreen } from "./components/StrategyScreen";

type Screen =
	| "home"
	| "server"
	| "accounts"
	| "stats"
	| "analytics"
	| "requests"
	| "logs"
	| "strategy";

export function App() {
	const [screen, setScreen] = useState<Screen>("home");
	const { exit } = useApp();

	const items = [
		{ label: "🚀 Server", value: "server" },
		{ label: "👥 Manage Accounts", value: "accounts" },
		{ label: "📊 View Statistics", value: "stats" },
		{ label: "📈 Analytics Dashboard", value: "analytics" },
		{ label: "📜 View Requests", value: "requests" },
		{ label: "📋 View Logs", value: "logs" },
		{ label: "⚖️  Load Balancer", value: "strategy" },
		{ label: "❌ Exit", value: "exit" },
	];

	const handleSelect = (item: { value: string }) => {
		if (item.value === "exit") {
			exit();
		} else {
			setScreen(item.value as Screen);
		}
	};

	const handleBack = () => {
		setScreen("home");
	};

	if (screen === "home") {
		return (
			<Box flexDirection="column" padding={1}>
				<Box marginBottom={1}>
					<Text color="cyan" bold>
						🎯 ccflare TUI
					</Text>
				</Box>
				<Text dimColor>Select an option:</Text>
				<Box marginTop={1}>
					<SelectInput items={items} onSelect={handleSelect} />
				</Box>
			</Box>
		);
	}

	return (
		<Box flexDirection="column" height="100%">
			{screen === "server" && <ServerScreen onBack={handleBack} />}
			{screen === "accounts" && <AccountsScreen onBack={handleBack} />}
			{screen === "stats" && <StatsScreen onBack={handleBack} />}
			{screen === "analytics" && <AnalyticsScreen onBack={handleBack} />}
			{screen === "requests" && <RequestsScreen onBack={handleBack} />}
			{screen === "logs" && <LogsScreen onBack={handleBack} />}
			{screen === "strategy" && <StrategyScreen onBack={handleBack} />}
		</Box>
	);
}
</file>

<file path="apps/tui/package.json">
{
	"name": "ccflare",
	"version": "1.0.0",
	"description": "TUI for ccflare load balancer",
	"bin": {
		"ccflare": "./dist/ccflare"
	},
	"type": "module",
	"scripts": {
		"dev": "bun run src/main.ts",
		"build": "bun build src/main.ts --compile --outfile dist/ccflare --target=bun",
		"prepublishOnly": "bun run build",
		"postpublish": "chmod +x dist/ccflare"
	},
	"dependencies": {
		"@ccflare/tui-core": "workspace:*",
		"@ccflare/ui-common": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/core-di": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/server": "workspace:*",
		"ink": "^6.0.0",
		"ink-select-input": "^6.0.0",
		"ink-spinner": "^5.0.0",
		"ink-text-input": "^6.0.0",
		"react": "^19.0.0"
	},
	"devDependencies": {
		"@types/react": "^19.0.0",
		"@types/node": "^20.0.0",
		"react-devtools-core": "^5.0.0"
	},
	"files": [
		"dist"
	],
	"keywords": [
		"ccflare",
		"load-balancer",
		"tui",
		"cli"
	],
	"publishConfig": {
		"access": "public"
	}
}
</file>

<file path="apps/tui/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"jsx": "react-jsx",
		"module": "ESNext",
		"target": "ESNext",
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"types": ["react", "node"]
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}
</file>

<file path="packages/agents/src/index.ts">
export type { Agent, AgentSource, AgentWorkspace } from "@ccflare/types";
export { AgentRegistry, agentRegistry } from "./discovery";
export { getAgentsDirectory } from "./paths";
export { workspacePersistence } from "./workspace-persistence";
</file>

<file path="packages/agents/src/paths.ts">
import { homedir } from "node:os";
import { join } from "node:path";

export function getAgentsDirectory(): string {
	return join(homedir(), ".claude", "agents");
}
</file>

<file path="packages/agents/src/workspace-persistence.ts">
import { existsSync } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import { homedir } from "node:os";
import { join } from "node:path";
import { Logger } from "@ccflare/logger";
import type { AgentWorkspace } from "@ccflare/types";

const log = new Logger("WorkspacePersistence");

const WORKSPACES_FILE = join(homedir(), ".ccflare", "workspaces.json");

interface WorkspacesData {
	version: number;
	workspaces: AgentWorkspace[];
}

export class WorkspacePersistence {
	async loadWorkspaces(): Promise<AgentWorkspace[]> {
		try {
			if (!existsSync(WORKSPACES_FILE)) {
				log.debug("No workspaces file found");
				return [];
			}

			const content = await readFile(WORKSPACES_FILE, "utf-8");
			const data: WorkspacesData = JSON.parse(content);

			if (data.version !== 1) {
				log.warn(`Unknown workspaces file version: ${data.version}`);
				return [];
			}

			log.info(`Loaded ${data.workspaces.length} workspaces from disk`);
			return data.workspaces;
		} catch (error) {
			log.error("Failed to load workspaces:", error);
			return [];
		}
	}

	async saveWorkspaces(workspaces: AgentWorkspace[]): Promise<void> {
		try {
			const data: WorkspacesData = {
				version: 1,
				workspaces,
			};

			const content = JSON.stringify(data, null, 2);

			// Ensure directory exists
			const dir = join(homedir(), ".ccflare");
			if (!existsSync(dir)) {
				const { mkdir } = await import("node:fs/promises");
				await mkdir(dir, { recursive: true });
			}

			await writeFile(WORKSPACES_FILE, content, "utf-8");
			log.info(`Saved ${workspaces.length} workspaces to disk`);
		} catch (error) {
			log.error("Failed to save workspaces:", error);
		}
	}
}

export const workspacePersistence = new WorkspacePersistence();
</file>

<file path="packages/agents/package.json">
{
	"name": "@ccflare/agents",
	"version": "1.0.0",
	"description": "Agent discovery and management for ccflare",
	"main": "dist/index.js",
	"types": "dist/index.d.ts",
	"scripts": {
		"build": "tsc",
		"dev": "tsc --watch",
		"clean": "rm -rf dist",
		"lint": "biome check --write",
		"format": "biome format --write",
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/config": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/types": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^22.5.4",
		"typescript": "^5.7.2"
	}
}
</file>

<file path="packages/agents/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"outDir": "./dist",
		"rootDir": "./src"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}
</file>

<file path="packages/cli-commands/src/commands/analyze.ts">
import type { Database } from "bun:sqlite";
import { TIME_CONSTANTS } from "@ccflare/core";
import { analyzeIndexUsage } from "@ccflare/database";

/**
 * Analyze query performance and index usage
 */
export function analyzePerformance(db: Database): void {
	console.log("\n=== Database Performance Analysis ===\n");

	// Basic index usage analysis
	analyzeIndexUsage(db);

	// Show detailed query performance for common patterns
	console.log("\n=== Query Performance Metrics ===\n");

	const performanceQueries = [
		{
			name: "Recent requests (last 24h)",
			query: `
				SELECT COUNT(*) as count 
				FROM requests 
				WHERE timestamp > ?
			`,
			params: [Date.now() - TIME_CONSTANTS.DAY],
		},
		{
			name: "Active accounts",
			query: `
				SELECT COUNT(*) as count 
				FROM accounts 
				WHERE paused = 0
			`,
			params: [],
		},
		{
			name: "Model usage distribution",
			query: `
				SELECT model, COUNT(*) as count 
				FROM requests 
				WHERE model IS NOT NULL AND timestamp > ? 
				GROUP BY model 
				ORDER BY count DESC 
				LIMIT 5
			`,
			params: [Date.now() - TIME_CONSTANTS.DAY],
		},
	];

	for (const test of performanceQueries) {
		try {
			const start = performance.now();
			const stmt = db.prepare(test.query);
			const result = stmt.all(...test.params);
			const duration = performance.now() - start;

			console.log(`${test.name}:`);
			console.log(`  Time: ${duration.toFixed(2)}ms`);
			console.log(`  Results: ${JSON.stringify(result)}\n`);
		} catch (error) {
			console.error(`${test.name}: Error - ${error}`);
		}
	}

	// Check if statistics need updating
	console.log("=== Index Optimization Status ===\n");

	// Get last ANALYZE time
	const lastAnalyze = db
		.prepare(`
		SELECT * FROM sqlite_stat1 LIMIT 1
	`)
		.get();

	if (!lastAnalyze) {
		console.log("⚠️  No index statistics found. Running ANALYZE...");
		db.exec("ANALYZE");
		console.log("✓ Index statistics updated");
	} else {
		console.log("✓ Index statistics are available");
	}

	// Show index coverage
	const indexedColumns = db
		.prepare(`
		SELECT 
			m.tbl_name as table_name,
			COUNT(DISTINCT m.name) as index_count
		FROM sqlite_master m
		WHERE m.type = 'index' 
			AND m.name NOT LIKE 'sqlite_%'
			AND m.sql IS NOT NULL
		GROUP BY m.tbl_name
	`)
		.all() as Array<{ table_name: string; index_count: number }>;

	console.log("\n=== Index Coverage ===\n");
	for (const table of indexedColumns) {
		console.log(`${table.table_name}: ${table.index_count} indexes`);
	}

	console.log("\n✓ Analysis complete");
}
</file>

<file path="packages/cli-commands/src/commands/stats.ts">
import type { Database } from "bun:sqlite";

/**
 * Reset all account statistics
 */
export function resetAllStats(db: Database): void {
	db.run(
		"UPDATE accounts SET request_count = 0, session_start = NULL, session_request_count = 0",
	);
}

/**
 * Clear all request history
 */
export function clearRequestHistory(db: Database): { count: number } {
	const result = db.run("DELETE FROM requests");
	return { count: result.changes };
}
</file>

<file path="packages/cli-commands/src/prompts/adapter.ts">
/**
 * Prompt adapter interface for abstracting user input collection
 */
export interface PromptAdapter {
	/**
	 * Present a selection menu to the user
	 * @param question The question to ask
	 * @param options Array of options with label and value
	 * @returns Promise resolving to the selected value
	 */
	select<T extends string | number>(
		question: string,
		options: Array<{ label: string; value: T }>,
	): Promise<T>;

	/**
	 * Get text input from the user
	 * @param question The question to ask
	 * @param mask Whether to mask the input (for passwords)
	 * @returns Promise resolving to the entered text
	 */
	input(question: string, mask?: boolean): Promise<string>;

	/**
	 * Get a yes/no confirmation from the user
	 * @param question The question to ask
	 * @returns Promise resolving to true if confirmed, false otherwise
	 */
	confirm(question: string): Promise<boolean>;
}
</file>

<file path="packages/cli-commands/src/prompts/index.ts">
import { stdPromptAdapter } from "./std-adapter";

// Re-export adapter types
export type { PromptAdapter } from "./adapter";
export { StdPromptAdapter, stdPromptAdapter } from "./std-adapter";

/**
 * Prompt user to select account mode
 */
export async function promptAccountMode(): Promise<"max" | "console"> {
	return stdPromptAdapter.select(
		"What type of account would you like to add?",
		[
			{ label: "Claude Max account", value: "max" },
			{ label: "Claude Console account", value: "console" },
		],
	);
}

/**
 * Prompt user to select account tier
 */
export async function promptAccountTier(): Promise<1 | 5 | 20> {
	return stdPromptAdapter.select(
		"Select the tier for this account (used for weighted load balancing):",
		[
			{ label: "1x tier (default free account)", value: 1 },
			{ label: "5x tier (paid account)", value: 5 },
			{ label: "20x tier (enterprise account)", value: 20 },
		],
	);
}

/**
 * Prompt user to enter authorization code
 */
export async function promptAuthorizationCode(): Promise<string> {
	return stdPromptAdapter.input("\nEnter the authorization code: ");
}

/**
 * Prompt user to confirm account removal
 */
export async function promptAccountRemovalConfirmation(
	accountName: string,
): Promise<boolean> {
	console.log(
		`\n⚠️  WARNING: You are about to remove the account '${accountName}'`,
	);
	console.log("This action cannot be undone.");
	console.log("\nTo confirm, please type the account name exactly:");

	const confirmation = prompt(`Type '${accountName}' to confirm deletion: `);

	if (!confirmation) {
		return false;
	}

	return confirmation === accountName;
}
</file>

<file path="packages/cli-commands/src/prompts/std-adapter.ts">
import type { PromptAdapter } from "./adapter";

/**
 * Standard prompt adapter using blocking prompt() calls
 */
export class StdPromptAdapter implements PromptAdapter {
	async select<T extends string | number>(
		question: string,
		options: Array<{ label: string; value: T }>,
	): Promise<T> {
		console.log(question);
		options.forEach((option, index) => {
			console.log(`${index + 1}) ${option.label}`);
		});

		const choice = prompt(`Enter your choice (${1}-${options.length}): `);
		const index = parseInt(choice || "", 10) - 1;

		if (index < 0 || index >= options.length || Number.isNaN(index)) {
			throw new Error(
				`Invalid choice. Please enter a number between 1 and ${options.length}.`,
			);
		}

		return options[index].value;
	}

	async input(question: string, _mask?: boolean): Promise<string> {
		// Note: Bun's prompt() doesn't support masking, so we ignore the mask parameter
		const answer = prompt(question);
		if (!answer) {
			throw new Error("Input is required");
		}
		return answer;
	}

	async confirm(question: string): Promise<boolean> {
		const answer = prompt(`${question} (y/n): `);
		return answer?.toLowerCase().startsWith("y") || false;
	}
}

// Export singleton instance
export const stdPromptAdapter = new StdPromptAdapter();
</file>

<file path="packages/cli-commands/src/index.ts">
// Export all commands
export * from "./commands/account";
export * from "./commands/analyze";
export * from "./commands/help";
export * from "./commands/stats";

// Export prompts
export * from "./prompts/index";
// Export main CLI runner
export { runCli } from "./runner";
// Export utilities
export * from "./utils/browser";
</file>

<file path="packages/cli-commands/src/runner.ts">
import { parseArgs } from "node:util";
import { Config } from "@ccflare/config";
import { shutdown } from "@ccflare/core";
import { container, SERVICE_KEYS } from "@ccflare/core-di";
import { DatabaseFactory } from "@ccflare/database";
import {
	addAccount,
	getAccountsList,
	pauseAccount,
	removeAccountWithConfirmation,
	resumeAccount,
} from "./commands/account";
import { analyzePerformance } from "./commands/analyze";
import { getHelpText } from "./commands/help";
import { clearRequestHistory, resetAllStats } from "./commands/stats";

/**
 * Main CLI runner
 */
export async function runCli(argv: string[]): Promise<void> {
	// Initialize DI container and services
	container.registerInstance(SERVICE_KEYS.Config, new Config());
	const config = container.resolve<Config>(SERVICE_KEYS.Config);
	DatabaseFactory.initialize();
	const dbOps = DatabaseFactory.getInstance();
	container.registerInstance(SERVICE_KEYS.Database, dbOps);

	try {
		// Parse command line arguments
		const { positionals, values } = parseArgs({
			args: argv.slice(2),
			strict: false,
			options: {
				mode: { type: "string" },
				tier: { type: "string" },
				force: { type: "boolean" },
			},
		});

		const command = positionals[0];

		switch (command) {
			case "add": {
				const name = positionals[1];
				if (!name) {
					console.error("Error: Account name is required");
					console.log(
						"Usage: ccflare-cli add <name> [--mode <max|console>] [--tier <1|5|20>]",
					);
					process.exit(1);
				}

				// Parse options
				const mode = values.mode as "max" | "console" | undefined;
				const tierValue = values.tier
					? parseInt(values.tier as string)
					: undefined;
				const tier =
					tierValue === 1 || tierValue === 5 || tierValue === 20
						? tierValue
						: undefined;

				await addAccount(dbOps, config, { name, mode, tier });
				break;
			}

			case "list": {
				const accounts = getAccountsList(dbOps);

				if (accounts.length === 0) {
					console.log("No accounts found");
				} else {
					console.log(`\nAccounts (${accounts.length}):`);
					console.log("─".repeat(100));

					// Header
					console.log(
						"Name".padEnd(20) +
							"Type".padEnd(10) +
							"Tier".padEnd(6) +
							"Requests".padEnd(12) +
							"Token".padEnd(10) +
							"Status".padEnd(20) +
							"Session",
					);
					console.log("─".repeat(100));

					// Rows
					for (const account of accounts) {
						console.log(
							account.name.padEnd(20) +
								account.provider.padEnd(10) +
								account.tierDisplay.padEnd(6) +
								`${account.requestCount}/${account.totalRequests}`.padEnd(12) +
								account.tokenStatus.padEnd(10) +
								account.rateLimitStatus.padEnd(20) +
								account.sessionInfo,
						);
					}
				}
				break;
			}

			case "remove": {
				const name = positionals[1];
				if (!name) {
					console.error("Error: Account name is required");
					console.log("Usage: ccflare-cli remove <name> [--force]");
					process.exit(1);
				}

				const result = await removeAccountWithConfirmation(
					dbOps,
					name,
					values.force === true,
				);
				console.log(result.message);
				if (!result.success) {
					process.exit(1);
				}
				break;
			}

			case "reset-stats": {
				const db = dbOps.getDatabase();
				resetAllStats(db);
				console.log("Account statistics reset successfully");
				break;
			}

			case "clear-history": {
				const db = dbOps.getDatabase();
				const result = clearRequestHistory(db);
				console.log(`Cleared ${result.count} request records`);
				break;
			}

			case "pause": {
				const name = positionals[1];
				if (!name) {
					console.error("Error: Account name is required");
					console.log("Usage: ccflare-cli pause <name>");
					process.exit(1);
				}

				const result = pauseAccount(dbOps, name);
				console.log(result.message);
				if (!result.success) {
					process.exit(1);
				}
				break;
			}

			case "resume": {
				const name = positionals[1];
				if (!name) {
					console.error("Error: Account name is required");
					console.log("Usage: ccflare-cli resume <name>");
					process.exit(1);
				}

				const result = resumeAccount(dbOps, name);
				console.log(result.message);
				if (!result.success) {
					process.exit(1);
				}
				break;
			}

			case "analyze": {
				const db = dbOps.getDatabase();
				analyzePerformance(db);
				break;
			}

			default: {
				console.log(getHelpText());
				if (command && command !== "help") {
					console.error(`\nError: Unknown command '${command}'`);
					process.exit(1);
				}
				break;
			}
		}
	} catch (error) {
		console.error(`Error: ${error instanceof Error ? error.message : error}`);
		process.exit(1);
	} finally {
		// Always shutdown resources
		await shutdown();
	}
}
</file>

<file path="packages/cli-commands/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/config/src/paths-common.ts">
import { homedir } from "node:os";
import { join } from "node:path";
import { platform } from "node:process";

/**
 * Get the platform-specific configuration directory for ccflare
 */
export function getPlatformConfigDir(): string {
	if (platform === "win32") {
		// Windows: Use LOCALAPPDATA or APPDATA
		const baseDir =
			process.env.LOCALAPPDATA ??
			process.env.APPDATA ??
			join(homedir(), "AppData", "Local");
		return join(baseDir, "ccflare");
	} else {
		// Linux/macOS: Follow XDG Base Directory specification
		const xdgConfig = process.env.XDG_CONFIG_HOME;
		const baseDir = xdgConfig ?? join(homedir(), ".config");
		return join(baseDir, "ccflare");
	}
}
</file>

<file path="packages/config/src/paths.ts">
import { join } from "node:path";
import { getPlatformConfigDir } from "./paths-common";

export function resolveConfigPath(): string {
	// Check for explicit config path from environment
	const explicitPath = process.env.ccflare_CONFIG_PATH;
	if (explicitPath) {
		return explicitPath;
	}

	// Use common platform config directory
	const configDir = getPlatformConfigDir();
	return join(configDir, "ccflare.json");
}
</file>

<file path="packages/config/package.json">
{
	"name": "@ccflare/config",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/logger": "workspace:*"
	}
}
</file>

<file path="packages/config/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/core/src/constants.ts">
/**
 * Centralized constants for the ccflare application
 * All magic numbers should be defined here to improve maintainability
 */

// Time constants (all in milliseconds)
export const TIME_CONSTANTS = {
	// Base units
	SECOND: 1000,
	MINUTE: 60 * 1000,
	HOUR: 60 * 60 * 1000,
	DAY: 24 * 60 * 60 * 1000,

	// Session durations
	SESSION_DURATION_DEFAULT: 5 * 60 * 60 * 1000, // 5 hours
	SESSION_DURATION_FALLBACK: 3600000, // 1 hour

	// Timeouts
	STREAM_TIMEOUT_DEFAULT: 1000 * 60 * 1, // 1 minute
	OAUTH_STATE_TTL: 10, // 10 minutes (stored separately as minutes)
	RETRY_DELAY_DEFAULT: 1000, // 1 second

	// Cache durations
	CACHE_YEAR: 31536000, // 365 days in seconds for HTTP cache headers
} as const;

// Buffer sizes (in bytes unless specified)
export const BUFFER_SIZES = {
	// Stream usage buffer size in KB (multiplied by 1024 to get bytes)
	STREAM_USAGE_BUFFER_KB: 64,
	STREAM_USAGE_BUFFER_BYTES: 64 * 1024,

	// Stream body max size
	STREAM_BODY_MAX_KB: 256,
	STREAM_BODY_MAX_BYTES: 256 * 1024, // 256KB default

	// Anthropic provider stream cap
	ANTHROPIC_STREAM_CAP_BYTES: 32768, // 32KB

	// Stream tee default max bytes
	STREAM_TEE_MAX_BYTES: 1024 * 1024, // 1MB

	// Log file size
	LOG_FILE_MAX_SIZE: 10 * 1024 * 1024, // 10MB
} as const;

// Network constants
export const NETWORK = {
	// Ports
	DEFAULT_PORT: 8080,

	// Timeouts
	IDLE_TIMEOUT_MAX: 255, // Max allowed by Bun
} as const;

// Cache control headers
export const CACHE = {
	// HTTP cache control max-age values (in seconds)
	STATIC_ASSETS_MAX_AGE: 31536000, // 1 year
	CACHE_CONTROL_IMMUTABLE: "public, max-age=31536000, immutable",
	CACHE_CONTROL_STATIC: "public, max-age=31536000",
	CACHE_CONTROL_NO_CACHE: "no-cache, no-store, must-revalidate",
} as const;

// Request/Response limits
export const LIMITS = {
	// Request history limits
	REQUEST_HISTORY_DEFAULT: 50,
	REQUEST_DETAILS_DEFAULT: 100,
	REQUEST_HISTORY_MAX: 1000,
	LOG_READ_DEFAULT: 1000,

	// Account name constraints
	ACCOUNT_NAME_MIN_LENGTH: 1,
	ACCOUNT_NAME_MAX_LENGTH: 100,

	// UI formatting
	CONSOLE_SEPARATOR_LENGTH: 100,
	CONSOLE_COLUMN_PADDING: {
		NAME: 20,
		TYPE: 10,
		TIER: 6,
		REQUESTS: 12,
		TOKEN: 10,
		STATUS: 20,
	},
} as const;

// HTTP status codes
export const HTTP_STATUS = {
	OK: 200,
	NOT_FOUND: 404,
	TOO_MANY_REQUESTS: 429,
	INTERNAL_SERVER_ERROR: 500,
	SERVICE_UNAVAILABLE: 503,
} as const;

// Account tiers - removed unused ACCOUNT_TIERS export
// Statistical calculations - removed unused STATS export
</file>

<file path="packages/core/src/errors.ts">
/**
 * Custom error classes for standardized error handling across the application
 */

/**
 * Base error class for all application errors
 */
export abstract class AppError extends Error {
	public readonly timestamp: Date;
	public readonly context?: Record<string, unknown>;

	constructor(
		message: string,
		public readonly code: string,
		public readonly statusCode: number,
		context?: Record<string, unknown>,
	) {
		super(message);
		this.name = this.constructor.name;
		this.timestamp = new Date();
		this.context = context;
		Error.captureStackTrace(this, this.constructor);
	}

	toJSON() {
		return {
			name: this.name,
			message: this.message,
			code: this.code,
			statusCode: this.statusCode,
			timestamp: this.timestamp,
			context: this.context,
		};
	}
}

/**
 * Authentication and authorization errors
 */
export class AuthError extends AppError {
	constructor(message: string, context?: Record<string, unknown>) {
		super(message, "AUTH_ERROR", 401, context);
	}
}

export class TokenRefreshError extends AuthError {
	constructor(accountId: string, originalError?: Error) {
		super("Failed to refresh access token", {
			accountId,
			originalError: originalError?.message,
		});
	}
}

/**
 * Rate limiting errors
 */
export class RateLimitError extends AppError {
	constructor(
		public readonly accountId: string,
		public readonly resetTime: number,
		public readonly remaining?: number,
	) {
		super("Rate limit exceeded", "RATE_LIMIT_ERROR", 429, {
			accountId,
			resetTime,
			remaining,
		});
	}
}

/**
 * Validation errors
 */
export class ValidationError extends AppError {
	constructor(
		message: string,
		public readonly field?: string,
		public readonly value?: unknown,
	) {
		super(message, "VALIDATION_ERROR", 400, { field, value });
	}
}

/**
 * Provider errors
 */
export class ProviderError extends AppError {
	constructor(
		message: string,
		public readonly provider: string,
		statusCode = 502,
		context?: Record<string, unknown>,
	) {
		super(message, "PROVIDER_ERROR", statusCode, { provider, ...context });
	}
}

export class OAuthError extends ProviderError {
	constructor(
		message: string,
		provider: string,
		public readonly oauthCode?: string,
	) {
		super(message, provider, 400, { oauthCode });
	}
}

/**
 * Service unavailable errors
 */
export class ServiceUnavailableError extends AppError {
	constructor(
		message: string,
		public readonly service?: string,
	) {
		super(message, "SERVICE_UNAVAILABLE", 503, { service });
	}
}

/**
 * Type guards
 */
export function isAppError(error: unknown): error is AppError {
	return error instanceof AppError;
}

/**
 * Error logger that sanitizes sensitive data
 */
export function logError(
	error: unknown,
	logger: { error: (msg: string, ...args: unknown[]) => void },
): void {
	if (isAppError(error)) {
		// Sanitize sensitive context data
		const sanitizedContext = error.context
			? sanitizeErrorContext(error.context)
			: undefined;
		logger.error(`${error.name}: ${error.message}`, {
			code: error.code,
			statusCode: error.statusCode,
			context: sanitizedContext,
		});
	} else if (error instanceof Error) {
		logger.error(`Error: ${error.message}`, {
			name: error.name,
			stack: error.stack,
		});
	} else {
		logger.error("Unknown error", error);
	}
}

/**
 * Sanitize error context to remove sensitive data
 */
function sanitizeErrorContext(
	context: Record<string, unknown>,
): Record<string, unknown> {
	const sanitized: Record<string, unknown> = {};
	const sensitiveKeys = ["token", "password", "secret", "key", "authorization"];

	for (const [key, value] of Object.entries(context)) {
		const lowerKey = key.toLowerCase();
		if (sensitiveKeys.some((sensitive) => lowerKey.includes(sensitive))) {
			sanitized[key] = "[REDACTED]";
		} else if (typeof value === "object" && value !== null) {
			sanitized[key] = sanitizeErrorContext(value as Record<string, unknown>);
		} else {
			sanitized[key] = value;
		}
	}

	return sanitized;
}
</file>

<file path="packages/core/src/lifecycle.ts">
export interface Disposable {
	dispose(): Promise<void> | void;
}

class LifecycleManager {
	private disposables: Set<Disposable> = new Set();
	private isShuttingDown = false;

	register(disposable: Disposable): void {
		this.disposables.add(disposable);
	}

	unregister(disposable: Disposable): void {
		this.disposables.delete(disposable);
	}

	async shutdown(): Promise<void> {
		if (this.isShuttingDown) {
			return;
		}

		this.isShuttingDown = true;
		const errors: Error[] = [];

		// Dispose in reverse order of registration
		const disposableArray = Array.from(this.disposables).reverse();

		for (const disposable of disposableArray) {
			try {
				await disposable.dispose();
			} catch (error) {
				errors.push(
					error instanceof Error
						? error
						: new Error(`Disposal error: ${String(error)}`),
				);
			}
		}

		this.disposables.clear();
		this.isShuttingDown = false;

		if (errors.length > 0) {
			throw new AggregateError(errors, "Errors occurred during shutdown");
		}
	}

	clear(): void {
		this.disposables.clear();
		this.isShuttingDown = false;
	}
}

// Global lifecycle manager instance
const lifecycleManager = new LifecycleManager();

export function registerDisposable(disposable: Disposable): void {
	lifecycleManager.register(disposable);
}

export function unregisterDisposable(disposable: Disposable): void {
	lifecycleManager.unregister(disposable);
}

export async function shutdown(): Promise<void> {
	await lifecycleManager.shutdown();
}

export function clearDisposables(): void {
	lifecycleManager.clear();
}
</file>

<file path="packages/core/src/strategy.ts">
import { type Account, StrategyName } from "@ccflare/types";

// Array of all strategies for backwards compatibility
export const STRATEGIES = Object.values(StrategyName);

export function isValidStrategy(strategy: string): strategy is StrategyName {
	return Object.values(StrategyName).includes(strategy as StrategyName);
}

// Default load balancing strategy
export const DEFAULT_STRATEGY = StrategyName.Session;

// Helper to check if an account is available (not rate-limited or paused)
export function isAccountAvailable(
	account: Account,
	now = Date.now(),
): boolean {
	return (
		!account.paused &&
		(!account.rate_limited_until || account.rate_limited_until < now)
	);
}

// Re-export from types package for backwards compatibility
export { StrategyName } from "@ccflare/types";
</file>

<file path="packages/core/package.json">
{
	"name": "@ccflare/core",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/types": "workspace:*"
	}
}
</file>

<file path="packages/core/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/core-di/src/container.ts">
type ServiceFactory<T> = () => T;
type ServiceKey = string | symbol;

class Container {
	private services = new Map<ServiceKey, unknown>();
	private factories = new Map<ServiceKey, ServiceFactory<unknown>>();

	register<T>(key: ServiceKey, factory: ServiceFactory<T>): void {
		this.factories.set(key, factory);
	}

	registerInstance<T>(key: ServiceKey, instance: T): void {
		this.services.set(key, instance);
	}

	resolve<T>(key: ServiceKey): T {
		// Check if instance already exists
		if (this.services.has(key)) {
			return this.services.get(key) as T;
		}

		// Check if factory exists
		const factory = this.factories.get(key);
		if (!factory) {
			throw new Error(`Service '${String(key)}' not registered`);
		}

		// Create instance and cache it (singleton)
		const instance = factory();
		this.services.set(key, instance);
		return instance as T;
	}

	has(key: ServiceKey): boolean {
		return this.factories.has(key) || this.services.has(key);
	}

	clear(): void {
		this.services.clear();
		this.factories.clear();
	}
}

// Global container instance
export const container = new Container();
</file>

<file path="packages/core-di/src/index.ts">
import { container as _container } from "./container";

export const container = _container;

// Service keys - using symbols for better encapsulation
export const SERVICE_KEYS = {
	Logger: Symbol("Logger"),
	Config: Symbol("Config"),
	Database: Symbol("Database"),
	PricingLogger: Symbol("PricingLogger"),
	AsyncWriter: Symbol("AsyncWriter"),
} as const;

// Type-safe service resolution helper
export function getService<T>(key: keyof typeof SERVICE_KEYS): T {
	return container.resolve<T>(SERVICE_KEYS[key]);
}
</file>

<file path="packages/core-di/package.json">
{
	"name": "@ccflare/core-di",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	}
}
</file>

<file path="packages/core-di/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/dashboard-web/src/components/accounts/DeleteConfirmationDialog.tsx">
import { AlertCircle } from "lucide-react";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Input } from "../ui/input";
import { Label } from "../ui/label";

interface DeleteConfirmationDialogProps {
	accountName: string;
	confirmInput: string;
	onConfirmInputChange: (value: string) => void;
	onConfirm: () => void;
	onCancel: () => void;
}

export function DeleteConfirmationDialog({
	accountName,
	confirmInput,
	onConfirmInputChange,
	onConfirm,
	onCancel,
}: DeleteConfirmationDialogProps) {
	return (
		<div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
			<Card className="w-full max-w-md">
				<CardHeader>
					<CardTitle>Confirm Account Removal</CardTitle>
					<CardDescription>This action cannot be undone.</CardDescription>
				</CardHeader>
				<CardContent className="space-y-4">
					<div className="p-4 bg-destructive/10 border border-destructive/20 rounded-lg">
						<div className="flex items-center gap-2 text-destructive">
							<AlertCircle className="h-5 w-5" />
							<p className="font-medium">Warning</p>
						</div>
						<p className="text-sm mt-2">
							You are about to permanently remove the account '{accountName}'.
							This will delete all associated data and cannot be recovered.
						</p>
					</div>
					<div className="space-y-2">
						<Label htmlFor="confirm-input">
							Type{" "}
							<span className="font-mono font-semibold">{accountName}</span> to
							confirm:
						</Label>
						<Input
							id="confirm-input"
							value={confirmInput}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
								onConfirmInputChange((e.target as HTMLInputElement).value)
							}
							placeholder="Enter account name"
							autoComplete="off"
						/>
					</div>
					<div className="flex gap-2">
						<Button
							variant="destructive"
							onClick={onConfirm}
							disabled={confirmInput !== accountName}
						>
							Delete Account
						</Button>
						<Button variant="outline" onClick={onCancel}>
							Cancel
						</Button>
					</div>
				</CardContent>
			</Card>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/agents/WorkspaceCard.tsx">
import type { AgentWorkspace } from "@ccflare/types";
import { formatDistanceToNow } from "date-fns";
import { Folder, FolderOpen, Package } from "lucide-react";
import { Badge } from "../ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";

interface WorkspaceCardProps {
	workspace: AgentWorkspace & { agentCount?: number };
	isActive?: boolean;
}

export function WorkspaceCard({ workspace, isActive }: WorkspaceCardProps) {
	const Icon = isActive ? FolderOpen : Folder;

	return (
		<Card
			className={`transition-all ${isActive ? "ring-2 ring-primary shadow-lg" : "hover:shadow-md"}`}
		>
			<CardHeader>
				<div className="flex items-start justify-between">
					<div className="flex items-center gap-3">
						<div
							className={`p-2 rounded-lg ${isActive ? "bg-primary/10" : "bg-muted"}`}
						>
							<Icon
								className={`h-5 w-5 ${isActive ? "text-primary" : "text-muted-foreground"}`}
							/>
						</div>
						<div>
							<CardTitle className="text-lg font-semibold">
								{workspace.name}
							</CardTitle>
							<CardDescription className="text-xs mt-1">
								{workspace.path}
							</CardDescription>
						</div>
					</div>
					{workspace.agentCount !== undefined && workspace.agentCount > 0 && (
						<Badge variant="secondary" className="gap-1">
							<Package className="h-3 w-3" />
							{workspace.agentCount}
						</Badge>
					)}
				</div>
			</CardHeader>
			<CardContent>
				<p className="text-sm text-muted-foreground">
					Last seen{" "}
					{formatDistanceToNow(new Date(workspace.lastSeen), {
						addSuffix: true,
					})}
				</p>
			</CardContent>
		</Card>
	);
}
</file>

<file path="packages/dashboard-web/src/components/analytics/AnalyticsControls.tsx">
import { CalendarDays, RefreshCw } from "lucide-react";
import type { TimeRange } from "../../constants";
import { Button } from "../ui/button";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { AnalyticsFilters, type FilterState } from "./AnalyticsFilters";

interface AnalyticsControlsProps {
	timeRange: TimeRange;
	setTimeRange: (range: TimeRange) => void;
	viewMode: "normal" | "cumulative";
	setViewMode: (mode: "normal" | "cumulative") => void;
	filters: FilterState;
	setFilters: (filters: FilterState) => void;
	availableAccounts: string[];
	availableModels: string[];
	activeFilterCount: number;
	filterOpen: boolean;
	setFilterOpen: (open: boolean) => void;
	loading: boolean;
	onRefresh: () => void;
}

export function AnalyticsControls({
	timeRange,
	setTimeRange,
	viewMode,
	setViewMode,
	filters,
	setFilters,
	availableAccounts,
	availableModels,
	activeFilterCount,
	filterOpen,
	setFilterOpen,
	loading,
	onRefresh,
}: AnalyticsControlsProps) {
	return (
		<div className="flex flex-col sm:flex-row gap-4 justify-between">
			<div className="flex flex-wrap gap-2">
				<Select
					value={timeRange}
					onValueChange={(v) => setTimeRange(v as TimeRange)}
				>
					<SelectTrigger className="w-32">
						<CalendarDays className="h-4 w-4 mr-2" />
						<SelectValue />
					</SelectTrigger>
					<SelectContent>
						<SelectItem value="1h">Last Hour</SelectItem>
						<SelectItem value="6h">Last 6 Hours</SelectItem>
						<SelectItem value="24h">Last 24 Hours</SelectItem>
						<SelectItem value="7d">Last 7 Days</SelectItem>
						<SelectItem value="30d">Last 30 Days</SelectItem>
					</SelectContent>
				</Select>

				<AnalyticsFilters
					filters={filters}
					setFilters={setFilters}
					availableAccounts={availableAccounts}
					availableModels={availableModels}
					activeFilterCount={activeFilterCount}
					filterOpen={filterOpen}
					setFilterOpen={setFilterOpen}
				/>
			</div>

			<div className="flex gap-2">
				<div className="flex gap-1 bg-muted rounded-md p-1">
					<Button
						variant={viewMode === "normal" ? "default" : "ghost"}
						size="sm"
						className="h-8 px-3"
						onClick={() => setViewMode("normal")}
					>
						Normal
					</Button>
					<Button
						variant={viewMode === "cumulative" ? "default" : "ghost"}
						size="sm"
						className="h-8 px-3"
						onClick={() => setViewMode("cumulative")}
					>
						Cumulative
					</Button>
				</div>
				<Button
					variant="outline"
					size="sm"
					onClick={onRefresh}
					disabled={loading}
				>
					<RefreshCw
						className={`h-4 w-4 mr-2 ${loading ? "animate-spin" : ""}`}
					/>
					Refresh
				</Button>
			</div>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/analytics/AnalyticsFilters.tsx">
import { Filter } from "lucide-react";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import { Label } from "../ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "../ui/popover";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Separator } from "../ui/separator";

export interface FilterState {
	accounts: string[];
	models: string[];
	status: "all" | "success" | "error";
}

interface AnalyticsFiltersProps {
	filters: FilterState;
	setFilters: (filters: FilterState) => void;
	availableAccounts: string[];
	availableModels: string[];
	activeFilterCount: number;
	filterOpen: boolean;
	setFilterOpen: (open: boolean) => void;
}

export function AnalyticsFilters({
	filters,
	setFilters,
	availableAccounts,
	availableModels,
	activeFilterCount,
	filterOpen,
	setFilterOpen,
}: AnalyticsFiltersProps) {
	return (
		<Popover open={filterOpen} onOpenChange={setFilterOpen}>
			<PopoverTrigger asChild>
				<Button variant="outline" size="sm">
					<Filter className="h-4 w-4 mr-2" />
					Filters
					{activeFilterCount > 0 && (
						<Badge variant="secondary" className="ml-2 h-5 px-1">
							{activeFilterCount}
						</Badge>
					)}
				</Button>
			</PopoverTrigger>
			<PopoverContent className="w-80" align="start">
				<div className="space-y-4">
					<div className="flex items-center justify-between">
						<h4 className="font-medium leading-none">Filters</h4>
						{activeFilterCount > 0 && (
							<Button
								variant="ghost"
								size="sm"
								onClick={() =>
									setFilters({ accounts: [], models: [], status: "all" })
								}
							>
								Clear all
							</Button>
						)}
					</div>

					<Separator />

					{/* Status Filter */}
					<div className="space-y-2">
						<Label>Status</Label>
						<Select
							value={filters.status}
							onValueChange={(value) =>
								setFilters({
									...filters,
									status: value as FilterState["status"],
								})
							}
						>
							<SelectTrigger>
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="all">All Requests</SelectItem>
								<SelectItem value="success">Success Only</SelectItem>
								<SelectItem value="error">Errors Only</SelectItem>
							</SelectContent>
						</Select>
					</div>

					{/* Account Filter */}
					{availableAccounts.length > 0 && (
						<div className="space-y-2">
							<Label>Accounts ({filters.accounts.length} selected)</Label>
							<div className="border rounded-md p-2 max-h-32 overflow-y-auto space-y-1">
								{availableAccounts.map((account) => (
									<label
										key={account}
										className="flex items-center space-x-2 cursor-pointer hover:bg-muted/50 p-1 rounded"
									>
										<input
											type="checkbox"
											className="rounded border-gray-300"
											checked={filters.accounts.includes(account)}
											onChange={(e) => {
												if (e.target.checked) {
													setFilters({
														...filters,
														accounts: [...filters.accounts, account],
													});
												} else {
													setFilters({
														...filters,
														accounts: filters.accounts.filter(
															(a) => a !== account,
														),
													});
												}
											}}
										/>
										<span className="text-sm">{account}</span>
									</label>
								))}
							</div>
						</div>
					)}

					{/* Model Filter */}
					{availableModels.length > 0 && (
						<div className="space-y-2">
							<Label>Models ({filters.models.length} selected)</Label>
							<div className="border rounded-md p-2 max-h-32 overflow-y-auto space-y-1">
								{availableModels.map((model) => (
									<label
										key={model}
										className="flex items-center space-x-2 cursor-pointer hover:bg-muted/50 p-1 rounded"
									>
										<input
											type="checkbox"
											className="rounded border-gray-300"
											checked={filters.models.includes(model)}
											onChange={(e) => {
												if (e.target.checked) {
													setFilters({
														...filters,
														models: [...filters.models, model],
													});
												} else {
													setFilters({
														...filters,
														models: filters.models.filter((m) => m !== model),
													});
												}
											}}
										/>
										<span className="text-sm truncate">{model}</span>
									</label>
								))}
							</div>
						</div>
					)}

					<Separator />

					<div className="flex justify-end">
						<Button size="sm" onClick={() => setFilterOpen(false)}>
							Done
						</Button>
					</div>
				</div>
			</PopoverContent>
		</Popover>
	);
}
</file>

<file path="packages/dashboard-web/src/components/analytics/index.ts">
export {
	CumulativeGrowthChart,
	CumulativeTokenComposition,
	MainMetricsChart,
	ModelComparisonCharts,
	PerformanceIndicatorsChart,
	TokenUsageBreakdown,
} from "./AnalyticsCharts";
export { AnalyticsControls } from "./AnalyticsControls";
export { AnalyticsFilters, type FilterState } from "./AnalyticsFilters";
export { ModelAnalytics } from "./ModelAnalytics";
export { TokenSpeedAnalytics } from "./TokenSpeedAnalytics";
</file>

<file path="packages/dashboard-web/src/components/analytics/ModelAnalytics.tsx">
import { Activity, BarChart3, TrendingUp, Zap } from "lucide-react";
import { useState } from "react";
import type { TimeRange } from "../../constants";
import { ModelPerformanceComparison, ModelTokenSpeedChart } from "../charts";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../ui/tabs";

interface ModelAnalyticsProps {
	modelPerformance: Array<{
		model: string;
		avgResponseTime: number;
		p95ResponseTime: number;
		errorRate: number;
		avgTokensPerSecond: number | null;
		minTokensPerSecond: number | null;
		maxTokensPerSecond: number | null;
	}>;
	costByModel: Array<{
		model: string;
		costUsd: number;
		requests: number;
		totalTokens?: number;
	}>;
	loading?: boolean;
	timeRange: TimeRange;
}

export function ModelAnalytics({
	modelPerformance,
	costByModel,
	loading = false,
}: ModelAnalyticsProps) {
	const [comparisonView, setComparisonView] = useState<
		"speed-cost" | "performance" | "efficiency"
	>("speed-cost");

	// Prepare data for the comparison chart
	const comparisonData = modelPerformance.map((perf) => {
		const costData = costByModel.find((c) => c.model === perf.model);
		const totalCost = costData?.costUsd || 0;
		const totalRequests = costData?.requests || 1;
		const totalTokens = costData?.totalTokens || 0;

		// Calculate cost per 1k tokens
		let costPer1kTokens: number;
		if (totalTokens > 0) {
			// Use actual token count for accurate calculation
			costPer1kTokens = (totalCost / totalTokens) * 1000;
		} else {
			// Fallback: estimate based on average cost per request
			const avgCostPerRequest = totalCost / totalRequests;
			const _estimatedTokensPerRequest = 1000; // Rough estimate
			costPer1kTokens = avgCostPerRequest;
		}

		return {
			model: perf.model,
			avgTokensPerSecond: perf.avgTokensPerSecond,
			costPer1kTokens,
			avgResponseTime: perf.avgResponseTime,
			errorRate: perf.errorRate,
			totalRequests,
		};
	});

	return (
		<div className="space-y-6">
			{/* Header with title and controls */}
			<div className="flex items-center justify-between">
				<div>
					<h3 className="text-lg font-semibold">Model Performance Analytics</h3>
					<p className="text-sm text-muted-foreground">
						Comprehensive analysis of model performance, cost, and efficiency
					</p>
				</div>
			</div>

			{/* Tabbed interface for different views */}
			<Tabs defaultValue="comparison" className="space-y-4">
				<TabsList className="grid w-full grid-cols-2">
					<TabsTrigger value="comparison" className="flex items-center gap-2">
						<TrendingUp className="h-4 w-4" />
						Multi-Metric Comparison
					</TabsTrigger>
					<TabsTrigger value="detailed" className="flex items-center gap-2">
						<BarChart3 className="h-4 w-4" />
						Detailed Analysis
					</TabsTrigger>
				</TabsList>

				{/* Multi-Metric Comparison Tab */}
				<TabsContent value="comparison" className="space-y-4">
					<Card className="bg-gradient-to-br from-background to-muted/10 border-muted">
						<CardHeader>
							<div className="flex items-center justify-between">
								<div className="space-y-1">
									<CardTitle className="text-2xl font-bold flex items-center gap-2">
										<Zap className="h-6 w-6 text-purple-500" />
										Model Performance Comparison
									</CardTitle>
									<CardDescription>
										{comparisonView === "speed-cost"
											? "Token generation speed vs. cost efficiency"
											: comparisonView === "performance"
												? "Response time and error rate analysis"
												: "Overall efficiency score (speed/cost ratio)"}
									</CardDescription>
								</div>
								<Select
									value={comparisonView}
									onValueChange={(v) =>
										setComparisonView(
											v as "speed-cost" | "performance" | "efficiency",
										)
									}
								>
									<SelectTrigger className="w-48">
										<SelectValue />
									</SelectTrigger>
									<SelectContent>
										<SelectItem value="speed-cost">
											<div className="flex items-center gap-2">
												<Zap className="h-4 w-4" />
												Speed vs Cost
											</div>
										</SelectItem>
										<SelectItem value="performance">
											<div className="flex items-center gap-2">
												<Activity className="h-4 w-4" />
												Performance Metrics
											</div>
										</SelectItem>
										<SelectItem value="efficiency">
											<div className="flex items-center gap-2">
												<TrendingUp className="h-4 w-4" />
												Efficiency Score
											</div>
										</SelectItem>
									</SelectContent>
								</Select>
							</div>
						</CardHeader>
						<CardContent>
							<ModelPerformanceComparison
								data={comparisonData}
								loading={loading}
								height={400}
								viewMode={comparisonView}
							/>
						</CardContent>
					</Card>
				</TabsContent>

				{/* Detailed Analysis Tab */}
				<TabsContent value="detailed" className="space-y-4">
					<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
						{/* Token Speed Chart */}
						<Card>
							<CardHeader>
								<CardTitle className="flex items-center gap-2">
									<Zap className="h-5 w-5" />
									Token Generation Speed
								</CardTitle>
								<CardDescription>
									Average, min, and max tokens per second by model
								</CardDescription>
							</CardHeader>
							<CardContent>
								<ModelTokenSpeedChart
									data={modelPerformance}
									loading={loading}
									height={350}
								/>
							</CardContent>
						</Card>

						{/* Model Stats Cards */}
						<div className="space-y-4">
							{/* Fastest Model Card */}
							<Card>
								<CardHeader className="pb-3">
									<CardTitle className="text-sm font-medium">
										Fastest Model
									</CardTitle>
								</CardHeader>
								<CardContent>
									{(() => {
										const fastest = modelPerformance
											.filter((m) => m.avgTokensPerSecond !== null)
											.sort(
												(a, b) =>
													(b.avgTokensPerSecond || 0) -
													(a.avgTokensPerSecond || 0),
											)[0];
										return fastest ? (
											<div className="space-y-2">
												<p className="text-2xl font-bold">{fastest.model}</p>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">Speed:</span>
													<span className="font-medium">
														{fastest.avgTokensPerSecond?.toFixed(1)} tok/s
													</span>
												</div>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														Response:
													</span>
													<span className="font-medium">
														{fastest.avgResponseTime.toFixed(0)}ms
													</span>
												</div>
											</div>
										) : (
											<p className="text-muted-foreground">No data</p>
										);
									})()}
								</CardContent>
							</Card>

							{/* Most Reliable Model Card */}
							<Card>
								<CardHeader className="pb-3">
									<CardTitle className="text-sm font-medium">
										Most Reliable Model
									</CardTitle>
								</CardHeader>
								<CardContent>
									{(() => {
										const reliable = modelPerformance.sort(
											(a, b) => a.errorRate - b.errorRate,
										)[0];
										return reliable ? (
											<div className="space-y-2">
												<p className="text-2xl font-bold">{reliable.model}</p>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														Error Rate:
													</span>
													<span className="font-medium text-green-600">
														{reliable.errorRate.toFixed(2)}%
													</span>
												</div>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														p95 Response:
													</span>
													<span className="font-medium">
														{reliable.p95ResponseTime.toFixed(0)}ms
													</span>
												</div>
											</div>
										) : (
											<p className="text-muted-foreground">No data</p>
										);
									})()}
								</CardContent>
							</Card>

							{/* Most Cost-Effective Model Card */}
							<Card>
								<CardHeader className="pb-3">
									<CardTitle className="text-sm font-medium">
										Most Cost-Effective
									</CardTitle>
								</CardHeader>
								<CardContent>
									{(() => {
										const costEffective = comparisonData
											.filter(
												(m) =>
													m.avgTokensPerSecond !== null &&
													m.costPer1kTokens > 0,
											)
											.sort((a, b) => {
												const efficiencyA =
													(a.avgTokensPerSecond || 0) / a.costPer1kTokens;
												const efficiencyB =
													(b.avgTokensPerSecond || 0) / b.costPer1kTokens;
												return efficiencyB - efficiencyA;
											})[0];
										return costEffective ? (
											<div className="space-y-2">
												<p className="text-2xl font-bold">
													{costEffective.model}
												</p>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														Efficiency:
													</span>
													<span className="font-medium">
														{(
															(costEffective.avgTokensPerSecond || 0) /
															costEffective.costPer1kTokens
														).toFixed(2)}{" "}
														tok/s/$
													</span>
												</div>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														Cost/1K:
													</span>
													<span className="font-medium">
														${costEffective.costPer1kTokens.toFixed(3)}
													</span>
												</div>
											</div>
										) : (
											<p className="text-muted-foreground">No data</p>
										);
									})()}
								</CardContent>
							</Card>
						</div>
					</div>
				</TabsContent>
			</Tabs>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/BasePieChart.tsx">
import type { ReactNode } from "react";
import {
	Cell,
	Legend,
	Pie,
	PieChart,
	ResponsiveContainer,
	Tooltip,
} from "recharts";
import {
	CHART_COLORS,
	type CHART_HEIGHTS,
	type CHART_TOOLTIP_STYLE,
} from "../../constants";
import { ChartContainer } from "./ChartContainer";
import { getChartHeight, getTooltipStyles } from "./chart-utils";
import type { ChartClickHandler, TooltipFormatterFunction } from "./types";

interface BasePieChartProps {
	data: Array<{ name: string; value: number; [key: string]: string | number }>;
	dataKey?: string;
	nameKey?: string;
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	innerRadius?: number;
	outerRadius?: number;
	paddingAngle?: number;
	cx?: string | number;
	cy?: string | number;
	colors?: string[];
	tooltipFormatter?: TooltipFormatterFunction;
	tooltipStyle?: keyof typeof CHART_TOOLTIP_STYLE | object;
	animationDuration?: number;
	showLegend?: boolean;
	legendLayout?: "horizontal" | "vertical";
	legendAlign?: "left" | "center" | "right";
	legendVerticalAlign?: "top" | "middle" | "bottom";
	renderLabel?: boolean;
	className?: string;
	error?: Error | null;
	emptyState?: ReactNode;
	onPieClick?: ChartClickHandler;
}

export function BasePieChart({
	data,
	dataKey = "value",
	nameKey = "name",
	loading = false,
	height = "medium",
	innerRadius = 0,
	outerRadius = 80,
	paddingAngle = 0,
	cx = "50%",
	cy = "50%",
	colors = [...CHART_COLORS],
	tooltipFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	showLegend = false,
	legendLayout = "horizontal",
	legendAlign = "center",
	legendVerticalAlign = "bottom",
	renderLabel = false,
	className = "",
	error = null,
	emptyState,
	onPieClick,
}: BasePieChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = !data || data.length === 0;
	const tooltipStyles = getTooltipStyles(tooltipStyle);

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<PieChart>
					<Pie
						data={data}
						cx={cx}
						cy={cy}
						innerRadius={innerRadius}
						outerRadius={outerRadius}
						paddingAngle={paddingAngle}
						dataKey={dataKey}
						nameKey={nameKey}
						animationDuration={animationDuration}
						label={renderLabel}
						onClick={onPieClick}
					>
						{data.map((entry, index) => (
							<Cell
								key={`cell-${entry[nameKey]}`}
								fill={colors[index % colors.length]}
							/>
						))}
					</Pie>
					<Tooltip contentStyle={tooltipStyles} formatter={tooltipFormatter} />
					{showLegend && (
						<Legend
							layout={legendLayout}
							align={legendAlign}
							verticalAlign={legendVerticalAlign}
						/>
					)}
				</PieChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/ChartContainer.tsx">
import { RefreshCw } from "lucide-react";
import type { ReactNode } from "react";
import { CHART_HEIGHTS } from "../../constants";

interface ChartContainerProps {
	children: ReactNode;
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	className?: string;
	error?: Error | null;
	emptyState?: ReactNode;
	isEmpty?: boolean;
}

export function ChartContainer({
	children,
	loading = false,
	height = "medium",
	className = "",
	error = null,
	emptyState,
	isEmpty = false,
}: ChartContainerProps) {
	const chartHeight =
		typeof height === "number" ? height : CHART_HEIGHTS[height];

	if (error) {
		return (
			<div
				className={`flex items-center justify-center ${className}`}
				style={{ height: chartHeight }}
			>
				<div className="text-center space-y-2">
					<p className="text-sm text-destructive">Error loading chart data</p>
					<p className="text-xs text-muted-foreground">{error.message}</p>
				</div>
			</div>
		);
	}

	if (loading) {
		return (
			<div
				className={`flex items-center justify-center ${className}`}
				style={{ height: chartHeight }}
			>
				<RefreshCw className="h-8 w-8 animate-spin text-muted-foreground" />
			</div>
		);
	}

	if (isEmpty && emptyState) {
		return (
			<div
				className={`flex items-center justify-center ${className}`}
				style={{ height: chartHeight }}
			>
				{emptyState}
			</div>
		);
	}

	return <div className={className}>{children}</div>;
}
</file>

<file path="packages/dashboard-web/src/components/charts/ChartTooltip.tsx">
import { CHART_TOOLTIP_STYLE } from "../../constants";
import type { TooltipFormatterValue } from "./types";

interface PayloadItem {
	dataKey: string;
	value: TooltipFormatterValue;
	name?: string;
	color?: string;
}

interface ChartTooltipProps {
	active?: boolean;
	payload?: PayloadItem[];
	label?: string;
	formatters?: Record<string, (value: TooltipFormatterValue) => string>;
	labelFormatter?: (label: string) => string;
	style?: keyof typeof CHART_TOOLTIP_STYLE | object;
}

export function ChartTooltip({
	active,
	payload,
	label,
	formatters = {},
	labelFormatter,
	style = "default",
}: ChartTooltipProps) {
	if (!active || !payload || !payload.length) {
		return null;
	}

	const tooltipStyle =
		typeof style === "string" ? CHART_TOOLTIP_STYLE[style] : style;

	const formattedLabel =
		labelFormatter && label ? labelFormatter(label) : label;

	return (
		<div className="p-3 rounded-md shadow-lg" style={tooltipStyle}>
			{formattedLabel && <p className="font-medium mb-2">{formattedLabel}</p>}
			<div className="space-y-1">
				{payload.map((entry, index) => {
					const formatter = formatters[entry.dataKey] || formatters.default;
					const value = formatter ? formatter(entry.value) : entry.value;

					return (
						<div
							key={`${entry.dataKey}-${index}`}
							className="flex items-center gap-2"
						>
							<div
								className="w-3 h-3 rounded-full"
								style={{ backgroundColor: entry.color }}
							/>
							<span className="text-sm">
								{entry.name}: <strong>{value}</strong>
							</span>
						</div>
					);
				})}
			</div>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/index.ts">
export { BaseAreaChart } from "./BaseAreaChart";
export { BaseBarChart } from "./BaseBarChart";
export { BaseLineChart } from "./BaseLineChart";
export { BasePieChart } from "./BasePieChart";
export { BaseScatterChart } from "./BaseScatterChart";
export { ChartContainer } from "./ChartContainer";
export { ChartTooltip } from "./ChartTooltip";
export { CostChart } from "./CostChart";
export { ModelPerformanceChart } from "./ModelPerformanceChart";
export { ModelPerformanceComparison } from "./ModelPerformanceComparison";
export { ModelTokenSpeedChart } from "./ModelTokenSpeedChart";
export { MultiModelChart } from "./MultiModelChart";
export { RequestVolumeChart } from "./RequestVolumeChart";
export { ResponseTimeChart } from "./ResponseTimeChart";
export { TokenSpeedChart } from "./TokenSpeedChart";
export { TokenUsageChart } from "./TokenUsageChart";
</file>

<file path="packages/dashboard-web/src/components/charts/ResponseTimeChart.tsx">
import { COLORS } from "../../constants";
import { BaseAreaChart } from "./BaseAreaChart";

interface ResponseTimeChartProps {
	data: Array<{
		time: string;
		responseTime: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}

export function ResponseTimeChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: ResponseTimeChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	return (
		<BaseAreaChart
			data={data}
			dataKey="responseTime"
			loading={loading}
			height={height}
			color={viewMode === "cumulative" ? COLORS.purple : COLORS.primary}
			strokeWidth={viewMode === "cumulative" ? 3 : 2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			tooltipFormatter={(value) => [`${value}ms`, "Response Time"]}
			tooltipLabelFormatter={(label) =>
				viewMode === "cumulative" ? `Cumulative at ${label}` : label
			}
			animationDuration={1000}
		/>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/types.ts">
// Common types for chart components
export type ChartDataPoint = Record<string, string | number>;

export type TooltipFormatterValue = string | number | [number, number];

export type TooltipFormatterFunction = (
	value: TooltipFormatterValue,
	name?: string,
) => [string, string] | string;

// Use any for chart click handlers to match recharts types
// biome-ignore lint/suspicious/noExplicitAny: recharts types require any
export type ChartClickHandler = (data: any) => void;
</file>

<file path="packages/dashboard-web/src/components/overview/ChartsSection.tsx">
import { CHART_COLORS, COLORS } from "../../constants";
import {
	BaseAreaChart,
	BaseBarChart,
	BaseLineChart,
	BasePieChart,
} from "../charts";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";

interface ChartsSectionProps {
	timeSeriesData: Array<{
		time: string;
		requests: number;
		successRate: number;
		responseTime: number;
		cost: string;
	}>;
	modelData: Array<{ name: string; value: number }>;
	accountHealthData: Array<{
		name: string;
		requests: number;
		successRate: number;
	}>;
	loading: boolean;
}

export function ChartsSection({
	timeSeriesData,
	modelData,
	accountHealthData,
	loading,
}: ChartsSectionProps) {
	return (
		<>
			{/* Charts Row 1 */}
			<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
				{/* Request Volume Chart */}
				<Card>
					<CardHeader>
						<CardTitle>Request Volume</CardTitle>
						<CardDescription>
							Requests per hour over the last 24 hours
						</CardDescription>
					</CardHeader>
					<CardContent>
						<BaseAreaChart
							data={timeSeriesData}
							dataKey="requests"
							loading={loading}
							height="medium"
						/>
					</CardContent>
				</Card>

				{/* Success Rate Chart */}
				<Card>
					<CardHeader>
						<CardTitle>Success Rate Trend</CardTitle>
						<CardDescription>Success percentage over time</CardDescription>
					</CardHeader>
					<CardContent>
						<BaseLineChart
							data={timeSeriesData}
							lines={{ dataKey: "successRate", stroke: COLORS.success }}
							loading={loading}
							height="medium"
							yAxisDomain={[80, 100]}
						/>
					</CardContent>
				</Card>
			</div>

			{/* Charts Row 2 */}
			<div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
				{/* Model Distribution */}
				<Card>
					<CardHeader>
						<CardTitle>Model Usage</CardTitle>
						<CardDescription>
							Distribution of API calls by model
						</CardDescription>
					</CardHeader>
					<CardContent>
						<BasePieChart
							data={modelData}
							loading={loading}
							height="small"
							innerRadius={60}
							outerRadius={80}
							paddingAngle={5}
							tooltipStyle="success"
						/>
						<div className="mt-4 space-y-2">
							{modelData.map((model, index) => (
								<div
									key={model.name}
									className="flex items-center justify-between text-sm"
								>
									<div className="flex items-center gap-2">
										<div
											className="h-3 w-3 rounded-full"
											style={{
												backgroundColor:
													CHART_COLORS[index % CHART_COLORS.length],
											}}
										/>
										<span className="text-muted-foreground">{model.name}</span>
									</div>
									<span className="font-medium">{model.value}</span>
								</div>
							))}
						</div>
					</CardContent>
				</Card>

				{/* Account Health */}
				<Card className="lg:col-span-2">
					<CardHeader>
						<CardTitle>Account Performance</CardTitle>
						<CardDescription>
							Request distribution and success rates by account
						</CardDescription>
					</CardHeader>
					<CardContent>
						<BaseBarChart
							data={accountHealthData}
							bars={[
								{ dataKey: "requests", yAxisId: "left", name: "Requests" },
								{
									dataKey: "successRate",
									yAxisId: "right",
									fill: COLORS.success,
									name: "Success %",
								},
							]}
							xAxisKey="name"
							loading={loading}
							height="small"
							secondaryYAxis={true}
							showLegend={true}
						/>
					</CardContent>
				</Card>
			</div>
		</>
	);
}
</file>

<file path="packages/dashboard-web/src/components/overview/LoadingSkeleton.tsx">
import { Card, CardContent, CardHeader } from "../ui/card";
import { Skeleton } from "../ui/skeleton";

export function LoadingSkeleton() {
	return (
		<div className="space-y-6">
			<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
				{[...Array(4)].map((_, i) => (
					// biome-ignore lint/suspicious/noArrayIndexKey: Skeleton cards are temporary placeholders
					<Card key={i}>
						<CardContent className="p-6">
							<Skeleton className="h-4 w-24 mb-2" />
							<Skeleton className="h-8 w-32 mb-2" />
							<Skeleton className="h-4 w-20" />
						</CardContent>
					</Card>
				))}
			</div>
			<Card>
				<CardHeader>
					<Skeleton className="h-6 w-32" />
				</CardHeader>
				<CardContent>
					<Skeleton className="h-64 w-full" />
				</CardContent>
			</Card>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/overview/SystemStatus.tsx">
import { CheckCircle, XCircle } from "lucide-react";
import { Badge } from "../ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";

interface SystemStatusProps {
	recentErrors?: string[];
}

export function SystemStatus({ recentErrors }: SystemStatusProps) {
	return (
		<Card>
			<CardHeader>
				<CardTitle>System Status</CardTitle>
				<CardDescription>
					Current operational status and recent events
				</CardDescription>
			</CardHeader>
			<CardContent>
				<div className="space-y-4">
					<div className="flex items-center justify-between p-4 rounded-lg bg-success/10">
						<div className="flex items-center gap-3">
							<CheckCircle className="h-5 w-5 text-success" />
							<div>
								<p className="font-medium">All Systems Operational</p>
								<p className="text-sm text-muted-foreground">
									No issues detected
								</p>
							</div>
						</div>
						<Badge variant="default" className="bg-success">
							Healthy
						</Badge>
					</div>

					{recentErrors && recentErrors.length > 0 && (
						<div className="space-y-2">
							<h4 className="text-sm font-medium text-muted-foreground">
								Recent Errors
							</h4>
							{recentErrors.slice(0, 3).map((error, i) => (
								<div
									key={`error-${error.substring(0, 20)}-${i}`}
									className="flex items-start gap-2 p-3 rounded-lg bg-destructive/10"
								>
									<XCircle className="h-4 w-4 text-destructive mt-0.5" />
									<p className="text-sm text-muted-foreground">{error}</p>
								</div>
							))}
						</div>
					)}
				</div>
			</CardContent>
		</Card>
	);
}
</file>

<file path="packages/dashboard-web/src/components/ui/badge.tsx">
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";

import { cn } from "../../lib/utils";

const badgeVariants = cva(
	"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
	{
		variants: {
			variant: {
				default:
					"border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
				secondary:
					"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
				destructive:
					"border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
				outline: "text-foreground",
				success:
					"border-transparent bg-green-500 text-white shadow hover:bg-green-500/80",
				warning:
					"border-transparent bg-yellow-500 text-white shadow hover:bg-yellow-500/80",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

interface BadgeProps
	extends React.HTMLAttributes<HTMLDivElement>,
		VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
	return (
		<div className={cn(badgeVariants({ variant }), className)} {...props} />
	);
}

export { Badge };
</file>

<file path="packages/dashboard-web/src/components/ui/button.tsx">
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "../../lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
	{
		variants: {
			variant: {
				default:
					"bg-primary text-primary-foreground shadow-sm hover:bg-primary/90 hover:shadow-md hover:-translate-y-0.5",
				destructive:
					"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
				outline:
					"border-2 border-border bg-background shadow-sm hover:bg-accent hover:text-accent-foreground hover:border-primary/50",
				secondary:
					"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-5 py-2",
				sm: "h-8 rounded-md px-3 text-xs",
				lg: "h-12 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button };
</file>

<file path="packages/dashboard-web/src/components/ui/dropdown-menu.tsx">
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";
import * as React from "react";

import { cn } from "../../lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const _DropdownMenuGroup = DropdownMenuPrimitive.Group;

const _DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const _DropdownMenuSub = DropdownMenuPrimitive.Sub;

const _DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
		inset?: boolean;
	}
>(({ className, inset, children, ...props }, ref) => (
	<DropdownMenuPrimitive.SubTrigger
		ref={ref}
		className={cn(
			"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
			inset && "pl-8",
			className,
		)}
		{...props}
	>
		{children}
		<ChevronRight className="ml-auto h-4 w-4" />
	</DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
	DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
	<DropdownMenuPrimitive.SubContent
		ref={ref}
		className={cn(
			"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
			className,
		)}
		{...props}
	/>
));
DropdownMenuSubContent.displayName =
	DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
	<DropdownMenuPrimitive.Portal>
		<DropdownMenuPrimitive.Content
			ref={ref}
			sideOffset={sideOffset}
			className={cn(
				"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
				"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				className,
			)}
			{...props}
		/>
	</DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
		inset?: boolean;
	}
>(({ className, inset, ...props }, ref) => (
	<DropdownMenuPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			inset && "pl-8",
			className,
		)}
		{...props}
	/>
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
	<DropdownMenuPrimitive.CheckboxItem
		ref={ref}
		className={cn(
			"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		checked={checked}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<DropdownMenuPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</DropdownMenuPrimitive.ItemIndicator>
		</span>
		{children}
	</DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
	DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
	<DropdownMenuPrimitive.RadioItem
		ref={ref}
		className={cn(
			"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<DropdownMenuPrimitive.ItemIndicator>
				<Circle className="h-2 w-2 fill-current" />
			</DropdownMenuPrimitive.ItemIndicator>
		</span>
		{children}
	</DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
		inset?: boolean;
	}
>(({ className, inset, ...props }, ref) => (
	<DropdownMenuPrimitive.Label
		ref={ref}
		className={cn(
			"px-2 py-1.5 text-sm font-semibold",
			inset && "pl-8",
			className,
		)}
		{...props}
	/>
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<DropdownMenuPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
	className,
	...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
	return (
		<span
			className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
			{...props}
		/>
	);
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
	DropdownMenu,
	DropdownMenuTrigger,
	DropdownMenuContent,
	DropdownMenuItem,
};
</file>

<file path="packages/dashboard-web/src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "../../lib/utils";

export interface InputProps
	extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
	({ className, type, ...props }, ref) => {
		return (
			<input
				type={type}
				className={cn(
					"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Input.displayName = "Input";

export { Input };
</file>

<file path="packages/dashboard-web/src/components/ui/label.tsx">
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "../../lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="packages/dashboard-web/src/components/ui/popover.tsx">
import * as PopoverPrimitive from "@radix-ui/react-popover";
import * as React from "react";

import { cn } from "../../lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
	React.ElementRef<typeof PopoverPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
	<PopoverPrimitive.Portal>
		<PopoverPrimitive.Content
			ref={ref}
			align={align}
			sideOffset={sideOffset}
			className={cn(
				"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				className,
			)}
			{...props}
		/>
	</PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };
</file>

<file path="packages/dashboard-web/src/components/ui/select.tsx">
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown } from "lucide-react";
import * as React from "react";

import { cn } from "../../lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-9 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("px-2 py-1.5 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>
		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
};
</file>

<file path="packages/dashboard-web/src/components/ui/separator.tsx">
import * as SeparatorPrimitive from "@radix-ui/react-separator";
import * as React from "react";

import { cn } from "../../lib/utils";

const Separator = React.forwardRef<
	React.ElementRef<typeof SeparatorPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
	(
		{ className, orientation = "horizontal", decorative = true, ...props },
		ref,
	) => (
		<SeparatorPrimitive.Root
			ref={ref}
			decorative={decorative}
			orientation={orientation}
			className={cn(
				"shrink-0 bg-border",
				orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
				className,
			)}
			{...props}
		/>
	),
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };
</file>

<file path="packages/dashboard-web/src/components/ui/skeleton.tsx">
import { cn } from "../../lib/utils";

function Skeleton({
	className,
	...props
}: React.HTMLAttributes<HTMLDivElement>) {
	return (
		<div
			className={cn("animate-pulse rounded-md bg-muted", className)}
			{...props}
		/>
	);
}

export { Skeleton };
</file>

<file path="packages/dashboard-web/src/components/ui/switch.tsx">
import * as SwitchPrimitives from "@radix-ui/react-switch";
import * as React from "react";

import { cn } from "../../lib/utils";

const Switch = React.forwardRef<
	React.ElementRef<typeof SwitchPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
	<SwitchPrimitives.Root
		className={cn(
			"peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
			className,
		)}
		{...props}
		ref={ref}
	>
		<SwitchPrimitives.Thumb
			className={cn(
				"pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0",
			)}
		/>
	</SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };
</file>

<file path="packages/dashboard-web/src/components/ui/tabs.tsx">
import * as TabsPrimitive from "@radix-ui/react-tabs";
import * as React from "react";

import { cn } from "../../lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
	React.ElementRef<typeof TabsPrimitive.List>,
	React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
	<TabsPrimitive.List
		ref={ref}
		className={cn(
			"inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
			className,
		)}
		{...props}
	/>
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
	React.ElementRef<typeof TabsPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
	<TabsPrimitive.Trigger
		ref={ref}
		className={cn(
			"inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
			className,
		)}
		{...props}
	/>
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
	React.ElementRef<typeof TabsPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
	<TabsPrimitive.Content
		ref={ref}
		className={cn(
			"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
			className,
		)}
		{...props}
	/>
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };
</file>

<file path="packages/dashboard-web/src/components/AnalyticsTab.tsx">
import { format } from "date-fns";
import { useMemo, useState } from "react";
import type { TimeRange } from "../constants";
import { useAnalytics } from "../hooks/queries";
import {
	AnalyticsControls,
	CumulativeGrowthChart,
	CumulativeTokenComposition,
	type FilterState,
	MainMetricsChart,
	ModelAnalytics,
	PerformanceIndicatorsChart,
	TokenSpeedAnalytics,
	TokenUsageBreakdown,
} from "./analytics";

export function AnalyticsTab() {
	const [timeRange, setTimeRange] = useState<TimeRange>("1h");
	const [selectedMetric, setSelectedMetric] = useState("requests");
	const [filterOpen, setFilterOpen] = useState(false);
	const [viewMode, setViewMode] = useState<"normal" | "cumulative">("normal");
	const [modelBreakdown, setModelBreakdown] = useState(false);
	const [filters, setFilters] = useState<FilterState>({
		accounts: [],
		models: [],
		status: "all",
	});

	// Fetch analytics data with automatic refetch on dependency changes
	const { data: analytics, isLoading: loading } = useAnalytics(
		timeRange,
		filters,
		viewMode,
		modelBreakdown,
	);

	// Get unique accounts and models from analytics data
	const availableAccounts = useMemo(
		() => analytics?.accountPerformance?.map((a) => a.name) || [],
		[analytics],
	);
	const availableModels = useMemo(
		() => analytics?.modelDistribution?.map((m) => m.model) || [],
		[analytics],
	);

	// Apply filters to data
	const filterData = <T extends { errorRate?: number | string }>(
		data: T[],
	): T[] => {
		if (!analytics) return data;

		return data.filter((point) => {
			// Status filter
			if (filters.status !== "all") {
				const errorRate =
					typeof point.errorRate === "string"
						? parseFloat(point.errorRate)
						: point.errorRate || 0;
				if (filters.status === "success" && errorRate > 50) return false;
				if (filters.status === "error" && errorRate <= 50) return false;
			}

			// For time series data, we can't filter by specific accounts/models
			// Those filters will be applied to the other charts
			return true;
		});
	};

	// Transform time series data for charts
	const data = filterData(
		analytics?.timeSeries.map((point) => ({
			time:
				timeRange === "30d"
					? format(new Date(point.ts), "MMM d")
					: format(new Date(point.ts), "HH:mm"),
			requests: point.requests,
			tokens: point.tokens,
			cost: parseFloat(point.costUsd.toFixed(2)),
			responseTime: Math.round(point.avgResponseTime),
			errorRate: parseFloat(point.errorRate.toFixed(1)),
			cacheHitRate: parseFloat(point.cacheHitRate.toFixed(1)),
			avgTokensPerSecond: point.avgTokensPerSecond || 0,
		})) || [],
	);

	// Calculate token usage breakdown
	const tokenBreakdown = analytics?.tokenBreakdown
		? [
				{
					type: "Input Tokens",
					value: analytics.tokenBreakdown.inputTokens,
					percentage: 0,
				},
				{
					type: "Cache Read",
					value: analytics.tokenBreakdown.cacheReadInputTokens,
					percentage: 0,
				},
				{
					type: "Cache Creation",
					value: analytics.tokenBreakdown.cacheCreationInputTokens,
					percentage: 0,
				},
				{
					type: "Output Tokens",
					value: analytics.tokenBreakdown.outputTokens,
					percentage: 0,
				},
			].map((item) => {
				const total = analytics.totals.totalTokens || 1;
				return { ...item, percentage: Math.round((item.value / total) * 100) };
			})
		: [];

	// Use real model performance data from backend with filters
	const _modelPerformance =
		analytics?.modelPerformance
			?.filter(
				(perf) =>
					filters.models.length === 0 || filters.models.includes(perf.model),
			)
			?.map((perf) => ({
				model: perf.model,
				avgTime: Math.round(perf.avgResponseTime),
				p95Time: Math.round(perf.p95ResponseTime),
				errorRate: parseFloat(perf.errorRate.toFixed(1)),
			})) || [];

	// Use real cost by model data with filters
	const costByModel =
		analytics?.costByModel
			?.filter(
				(model) =>
					filters.models.length === 0 || filters.models.includes(model.model),
			)
			?.slice(0, 4) || [];

	// Count active filters
	const activeFilterCount =
		filters.accounts.length +
		filters.models.length +
		(filters.status !== "all" ? 1 : 0);

	return (
		<div className="space-y-6">
			{/* Controls */}
			<AnalyticsControls
				timeRange={timeRange}
				setTimeRange={setTimeRange}
				viewMode={viewMode}
				setViewMode={(mode) => {
					setViewMode(mode);
					// Disable per-model breakdown when switching to cumulative
					if (mode === "cumulative") {
						setModelBreakdown(false);
					}
				}}
				filters={filters}
				setFilters={setFilters}
				availableAccounts={availableAccounts}
				availableModels={availableModels}
				activeFilterCount={activeFilterCount}
				filterOpen={filterOpen}
				setFilterOpen={setFilterOpen}
				loading={loading}
				onRefresh={() => setTimeRange(timeRange)}
			/>

			{/* Cumulative View - Show cumulative charts first */}
			{viewMode === "cumulative" && analytics && (
				<>
					{/* Beautiful Cumulative Chart */}
					<CumulativeGrowthChart data={data} />

					{/* Cumulative Token Breakdown Ribbon Chart */}
					{tokenBreakdown.length > 0 && (
						<CumulativeTokenComposition tokenBreakdown={tokenBreakdown} />
					)}
				</>
			)}

			{/* Main Metrics Chart */}
			<MainMetricsChart
				data={data}
				rawTimeSeries={analytics?.timeSeries}
				loading={loading}
				viewMode={viewMode}
				timeRange={timeRange}
				selectedMetric={selectedMetric}
				setSelectedMetric={setSelectedMetric}
				modelBreakdown={modelBreakdown}
				onModelBreakdownChange={setModelBreakdown}
			/>

			{/* Normal View Charts - Only show in normal mode */}
			{viewMode === "normal" && (
				<>
					{/* Secondary Charts Row */}
					<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
						<PerformanceIndicatorsChart
							data={data}
							loading={loading}
							modelBreakdown={modelBreakdown}
							rawTimeSeries={analytics?.timeSeries}
							timeRange={timeRange}
						/>
						<TokenUsageBreakdown
							tokenBreakdown={tokenBreakdown}
							timeRange={timeRange}
						/>
					</div>

					{/* Enhanced Model Analytics */}
					<ModelAnalytics
						modelPerformance={analytics?.modelPerformance || []}
						costByModel={costByModel}
						loading={loading}
						timeRange={timeRange}
					/>

					{/* Token Speed Analytics */}
					<TokenSpeedAnalytics
						timeSeriesData={data}
						modelPerformance={analytics?.modelPerformance || []}
						loading={loading}
						timeRange={timeRange}
					/>
				</>
			)}
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/CopyButton.tsx">
import { Check, Copy } from "lucide-react";
import { type ComponentProps, useRef, useState } from "react";
import { cn } from "../lib/utils";
import { Button } from "./ui/button";

interface CopyButtonProps {
	/**
	 * String or function returning the string to copy.
	 */
	value?: string;
	getValue?: () => string;
	/**
	 * Forwarded props to underlying Button
	 */
	variant?: ComponentProps<typeof Button>["variant"];
	size?: ComponentProps<typeof Button>["size"];
	className?: string;
	/**
	 * Children to render inside the button. If provided, an icon will be shown to the left.
	 */
	children?: React.ReactNode;
	/**
	 * Optional title attribute for accessibility.
	 */
	title?: string;
}

/**
 * A small wrapper around the standard Button that copies supplied text to the
 * clipboard and temporarily shows a "Copied!" label with a subtle animation.
 */
export function CopyButton({
	value,
	getValue,
	variant = "ghost",
	size = "sm",
	className,
	children,
	title,
}: CopyButtonProps) {
	const [copied, setCopied] = useState(false);
	const timeoutRef = useRef<number | null>(null);

	const handleCopy = () => {
		const text = typeof getValue === "function" ? getValue() : (value ?? "");
		if (!text) return;

		navigator.clipboard
			.writeText(text)
			.then(() => {
				setCopied(true);
				// Reset after 1.5s
				if (timeoutRef.current) {
					window.clearTimeout(timeoutRef.current);
				}
				timeoutRef.current = window.setTimeout(() => setCopied(false), 1500);
			})
			.catch((err) => console.error("Failed to copy", err));
	};

	return (
		<Button
			variant={variant}
			size={size}
			onClick={handleCopy}
			title={title}
			className={cn("relative overflow-hidden", className)}
		>
			{copied ? (
				<span className="animate-pulse">
					<Check className="h-4 w-4" />
				</span>
			) : children ? (
				<>
					<Copy className="h-4 w-4 mr-1" />
					{children}
				</>
			) : (
				<Copy className="h-4 w-4" />
			)}
		</Button>
	);
}
</file>

<file path="packages/dashboard-web/src/components/StatsTab.tsx">
import { formatPercentage } from "@ccflare/ui-common";
import { RefreshCw } from "lucide-react";
import { useResetStats, useStats } from "../hooks/queries";
import { useApiError } from "../hooks/useApiError";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";

export function StatsTab() {
	const { formatError } = useApiError();
	const {
		data: stats,
		isLoading: loading,
		error,
		refetch: loadStats,
	} = useStats();
	const resetStatsMutation = useResetStats();

	const handleResetStats = async () => {
		if (!confirm("Are you sure you want to reset all statistics?")) return;

		try {
			await resetStatsMutation.mutateAsync();
		} catch (err) {
			// Since we can't set error directly, we'll just alert the user
			alert(formatError(err));
		}
	};

	if (loading) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-muted-foreground">Loading statistics...</p>
				</CardContent>
			</Card>
		);
	}

	if (error) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-destructive">Error: {formatError(error)}</p>
					<Button
						onClick={() => loadStats()}
						variant="outline"
						size="sm"
						className="mt-2"
					>
						<RefreshCw className="mr-2 h-4 w-4" />
						Retry
					</Button>
				</CardContent>
			</Card>
		);
	}

	return (
		<div className="space-y-4">
			<Card>
				<CardHeader>
					<div className="flex items-center justify-between">
						<CardTitle>Account Performance</CardTitle>
						<Button onClick={() => loadStats()} variant="ghost" size="sm">
							<RefreshCw className="h-4 w-4" />
						</Button>
					</div>
				</CardHeader>
				<CardContent>
					{stats?.accounts && stats.accounts.length > 0 ? (
						<div className="space-y-4">
							{stats.accounts.map(
								(account: {
									name: string;
									requestCount: number;
									successRate: number;
								}) => (
									<div key={account.name} className="space-y-2">
										<div className="flex items-center justify-between">
											<span className="font-medium">{account.name}</span>
											<span className="text-sm text-muted-foreground">
												{account.requestCount} requests
											</span>
										</div>
										<div className="w-full bg-secondary rounded-full h-2">
											<div
												className="bg-primary h-2 rounded-full transition-all"
												style={{ width: `${account.successRate}%` }}
											/>
										</div>
										<div className="flex items-center justify-between text-sm">
											<span className="text-muted-foreground">
												Success rate
											</span>
											<span
												className={
													account.successRate >= 95
														? "text-green-600"
														: account.successRate >= 80
															? "text-yellow-600"
															: "text-red-600"
												}
											>
												{formatPercentage(account.successRate)}
											</span>
										</div>
									</div>
								),
							)}
						</div>
					) : (
						<p className="text-muted-foreground">No account data available</p>
					)}
				</CardContent>
			</Card>

			{stats?.recentErrors && stats.recentErrors.length > 0 && (
				<Card>
					<CardHeader>
						<CardTitle>Recent Errors</CardTitle>
						<CardDescription>Last 10 errors from all accounts</CardDescription>
					</CardHeader>
					<CardContent>
						<div className="space-y-2">
							{stats.recentErrors.map((error: string, i: number) => (
								<div
									key={`error-${i}-${error.substring(0, 10)}`}
									className="text-sm p-2 bg-destructive/10 rounded-md"
								>
									<p className="text-destructive">{error}</p>
								</div>
							))}
						</div>
					</CardContent>
				</Card>
			)}

			<Card>
				<CardHeader>
					<CardTitle>Actions</CardTitle>
				</CardHeader>
				<CardContent>
					<Button
						onClick={handleResetStats}
						variant="destructive"
						disabled={resetStatsMutation.isPending}
					>
						Reset All Statistics
					</Button>
				</CardContent>
			</Card>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/StrategyCard.tsx">
import { RefreshCw, Settings } from "lucide-react";
import { useCallback, useEffect, useState } from "react";
import { api } from "../api";
import { Badge } from "./ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "./ui/select";
import { Skeleton } from "./ui/skeleton";

export function StrategyCard() {
	const [currentStrategy, setCurrentStrategy] = useState<string>("");
	const [strategies, setStrategies] = useState<string[]>([]);
	const [loading, setLoading] = useState(true);
	const [changing, setChanging] = useState(false);
	const [error, setError] = useState<string | null>(null);
	const [success, setSuccess] = useState(false);

	const loadData = useCallback(async () => {
		try {
			setLoading(true);
			setError(null);
			const [current, list] = await Promise.all([
				api.getStrategy(),
				api.listStrategies(),
			]);
			setCurrentStrategy(current);
			setStrategies(list);
		} catch (err) {
			setError(err instanceof Error ? err.message : "Failed to load data");
		} finally {
			setLoading(false);
		}
	}, []);

	useEffect(() => {
		loadData();
	}, [loadData]);

	const handleStrategyChange = async (newStrategy: string) => {
		if (newStrategy === currentStrategy) return;

		try {
			setChanging(true);
			setError(null);
			setSuccess(false);
			await api.setStrategy(newStrategy);
			setCurrentStrategy(newStrategy);
			setSuccess(true);
			setTimeout(() => setSuccess(false), 3000);
		} catch (err) {
			setError(
				err instanceof Error ? err.message : "Failed to update strategy",
			);
		} finally {
			setChanging(false);
		}
	};

	if (loading) {
		return (
			<Card>
				<CardHeader>
					<CardTitle>Load Balancer Strategy</CardTitle>
					<CardDescription>
						Configure how requests are distributed across accounts
					</CardDescription>
				</CardHeader>
				<CardContent>
					<Skeleton className="h-10 w-full" />
				</CardContent>
			</Card>
		);
	}

	return (
		<Card className="card-hover">
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle className="flex items-center gap-2">
							<Settings className="h-5 w-5" />
							Load Balancer Strategy
						</CardTitle>
						<CardDescription>
							Configure how requests are distributed across accounts
						</CardDescription>
					</div>
					{success && (
						<Badge variant="default" className="bg-success">
							Updated
						</Badge>
					)}
				</div>
			</CardHeader>
			<CardContent>
				<div className="space-y-4">
					<div>
						<p className="text-sm font-medium mb-2">Current Strategy</p>
						<Select
							value={currentStrategy}
							onValueChange={handleStrategyChange}
							disabled={changing}
						>
							<SelectTrigger className="w-full">
								<SelectValue placeholder="Select a strategy" />
							</SelectTrigger>
							<SelectContent>
								{strategies.map((strategy) => (
									<SelectItem key={strategy} value={strategy}>
										{strategy}
									</SelectItem>
								))}
							</SelectContent>
						</Select>
					</div>

					{changing && (
						<div className="flex items-center gap-2 text-sm text-muted-foreground">
							<RefreshCw className="h-4 w-4 animate-spin" />
							Updating strategy...
						</div>
					)}

					{error && (
						<div className="text-sm text-destructive">Error: {error}</div>
					)}

					<div className="text-xs text-muted-foreground">
						<p>
							<strong>session:</strong> Maintains 5-hour sessions with a single
							account to minimize rate limits
						</p>
					</div>
				</div>
			</CardContent>
		</Card>
	);
}
</file>

<file path="packages/dashboard-web/src/components/theme-toggle.tsx">
import { Monitor, Moon, Sun } from "lucide-react";
import { useTheme } from "../contexts/theme-context";
import { Button } from "./ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "./ui/dropdown-menu";

export function ThemeToggle() {
	const { setTheme } = useTheme();

	return (
		<DropdownMenu>
			<DropdownMenuTrigger asChild>
				<Button variant="ghost" size="sm" className="w-9 px-0">
					<Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
					<Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
					<span className="sr-only">Toggle theme</span>
				</Button>
			</DropdownMenuTrigger>
			<DropdownMenuContent align="end">
				<DropdownMenuItem onClick={() => setTheme("light")}>
					<Sun className="mr-2 h-4 w-4" />
					<span>Light</span>
				</DropdownMenuItem>
				<DropdownMenuItem onClick={() => setTheme("dark")}>
					<Moon className="mr-2 h-4 w-4" />
					<span>Dark</span>
				</DropdownMenuItem>
				<DropdownMenuItem onClick={() => setTheme("system")}>
					<Monitor className="mr-2 h-4 w-4" />
					<span>System</span>
				</DropdownMenuItem>
			</DropdownMenuContent>
		</DropdownMenu>
	);
}
</file>

<file path="packages/dashboard-web/src/components/TokenUsageDisplay.tsx">
import { processTokenUsage } from "@ccflare/ui-common";
import type { RequestSummary } from "../api";

interface TokenUsageDisplayProps {
	summary: RequestSummary | undefined;
}

export function TokenUsageDisplay({ summary }: TokenUsageDisplayProps) {
	// Convert RequestSummary to TokenUsageData format, handling null -> undefined conversion
	const tokenData = summary
		? {
				inputTokens: summary.inputTokens,
				outputTokens: summary.outputTokens,
				cacheReadInputTokens: summary.cacheReadInputTokens,
				cacheCreationInputTokens: summary.cacheCreationInputTokens,
				totalTokens: summary.totalTokens,
				costUsd: summary.costUsd,
				responseTimeMs: summary.responseTimeMs ?? undefined,
				tokensPerSecond: summary.tokensPerSecond,
			}
		: undefined;

	const usage = processTokenUsage(tokenData);

	if (!usage.hasData) {
		return (
			<div className="text-center text-muted-foreground py-8">
				<p>No token usage data available</p>
			</div>
		);
	}

	const { sections } = usage;

	return (
		<div className="space-y-4">
			<div className="grid grid-cols-2 gap-4">
				{sections.inputTokens && (
					<div className="bg-muted p-4 rounded-lg">
						<h4 className="font-semibold mb-2">{sections.inputTokens.label}</h4>
						<p className="text-2xl font-mono">{sections.inputTokens.value}</p>
					</div>
				)}

				{sections.outputTokens && (
					<div className="bg-muted p-4 rounded-lg">
						<h4 className="font-semibold mb-2">
							{sections.outputTokens.label}
						</h4>
						<p className="text-2xl font-mono">{sections.outputTokens.value}</p>
					</div>
				)}

				{sections.cacheReadTokens && (
					<div className="bg-muted p-4 rounded-lg">
						<h4 className="font-semibold mb-2">
							{sections.cacheReadTokens.label}
						</h4>
						<p className="text-2xl font-mono">
							{sections.cacheReadTokens.value}
						</p>
					</div>
				)}

				{sections.cacheCreationTokens && (
					<div className="bg-muted p-4 rounded-lg">
						<h4 className="font-semibold mb-2">
							{sections.cacheCreationTokens.label}
						</h4>
						<p className="text-2xl font-mono">
							{sections.cacheCreationTokens.value}
						</p>
					</div>
				)}
			</div>

			{sections.totalTokens && (
				<div className="bg-primary/10 p-4 rounded-lg">
					<h4 className="font-semibold mb-2">{sections.totalTokens.label}</h4>
					<p className="text-3xl font-mono font-bold">
						{sections.totalTokens.value}
					</p>
					{sections.cost && (
						<p className="mt-2 text-lg text-muted-foreground">
							{sections.cost.label}: {sections.cost.value}
						</p>
					)}
				</div>
			)}

			{sections.responseTime && (
				<div className="bg-muted p-4 rounded-lg">
					<h4 className="font-semibold mb-2">{sections.responseTime.label}</h4>
					<p className="text-2xl font-mono">{sections.responseTime.value}</p>
				</div>
			)}

			{sections.tokensPerSecond && (
				<div className="bg-muted p-4 rounded-lg">
					<h4 className="font-semibold mb-2">
						{sections.tokensPerSecond.label}
					</h4>
					<p className="text-2xl font-mono">{sections.tokensPerSecond.value}</p>
				</div>
			)}
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/contexts/theme-context.tsx">
import type React from "react";
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

type ThemeContextType = {
	theme: Theme;
	setTheme: (theme: Theme) => void;
};

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
	const [theme, setTheme] = useState<Theme>(() => {
		const stored = localStorage.getItem("theme") as Theme;
		return stored || "system";
	});

	useEffect(() => {
		const root = window.document.documentElement;
		root.classList.remove("light", "dark");

		let effectiveTheme = theme;
		if (theme === "system") {
			effectiveTheme = window.matchMedia("(prefers-color-scheme: dark)").matches
				? "dark"
				: "light";
		}

		root.classList.add(effectiveTheme);
		localStorage.setItem("theme", theme);
	}, [theme]);

	useEffect(() => {
		if (theme === "system") {
			const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
			const handleChange = () => {
				const root = window.document.documentElement;
				root.classList.remove("light", "dark");
				root.classList.add(mediaQuery.matches ? "dark" : "light");
			};

			mediaQuery.addEventListener("change", handleChange);
			return () => mediaQuery.removeEventListener("change", handleChange);
		}
	}, [theme]);

	return (
		<ThemeContext.Provider value={{ theme, setTheme }}>
			{children}
		</ThemeContext.Provider>
	);
}

export function useTheme() {
	const context = useContext(ThemeContext);
	if (!context) {
		throw new Error("useTheme must be used within a ThemeProvider");
	}
	return context;
}
</file>

<file path="packages/dashboard-web/src/hooks/useApiError.ts">
import {
	type ErrorFormatterOptions,
	type ErrorType,
	formatError as formatErrorFromPackage,
	getErrorType,
	isAuthError as isAuthErrorCheck,
	isNetworkError as isNetworkErrorCheck,
	isRateLimitError as isRateLimitErrorCheck,
} from "@ccflare/errors";
import { useCallback, useMemo } from "react";

export interface UseApiErrorOptions extends ErrorFormatterOptions {
	/**
	 * Whether to log errors to console
	 * @default false
	 */
	logErrors?: boolean;
}

export interface UseApiErrorReturn {
	/**
	 * Format an error into a user-friendly message
	 */
	formatError: (error: unknown) => string;
	/**
	 * Check if an error is a network error
	 */
	isNetworkError: (error: unknown) => boolean;
	/**
	 * Check if an error is an authentication error
	 */
	isAuthError: (error: unknown) => boolean;
	/**
	 * Check if an error is a rate limit error
	 */
	isRateLimitError: (error: unknown) => boolean;
	/**
	 * Get error type
	 */
	getErrorType: (error: unknown) => ErrorType;
}

/**
 * Hook for consistent error handling across the dashboard
 *
 * @example
 * ```tsx
 * const { formatError, isNetworkError } = useApiError({
 *   errorMap: {
 *     "Network Error": "Unable to connect to the server. Please check your connection.",
 *   }
 * });
 *
 * try {
 *   await api.getAccounts();
 * } catch (err) {
 *   const message = formatError(err);
 *   setError(message);
 * }
 * ```
 */
export function useApiError(
	options: UseApiErrorOptions = {},
): UseApiErrorReturn {
	const { logErrors = false, ...formatOptions } = options;

	// Memoize formatOptions to avoid re-creating on every render
	const memoizedFormatOptions = useMemo(
		() => ({
			...formatOptions,
			errorMap: {
				...formatOptions.errorMap,
				// Override auth error message for dashboard context
				unauthorized: "Authentication failed. Please re-add your account.",
				401: "Authentication failed. Please re-add your account.",
			},
		}),
		// biome-ignore lint/correctness/useExhaustiveDependencies: formatOptions is destructured from options
		[formatOptions],
	);

	const formatError = useCallback(
		(error: unknown): string => {
			if (logErrors) {
				console.error("[API Error]", error);
			}

			// Use the formatError from the errors package with custom auth message
			return formatErrorFromPackage(error, memoizedFormatOptions);
		},
		[logErrors, memoizedFormatOptions],
	);

	const isNetworkError = useCallback((error: unknown): boolean => {
		return isNetworkErrorCheck(error);
	}, []);

	const isAuthError = useCallback((error: unknown): boolean => {
		return isAuthErrorCheck(error);
	}, []);

	const isRateLimitError = useCallback((error: unknown): boolean => {
		return isRateLimitErrorCheck(error);
	}, []);

	const getErrorTypeWrapper = useCallback((error: unknown): ErrorType => {
		return getErrorType(error);
	}, []);

	return useMemo(
		() => ({
			formatError,
			isNetworkError,
			isAuthError,
			isRateLimitError,
			getErrorType: getErrorTypeWrapper,
		}),
		[
			formatError,
			isNetworkError,
			isAuthError,
			isRateLimitError,
			getErrorTypeWrapper,
		],
	);
}
</file>

<file path="packages/dashboard-web/src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}
</file>

<file path="packages/dashboard-web/src/favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <defs>
    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:1" />
    </linearGradient>
  </defs>
  <rect width="100" height="100" rx="20" fill="url(#gradient)"/>
  <text x="50" y="65" font-family="system-ui, -apple-system, sans-serif" font-size="48" font-weight="bold" text-anchor="middle" fill="white">CF</text>
</svg>
</file>

<file path="packages/dashboard-web/src/global.d.ts">
/// <reference lib="dom" />
/// <reference lib="dom.iterable" />

declare global {
	interface Window {
		EventSource: typeof EventSource;
	}
}

export {};
</file>

<file path="packages/dashboard-web/src/index.css">
@import "../styles/globals.css";

@layer base {
	:root {
		@apply font-sans;
	}

	body {
		@apply min-w-[320px] min-h-screen relative m-0 bg-background text-foreground;
	}
}
</file>

<file path="packages/dashboard-web/src/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
    <title>ccflare Dashboard</title>
    <script type="module" src="./frontend.tsx" async></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
</file>

<file path="packages/dashboard-web/styles/globals.css">
@import "tailwindcss";

@plugin "tailwindcss-animate";

@custom-variant dark (&:is(.dark *));

:root {
	--background: hsl(0 0% 100%);
	--foreground: hsl(240 10% 3.9%);
	--card: hsl(0 0% 100%);
	--card-foreground: hsl(240 10% 3.9%);
	--popover: hsl(0 0% 100%);
	--popover-foreground: hsl(240 10% 3.9%);
	--primary: hsl(24 89% 56%); /* ccflare Orange #F38020 */
	--primary-foreground: hsl(0 0% 100%);
	--secondary: hsl(240 4.8% 95.9%);
	--secondary-foreground: hsl(240 5.9% 10%);
	--muted: hsl(240 4.8% 95.9%);
	--muted-foreground: hsl(240 3.8% 46.1%);
	--accent: hsl(24 89% 56%); /* ccflare Orange */
	--accent-foreground: hsl(0 0% 100%);
	--destructive: hsl(0 84.2% 60.2%);
	--destructive-foreground: hsl(0 0% 98%);
	--border: hsl(240 5.9% 90%);
	--input: hsl(240 5.9% 90%);
	--ring: hsl(24 89% 56%); /* ccflare Orange */
	--radius: 0.375rem;
	--cf-orange: #f38020;
}

.dark {
	--background: hsl(220 13% 8%); /* Dark background like ccflare */
	--foreground: hsl(0 0% 95%);
	--card: hsl(220 13% 12%);
	--card-foreground: hsl(0 0% 95%);
	--popover: hsl(220 13% 12%);
	--popover-foreground: hsl(0 0% 95%);
	--primary: hsl(24 89% 56%); /* ccflare Orange */
	--primary-foreground: hsl(0 0% 100%);
	--secondary: hsl(220 13% 18%);
	--secondary-foreground: hsl(0 0% 95%);
	--muted: hsl(220 13% 18%);
	--muted-foreground: hsl(220 9% 55%);
	--accent: hsl(24 89% 56%); /* ccflare Orange */
	--accent-foreground: hsl(0 0% 100%);
	--destructive: hsl(0 84.2% 60.2%);
	--destructive-foreground: hsl(0 0% 98%);
	--border: hsl(220 13% 20%);
	--input: hsl(220 13% 18%);
	--ring: hsl(24 89% 56%); /* ccflare Orange */
	--cf-orange: #f38020;
}

@theme inline {
	--color-background: var(--background);
	--color-foreground: var(--foreground);
	--color-card: var(--card);
	--color-card-foreground: var(--card-foreground);
	--color-popover: var(--popover);
	--color-popover-foreground: var(--popover-foreground);
	--color-primary: var(--primary);
	--color-primary-foreground: var(--primary-foreground);
	--color-secondary: var(--secondary);
	--color-secondary-foreground: var(--secondary-foreground);
	--color-muted: var(--muted);
	--color-muted-foreground: var(--muted-foreground);
	--color-accent: var(--accent);
	--color-accent-foreground: var(--accent-foreground);
	--color-destructive: var(--destructive);
	--color-destructive-foreground: var(--destructive-foreground);
	--color-border: var(--border);
	--color-input: var(--input);
	--color-ring: var(--ring);
	--radius-sm: calc(var(--radius) - 4px);
	--radius-md: calc(var(--radius) - 2px);
	--radius-lg: var(--radius);
	--radius-xl: calc(var(--radius) + 4px);
	--animate-accordion-down: accordion-down 0.2s ease-out;
	--animate-accordion-up: accordion-up 0.2s ease-out;

	@keyframes accordion-down {
		from {
			height: 0;
		}
		to {
			height: var(--radix-accordion-content-height);
		}
	}

	@keyframes accordion-up {
		from {
			height: var(--radix-accordion-content-height);
		}
		to {
			height: 0;
		}
	}
}

@layer base {
	* {
		@apply border-border outline-ring/50;
	}
	body {
		@apply bg-background text-foreground antialiased;
		font-feature-settings:
			"rlig" 1,
			"calt" 1;
	}

	/* Custom scrollbar */
	::-webkit-scrollbar {
		width: 10px;
		height: 10px;
	}

	::-webkit-scrollbar-track {
		@apply bg-background;
	}

	::-webkit-scrollbar-thumb {
		@apply bg-muted-foreground/20 rounded-md;
	}

	::-webkit-scrollbar-thumb:hover {
		@apply bg-muted-foreground/30;
	}

	/* Charts custom styling */
	.recharts-surface {
		overflow: visible;
	}

	/* Smooth transitions for theme switching */
	* {
		transition:
			background-color 0.2s ease-in-out,
			border-color 0.2s ease-in-out;
	}

	/* Glass morphism effects */
	.glass {
		@apply bg-background/80 backdrop-blur-md;
	}

	/* Gradient text */
	.gradient-text {
		background: linear-gradient(135deg, var(--cf-orange) 0%, #f97316 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	/* Card hover effects */
	.card-hover {
		@apply transition-all duration-200 hover:shadow-lg hover:scale-[1.02];
	}

	/* Success/Error/Warning colors */
	.text-success {
		@apply text-green-600 dark:text-green-400;
	}

	.text-warning {
		@apply text-yellow-600 dark:text-yellow-400;
	}

	.bg-success {
		@apply bg-green-100 dark:bg-green-900/20;
	}

	.bg-warning {
		@apply bg-yellow-100 dark:bg-yellow-900/20;
	}
}
</file>

<file path="packages/dashboard-web/build.ts">
#!/usr/bin/env bun
import { existsSync } from "node:fs";
import { rm, writeFile } from "node:fs/promises";
import path from "node:path";
import plugin from "bun-plugin-tailwind";

console.log("\n🚀 Building dashboard...\n");

const outdir = path.join(process.cwd(), "dist");

if (existsSync(outdir)) {
	console.log(`🗑️ Cleaning previous build at ${outdir}`);
	await rm(outdir, { recursive: true, force: true });
}

const start = performance.now();

const entrypoints = ["src/index.html"];
console.log(`📄 Building dashboard from ${entrypoints[0]}\n`);

const result = await Bun.build({
	entrypoints,
	outdir,
	plugins: [plugin],
	minify: true,
	target: "browser",
	sourcemap: "linked",
	splitting: true,
	define: {
		"process.env.NODE_ENV": JSON.stringify("production"),
	},
});

// Generate manifest.json with asset mappings
const manifest: Record<string, string> = {};
for (const output of result.outputs) {
	const relativePath = path.relative(outdir, output.path);
	const publicPath = `/${relativePath}`;
	manifest[publicPath] = publicPath;
}

await writeFile(
	path.join(outdir, "manifest.json"),
	JSON.stringify(manifest, null, 2),
);

const end = performance.now();
const buildTime = (end - start).toFixed(2);

console.log(`✅ Dashboard build completed in ${buildTime}ms\n`);
console.log(`📦 Output files:`);
result.outputs.forEach((output) => {
	console.log(`   - ${path.relative(process.cwd(), output.path)}`);
});
</file>

<file path="packages/dashboard-web/bunfig.toml">
[serve.static]
plugins = ["bun-plugin-tailwind"]
env = "BUN_PUBLIC_*"
</file>

<file path="packages/dashboard-web/components.json">
{
	"$schema": "https://ui.shadcn.com/schema.json",
	"style": "new-york",
	"rsc": false,
	"tsx": true,
	"tailwind": {
		"config": "",
		"css": "styles/globals.css",
		"baseColor": "zinc",
		"cssVariables": true,
		"prefix": ""
	},
	"aliases": {
		"components": "@/components",
		"utils": "@/lib/utils",
		"ui": "@/components/ui",
		"lib": "@/lib",
		"hooks": "@/hooks"
	},
	"iconLibrary": "lucide"
}
</file>

<file path="packages/dashboard-web/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"lib": ["ESNext", "DOM", "DOM.Iterable"],
		"target": "ESNext",
		"module": "ESNext",
		"moduleDetection": "force",
		"jsx": "react-jsx",
		"allowJs": true,
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"verbatimModuleSyntax": true,
		"noEmit": true,
		"strict": true,
		"skipLibCheck": true,
		"noFallthroughCasesInSwitch": true,
		"baseUrl": ".",
		"paths": {
			"@/*": ["./src/*"]
		}
	},
	"include": ["src/**/*"],
	"exclude": ["dist", "node_modules"]
}
</file>

<file path="packages/database/src/repositories/base.repository.ts">
import type { Database } from "bun:sqlite";

type QueryParams = Array<string | number | boolean | null | Buffer>;

export abstract class BaseRepository<_T> {
	constructor(protected db: Database) {}

	protected query<R>(sql: string, params: QueryParams = []): R[] {
		return this.db.query<R, QueryParams>(sql).all(...params) as R[];
	}

	protected get<R>(sql: string, params: QueryParams = []): R | null {
		const result = this.db.query<R, QueryParams>(sql).get(...params);
		return result as R | null;
	}

	protected run(sql: string, params: QueryParams = []): void {
		this.db.run(sql, params);
	}

	protected runWithChanges(sql: string, params: QueryParams = []): number {
		const result = this.db.run(sql, params);
		return result.changes;
	}
}
</file>

<file path="packages/database/src/repositories/oauth.repository.ts">
import { BaseRepository } from "./base.repository";

export interface OAuthSession {
	accountName: string;
	verifier: string;
	mode: "console" | "max";
	tier: number;
}

export class OAuthRepository extends BaseRepository<OAuthSession> {
	createSession(
		sessionId: string,
		accountName: string,
		verifier: string,
		mode: "console" | "max",
		tier: number,
		ttlMinutes = 10,
	): void {
		const now = Date.now();
		const expiresAt = now + ttlMinutes * 60 * 1000;

		this.run(
			`
			INSERT INTO oauth_sessions (id, account_name, verifier, mode, tier, created_at, expires_at)
			VALUES (?, ?, ?, ?, ?, ?, ?)
		`,
			[sessionId, accountName, verifier, mode, tier, now, expiresAt],
		);
	}

	getSession(sessionId: string): OAuthSession | null {
		const row = this.get<{
			account_name: string;
			verifier: string;
			mode: "console" | "max";
			tier: number;
			expires_at: number;
		}>(
			`
			SELECT account_name, verifier, mode, tier, expires_at 
			FROM oauth_sessions 
			WHERE id = ? AND expires_at > ?
		`,
			[sessionId, Date.now()],
		);

		if (!row) return null;

		return {
			accountName: row.account_name,
			verifier: row.verifier,
			mode: row.mode,
			tier: row.tier,
		};
	}

	deleteSession(sessionId: string): void {
		this.run(`DELETE FROM oauth_sessions WHERE id = ?`, [sessionId]);
	}

	cleanupExpiredSessions(): number {
		return this.runWithChanges(
			`DELETE FROM oauth_sessions WHERE expires_at <= ?`,
			[Date.now()],
		);
	}
}
</file>

<file path="packages/database/src/repositories/stats.repository.ts">
/**
 * Consolidated stats repository to eliminate duplication between tui-core and http-api
 */
import type { Database } from "bun:sqlite";
import { NO_ACCOUNT_ID } from "@ccflare/types";

export interface AccountStats {
	name: string;
	requestCount: number;
	successRate: number;
	totalRequests?: number;
}

export interface AggregatedStats {
	totalRequests: number;
	successfulRequests: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	inputTokens: number;
	outputTokens: number;
	cacheReadInputTokens: number;
	cacheCreationInputTokens: number;
	avgTokensPerSecond: number | null;
}

export class StatsRepository {
	constructor(private db: Database) {}

	/**
	 * Get aggregated statistics for all requests
	 */
	getAggregatedStats(): AggregatedStats {
		const stats = this.db
			.query(
				`SELECT 
					COUNT(*) as totalRequests,
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successfulRequests,
					AVG(response_time_ms) as avgResponseTime,
					SUM(input_tokens) as inputTokens,
					SUM(output_tokens) as outputTokens,
					SUM(cache_creation_input_tokens) as cacheCreationInputTokens,
					SUM(cache_read_input_tokens) as cacheReadInputTokens,
					SUM(cost_usd) as totalCostUsd,
					AVG(output_tokens_per_second) as avgTokensPerSecond
				FROM requests`,
			)
			.get() as AggregatedStats;

		// Calculate total tokens
		const totalTokens =
			(stats.inputTokens || 0) +
			(stats.outputTokens || 0) +
			(stats.cacheCreationInputTokens || 0) +
			(stats.cacheReadInputTokens || 0);

		return {
			...stats,
			totalTokens,
			avgResponseTime: stats.avgResponseTime || 0,
			totalCostUsd: stats.totalCostUsd || 0,
		};
	}

	/**
	 * Get account statistics with success rates
	 * This consolidates the duplicated logic between tui-core and http-api
	 */
	getAccountStats(limit = 10, includeUnauthenticated = true): AccountStats[] {
		// Get account request counts
		const accountStatsQuery = includeUnauthenticated
			? `
				SELECT 
					COALESCE(a.id, ?) as id,
					COALESCE(a.name, ?) as name,
					COUNT(r.id) as requestCount,
					COALESCE(a.total_requests, 0) as totalRequests
				FROM requests r
				LEFT JOIN accounts a ON a.id = r.account_used
				GROUP BY COALESCE(a.id, ?), COALESCE(a.name, ?)
				HAVING requestCount > 0
				ORDER BY requestCount DESC
				LIMIT ?
			`
			: `
				SELECT 
					a.id,
					a.name,
					a.request_count as requestCount,
					a.total_requests as totalRequests
				FROM accounts a
				WHERE a.request_count > 0
				ORDER BY a.request_count DESC
				LIMIT ?
			`;

		const params = includeUnauthenticated
			? [NO_ACCOUNT_ID, NO_ACCOUNT_ID, NO_ACCOUNT_ID, NO_ACCOUNT_ID, limit]
			: [limit];

		const accountStats = this.db
			.query(accountStatsQuery)
			.all(...params) as Array<{
			id: string;
			name: string;
			requestCount: number;
			totalRequests: number;
		}>;

		// Calculate success rate per account using a batch query
		if (accountStats.length === 0) return [];

		const accountIds = accountStats.map((a) => a.id);
		const placeholders = accountIds.map(() => "?").join(",");

		const successRates = this.db
			.query(
				`SELECT 
					account_used as accountId,
					COUNT(*) as total,
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful
				FROM requests
				WHERE account_used IN (${placeholders})
				GROUP BY account_used`,
			)
			.all(...accountIds) as Array<{
			accountId: string;
			total: number;
			successful: number;
		}>;

		// Create a map for O(1) lookup
		const successRateMap = new Map(
			successRates.map((sr) => [
				sr.accountId,
				sr.total > 0 ? Math.round((sr.successful / sr.total) * 100) : 0,
			]),
		);

		// Combine the data
		return accountStats.map((acc) => ({
			name: acc.name,
			requestCount: acc.requestCount,
			successRate: successRateMap.get(acc.id) || 0,
			totalRequests: acc.totalRequests,
		}));
	}

	/**
	 * Get count of active accounts
	 */
	getActiveAccountCount(): number {
		const result = this.db
			.query("SELECT COUNT(*) as count FROM accounts WHERE request_count > 0")
			.get() as { count: number };
		return result.count;
	}

	/**
	 * Get recent errors (already exists in request.repository, but adding for completeness)
	 */
	getRecentErrors(limit = 10): string[] {
		const errors = this.db
			.query(
				`SELECT DISTINCT error_message
				FROM requests
				WHERE error_message IS NOT NULL
					AND error_message != ''
				ORDER BY timestamp DESC
				LIMIT ?`,
			)
			.all(limit) as Array<{ error_message: string }>;

		return errors.map((e) => e.error_message);
	}

	/**
	 * Get top models by usage
	 */
	getTopModels(
		limit = 5,
	): Array<{ model: string; count: number; percentage: number }> {
		const models = this.db
			.query(
				`WITH model_counts AS (
					SELECT 
						model,
						COUNT(*) as count
					FROM requests
					WHERE model IS NOT NULL
					GROUP BY model
				),
				total AS (
					SELECT COUNT(*) as total FROM requests WHERE model IS NOT NULL
				)
				SELECT 
					mc.model,
					mc.count,
					ROUND(CAST(mc.count AS REAL) / t.total * 100, 2) as percentage
				FROM model_counts mc, total t
				ORDER BY mc.count DESC
				LIMIT ?`,
			)
			.all(limit) as Array<{
			model: string;
			count: number;
			percentage: number;
		}>;

		return models;
	}
}
</file>

<file path="packages/database/src/repositories/strategy.repository.ts">
import { BaseRepository } from "./base.repository";

export interface StrategyData {
	name: string;
	config: Record<string, unknown>;
	updatedAt: number;
}

export class StrategyRepository extends BaseRepository<StrategyData> {
	getStrategy(name: string): StrategyData | null {
		const row = super.get<{ name: string; config: string; updated_at: number }>(
			`SELECT name, config, updated_at FROM strategies WHERE name = ?`,
			[name],
		);

		if (!row) return null;

		return {
			name: row.name,
			config: JSON.parse(row.config),
			updatedAt: row.updated_at,
		};
	}

	set(name: string, config: Record<string, unknown>): void {
		const now = Date.now();
		const configJson = JSON.stringify(config);

		this.run(
			`INSERT OR REPLACE INTO strategies (name, config, updated_at) VALUES (?, ?, ?)`,
			[name, configJson, now],
		);
	}

	list(): StrategyData[] {
		const rows = this.query<{
			name: string;
			config: string;
			updated_at: number;
		}>(`SELECT name, config, updated_at FROM strategies ORDER BY name`);

		return rows.map((row) => ({
			name: row.name,
			config: JSON.parse(row.config),
			updatedAt: row.updated_at,
		}));
	}

	delete(name: string): boolean {
		const changes = this.runWithChanges(
			`DELETE FROM strategies WHERE name = ?`,
			[name],
		);
		return changes > 0;
	}
}
</file>

<file path="packages/database/src/analyze-performance.ts">
#!/usr/bin/env bun
import { Database } from "bun:sqlite";
import { Logger } from "@ccflare/logger";
import { resolveDbPath } from "./paths";
import { analyzeIndexUsage } from "./performance-indexes";

const log = new Logger("PerformanceAnalysis");

/**
 * Analyze query performance and index usage
 */
function analyzeQueryPerformance(db: Database) {
	log.info("\n=== Query Performance Analysis ===\n");

	// Test queries that should benefit from the new indexes
	const testQueries = [
		{
			name: "Time-based account analytics",
			query: `
				SELECT COUNT(*), account_used 
				FROM requests 
				WHERE timestamp > ? AND account_used IS NOT NULL 
				GROUP BY account_used
			`,
			params: [Date.now() - 24 * 60 * 60 * 1000], // Last 24 hours
		},
		{
			name: "Model performance with timestamp filter",
			query: `
				SELECT model, COUNT(*), AVG(response_time_ms)
				FROM requests 
				WHERE timestamp > ? AND model IS NOT NULL 
				GROUP BY model
			`,
			params: [Date.now() - 24 * 60 * 60 * 1000],
		},
		{
			name: "Success rate calculation",
			query: `
				SELECT 
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as success_rate
				FROM requests 
				WHERE timestamp > ?
			`,
			params: [Date.now() - 24 * 60 * 60 * 1000],
		},
		{
			name: "Active accounts lookup",
			query: `
				SELECT id, name, request_count 
				FROM accounts 
				WHERE paused = 0 
				ORDER BY request_count DESC
			`,
			params: [],
		},
		{
			name: "Cost analysis by model",
			query: `
				SELECT model, SUM(cost_usd) as total_cost
				FROM requests 
				WHERE cost_usd > 0 AND model IS NOT NULL 
				GROUP BY model 
				ORDER BY total_cost DESC
			`,
			params: [],
		},
		{
			name: "P95 response time calculation",
			query: `
				WITH ordered_times AS (
					SELECT 
						response_time_ms,
						ROW_NUMBER() OVER (ORDER BY response_time_ms) as row_num,
						COUNT(*) OVER () as total_count
					FROM requests 
					WHERE model = ? AND response_time_ms IS NOT NULL
				)
				SELECT response_time_ms as p95_response_time
				FROM ordered_times
				WHERE row_num = CAST(CEIL(total_count * 0.95) AS INTEGER)
				LIMIT 1
			`,
			params: ["claude-3-5-sonnet-20241022"],
		},
	];

	// Run each test query with EXPLAIN QUERY PLAN
	for (const test of testQueries) {
		log.info(`\n--- ${test.name} ---`);

		try {
			// Get query plan
			const planStmt = db.prepare(`EXPLAIN QUERY PLAN ${test.query}`);
			const plan = planStmt.all(...test.params);
			log.info("Query Plan:");
			for (const row of plan) {
				log.info(`  ${JSON.stringify(row)}`);
			}

			// Time the actual query
			const start = performance.now();
			const stmt = db.prepare(test.query);
			const result = stmt.all(...test.params);
			const duration = performance.now() - start;

			log.info(`Execution time: ${duration.toFixed(2)}ms`);
			log.info(`Rows returned: ${result.length}`);
		} catch (error) {
			log.error(`Error: ${error}`);
		}
	}
}

/**
 * Show index statistics
 */
function showIndexStats(db: Database) {
	log.info("\n=== Index Statistics ===\n");

	// Get index list with size estimates
	const indexes = db
		.prepare(`
			SELECT 
				m.name as index_name,
				m.tbl_name as table_name,
				m.sql as create_sql,
				s.stat as stat_value
			FROM sqlite_master m
			LEFT JOIN sqlite_stat1 s ON m.name = s.idx
			WHERE m.type = 'index' 
				AND m.name NOT LIKE 'sqlite_%'
				AND m.name LIKE 'idx_%'
			ORDER BY m.tbl_name, m.name
		`)
		.all() as Array<{
		index_name: string;
		table_name: string;
		create_sql: string;
		stat_value: string | null;
	}>;

	log.info(`Total performance indexes: ${indexes.length}\n`);

	let currentTable = "";
	for (const index of indexes) {
		if (index.table_name !== currentTable) {
			currentTable = index.table_name;
			log.info(`\n${currentTable}:`);
		}
		log.info(`  - ${index.index_name}`);
		if (index.stat_value) {
			log.info(`    Stats: ${index.stat_value}`);
		}
	}

	// Run ANALYZE to update statistics
	log.info("\nRunning ANALYZE to update statistics...");
	db.exec("ANALYZE");
	log.info("Statistics updated.");
}

/**
 * Main function
 */
function main() {
	const dbPath = resolveDbPath();
	log.info(`Analyzing database at: ${dbPath}\n`);

	const db = new Database(dbPath, { readonly: true });

	try {
		// Show basic index usage analysis
		analyzeIndexUsage(db);

		// Show detailed index statistics
		showIndexStats(db);

		// Analyze query performance
		analyzeQueryPerformance(db);

		log.info("\n=== Analysis Complete ===\n");
	} finally {
		db.close();
	}
}

// Run if called directly
if (import.meta.main) {
	main();
}
</file>

<file path="packages/database/src/async-writer.ts">
import type { Disposable } from "@ccflare/core";
import { Logger } from "@ccflare/logger";

const logger = new Logger("async-db-writer");

type DbJob = () => void | Promise<void>;

export class AsyncDbWriter implements Disposable {
	private queue: DbJob[] = [];
	private running = false;
	private intervalId: Timer | null = null;

	constructor() {
		// Process queue every 100ms
		this.intervalId = setInterval(() => void this.processQueue(), 100);
	}

	enqueue(job: DbJob): void {
		this.queue.push(job);
		// Immediately try to process if not already running
		void this.processQueue();
	}

	private async processQueue(): Promise<void> {
		if (this.running || this.queue.length === 0) {
			return;
		}

		this.running = true;

		try {
			while (this.queue.length > 0) {
				const job = this.queue.shift();
				if (!job) continue;
				try {
					await job();
				} catch (error) {
					logger.error("Failed to execute DB job", error);
				}
			}
		} finally {
			this.running = false;
		}
	}

	async dispose(): Promise<void> {
		logger.info("Flushing async DB writer queue...");

		// Stop the interval
		if (this.intervalId) {
			clearInterval(this.intervalId);
			this.intervalId = null;
		}

		// Process any remaining jobs
		await this.processQueue();

		logger.info("Async DB writer queue flushed", {
			remainingJobs: this.queue.length,
		});
	}
}
</file>

<file path="packages/database/src/factory.ts">
import { registerDisposable, unregisterDisposable } from "@ccflare/core";
import { DatabaseOperations, type RuntimeConfig } from "./index";

let instance: DatabaseOperations | null = null;
let dbPath: string | undefined;
let runtimeConfig: RuntimeConfig | undefined;

export function initialize(
	dbPathParam?: string,
	runtimeConfigParam?: RuntimeConfig,
): void {
	dbPath = dbPathParam;
	runtimeConfig = runtimeConfigParam;
}

export function getInstance(): DatabaseOperations {
	if (!instance) {
		instance = new DatabaseOperations(dbPath);
		if (runtimeConfig) {
			instance.setRuntimeConfig(runtimeConfig);
		}
		// Register with lifecycle manager
		registerDisposable(instance);
	}
	return instance;
}

export function closeAll(): void {
	if (instance) {
		unregisterDisposable(instance);
		instance.close();
		instance = null;
	}
}

export function reset(): void {
	closeAll();
}

export const DatabaseFactory = {
	initialize,
	getInstance,
	closeAll,
	reset,
};
</file>

<file path="packages/database/src/index.ts">
// Re-export the DatabaseOperations class
import { DatabaseOperations } from "./database-operations";
export { DatabaseOperations };

// Re-export other utilities
export { AsyncDbWriter } from "./async-writer";
export type { RuntimeConfig } from "./database-operations";
export { DatabaseFactory } from "./factory";
export { ensureSchema, runMigrations } from "./migrations";
export { resolveDbPath } from "./paths";
export { analyzeIndexUsage } from "./performance-indexes";

// Re-export repository types
export type { StatsRepository } from "./repositories/stats.repository";
</file>

<file path="packages/database/src/paths.ts">
import { join } from "node:path";
import { getPlatformConfigDir } from "@ccflare/config";

export function resolveDbPath(): string {
	// Check for explicit DB path from environment
	const explicitPath = process.env.ccflare_DB_PATH;
	if (explicitPath) {
		return explicitPath;
	}

	// Use common platform config directory
	const configDir = getPlatformConfigDir();
	return join(configDir, "ccflare.db");
}
</file>

<file path="packages/database/src/performance-indexes.ts">
import type { Database } from "bun:sqlite";
import { Logger } from "@ccflare/logger";

const log = new Logger("PerformanceIndexes");

/**
 * Add performance indexes to improve query performance
 * This migration adds indexes based on common query patterns in the application
 */
export function addPerformanceIndexes(db: Database): void {
	log.info("Adding performance indexes...");

	// 1. Composite index on requests(timestamp, account_used) for time-based account queries
	// Used in analytics for filtering by time range and account
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_timestamp_account 
		ON requests(timestamp DESC, account_used)
	`);
	log.info("Added index: idx_requests_timestamp_account");

	// 2. Index on requests(model, timestamp) for model analytics
	// Used in model distribution and performance queries
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_model_timestamp 
		ON requests(model, timestamp DESC) 
		WHERE model IS NOT NULL
	`);
	log.info("Added index: idx_requests_model_timestamp");

	// 3. Index on requests(success, timestamp) for success rate calculations
	// Used in analytics for calculating success rates over time
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_success_timestamp 
		ON requests(success, timestamp DESC)
	`);
	log.info("Added index: idx_requests_success_timestamp");

	// 4. Index on accounts(paused) for finding active accounts
	// Used in load balancer to quickly filter active accounts
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_paused 
		ON accounts(paused) 
		WHERE paused = 0
	`);
	log.info("Added index: idx_accounts_paused");

	// 5. Index on requests(account_used, timestamp) for per-account analytics
	// Used in account performance queries
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_account_timestamp 
		ON requests(account_used, timestamp DESC)
	`);
	log.info("Added index: idx_requests_account_timestamp");

	// 6. Additional indexes based on observed query patterns

	// Index for cost analysis queries
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_cost_model 
		ON requests(cost_usd, model, timestamp DESC) 
		WHERE cost_usd > 0 AND model IS NOT NULL
	`);
	log.info("Added index: idx_requests_cost_model");

	// Index for response time analysis (for p95 calculations)
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_response_time 
		ON requests(model, response_time_ms) 
		WHERE response_time_ms IS NOT NULL AND model IS NOT NULL
	`);
	log.info("Added index: idx_requests_response_time");

	// Index for token usage analysis
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_tokens 
		ON requests(timestamp DESC, total_tokens) 
		WHERE total_tokens > 0
	`);
	log.info("Added index: idx_requests_tokens");

	// Index for account name lookups (used in analytics joins)
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_name 
		ON accounts(name)
	`);
	log.info("Added index: idx_accounts_name");

	// Index for rate limit checks
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_rate_limited 
		ON accounts(rate_limited_until) 
		WHERE rate_limited_until IS NOT NULL
	`);
	log.info("Added index: idx_accounts_rate_limited");

	// Index for session management
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_session 
		ON accounts(session_start, session_request_count) 
		WHERE session_start IS NOT NULL
	`);
	log.info("Added index: idx_accounts_session");

	// Composite index for account ordering in load balancer
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_request_count 
		ON accounts(request_count DESC, last_used)
	`);
	log.info("Added index: idx_accounts_request_count");

	log.info("Performance indexes added successfully");
}

/**
 * Analyze current index usage and suggest optimizations
 */
export function analyzeIndexUsage(db: Database): void {
	log.info("\nAnalyzing index usage...");

	// Get all indexes
	const indexes = db
		.prepare(
			`SELECT name, tbl_name, sql 
			FROM sqlite_master 
			WHERE type = 'index' AND name NOT LIKE 'sqlite_%'
			ORDER BY tbl_name, name`,
		)
		.all() as Array<{ name: string; tbl_name: string; sql: string }>;

	log.info(`\nTotal indexes: ${indexes.length}`);
	for (const index of indexes) {
		log.info(`- ${index.name} on ${index.tbl_name}`);
	}

	// Analyze table statistics
	const tables = ["accounts", "requests", "request_payloads"];
	for (const table of tables) {
		const count = db
			.prepare(`SELECT COUNT(*) as count FROM ${table}`)
			.get() as { count: number };
		log.info(`\n${table} table: ${count.count} rows`);
	}
}
</file>

<file path="packages/database/package.json">
{
	"name": "@ccflare/database",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit",
		"analyze": "bun run ./src/analyze-performance.ts"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/logger": "workspace:*"
	}
}
</file>

<file path="packages/database/PERFORMANCE.md">
# Database Performance Optimizations

## Overview

This document describes the database indexes added to improve query performance in the Claude proxy load balancer.

## Indexes Added

### 1. Time-based Account Queries
- **Index**: `idx_requests_timestamp_account` on `requests(timestamp DESC, account_used)`
- **Purpose**: Speeds up analytics queries that filter by time range and account
- **Used by**: Analytics endpoints for per-account metrics

### 2. Model Analytics
- **Index**: `idx_requests_model_timestamp` on `requests(model, timestamp DESC)` WHERE `model IS NOT NULL`
- **Purpose**: Optimizes model distribution and performance queries
- **Used by**: Model analytics, performance metrics

### 3. Success Rate Calculations
- **Index**: `idx_requests_success_timestamp` on `requests(success, timestamp DESC)`
- **Purpose**: Speeds up success rate calculations over time periods
- **Used by**: Dashboard analytics, health checks

### 4. Active Account Lookups
- **Index**: `idx_accounts_paused` on `accounts(paused)` WHERE `paused = 0`
- **Purpose**: Quickly find active (non-paused) accounts
- **Used by**: Load balancer account selection

### 5. Per-Account Analytics
- **Index**: `idx_requests_account_timestamp` on `requests(account_used, timestamp DESC)`
- **Purpose**: Optimizes queries for individual account performance
- **Used by**: Account performance dashboards

### 6. Cost Analysis
- **Index**: `idx_requests_cost_model` on `requests(cost_usd, model, timestamp DESC)`
- **Purpose**: Speeds up cost analysis queries by model
- **Used by**: Cost tracking and billing analytics

### 7. Response Time Analysis
- **Index**: `idx_requests_response_time` on `requests(model, response_time_ms)`
- **Purpose**: Optimizes p95 percentile calculations
- **Used by**: Performance metrics, SLA monitoring

### 8. Token Usage
- **Index**: `idx_requests_tokens` on `requests(timestamp DESC, total_tokens)`
- **Purpose**: Speeds up token usage analytics
- **Used by**: Usage tracking, quota monitoring

### 9. Account Name Lookups
- **Index**: `idx_accounts_name` on `accounts(name)`
- **Purpose**: Optimizes joins between requests and accounts tables
- **Used by**: Analytics queries that filter by account name

### 10. Rate Limit Checks
- **Index**: `idx_accounts_rate_limited` on `accounts(rate_limited_until)`
- **Purpose**: Quickly identify rate-limited accounts
- **Used by**: Load balancer account selection

### 11. Session Management
- **Index**: `idx_accounts_session` on `accounts(session_start, session_request_count)`
- **Purpose**: Optimizes session-based load balancing
- **Used by**: Session strategy implementation

### 12. Request Count Ordering
- **Index**: `idx_accounts_request_count` on `accounts(request_count DESC, last_used)`
- **Purpose**: Speeds up account ordering for load balancing
- **Used by**: Various load balancing strategies

## Query Optimizations

### P95 Response Time Calculation
The p95 response time calculation has been optimized to use SQL window functions instead of loading all response times into memory:

```sql
WITH ordered_times AS (
  SELECT 
    response_time_ms,
    ROW_NUMBER() OVER (ORDER BY response_time_ms) as row_num,
    COUNT(*) OVER () as total_count
  FROM requests
  WHERE model = ? AND response_time_ms IS NOT NULL
)
SELECT response_time_ms as p95_response_time
FROM ordered_times
WHERE row_num = CAST(CEIL(total_count * 0.95) AS INTEGER)
LIMIT 1
```

## Performance Analysis

To analyze the performance impact of these indexes:

```bash
# From the database package directory
bun run analyze

# Or from the project root
cd packages/database && bun run analyze
```

This will show:
- Current index usage statistics
- Query execution plans
- Performance timings for common queries

## Maintenance Considerations

1. **Index Size**: The indexes add storage overhead but significantly improve query performance
2. **Write Performance**: Slight overhead on INSERT operations, but negligible for this use case
3. **Statistics**: Run `ANALYZE` periodically to keep query optimizer statistics current
4. **Monitoring**: Use the analyze script to verify indexes are being used effectively

## Future Optimizations

Consider these additional optimizations if needed:
1. Composite indexes for complex WHERE clauses
2. Covering indexes to avoid table lookups
3. Partial indexes for frequently filtered subsets
4. Query rewriting for better index utilization
</file>

<file path="packages/database/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/errors/src/index.ts">
// Re-export core errors that are available
export {
	OAuthError,
	ProviderError,
	RateLimitError,
	ServiceUnavailableError,
	TokenRefreshError,
	ValidationError,
} from "@ccflare/core";

// Error type constants
export const ERROR_TYPES = {
	NETWORK: "network",
	AUTH: "auth",
	RATE_LIMIT: "rate-limit",
	VALIDATION: "validation",
	SERVER: "server",
	UNKNOWN: "unknown",
} as const;

export type ErrorType = (typeof ERROR_TYPES)[keyof typeof ERROR_TYPES];

// HTTP error class for API responses
export class HttpError extends Error {
	constructor(
		public status: number,
		message: string,
		public details?: unknown,
	) {
		super(message);
		this.name = "HttpError";
	}
}

// Common HTTP error factories
export const BadRequest = (message: string, details?: unknown) =>
	new HttpError(400, message, details);

export const Unauthorized = (message: string, details?: unknown) =>
	new HttpError(401, message, details);

export const Forbidden = (message: string, details?: unknown) =>
	new HttpError(403, message, details);

export const NotFound = (message: string, details?: unknown) =>
	new HttpError(404, message, details);

export const Conflict = (message: string, details?: unknown) =>
	new HttpError(409, message, details);

export const UnprocessableEntity = (message: string, details?: unknown) =>
	new HttpError(422, message, details);

export const TooManyRequests = (message: string, details?: unknown) =>
	new HttpError(429, message, details);

export const InternalServerError = (message: string, details?: unknown) =>
	new HttpError(500, message, details);

export const BadGateway = (message: string, details?: unknown) =>
	new HttpError(502, message, details);

export const ServiceUnavailable = (message: string, details?: unknown) =>
	new HttpError(503, message, details);

export const GatewayTimeout = (message: string, details?: unknown) =>
	new HttpError(504, message, details);

// Error type detection
export function getErrorType(error: unknown): ErrorType {
	if (error instanceof HttpError) {
		if (error.status === 401) return ERROR_TYPES.AUTH;
		if (error.status === 429) return ERROR_TYPES.RATE_LIMIT;
		if (error.status >= 400 && error.status < 500)
			return ERROR_TYPES.VALIDATION;
		if (error.status >= 500) return ERROR_TYPES.SERVER;
	}

	if (error instanceof Error) {
		const message = error.message.toLowerCase();

		// Check for specific error types in message
		if (
			message.includes("network") ||
			message.includes("fetch failed") ||
			message.includes("connection") ||
			message.includes("econnrefused")
		) {
			return ERROR_TYPES.NETWORK;
		}

		if (
			message.includes("unauthorized") ||
			message.includes("authentication") ||
			message.includes("401") ||
			message.includes("token")
		) {
			return ERROR_TYPES.AUTH;
		}

		if (
			message.includes("rate limit") ||
			message.includes("too many requests") ||
			message.includes("429")
		) {
			return ERROR_TYPES.RATE_LIMIT;
		}

		if (
			message.includes("validation") ||
			message.includes("invalid") ||
			message.includes("bad request")
		) {
			return ERROR_TYPES.VALIDATION;
		}

		if (
			message.includes("server error") ||
			message.includes("500") ||
			message.includes("502") ||
			message.includes("503") ||
			message.includes("504")
		) {
			return ERROR_TYPES.SERVER;
		}
	}

	return ERROR_TYPES.UNKNOWN;
}

// Error type checkers
export const isNetworkError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.NETWORK;

export const isAuthError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.AUTH;

export const isRateLimitError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.RATE_LIMIT;

export const isValidationError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.VALIDATION;

export const isServerError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.SERVER;

// Default error messages
const DEFAULT_ERROR_MESSAGES: Record<ErrorType, string> = {
	[ERROR_TYPES.NETWORK]:
		"Network error. Please check your connection and try again.",
	[ERROR_TYPES.AUTH]: "Authentication failed. Please sign in again.",
	[ERROR_TYPES.RATE_LIMIT]: "Too many requests. Please try again later.",
	[ERROR_TYPES.VALIDATION]: "Invalid request. Please check your input.",
	[ERROR_TYPES.SERVER]: "Server error. Please try again later.",
	[ERROR_TYPES.UNKNOWN]: "An unexpected error occurred.",
};

// Error formatting options
export interface ErrorFormatterOptions {
	defaultMessage?: string;
	errorMap?: Record<string, string>;
	includeDetails?: boolean;
}

// Format error for user display
export function formatError(
	error: unknown,
	options: ErrorFormatterOptions = {},
): string {
	const {
		defaultMessage = DEFAULT_ERROR_MESSAGES[ERROR_TYPES.UNKNOWN],
		errorMap = {},
		includeDetails = false,
	} = options;

	// Handle null/undefined
	if (error == null) {
		return defaultMessage;
	}

	// Handle Error instances
	if (error instanceof Error) {
		const message = error.message;

		// Check error map for custom messages
		for (const [key, value] of Object.entries(errorMap)) {
			if (message.includes(key)) {
				return value;
			}
		}

		// Get error type and use default message if appropriate
		const errorType = getErrorType(error);
		const defaultTypeMessage = DEFAULT_ERROR_MESSAGES[errorType];

		// For known error types, prefer the default message unless includeDetails is true
		if (errorType !== ERROR_TYPES.UNKNOWN && !includeDetails) {
			return defaultTypeMessage;
		}

		// Return the actual error message
		return message;
	}

	// Handle string errors
	if (typeof error === "string") {
		return error;
	}

	// Handle objects with message property
	if (typeof error === "object" && error !== null && "message" in error) {
		return String(error.message);
	}

	// Fallback
	return defaultMessage;
}

// Parse HTTP response error
export async function parseHttpError(response: Response): Promise<HttpError> {
	let message = `HTTP ${response.status}: ${response.statusText}`;
	let details: unknown;

	try {
		const contentType = response.headers.get("content-type");
		if (contentType?.includes("application/json")) {
			const data = await response.json();
			if (data.error) {
				message =
					typeof data.error === "string"
						? data.error
						: data.error.message || message;
				details = data.error;
			} else if (data.message) {
				message = data.message;
				details = data;
			}
		} else {
			const text = await response.text();
			if (text) {
				message = text;
			}
		}
	} catch {
		// Ignore parsing errors
	}

	return new HttpError(response.status, message, details);
}
</file>

<file path="packages/errors/package.json">
{
	"name": "@ccflare/errors",
	"version": "1.0.0",
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"scripts": {
		"typecheck": "tsc --noEmit",
		"lint": "biome check --write --unsafe"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*"
	},
	"devDependencies": {
		"@types/bun": "1.1.15",
		"typescript": "5.7.2"
	}
}
</file>

<file path="packages/errors/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"baseUrl": ".",
		"outDir": "./dist",
		"rootDir": "./src"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}
</file>

<file path="packages/http-api/src/handlers/analytics.ts">
import {
	errorResponse,
	InternalServerError,
	jsonResponse,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import { NO_ACCOUNT_ID } from "@ccflare/types";
import type { AnalyticsResponse, APIContext } from "../types";

const log = new Logger("AnalyticsHandler");

interface BucketConfig {
	bucketMs: number;
	displayName: string;
}

interface TotalsResult {
	total_requests: number;
	success_rate: number;
	avg_response_time: number;
	total_tokens: number;
	total_cost_usd: number;
	avg_tokens_per_second: number;
}

interface ActiveAccountsResult {
	active_accounts: number;
}

interface TokenBreakdownResult {
	input_tokens: number;
	cache_read_input_tokens: number;
	cache_creation_input_tokens: number;
	output_tokens: number;
}

function getRangeConfig(range: string): {
	startMs: number;
	bucket: BucketConfig;
} {
	const now = Date.now();
	const hour = 60 * 60 * 1000;
	const day = 24 * hour;

	switch (range) {
		case "1h":
			return {
				startMs: now - hour,
				bucket: { bucketMs: 60 * 1000, displayName: "1m" },
			};
		case "6h":
			return {
				startMs: now - 6 * hour,
				bucket: { bucketMs: 5 * 60 * 1000, displayName: "5m" },
			};
		case "24h":
			return {
				startMs: now - day,
				bucket: { bucketMs: hour, displayName: "1h" },
			};
		case "7d":
			return {
				startMs: now - 7 * day,
				bucket: { bucketMs: hour, displayName: "1h" },
			};
		case "30d":
			return {
				startMs: now - 30 * day,
				bucket: { bucketMs: day, displayName: "1d" },
			};
		default:
			return {
				startMs: now - day,
				bucket: { bucketMs: hour, displayName: "1h" },
			};
	}
}

export function createAnalyticsHandler(context: APIContext) {
	return async (params: URLSearchParams): Promise<Response> => {
		const { db } = context;
		const range = params.get("range") ?? "24h";
		const { startMs, bucket } = getRangeConfig(range);
		const mode = params.get("mode") ?? "normal";
		const isCumulative = mode === "cumulative";

		// Extract filters
		const accountsFilter =
			params.get("accounts")?.split(",").filter(Boolean) || [];
		const modelsFilter = params.get("models")?.split(",").filter(Boolean) || [];
		const statusFilter = params.get("status") || "all";

		// Build filter conditions
		const conditions: string[] = ["timestamp > ?"];
		const queryParams: (string | number)[] = [startMs];

		if (accountsFilter.length > 0) {
			// Handle account filter - map account names to IDs via join
			const placeholders = accountsFilter.map(() => "?").join(",");
			conditions.push(`(
				r.account_used IN (SELECT id FROM accounts WHERE name IN (${placeholders}))
				OR (r.account_used = ? AND ? IN (${placeholders}))
			)`);
			queryParams.push(
				...accountsFilter,
				NO_ACCOUNT_ID,
				NO_ACCOUNT_ID,
				...accountsFilter,
			);
		}

		if (modelsFilter.length > 0) {
			const placeholders = modelsFilter.map(() => "?").join(",");
			conditions.push(`model IN (${placeholders})`);
			queryParams.push(...modelsFilter);
		}

		if (statusFilter === "success") {
			conditions.push("success = 1");
		} else if (statusFilter === "error") {
			conditions.push("success = 0");
		}

		const whereClause = conditions.join(" AND ");

		try {
			// Get totals
			const totalsQuery = db.prepare(`
				SELECT
					COUNT(*) as total_requests,
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as success_rate,
					AVG(response_time_ms) as avg_response_time,
					SUM(COALESCE(total_tokens, 0)) as total_tokens,
					SUM(COALESCE(cost_usd, 0)) as total_cost_usd,
					AVG(output_tokens_per_second) as avg_tokens_per_second
				FROM requests r
				WHERE ${whereClause}
			`);
			const totals = totalsQuery.get(...queryParams) as TotalsResult;

			// Get active accounts count (including no_account for unauthenticated requests)
			const activeAccountsQuery = db.prepare(`
				SELECT COUNT(DISTINCT COALESCE(account_used, ?)) as active_accounts
				FROM requests r
				WHERE ${whereClause}
			`);
			const activeAccounts = activeAccountsQuery.get(
				NO_ACCOUNT_ID,
				...queryParams,
			) as ActiveAccountsResult;

			// Check if we need per-model time series
			const includeModelBreakdown = params.get("modelBreakdown") === "true";

			// Get time series data
			const timeSeriesQuery = db.prepare(`
				SELECT
					(timestamp / ?) * ? as ts,
					${includeModelBreakdown ? "model," : ""}
					COUNT(*) as requests,
					SUM(COALESCE(total_tokens, 0)) as tokens,
					SUM(COALESCE(cost_usd, 0)) as cost_usd,
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as success_rate,
					SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as error_rate,
					SUM(COALESCE(cache_read_input_tokens, 0)) * 100.0 / 
						NULLIF(SUM(COALESCE(input_tokens, 0) + COALESCE(cache_read_input_tokens, 0) + COALESCE(cache_creation_input_tokens, 0)), 0) as cache_hit_rate,
					AVG(response_time_ms) as avg_response_time,
					AVG(output_tokens_per_second) as avg_tokens_per_second
				FROM requests r
				WHERE ${whereClause} ${includeModelBreakdown ? "AND model IS NOT NULL" : ""}
				GROUP BY ts${includeModelBreakdown ? ", model" : ""}
				ORDER BY ts${includeModelBreakdown ? ", model" : ""}
			`);
			const timeSeries = timeSeriesQuery.all(
				bucket.bucketMs,
				bucket.bucketMs,
				...queryParams,
			) as Array<{
				ts: number;
				model?: string;
				requests: number;
				tokens: number;
				cost_usd: number;
				success_rate: number;
				error_rate: number;
				cache_hit_rate: number;
				avg_response_time: number;
				avg_tokens_per_second: number | null;
			}>;

			// Get token breakdown
			const tokenBreakdownQuery = db.prepare(`
				SELECT
					SUM(COALESCE(input_tokens, 0)) as input_tokens,
					SUM(COALESCE(cache_read_input_tokens, 0)) as cache_read_input_tokens,
					SUM(COALESCE(cache_creation_input_tokens, 0)) as cache_creation_input_tokens,
					SUM(COALESCE(output_tokens, 0)) as output_tokens
				FROM requests r
				WHERE ${whereClause}
			`);
			const tokenBreakdown = tokenBreakdownQuery.get(
				...queryParams,
			) as TokenBreakdownResult;

			// Get model distribution
			const modelDistQuery = db.prepare(`
				SELECT
					model,
					COUNT(*) as count
				FROM requests r
				WHERE ${whereClause} AND model IS NOT NULL
				GROUP BY model
				ORDER BY count DESC
				LIMIT 10
			`);
			const modelDistribution = modelDistQuery.all(...queryParams) as Array<{
				model: string;
				count: number;
			}>;

			// Get account performance (including unauthenticated requests)
			const accountPerfQuery = db.prepare(`
				SELECT
					COALESCE(a.name, ?) as name,
					COUNT(r.id) as requests,
					SUM(CASE WHEN r.success = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(r.id), 0) as success_rate
				FROM requests r
				LEFT JOIN accounts a ON a.id = r.account_used
				WHERE ${whereClause}
				GROUP BY name
				HAVING requests > 0
				ORDER BY requests DESC
			`);
			const accountPerformance = accountPerfQuery.all(
				NO_ACCOUNT_ID,
				...queryParams,
			) as Array<{
				name: string;
				requests: number;
				success_rate: number;
			}>;

			// Get model performance metrics
			const modelPerfQuery = db.prepare(`
				SELECT
					model,
					AVG(response_time_ms) as avg_response_time,
					MAX(response_time_ms) as max_response_time,
					COUNT(*) as total_requests,
					SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) as error_count,
					SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as error_rate,
					AVG(output_tokens_per_second) as avg_tokens_per_second,
					MIN(CASE WHEN output_tokens_per_second > 0 THEN output_tokens_per_second ELSE NULL END) as min_tokens_per_second,
					MAX(output_tokens_per_second) as max_tokens_per_second
				FROM requests r
				WHERE ${whereClause} AND model IS NOT NULL
				GROUP BY model
				ORDER BY total_requests DESC
				LIMIT 10
			`);
			const modelPerfData = modelPerfQuery.all(...queryParams) as Array<{
				model: string;
				avg_response_time: number;
				max_response_time: number;
				total_requests: number;
				error_count: number;
				error_rate: number;
				avg_tokens_per_second: number | null;
				min_tokens_per_second: number | null;
				max_tokens_per_second: number | null;
			}>;

			// Calculate p95 for each model using SQL window functions
			const modelPerformance = modelPerfData.map((modelData) => {
				// Use SQLite's NTILE or manual percentile calculation
				// SQLite doesn't have built-in percentile functions, but we can use a more efficient query
				const p95Result = db
					.prepare(`
					WITH ordered_times AS (
						SELECT 
							response_time_ms,
							ROW_NUMBER() OVER (ORDER BY response_time_ms) as row_num,
							COUNT(*) OVER () as total_count
						FROM requests r
						WHERE ${whereClause} AND model = ? AND response_time_ms IS NOT NULL
					)
					SELECT response_time_ms as p95_response_time
					FROM ordered_times
					WHERE row_num = CAST(CEIL(total_count * 0.95) AS INTEGER)
					LIMIT 1
				`)
					.get(...queryParams, modelData.model) as
					| { p95_response_time: number }
					| undefined;

				return {
					model: modelData.model,
					avgResponseTime: modelData.avg_response_time || 0,
					p95ResponseTime:
						p95Result?.p95_response_time || modelData.avg_response_time || 0,
					errorRate: modelData.error_rate || 0,
					avgTokensPerSecond: modelData.avg_tokens_per_second || null,
					minTokensPerSecond: modelData.min_tokens_per_second || null,
					maxTokensPerSecond: modelData.max_tokens_per_second || null,
				};
			});

			// Get cost by model
			const costByModelQuery = db.prepare(`
				SELECT
					model,
					SUM(COALESCE(cost_usd, 0)) as cost_usd,
					COUNT(*) as requests,
					SUM(COALESCE(total_tokens, 0)) as total_tokens
				FROM requests r
				WHERE ${whereClause} AND COALESCE(cost_usd, 0) > 0 AND model IS NOT NULL
				GROUP BY model
				ORDER BY cost_usd DESC
				LIMIT 10
			`);
			const costByModel = costByModelQuery.all(...queryParams) as Array<{
				model: string;
				cost_usd: number;
				requests: number;
				total_tokens: number;
			}>;

			// Transform timeSeries data
			let transformedTimeSeries = timeSeries.map((point) => ({
				ts: point.ts,
				...(point.model && { model: point.model }),
				requests: point.requests || 0,
				tokens: point.tokens || 0,
				costUsd: point.cost_usd || 0,
				successRate: point.success_rate || 0,
				errorRate: point.error_rate || 0,
				cacheHitRate: point.cache_hit_rate || 0,
				avgResponseTime: point.avg_response_time || 0,
				avgTokensPerSecond: point.avg_tokens_per_second || null,
			}));

			// Apply cumulative transformation if requested
			if (isCumulative && !includeModelBreakdown) {
				let runningRequests = 0;
				let runningTokens = 0;
				let runningCostUsd = 0;

				transformedTimeSeries = transformedTimeSeries.map((point) => {
					runningRequests += point.requests;
					runningTokens += point.tokens;
					runningCostUsd += point.costUsd;

					return {
						...point,
						requests: runningRequests,
						tokens: runningTokens,
						costUsd: runningCostUsd,
						// Keep rates as-is (not cumulative)
					};
				});
			} else if (isCumulative && includeModelBreakdown) {
				// For per-model cumulative, track running totals per model
				const runningTotals: Record<
					string,
					{ requests: number; tokens: number; costUsd: number }
				> = {};

				transformedTimeSeries = transformedTimeSeries.map((point) => {
					if (point.model) {
						if (!runningTotals[point.model]) {
							runningTotals[point.model] = {
								requests: 0,
								tokens: 0,
								costUsd: 0,
							};
						}
						runningTotals[point.model].requests += point.requests;
						runningTotals[point.model].tokens += point.tokens;
						runningTotals[point.model].costUsd += point.costUsd;

						return {
							...point,
							requests: runningTotals[point.model].requests,
							tokens: runningTotals[point.model].tokens,
							costUsd: runningTotals[point.model].costUsd,
						};
					}
					return point;
				});
			}

			const response: AnalyticsResponse = {
				meta: {
					range,
					bucket: bucket.displayName,
					cumulative: isCumulative,
				},
				totals: {
					requests: totals.total_requests || 0,
					successRate: totals.success_rate || 0,
					activeAccounts: activeAccounts.active_accounts || 0,
					avgResponseTime: totals.avg_response_time || 0,
					totalTokens: totals.total_tokens || 0,
					totalCostUsd: totals.total_cost_usd || 0,
					avgTokensPerSecond: totals.avg_tokens_per_second || null,
				},
				timeSeries: transformedTimeSeries,
				tokenBreakdown: {
					inputTokens: tokenBreakdown?.input_tokens || 0,
					cacheReadInputTokens: tokenBreakdown?.cache_read_input_tokens || 0,
					cacheCreationInputTokens:
						tokenBreakdown?.cache_creation_input_tokens || 0,
					outputTokens: tokenBreakdown?.output_tokens || 0,
				},
				modelDistribution,
				accountPerformance: accountPerformance.map((acc) => ({
					name: acc.name,
					requests: acc.requests,
					successRate: acc.success_rate || 0,
				})),
				costByModel: costByModel.map((model) => ({
					model: model.model,
					costUsd: model.cost_usd || 0,
					requests: model.requests || 0,
					totalTokens: model.total_tokens || 0,
				})),
				modelPerformance,
			};

			return jsonResponse(response);
		} catch (error) {
			log.error("Analytics error:", error);
			return errorResponse(
				InternalServerError("Failed to fetch analytics data"),
			);
		}
	};
}
</file>

<file path="packages/http-api/src/handlers/health.ts">
import type { Database } from "bun:sqlite";
import type { Config } from "@ccflare/config";
import { jsonResponse } from "@ccflare/http-common";
import type { HealthResponse } from "../types";

/**
 * Create a health check handler
 */
export function createHealthHandler(db: Database, config: Config) {
	return (): Response => {
		const accountCount = db
			.query("SELECT COUNT(*) as count FROM accounts")
			.get() as { count: number } | undefined;

		const response: HealthResponse = {
			status: "ok",
			accounts: accountCount?.count || 0,
			timestamp: new Date().toISOString(),
			strategy: config.getStrategy(),
		};

		return jsonResponse(response);
	};
}
</file>

<file path="packages/http-api/src/handlers/logs-history.ts">
import {
	errorResponse,
	InternalServerError,
	jsonResponse,
} from "@ccflare/http-common";
import { logFileWriter } from "@ccflare/logger";

/**
 * Create a logs history handler to fetch past logs
 */
export function createLogsHistoryHandler() {
	return async (): Promise<Response> => {
		try {
			// Get the last 1000 logs by default
			const logs = await logFileWriter.readLogs(1000);

			return jsonResponse(logs);
		} catch (_error) {
			return errorResponse(InternalServerError("Failed to fetch log history"));
		}
	};
}
</file>

<file path="packages/http-api/src/handlers/logs.ts">
import { sseResponse } from "@ccflare/http-common";
import { Logger, logBus } from "@ccflare/logger";
import type { LogEvent } from "@ccflare/types";

const log = new Logger("LogsHandler");

/**
 * Create a logs stream handler using Server-Sent Events
 */
export function createLogsStreamHandler() {
	return (): Response => {
		// Use TransformStream for better Bun compatibility
		const { readable, writable } = new TransformStream();
		const writer = writable.getWriter();
		const encoder = new TextEncoder();
		let closed = false;

		// Send initial connection message
		(async () => {
			try {
				const initialData = `data: ${JSON.stringify({ connected: true })}\n\n`;
				await writer.write(encoder.encode(initialData));
			} catch (e) {
				log.error("Error sending initial message:", e);
			}
		})();

		// Listen for log events
		const handleLogEvent = async (event: LogEvent) => {
			if (closed) return;

			try {
				const data = `data: ${JSON.stringify(event)}\n\n`;
				await writer.write(encoder.encode(data));
			} catch (_error) {
				// Stream closed
				closed = true;
				logBus.off("log", handleLogEvent);
				try {
					await writer.close();
				} catch {}
			}
		};

		// Subscribe to log events
		logBus.on("log", handleLogEvent);

		// Clean up on request abort
		setTimeout(() => {
			// ReadableStream doesn't have a standard 'closed' property
			// This is a workaround for stream closure detection
			if (!closed) {
				// Just rely on the error handling in handleLogEvent
				// to detect when the stream is closed
			}
		}, 0);

		return sseResponse(readable);
	};
}
</file>

<file path="packages/http-api/src/handlers/requests.ts">
import type { Database } from "bun:sqlite";
import type { DatabaseOperations } from "@ccflare/database";
import { jsonResponse } from "@ccflare/http-common";
import type { RequestResponse } from "../types";

/**
 * Create a requests summary handler (existing functionality)
 */
export function createRequestsSummaryHandler(db: Database) {
	return (limit: number = 50): Response => {
		const requests = db
			.query(
				`
				SELECT r.*, a.name as account_name
				FROM requests r
				LEFT JOIN accounts a ON r.account_used = a.id
				ORDER BY r.timestamp DESC
				LIMIT ?1
			`,
			)
			.all(limit) as Array<{
			id: string;
			timestamp: number;
			method: string;
			path: string;
			account_used: string | null;
			account_name: string | null;
			status_code: number | null;
			success: 0 | 1;
			error_message: string | null;
			response_time_ms: number | null;
			failover_attempts: number;
			model: string | null;
			prompt_tokens: number | null;
			completion_tokens: number | null;
			total_tokens: number | null;
			input_tokens: number | null;
			cache_read_input_tokens: number | null;
			cache_creation_input_tokens: number | null;
			output_tokens: number | null;
			cost_usd: number | null;
			agent_used: string | null;
			output_tokens_per_second: number | null;
		}>;

		const response: RequestResponse[] = requests.map((request) => ({
			id: request.id,
			timestamp: new Date(request.timestamp).toISOString(),
			method: request.method,
			path: request.path,
			accountUsed: request.account_name || request.account_used,
			statusCode: request.status_code,
			success: request.success === 1,
			errorMessage: request.error_message,
			responseTimeMs: request.response_time_ms,
			failoverAttempts: request.failover_attempts,
			model: request.model || undefined,
			promptTokens: request.prompt_tokens || undefined,
			completionTokens: request.completion_tokens || undefined,
			totalTokens: request.total_tokens || undefined,
			inputTokens: request.input_tokens || undefined,
			cacheReadInputTokens: request.cache_read_input_tokens || undefined,
			cacheCreationInputTokens:
				request.cache_creation_input_tokens || undefined,
			outputTokens: request.output_tokens || undefined,
			costUsd: request.cost_usd || undefined,
			agentUsed: request.agent_used || undefined,
			tokensPerSecond: request.output_tokens_per_second || undefined,
		}));

		return jsonResponse(response);
	};
}

/**
 * Create a detailed requests handler with full payload data
 */
export function createRequestsDetailHandler(dbOps: DatabaseOperations) {
	return (limit = 100): Response => {
		const rows = dbOps.listRequestPayloadsWithAccountNames(limit);
		const parsed = rows.map((r) => {
			try {
				const data = JSON.parse(r.json);
				// Add account name to the meta field if available
				if (r.account_name && data.meta) {
					data.meta.accountName = r.account_name;
				}
				return { id: r.id, ...data };
			} catch {
				return { id: r.id, error: "Failed to parse payload" };
			}
		});

		return jsonResponse(parsed);
	};
}
</file>

<file path="packages/http-api/src/handlers/stats.ts">
import type { DatabaseOperations } from "@ccflare/database";
import { jsonResponse } from "@ccflare/http-common";

/**
 * Create a stats handler
 */
export function createStatsHandler(dbOps: DatabaseOperations) {
	return (): Response => {
		const statsRepository = dbOps.getStatsRepository();

		// Get overall statistics using the consolidated repository
		const stats = statsRepository.getAggregatedStats();
		const activeAccounts = statsRepository.getActiveAccountCount();

		const successRate =
			stats.totalRequests > 0
				? Math.round((stats.successfulRequests / stats.totalRequests) * 100)
				: 0;

		// Get per-account stats (including unauthenticated requests)
		const accountsWithStats = statsRepository.getAccountStats(10, true);

		// Get recent errors
		const recentErrors = statsRepository.getRecentErrors();

		// Get top models
		const topModels = statsRepository.getTopModels();

		const response = {
			totalRequests: stats.totalRequests,
			successRate,
			activeAccounts,
			avgResponseTime: Math.round(stats.avgResponseTime || 0),
			totalTokens: stats.totalTokens,
			totalCostUsd: stats.totalCostUsd,
			topModels,
			avgTokensPerSecond: stats.avgTokensPerSecond,
			accounts: accountsWithStats,
			recentErrors,
		};

		return jsonResponse(response);
	};
}

/**
 * Create a stats reset handler
 */
export function createStatsResetHandler(dbOps: DatabaseOperations) {
	return async (): Promise<Response> => {
		const db = dbOps.getDatabase();
		// Clear request history
		db.run("DELETE FROM requests");
		// Reset account statistics
		db.run("UPDATE accounts SET request_count = 0, session_request_count = 0");

		return jsonResponse({
			success: true,
			message: "Statistics reset successfully",
		});
	};
}
</file>

<file path="packages/http-api/src/utils/handler-factory.ts">
import { errorResponse } from "@ccflare/http-common";
import type { APIContext } from "../types";

export interface HandlerOptions {
	requiresAuth?: boolean;
	method?: string;
}

/**
 * Factory for creating consistent API handlers with error handling
 */
export function createHandler<T extends unknown[], R>(
	handler: (context: APIContext, ...args: T) => R | Promise<R>,
	_options: HandlerOptions = {},
): (...args: T) => Promise<Response> {
	return async (...args: T): Promise<Response> => {
		try {
			// In a real implementation, you'd pass the context here
			// For now, we'll assume it's available through dependency injection
			const result = await handler({} as APIContext, ...args);
			return result as Response;
		} catch (error) {
			return errorResponse(error);
		}
	};
}

/**
 * Helper for parsing and validating request body
 */
export async function parseRequestBody<T>(req: Request): Promise<T> {
	try {
		const body = await req.json();
		return body as T;
	} catch (_error) {
		throw new Error("Invalid JSON in request body");
	}
}

/**
 * Helper for extracting common query parameters
 */
export function extractQueryParams(
	url: URL,
	params: string[],
): Record<string, string | null> {
	const result: Record<string, string | null> = {};
	for (const param of params) {
		result[param] = url.searchParams.get(param);
	}
	return result;
}
</file>

<file path="packages/http-api/src/utils/http-error.ts">
// Re-export all HTTP utilities from the shared http-common package
export {
	BadRequest,
	Conflict,
	errorResponse,
	Forbidden,
	HttpError,
	InternalServerError,
	jsonResponse,
	NotFound,
	Unauthorized,
} from "@ccflare/http-common";
</file>

<file path="packages/http-api/src/index.ts">
// Export router - the main public API
export { APIRouter } from "./router";

// Export types
export * from "./types";

// Export utilities
export * from "./utils/http-error";
</file>

<file path="packages/http-api/package.json">
{
	"name": "@ccflare/http-api",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/agents": "workspace:*",
		"@ccflare/core": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/oauth-flow": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}
</file>

<file path="packages/http-api/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/http-common/src/client.ts">
import { HttpError, parseHttpError } from "@ccflare/errors";

export interface RequestOptions extends RequestInit {
	timeout?: number;
	retries?: number;
	retryDelay?: number;
	baseUrl?: string;
}

export interface ClientOptions {
	baseUrl?: string;
	defaultHeaders?: HeadersInit;
	timeout?: number;
	retries?: number;
	retryDelay?: number;
}

/**
 * Base HTTP client with common functionality
 */
export class HttpClient {
	private options: Required<ClientOptions>;

	constructor(options: ClientOptions = {}) {
		this.options = {
			baseUrl: options.baseUrl || "",
			defaultHeaders: options.defaultHeaders || {},
			timeout: options.timeout || 30000,
			retries: options.retries || 0,
			retryDelay: options.retryDelay || 1000,
		};
	}

	/**
	 * Make an HTTP request with retries and timeout
	 */
	async request<T = unknown>(
		url: string,
		options: RequestOptions = {},
	): Promise<T> {
		const {
			timeout = this.options.timeout,
			retries = this.options.retries,
			retryDelay = this.options.retryDelay,
			baseUrl = this.options.baseUrl,
			...fetchOptions
		} = options;

		const fullUrl = baseUrl ? new URL(url, baseUrl).toString() : url;
		const headers = {
			...this.options.defaultHeaders,
			...fetchOptions.headers,
		};

		let lastError: Error | null = null;

		for (let attempt = 0; attempt <= retries; attempt++) {
			try {
				const controller = new AbortController();
				const timeoutId = setTimeout(() => controller.abort(), timeout);

				const response = await fetch(fullUrl, {
					...fetchOptions,
					headers,
					signal: controller.signal,
				});

				clearTimeout(timeoutId);

				if (!response.ok) {
					const error = await parseHttpError(response);
					throw error;
				}

				const contentType = response.headers.get("content-type");
				if (contentType?.includes("application/json")) {
					return await response.json();
				}

				return (await response.text()) as T;
			} catch (error) {
				lastError = error as Error;

				// Don't retry on client errors (4xx)
				if (error instanceof HttpError && error.status < 500) {
					throw error;
				}

				// Don't retry on abort
				if (error instanceof Error && error.name === "AbortError") {
					throw new HttpError(408, "Request timeout");
				}

				// Retry if we have attempts left
				if (attempt < retries) {
					await this.delay(retryDelay * (attempt + 1));
				}
			}
		}

		throw lastError || new Error("Unknown error");
	}

	/**
	 * Convenience methods
	 */
	get<T = unknown>(url: string, options?: RequestOptions): Promise<T> {
		return this.request<T>(url, { ...options, method: "GET" });
	}

	post<T = unknown>(
		url: string,
		body?: unknown,
		options?: RequestOptions,
	): Promise<T> {
		return this.request<T>(url, {
			...options,
			method: "POST",
			body: body ? JSON.stringify(body) : undefined,
			headers: {
				"Content-Type": "application/json",
				...options?.headers,
			},
		});
	}

	put<T = unknown>(
		url: string,
		body?: unknown,
		options?: RequestOptions,
	): Promise<T> {
		return this.request<T>(url, {
			...options,
			method: "PUT",
			body: body ? JSON.stringify(body) : undefined,
			headers: {
				"Content-Type": "application/json",
				...options?.headers,
			},
		});
	}

	patch<T = unknown>(
		url: string,
		body?: unknown,
		options?: RequestOptions,
	): Promise<T> {
		return this.request<T>(url, {
			...options,
			method: "PATCH",
			body: body ? JSON.stringify(body) : undefined,
			headers: {
				"Content-Type": "application/json",
				...options?.headers,
			},
		});
	}

	delete<T = unknown>(url: string, options?: RequestOptions): Promise<T> {
		return this.request<T>(url, { ...options, method: "DELETE" });
	}

	/**
	 * Delay helper for retries
	 */
	private delay(ms: number): Promise<void> {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}
}
</file>

<file path="packages/http-common/src/errors.ts">
// Re-export HTTP errors from the unified errors package
export {
	BadGateway,
	BadRequest,
	Conflict,
	Forbidden,
	GatewayTimeout,
	HttpError,
	InternalServerError,
	NotFound,
	ServiceUnavailable,
	TooManyRequests,
	Unauthorized,
	UnprocessableEntity,
} from "@ccflare/errors";
</file>

<file path="packages/http-common/src/responses.ts">
import { HttpError } from "./errors";

/**
 * Create a JSON response with proper headers
 */
export function jsonResponse(
	data: unknown,
	status = 200,
	headers?: HeadersInit,
): Response {
	return new Response(JSON.stringify(data), {
		status,
		headers: {
			"Content-Type": "application/json",
			...headers,
		},
	});
}

/**
 * Create an error response from any error type
 */
export function errorResponse(error: unknown): Response {
	if (error instanceof HttpError) {
		const body: { error: string; details?: unknown } = {
			error: error.message,
		};
		if (error.details !== undefined) {
			body.details = error.details;
		}
		return jsonResponse(body, error.status);
	}

	// Handle generic errors
	const message =
		error instanceof Error ? error.message : "Internal server error";
	const status = 500;

	// In browser context, we can't log to files
	// Server-side code should handle logging before calling errorResponse
	if (typeof console !== "undefined" && console.error) {
		console.error("Unhandled error:", error);
	}

	return jsonResponse({ error: message }, status);
}

/**
 * Create a success response with optional data
 */
export function successResponse(
	data?: unknown,
	message = "Success",
	status = 200,
): Response {
	return jsonResponse({ message, data }, status);
}

/**
 * Create a paginated response
 */
export function paginatedResponse<T>(
	items: T[],
	page: number,
	perPage: number,
	total: number,
	headers?: HeadersInit,
): Response {
	const totalPages = Math.ceil(total / perPage);

	return jsonResponse(
		{
			items,
			pagination: {
				page,
				perPage,
				total,
				totalPages,
				hasNext: page < totalPages,
				hasPrev: page > 1,
			},
		},
		200,
		headers,
	);
}

/**
 * Create a streaming response for Server-Sent Events
 */
export function sseResponse(
	stream: ReadableStream,
	headers?: HeadersInit,
): Response {
	return new Response(stream, {
		headers: {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache",
			Connection: "keep-alive",
			...headers,
		},
	});
}
</file>

<file path="packages/http-common/package.json">
{
	"name": "@ccflare/http-common",
	"private": true,
	"version": "0.0.0",
	"type": "module",
	"exports": {
		".": "./src/index.ts",
		"./*": "./src/*.ts"
	},
	"scripts": {
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/types": "workspace:*",
		"@ccflare/errors": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^22.10.2",
		"typescript": "^5.7.2"
	}
}
</file>

<file path="packages/http-common/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist"
	},
	"include": ["src/**/*"]
}
</file>

<file path="packages/load-balancer/src/strategies/index.ts">
import { isAccountAvailable, TIME_CONSTANTS } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type {
	Account,
	LoadBalancingStrategy,
	RequestMeta,
	StrategyStore,
} from "@ccflare/types";

export class SessionStrategy implements LoadBalancingStrategy {
	private sessionDurationMs: number;
	private store: StrategyStore | null = null;
	private log = new Logger("SessionStrategy");

	constructor(
		sessionDurationMs: number = TIME_CONSTANTS.SESSION_DURATION_DEFAULT,
	) {
		this.sessionDurationMs = sessionDurationMs;
	}

	initialize(store: StrategyStore): void {
		this.store = store;
	}

	private resetSessionIfExpired(account: Account): void {
		const now = Date.now();

		if (
			!account.session_start ||
			now - account.session_start >= this.sessionDurationMs
		) {
			// Reset session
			if (this.store) {
				const wasExpired = account.session_start !== null;
				this.log.info(
					wasExpired
						? `Session expired for account ${account.name}, starting new session`
						: `Starting new session for account ${account.name}`,
				);
				this.store.resetAccountSession(account.id, now);

				// Update the account object to reflect changes
				account.session_start = now;
				account.session_request_count = 0;
			}
		}
	}

	select(accounts: Account[], _meta: RequestMeta): Account[] {
		const now = Date.now();

		// Find account with active session (most recent session_start within window)
		let activeAccount: Account | null = null;
		let mostRecentSessionStart = 0;

		for (const account of accounts) {
			if (
				account.session_start &&
				now - account.session_start < this.sessionDurationMs &&
				account.session_start > mostRecentSessionStart
			) {
				activeAccount = account;
				mostRecentSessionStart = account.session_start;
			}
		}

		// If we have an active account and it's available, use it exclusively
		if (activeAccount && isAccountAvailable(activeAccount, now)) {
			// Reset session if expired (shouldn't happen but just in case)
			this.resetSessionIfExpired(activeAccount);
			this.log.info(
				`Continuing session for account ${activeAccount.name} (${activeAccount.session_request_count} requests in session)`,
			);
			// Return active account first, then others as fallback
			const others = accounts.filter(
				(a) => a.id !== activeAccount.id && isAccountAvailable(a, now),
			);
			return [activeAccount, ...others];
		}

		// No active session or active account is rate limited
		// Filter available accounts
		const available = accounts.filter((a) => isAccountAvailable(a, now));

		if (available.length === 0) return [];

		// Pick the first available account and start a new session with it
		const chosenAccount = available[0];
		this.resetSessionIfExpired(chosenAccount);

		// Return chosen account first, then others as fallback
		const others = available.filter((a) => a.id !== chosenAccount.id);
		return [chosenAccount, ...others];
	}
}
</file>

<file path="packages/load-balancer/src/index.ts">
export { SessionStrategy } from "./strategies";
</file>

<file path="packages/load-balancer/package.json">
{
	"name": "@ccflare/load-balancer",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/logger": "workspace:*"
	}
}
</file>

<file path="packages/load-balancer/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/logger/src/file-writer.ts">
import { createWriteStream, existsSync, mkdirSync, statSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import {
	BUFFER_SIZES,
	type Disposable,
	LIMITS,
	registerDisposable,
} from "@ccflare/core";
import type { LogEvent } from "@ccflare/types";

export class LogFileWriter implements Disposable {
	private logDir: string;
	private logFile: string;
	private stream: ReturnType<typeof createWriteStream> | null = null;
	private maxFileSize = BUFFER_SIZES.LOG_FILE_MAX_SIZE;

	constructor() {
		// Create log directory in tmp folder
		this.logDir = join(tmpdir(), "ccflare-logs");
		if (!existsSync(this.logDir)) {
			mkdirSync(this.logDir, { recursive: true });
		}

		this.logFile = join(this.logDir, "app.log");
		this.initStream();
	}

	private initStream(): void {
		// Check if we need to rotate
		if (existsSync(this.logFile)) {
			const stats = statSync(this.logFile);
			if (stats.size > this.maxFileSize) {
				this.rotateLog();
			}
		}

		// Create write stream with append mode
		this.stream = createWriteStream(this.logFile, { flags: "a" });
	}

	private rotateLog(): void {
		if (this.stream) {
			this.stream.end();
		}

		// Simple rotation: just delete old log
		// In production, you might want to keep a few rotated files
		if (existsSync(this.logFile)) {
			// For now, just delete the old file
			// In a production system, you'd rename it to keep history
			try {
				require("node:fs").unlinkSync(this.logFile);
			} catch (_e) {
				console.error("Failed to rotate log:", _e);
			}
		}
	}

	write(event: LogEvent): void {
		if (!this.stream || this.stream.destroyed) {
			this.initStream();
		}

		const line = `${JSON.stringify(event)}\n`;
		if (this.stream) {
			this.stream.write(line);
		}
	}

	async readLogs(limit: number = LIMITS.LOG_READ_DEFAULT): Promise<LogEvent[]> {
		if (!existsSync(this.logFile)) {
			return [];
		}

		try {
			const content = await Bun.file(this.logFile).text();
			const lines = content.trim().split("\n").filter(Boolean);

			// Return the last N logs
			return lines
				.slice(-limit)
				.map((line) => {
					try {
						return JSON.parse(line);
					} catch {
						return null;
					}
				})
				.filter((log): log is LogEvent => log !== null);
		} catch (_e) {
			console.error("Failed to read logs:", _e);
			return [];
		}
	}

	close(): void {
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	}

	dispose(): void {
		this.close();
	}
}

// Singleton instance
export const logFileWriter = new LogFileWriter();

// Register with lifecycle manager
registerDisposable(logFileWriter);
</file>

<file path="packages/logger/src/index.ts">
import { EventEmitter } from "node:events";
import type { LogEvent } from "@ccflare/types";
import { logFileWriter } from "./file-writer";

export enum LogLevel {
	DEBUG = 0,
	INFO = 1,
	WARN = 2,
	ERROR = 3,
}

export type LogFormat = "pretty" | "json";

// Event emitter for log streaming
export const logBus = new EventEmitter();

export class Logger {
	private level: LogLevel;
	private prefix: string;
	private format: LogFormat;
	private silentConsole: boolean;

	constructor(prefix: string = "", level: LogLevel = LogLevel.INFO) {
		this.prefix = prefix;
		this.level = this.getLogLevelFromEnv() || level;
		this.format = (process.env.LOG_FORMAT as LogFormat) || "pretty";
		// Only show console output in debug mode or if ccflare_DEBUG is set
		this.silentConsole = !(
			process.env.ccflare_DEBUG === "1" || this.level === LogLevel.DEBUG
		);
	}

	private getLogLevelFromEnv(): LogLevel | null {
		const envLevel = process.env.LOG_LEVEL?.toUpperCase();
		if (envLevel && envLevel in LogLevel) {
			return LogLevel[envLevel as keyof typeof LogLevel];
		}
		return null;
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
	private formatMessage(level: string, message: string, data?: any): string {
		const timestamp = new Date().toISOString();

		if (this.format === "json") {
			const logEntry = {
				ts: timestamp,
				level,
				prefix: this.prefix || undefined,
				msg: message,
				...(data && { data }),
			};
			return JSON.stringify(logEntry);
		} else {
			const prefix = this.prefix ? `[${this.prefix}] ` : "";
			const dataStr = data ? ` ${JSON.stringify(data)}` : "";
			return `[${timestamp}] ${level}: ${prefix}${message}${dataStr}`;
		}
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
	debug(message: string, data?: any): void {
		if (this.level <= LogLevel.DEBUG) {
			const msg = this.formatMessage("DEBUG", message, data);
			const event: LogEvent = {
				ts: Date.now(),
				level: "DEBUG",
				msg: message,
			};
			logBus.emit("log", event);
			logFileWriter.write(event);
			if (!this.silentConsole) console.log(msg);
		}
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
	info(message: string, data?: any): void {
		if (this.level <= LogLevel.INFO) {
			const msg = this.formatMessage("INFO", message, data);
			const event: LogEvent = {
				ts: Date.now(),
				level: "INFO",
				msg: message,
			};
			logBus.emit("log", event);
			logFileWriter.write(event);
			if (!this.silentConsole) console.log(msg);
		}
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
	warn(message: string, data?: any): void {
		if (this.level <= LogLevel.WARN) {
			const msg = this.formatMessage("WARN", message, data);
			const event: LogEvent = {
				ts: Date.now(),
				level: "WARN",
				msg: message,
			};
			logBus.emit("log", event);
			logFileWriter.write(event);
			if (!this.silentConsole) console.warn(msg);
		}
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any error type
	error(message: string, error?: any): void {
		if (this.level <= LogLevel.ERROR) {
			const msg = this.formatMessage("ERROR", message, error);
			const event: LogEvent = {
				ts: Date.now(),
				level: "ERROR",
				msg: message,
			};
			logBus.emit("log", event);
			logFileWriter.write(event);
			if (!this.silentConsole) console.error(msg);
		}
	}

	setLevel(level: LogLevel): void {
		this.level = level;
		// Update silentConsole when level changes
		this.silentConsole = !(
			process.env.ccflare_DEBUG === "1" || this.level === LogLevel.DEBUG
		);
	}

	getLevel(): LogLevel {
		return this.level;
	}
}

// Default logger instance
export const log = new Logger();
export { logFileWriter } from "./file-writer";
</file>

<file path="packages/logger/package.json">
{
	"name": "@ccflare/logger",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}
</file>

<file path="packages/logger/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/oauth-flow/package.json">
{
	"name": "@ccflare/oauth-flow",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/config": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}
</file>

<file path="packages/providers/src/oauth/base-oauth-provider.ts">
import { generatePKCE } from "./pkce";

export interface OAuthConfig {
	clientId: string;
	authorizationUrl: string;
	tokenUrl: string;
	redirectUri: string;
	scopes: string[];
}

export interface OAuthTokens {
	accessToken: string;
	refreshToken?: string;
	expiresAt: number;
}

/**
 * Base class for OAuth providers to reduce duplication
 */
export abstract class BaseOAuthProvider {
	protected config: OAuthConfig;

	constructor(config: OAuthConfig) {
		this.config = config;
	}

	/**
	 * Generate authorization URL with PKCE
	 */
	async generateAuthUrl(
		state: string,
	): Promise<{ url: string; verifier: string }> {
		const { challenge: codeChallenge, verifier: codeVerifier } =
			await generatePKCE();

		const params = new URLSearchParams({
			response_type: "code",
			client_id: this.config.clientId,
			redirect_uri: this.config.redirectUri,
			scope: this.config.scopes.join(" "),
			state,
			code_challenge: codeChallenge,
			code_challenge_method: "S256",
		});

		// Allow subclasses to add custom parameters
		this.addCustomAuthParams(params);

		const url = `${this.config.authorizationUrl}?${params.toString()}`;
		return { url, verifier: codeVerifier };
	}

	/**
	 * Exchange authorization code for tokens
	 */
	async exchangeCodeForTokens(
		code: string,
		verifier: string,
	): Promise<OAuthTokens> {
		const body = new URLSearchParams({
			grant_type: "authorization_code",
			client_id: this.config.clientId,
			code,
			redirect_uri: this.config.redirectUri,
			code_verifier: verifier,
		});

		// Allow subclasses to add custom token parameters
		this.addCustomTokenParams(body);

		const response = await fetch(this.config.tokenUrl, {
			method: "POST",
			headers: {
				"Content-Type": "application/x-www-form-urlencoded",
			},
			body: body.toString(),
		});

		if (!response.ok) {
			const error = await response.text();
			throw new Error(`Token exchange failed: ${error}`);
		}

		const data = await response.json();
		return this.parseTokenResponse(data);
	}

	/**
	 * Refresh tokens using refresh token
	 */
	async refreshTokens(refreshToken: string): Promise<OAuthTokens> {
		const body = new URLSearchParams({
			grant_type: "refresh_token",
			client_id: this.config.clientId,
			refresh_token: refreshToken,
		});

		const response = await fetch(this.config.tokenUrl, {
			method: "POST",
			headers: {
				"Content-Type": "application/x-www-form-urlencoded",
			},
			body: body.toString(),
		});

		if (!response.ok) {
			const error = await response.text();
			throw new Error(`Token refresh failed: ${error}`);
		}

		const data = await response.json();
		return this.parseTokenResponse(data);
	}

	/**
	 * Hook for subclasses to add custom authorization parameters
	 */
	protected addCustomAuthParams(_params: URLSearchParams): void {
		// Default implementation does nothing
	}

	/**
	 * Hook for subclasses to add custom token exchange parameters
	 */
	protected addCustomTokenParams(_params: URLSearchParams): void {
		// Default implementation does nothing
	}

	/**
	 * Parse token response - must be implemented by subclasses
	 */
	protected abstract parseTokenResponse(data: unknown): OAuthTokens;
}
</file>

<file path="packages/providers/src/oauth/index.ts">
export { BaseOAuthProvider, type OAuthTokens } from "./base-oauth-provider";
export { generatePKCE } from "./pkce";
</file>

<file path="packages/providers/src/oauth/pkce.ts">
import type { PKCEChallenge } from "../types";

/**
 * Generate a PKCE challenge for OAuth flows
 */
export async function generatePKCE(): Promise<PKCEChallenge> {
	// Generate random verifier
	const verifierBytes = new Uint8Array(32);
	crypto.getRandomValues(verifierBytes);
	const verifier = base64urlEncode(verifierBytes);

	// Calculate SHA-256 challenge
	const encoder = new TextEncoder();
	const data = encoder.encode(verifier);
	const hashBuffer = await crypto.subtle.digest("SHA-256", data);
	const challenge = base64urlEncode(new Uint8Array(hashBuffer));

	return { verifier, challenge };
}

/**
 * Base64 URL encode without padding
 */
function base64urlEncode(bytes: Uint8Array): string {
	const base64 = btoa(String.fromCharCode(...bytes));
	return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
</file>

<file path="packages/providers/src/providers/anthropic/index.ts">
export { AnthropicOAuthProvider } from "./oauth";
export { AnthropicProvider } from "./provider";
</file>

<file path="packages/providers/src/providers/anthropic/oauth.ts">
import { OAuthError } from "@ccflare/core";
import type {
	OAuthProvider,
	OAuthProviderConfig,
	PKCEChallenge,
	TokenResult,
} from "../../types";

export class AnthropicOAuthProvider implements OAuthProvider {
	getOAuthConfig(mode: "console" | "max" = "console"): OAuthProviderConfig {
		const baseUrl =
			mode === "console"
				? "https://console.anthropic.com"
				: "https://claude.ai";

		return {
			authorizeUrl: `${baseUrl}/oauth/authorize`,
			tokenUrl: "https://console.anthropic.com/v1/oauth/token",
			clientId: "", // Will be passed from config
			scopes: ["org:create_api_key", "user:profile", "user:inference"],
			redirectUri: "https://console.anthropic.com/oauth/code/callback",
			mode,
		};
	}

	generateAuthUrl(config: OAuthProviderConfig, pkce: PKCEChallenge): string {
		const url = new URL(config.authorizeUrl);
		url.searchParams.set("code", "true");
		url.searchParams.set("client_id", config.clientId);
		url.searchParams.set("response_type", "code");
		url.searchParams.set("redirect_uri", config.redirectUri);
		url.searchParams.set("scope", config.scopes.join(" "));
		url.searchParams.set("code_challenge", pkce.challenge);
		url.searchParams.set("code_challenge_method", "S256");
		url.searchParams.set("state", pkce.verifier);
		return url.toString();
	}

	async exchangeCode(
		code: string,
		verifier: string,
		config: OAuthProviderConfig,
	): Promise<TokenResult> {
		const splits = code.split("#");
		const response = await fetch(config.tokenUrl, {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify({
				code: splits[0],
				state: splits[1],
				grant_type: "authorization_code",
				client_id: config.clientId,
				redirect_uri: config.redirectUri,
				code_verifier: verifier,
			}),
		});

		if (!response.ok) {
			let errorDetails: { error?: string; error_description?: string } | null =
				null;
			try {
				errorDetails = await response.json();
			} catch {
				// Failed to parse error response
			}

			const errorMessage =
				errorDetails?.error_description ||
				errorDetails?.error ||
				response.statusText ||
				"OAuth token exchange failed";

			throw new OAuthError(errorMessage, "anthropic", errorDetails?.error);
		}

		const json = (await response.json()) as {
			refresh_token: string;
			access_token: string;
			expires_in: number;
		};

		return {
			refreshToken: json.refresh_token,
			accessToken: json.access_token,
			expiresAt: Date.now() + json.expires_in * 1000,
		};
	}
}
</file>

<file path="packages/providers/src/providers/index.ts">
export {
	AnthropicOAuthProvider,
	AnthropicProvider,
} from "./anthropic/index";
</file>

<file path="packages/providers/src/index.ts">
// Export all types

// Export base provider class
export { BaseProvider } from "./base";
// Export OAuth utilities
export * from "./oauth";
// Export providers
export * from "./providers/index";
// Export registry functions
export {
	getOAuthProvider,
	getProvider,
	listOAuthProviders,
	listProviders,
	registerProvider,
} from "./registry";
export * from "./types";

import { AnthropicProvider } from "./providers/anthropic/provider";
// Auto-register built-in providers
import { registry } from "./registry";

registry.registerProvider(new AnthropicProvider());
</file>

<file path="packages/providers/src/registry.ts">
import type { OAuthProvider, Provider } from "./types";

class ProviderRegistry {
	private providers = new Map<string, Provider>();
	private oauthProviders = new Map<string, OAuthProvider>();

	/**
	 * Register a provider
	 */
	registerProvider(provider: Provider): void {
		this.providers.set(provider.name, provider);

		// Auto-register OAuth provider if supported
		if (
			"supportsOAuth" in provider &&
			typeof provider.supportsOAuth === "function" &&
			"getOAuthProvider" in provider &&
			typeof provider.getOAuthProvider === "function"
		) {
			const supportsOAuth = provider.supportsOAuth as () => boolean;
			if (supportsOAuth()) {
				const getOAuthProvider =
					provider.getOAuthProvider as () => OAuthProvider;
				const oauthProvider = getOAuthProvider();
				this.oauthProviders.set(provider.name, oauthProvider);
			}
		}
	}

	/**
	 * Get a provider by name
	 */
	getProvider(name: string): Provider | undefined {
		return this.providers.get(name);
	}

	/**
	 * Get an OAuth provider by name
	 */
	getOAuthProvider(name: string): OAuthProvider | undefined {
		return this.oauthProviders.get(name);
	}

	/**
	 * List all registered provider names
	 */
	listProviders(): string[] {
		return Array.from(this.providers.keys());
	}

	/**
	 * List all providers that support OAuth
	 */
	listOAuthProviders(): string[] {
		return Array.from(this.oauthProviders.keys());
	}

	/**
	 * Unregister a provider (useful for testing)
	 */
	unregisterProvider(name: string): boolean {
		this.oauthProviders.delete(name);
		return this.providers.delete(name);
	}

	/**
	 * Clear all providers (useful for testing)
	 */
	clear(): void {
		this.providers.clear();
		this.oauthProviders.clear();
	}
}

// Create singleton registry instance
export const registry = new ProviderRegistry();

// Export convenience functions
export const registerProvider = (provider: Provider) =>
	registry.registerProvider(provider);
export const getProvider = (name: string) => registry.getProvider(name);
export const getOAuthProvider = (name: string) =>
	registry.getOAuthProvider(name);
export const listProviders = () => registry.listProviders();
export const listOAuthProviders = () => registry.listOAuthProviders();
</file>

<file path="packages/providers/package.json">
{
	"name": "@ccflare/providers",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*"
	}
}
</file>

<file path="packages/providers/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/proxy/src/handlers/account-selector.ts">
import type { Account, RequestMeta } from "@ccflare/types";
import type { ProxyContext } from "./proxy-types";

/**
 * Gets accounts ordered by the load balancing strategy
 * @param meta - Request metadata
 * @param ctx - The proxy context
 * @returns Array of ordered accounts
 */
export function getOrderedAccounts(
	meta: RequestMeta,
	ctx: ProxyContext,
): Account[] {
	const allAccounts = ctx.dbOps.getAllAccounts();
	// Filter accounts by provider
	const providerAccounts = allAccounts.filter(
		(account) =>
			account.provider === ctx.provider.name || account.provider === null,
	);
	return ctx.strategy.select(providerAccounts, meta);
}

/**
 * Selects accounts for a request based on the load balancing strategy
 * @param meta - Request metadata
 * @param ctx - The proxy context
 * @returns Array of selected accounts
 */
export function selectAccountsForRequest(
	meta: RequestMeta,
	ctx: ProxyContext,
): Account[] {
	return getOrderedAccounts(meta, ctx);
}
</file>

<file path="packages/proxy/src/handlers/proxy-types.ts">
import type { RuntimeConfig } from "@ccflare/config";
import type { AsyncDbWriter, DatabaseOperations } from "@ccflare/database";
import type { Provider } from "@ccflare/providers";
import type { LoadBalancingStrategy } from "@ccflare/types";

export interface ProxyContext {
	strategy: LoadBalancingStrategy;
	dbOps: DatabaseOperations;
	runtime: RuntimeConfig;
	provider: Provider;
	refreshInFlight: Map<string, Promise<string>>;
	asyncWriter: AsyncDbWriter;
	usageWorker: Worker;
}

/** Error messages used throughout the proxy module */
export const ERROR_MESSAGES = {
	NO_ACCOUNTS:
		"No active accounts available - forwarding request without authentication",
	PROVIDER_CANNOT_HANDLE: "Provider cannot handle path",
	REFRESH_NOT_FOUND: "Refresh promise not found for account",
	UNAUTHENTICATED_FAILED: "Failed to forward unauthenticated request",
	ALL_ACCOUNTS_FAILED: "All accounts failed to proxy the request",
	TOKEN_REFRESH_FAILED: "Failed to refresh access token",
	PROXY_REQUEST_FAILED: "Failed to proxy request with account",
} as const;

/** Timing constants */
export const TIMING = {
	WORKER_SHUTDOWN_DELAY: 100, // ms
} as const;

/** HTTP headers used in proxy operations */
export const HEADERS = {
	CONTENT_TYPE: "Content-Type",
	AUTHORIZATION: "Authorization",
} as const;
</file>

<file path="packages/proxy/src/handlers/request-handler.ts">
import crypto from "node:crypto";
import { ValidationError } from "@ccflare/core";
import type { Provider } from "@ccflare/providers";
import type { RequestMeta } from "@ccflare/types";
import { ERROR_MESSAGES } from "./proxy-types";

/**
 * Creates request metadata for tracking and analytics
 * @param req - The incoming request
 * @param url - The parsed URL
 * @returns Request metadata object
 */
export function createRequestMetadata(req: Request, url: URL): RequestMeta {
	return {
		id: crypto.randomUUID(),
		method: req.method,
		path: url.pathname,
		timestamp: Date.now(),
	};
}

/**
 * Validates that the provider can handle the requested path
 * @param provider - The provider instance
 * @param pathname - The request path
 * @throws {ValidationError} If provider cannot handle the path
 */
export function validateProviderPath(
	provider: Provider,
	pathname: string,
): void {
	if (!provider.canHandle(pathname)) {
		throw new ValidationError(
			`${ERROR_MESSAGES.PROVIDER_CANNOT_HANDLE}: ${pathname}`,
			"path",
			pathname,
		);
	}
}

/**
 * Prepares request body for analytics and creates body stream factory
 * @param req - The incoming request
 * @returns Object containing the buffered body and stream factory
 */
export async function prepareRequestBody(req: Request): Promise<{
	buffer: ArrayBuffer | null;
	createStream: () => ReadableStream<Uint8Array> | undefined;
}> {
	let buffer: ArrayBuffer | null = null;

	if (req.body) {
		buffer = await req.arrayBuffer();
	}

	return {
		buffer,
		createStream: () => {
			if (!buffer) return undefined;
			return new Response(buffer).body ?? undefined;
		},
	};
}

/**
 * Makes the actual HTTP request to the provider
 * @param targetUrl - The target URL to fetch
 * @param method - HTTP method
 * @param headers - Request headers
 * @param createBodyStream - Function to create request body stream
 * @param hasBody - Whether the request has a body
 * @returns Promise resolving to the response
 */
export async function makeProxyRequest(
	targetUrl: string,
	method: string,
	headers: Headers,
	createBodyStream: () => ReadableStream<Uint8Array> | undefined,
	hasBody: boolean,
): Promise<Response> {
	return fetch(targetUrl, {
		method,
		headers,
		body: createBodyStream(),
		...(hasBody ? ({ duplex: "half" } as RequestInit) : {}),
	});
}
</file>

<file path="packages/proxy/src/index.ts">
// Re-export provider-related types and functions from @ccflare/providers
export type {
	Provider,
	RateLimitInfo,
	TokenRefreshResult,
} from "@ccflare/providers";
export {
	getProvider,
	listProviders,
	registerProvider,
} from "@ccflare/providers";
export {
	getUsageWorker,
	handleProxy,
	type ProxyContext,
	terminateUsageWorker,
} from "./proxy";
export {
	forwardToClient,
	type ResponseHandlerOptions,
} from "./response-handler";
export type { ProxyRequest, ProxyResponse } from "./types";
export type {
	ChunkMessage,
	ControlMessage,
	EndMessage,
	StartMessage,
	WorkerMessage,
} from "./worker-messages";
</file>

<file path="packages/proxy/src/stream-tee.ts">
import { BUFFER_SIZES } from "@ccflare/core";

/**
 * Tees a ReadableStream to capture data without blocking the original stream.
 * Allows buffering stream content for analytics while maintaining streaming performance.
 */
export function teeStream(
	upstream: ReadableStream<Uint8Array>,
	options: {
		onChunk?: (chunk: Uint8Array) => void;
		onClose?: (buffered: Uint8Array[]) => void;
		onError?: (error: Error) => void;
		maxBytes?: number; // Max bytes to buffer (default: 1MB)
	} = {},
): ReadableStream<Uint8Array> {
	const {
		onChunk,
		onClose,
		onError,
		maxBytes = BUFFER_SIZES.STREAM_TEE_MAX_BYTES,
	} = options;
	const reader = upstream.getReader();
	const buffered: Uint8Array[] = [];
	let totalBytes = 0;
	let truncated = false;

	return new ReadableStream({
		async pull(controller) {
			try {
				const { value, done } = await reader.read();

				if (done) {
					onClose?.(buffered);
					controller.close();
					return;
				}

				// Pass through to client immediately
				controller.enqueue(value);

				// Buffer for analytics if under limit
				if (!truncated && totalBytes + value.length <= maxBytes) {
					buffered.push(value);
					totalBytes += value.length;
				} else if (!truncated) {
					truncated = true;
					// Still buffer this chunk partially to reach exactly maxBytes
					const remaining = maxBytes - totalBytes;
					if (remaining > 0) {
						buffered.push(value.slice(0, remaining));
						totalBytes = maxBytes;
					}
				}

				// Notify chunk handler
				onChunk?.(value);
			} catch (error) {
				onError?.(error as Error);
				controller.error(error);
			}
		},

		cancel(reason) {
			return reader.cancel(reason);
		},
	});
}

/**
 * Combines buffered chunks into a single Buffer
 */
export function combineChunks(chunks: Uint8Array[]): Buffer {
	const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
	const combined = Buffer.allocUnsafe(totalLength);
	let offset = 0;

	for (const chunk of chunks) {
		combined.set(chunk, offset);
		offset += chunk.length;
	}

	return combined;
}
</file>

<file path="packages/proxy/src/types.ts">
export interface ProxyRequest {
	method: string;
	path: string;
	headers: Headers;
	body: ArrayBuffer | null;
	query: string;
}

export interface ProxyResponse {
	status: number;
	statusText: string;
	headers: Headers;
	body: ReadableStream<Uint8Array> | string | null;
}
</file>

<file path="packages/proxy/package.json">
{
	"name": "@ccflare/proxy",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/agents": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/core": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/ui-common": "workspace:*",
		"@dqbd/tiktoken": "^1.0.21"
	}
}
</file>

<file path="packages/proxy/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/tui-core/src/accounts.ts">
import * as cliCommands from "@ccflare/cli-commands";
import { openBrowser } from "@ccflare/cli-commands";
import { Config } from "@ccflare/config";
import { DatabaseFactory } from "@ccflare/database";
import { type BeginResult, createOAuthFlow } from "@ccflare/oauth-flow";
import type { AccountListItem, AddAccountOptions } from "@ccflare/types";

export interface OAuthFlowResult extends BeginResult {
	// Extends BeginResult from oauth-flow package
}

/**
 * Begin OAuth flow for adding an account (TUI version)
 * Returns the auth URL and PKCE data needed to complete the flow
 */
export async function beginAddAccount(
	options: AddAccountOptions,
): Promise<OAuthFlowResult> {
	const { name, mode = "max" } = options;
	const config = new Config();
	const dbOps = DatabaseFactory.getInstance();

	// Create OAuth flow instance
	const oauthFlow = await createOAuthFlow(dbOps, config);

	// Begin OAuth flow
	const flowResult = await oauthFlow.begin({ name, mode });

	// Open browser
	console.log(`\nOpening browser to authenticate...`);
	const browserOpened = await openBrowser(flowResult.authUrl);
	if (!browserOpened) {
		console.log(
			`Please open the following URL in your browser:\n${flowResult.authUrl}`,
		);
	}

	return flowResult;
}

/**
 * Complete OAuth flow after receiving authorization code
 */
export async function completeAddAccount(
	options: AddAccountOptions & { code: string; flowData: OAuthFlowResult },
): Promise<void> {
	const { name, mode = "max", tier = 1, code, flowData } = options;
	const config = new Config();
	const dbOps = DatabaseFactory.getInstance();

	// Create OAuth flow instance
	const oauthFlow = await createOAuthFlow(dbOps, config);

	// Complete OAuth flow
	console.log("\nExchanging code for tokens...");
	const _account = await oauthFlow.complete(
		{ sessionId: flowData.sessionId, code, tier, name },
		flowData,
	);

	console.log(`\nAccount '${name}' added successfully!`);
	console.log(`Type: ${mode === "max" ? "Claude Max" : "Claude Console"}`);
	console.log(`Tier: ${tier}x`);
}

/**
 * Legacy function for non-TUI usage
 */
export async function addAccount(options: AddAccountOptions): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	const config = new Config();
	await cliCommands.addAccount(dbOps, config, {
		name: options.name,
		mode: options.mode || "max",
		tier: options.tier || 1,
	});
}

export async function getAccounts(): Promise<AccountListItem[]> {
	const dbOps = DatabaseFactory.getInstance();
	return await cliCommands.getAccountsList(dbOps);
}

export async function removeAccount(name: string): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	await cliCommands.removeAccount(dbOps, name);
}

export async function pauseAccount(
	name: string,
): Promise<{ success: boolean; message: string }> {
	const dbOps = DatabaseFactory.getInstance();
	return cliCommands.pauseAccount(dbOps, name);
}

export async function resumeAccount(
	name: string,
): Promise<{ success: boolean; message: string }> {
	const dbOps = DatabaseFactory.getInstance();
	return cliCommands.resumeAccount(dbOps, name);
}
</file>

<file path="packages/tui-core/src/logs.ts">
import { logBus, logFileWriter } from "@ccflare/logger";
import type { LogEvent } from "@ccflare/types";

export function streamLogs(callback: (log: LogEvent) => void): () => void {
	const listener = (event: LogEvent) => {
		callback(event);
	};

	logBus.on("log", listener);

	// Return unsubscribe function
	return () => {
		logBus.off("log", listener);
	};
}

export async function getLogHistory(limit = 1000): Promise<LogEvent[]> {
	try {
		return await logFileWriter.readLogs(limit);
	} catch (error) {
		console.error("Failed to read log history:", error);
		return [];
	}
}
</file>

<file path="packages/tui-core/src/requests.ts">
import { DatabaseFactory } from "@ccflare/database";
import type { RequestPayload } from "@ccflare/types";

export type { RequestPayload };

export interface RequestSummary {
	id: string;
	model?: string;
	inputTokens?: number;
	outputTokens?: number;
	totalTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	costUsd?: number;
	responseTimeMs?: number;
}

export async function getRequests(limit = 100): Promise<RequestPayload[]> {
	const dbOps = DatabaseFactory.getInstance();
	const rows = dbOps.listRequestPayloads(limit);

	const parsed = rows.map((r: { id: string; json: string }) => {
		try {
			const data = JSON.parse(r.json);
			// Add account name if we have accountId
			if (data.meta?.accountId) {
				const account = dbOps.getAccount(data.meta.accountId);
				if (account) {
					data.meta.accountName = account.name;
				}
			}
			return { id: r.id, ...data } as RequestPayload;
		} catch {
			return {
				id: r.id,
				error: "Failed to parse payload",
				request: { headers: {}, body: null },
				response: null,
				meta: { timestamp: Date.now() },
			} as RequestPayload;
		}
	});

	return parsed;
}

export async function getRequestSummaries(
	limit = 100,
): Promise<Map<string, RequestSummary>> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();

	const summaries = db
		.query(`
		SELECT 
			id,
			model,
			input_tokens as inputTokens,
			output_tokens as outputTokens,
			total_tokens as totalTokens,
			cache_read_input_tokens as cacheReadInputTokens,
			cache_creation_input_tokens as cacheCreationInputTokens,
			cost_usd as costUsd,
			response_time_ms as responseTimeMs
		FROM requests
		ORDER BY timestamp DESC
		LIMIT ?
	`)
		.all(limit) as Array<{
		id: string;
		model?: string;
		inputTokens?: number;
		outputTokens?: number;
		totalTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		costUsd?: number;
		responseTimeMs?: number;
	}>;

	const summaryMap = new Map<string, RequestSummary>();
	summaries.forEach((summary) => {
		summaryMap.set(summary.id, {
			id: summary.id,
			model: summary.model || undefined,
			inputTokens: summary.inputTokens || undefined,
			outputTokens: summary.outputTokens || undefined,
			totalTokens: summary.totalTokens || undefined,
			cacheReadInputTokens: summary.cacheReadInputTokens || undefined,
			cacheCreationInputTokens: summary.cacheCreationInputTokens || undefined,
			costUsd: summary.costUsd || undefined,
			responseTimeMs: summary.responseTimeMs || undefined,
		});
	});

	return summaryMap;
}
</file>

<file path="packages/tui-core/src/stats.ts">
import * as cliCommands from "@ccflare/cli-commands";
import { DatabaseFactory } from "@ccflare/database";

export interface Stats {
	totalRequests: number;
	successRate: number;
	activeAccounts: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	avgTokensPerSecond: number | null;
	tokenDetails?: {
		inputTokens: number;
		cacheReadInputTokens: number;
		cacheCreationInputTokens: number;
		outputTokens: number;
	};
	accounts: Array<{
		name: string;
		requestCount: number;
		successRate: number;
	}>;
	recentErrors: string[];
}

export async function getStats(): Promise<Stats> {
	const dbOps = DatabaseFactory.getInstance();
	const statsRepository = dbOps.getStatsRepository();

	// Get overall statistics using the consolidated repository
	const stats = statsRepository.getAggregatedStats();
	const activeAccounts = statsRepository.getActiveAccountCount();

	const successRate =
		stats && stats.totalRequests > 0
			? Math.round((stats.successfulRequests / stats.totalRequests) * 100)
			: 0;

	// Get per-account stats using the consolidated repository
	const accountsWithStats = statsRepository.getAccountStats(10, false);

	// Get recent errors
	const recentErrors = statsRepository.getRecentErrors();

	return {
		totalRequests: stats.totalRequests,
		successRate,
		activeAccounts,
		avgResponseTime: Math.round(stats.avgResponseTime || 0),
		totalTokens: stats.totalTokens,
		totalCostUsd: stats.totalCostUsd,
		avgTokensPerSecond: stats.avgTokensPerSecond,
		tokenDetails:
			stats.inputTokens || stats.outputTokens
				? {
						inputTokens: stats.inputTokens,
						cacheReadInputTokens: stats.cacheReadInputTokens,
						cacheCreationInputTokens: stats.cacheCreationInputTokens,
						outputTokens: stats.outputTokens,
					}
				: undefined,
		accounts: accountsWithStats,
		recentErrors,
	};
}

export async function resetStats(): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	// Clear request history
	db.run("DELETE FROM requests");
	// Reset account statistics
	db.run("UPDATE accounts SET request_count = 0, session_request_count = 0");
}

export async function clearHistory(): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	db.run("DELETE FROM requests");
}

export async function analyzePerformance(): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	cliCommands.analyzePerformance(db);
}
</file>

<file path="packages/tui-core/src/strategy.ts">
import { Config } from "@ccflare/config";

async function getPort(): Promise<number> {
	const config = new Config();
	const runtime = config.getRuntime();
	return runtime.port || 8080;
}

export async function getStrategy(): Promise<string> {
	const port = await getPort();
	const baseUrl = `http://localhost:${port}`;
	const res = await fetch(`${baseUrl}/api/config/strategy`);
	if (!res.ok) throw new Error("Failed to fetch strategy");
	const data = (await res.json()) as { strategy: string };
	return data.strategy;
}

export async function listStrategies(): Promise<string[]> {
	const port = await getPort();
	const baseUrl = `http://localhost:${port}`;
	const res = await fetch(`${baseUrl}/api/strategies`);
	if (!res.ok) throw new Error("Failed to list strategies");
	return res.json() as Promise<string[]>;
}

export async function setStrategy(strategy: string): Promise<void> {
	const port = await getPort();
	const baseUrl = `http://localhost:${port}`;
	const res = await fetch(`${baseUrl}/api/config/strategy`, {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({ strategy }),
	});
	if (!res.ok) {
		const error = (await res.json()) as { error?: string };
		throw new Error(error.error || "Failed to set strategy");
	}
}
</file>

<file path="packages/tui-core/package.json">
{
	"name": "@ccflare/tui-core",
	"version": "1.0.0",
	"description": "Core controller logic for ccflare TUI",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/cli-commands": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/core": "workspace:*",
		"@ccflare/oauth-flow": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/types": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^20.0.0"
	}
}
</file>

<file path="packages/tui-core/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"module": "ESNext",
		"target": "ESNext",
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"types": ["node"]
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules"]
}
</file>

<file path="packages/types/src/context.ts">
import type { Database } from "bun:sqlite";
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import type { Account } from "./account";
import type { RequestMeta } from "./api";
import type { StrategyStore } from "./strategy";

// API context for HTTP handlers
export interface APIContext {
	db: Database;
	config: Config;
	dbOps: DatabaseOperations;
}

// Load balancing strategy interface
export interface LoadBalancingStrategy {
	/**
	 * Return a filtered & ordered list of candidate accounts.
	 * Accounts that are rate-limited should be filtered out.
	 * The first account in the list should be tried first.
	 */
	select(accounts: Account[], meta: RequestMeta): Account[];

	/**
	 * Optional initialization method to inject dependencies
	 * Used for strategies that need access to a StrategyStore
	 */
	initialize?(store: StrategyStore): void;
}
</file>

<file path="packages/types/src/logging.ts">
export interface LogEvent {
	ts: number;
	level: "DEBUG" | "INFO" | "WARN" | "ERROR";
	msg: string;
}
</file>

<file path="packages/types/src/strategy.ts">
import type { Account } from "./account";

export enum StrategyName {
	Session = "session",
}

/**
 * Interface for strategy-specific database operations
 * Allows strategies to interact with the database without direct SQL access
 */
export interface StrategyStore {
	/**
	 * Reset session for an account
	 * Updates session_start and session_request_count
	 */
	resetAccountSession(accountId: string, timestamp: number): void;

	/**
	 * Get all accounts (optional method for strategies that need full account list)
	 */
	getAllAccounts?(): Account[];

	/**
	 * Update account request count
	 */
	updateAccountRequestCount?(accountId: string, count: number): void;

	/**
	 * Get account by ID
	 */
	getAccount?(accountId: string): Account | null;
}
</file>

<file path="packages/types/package.json">
{
	"name": "@ccflare/types",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	}
}
</file>

<file path="packages/types/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}
</file>

<file path="packages/ui-common/src/components/TokenUsageDisplay.tsx">
import {
	formatCost,
	formatDuration,
	formatTokens,
	formatTokensPerSecond,
} from "../formatters";

/**
 * Token usage data structure
 */
export interface TokenUsageData {
	inputTokens?: number;
	outputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	totalTokens?: number;
	costUsd?: number;
	responseTimeMs?: number;
	tokensPerSecond?: number;
}

/**
 * Processed token usage information for display
 */
export interface TokenUsageInfo {
	hasData: boolean;
	sections: {
		inputTokens?: { label: string; value: string };
		outputTokens?: { label: string; value: string };
		cacheReadTokens?: { label: string; value: string };
		cacheCreationTokens?: { label: string; value: string };
		totalTokens?: { label: string; value: string };
		cost?: { label: string; value: string };
		responseTime?: { label: string; value: string };
		tokensPerSecond?: { label: string; value: string };
	};
}

/**
 * Process token usage data for display
 * This contains the shared business logic for both dashboard and TUI
 */
export function processTokenUsage(
	data: TokenUsageData | undefined,
): TokenUsageInfo {
	if (!data || (!data.inputTokens && !data.outputTokens)) {
		return {
			hasData: false,
			sections: {},
		};
	}

	const sections: TokenUsageInfo["sections"] = {};

	// Input tokens
	if (data.inputTokens !== undefined) {
		sections.inputTokens = {
			label: "Input Tokens",
			value: formatTokens(data.inputTokens),
		};
	}

	// Output tokens
	if (data.outputTokens !== undefined) {
		sections.outputTokens = {
			label: "Output Tokens",
			value: formatTokens(data.outputTokens),
		};
	}

	// Cache read tokens
	if (
		data.cacheReadInputTokens !== undefined &&
		data.cacheReadInputTokens > 0
	) {
		sections.cacheReadTokens = {
			label: "Cache Read Tokens",
			value: formatTokens(data.cacheReadInputTokens),
		};
	}

	// Cache creation tokens
	if (
		data.cacheCreationInputTokens !== undefined &&
		data.cacheCreationInputTokens > 0
	) {
		sections.cacheCreationTokens = {
			label: "Cache Creation Tokens",
			value: formatTokens(data.cacheCreationInputTokens),
		};
	}

	// Total tokens
	if (data.totalTokens !== undefined) {
		sections.totalTokens = {
			label: "Total Tokens",
			value: formatTokens(data.totalTokens),
		};
	}

	// Cost
	if (data.costUsd !== undefined && data.costUsd > 0) {
		sections.cost = {
			label: "Cost",
			value: formatCost(data.costUsd),
		};
	}

	// Response time
	if (data.responseTimeMs !== undefined) {
		sections.responseTime = {
			label: "Response Time",
			value: formatDuration(data.responseTimeMs),
		};
	}

	// Tokens per second
	if (data.tokensPerSecond !== undefined && data.tokensPerSecond > 0) {
		sections.tokensPerSecond = {
			label: "Speed",
			value: formatTokensPerSecond(data.tokensPerSecond),
		};
	}

	return {
		hasData: true,
		sections,
	};
}

/**
 * Helper to determine if there are cache tokens to display
 */
export function hasCacheTokens(data: TokenUsageData | undefined): boolean {
	if (!data) return false;
	return (
		(data.cacheReadInputTokens !== undefined &&
			data.cacheReadInputTokens > 0) ||
		(data.cacheCreationInputTokens !== undefined &&
			data.cacheCreationInputTokens > 0)
	);
}
</file>

<file path="packages/ui-common/src/formatters.ts">
import { TIME_CONSTANTS } from "@ccflare/core";

/**
 * Format duration in milliseconds to human-readable string
 */
export function formatDuration(ms: number): string {
	if (ms < TIME_CONSTANTS.SECOND) return `${ms}ms`;
	if (ms < TIME_CONSTANTS.MINUTE)
		return `${(ms / TIME_CONSTANTS.SECOND).toFixed(1)}s`;
	if (ms < TIME_CONSTANTS.HOUR)
		return `${(ms / TIME_CONSTANTS.MINUTE).toFixed(1)}m`;
	return `${(ms / TIME_CONSTANTS.HOUR).toFixed(1)}h`;
}

/**
 * Format tokens with locale-aware thousands separator
 */
export function formatTokens(tokens?: number): string {
	if (!tokens || tokens === 0) return "0";
	return tokens.toLocaleString();
}

/**
 * Format USD cost with 4 decimal places
 */
export function formatCost(cost?: number): string {
	if (!cost || cost === 0) return "$0.0000";
	return `$${cost.toFixed(4)}`;
}

/**
 * Format percentage with specified decimal places
 */
export function formatPercentage(value: number, decimals = 1): string {
	return `${value.toFixed(decimals)}%`;
}

/**
 * Format number with locale-aware thousands separator
 */
export function formatNumber(value: number): string {
	return value.toLocaleString();
}

/**
 * Format timestamp to locale string
 */
export function formatTimestamp(timestamp: number | string): string {
	const date =
		typeof timestamp === "string" ? new Date(timestamp) : new Date(timestamp);
	return date.toLocaleString();
}

/**
 * Format tokens per second with 1 decimal place
 */
export function formatTokensPerSecond(tokensPerSecond?: number | null): string {
	if (!tokensPerSecond || tokensPerSecond === 0) return "0 tok/s";
	return `${tokensPerSecond.toFixed(1)} tok/s`;
}
</file>

<file path="packages/ui-common/package.json">
{
	"name": "@ccflare/ui-common",
	"private": true,
	"version": "0.0.0",
	"type": "module",
	"exports": {
		".": "./src/index.ts",
		"./*": "./src/*.ts"
	},
	"scripts": {
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/types": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^22.10.2",
		"typescript": "^5.7.2"
	}
}
</file>

<file path="packages/ui-common/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist"
	},
	"include": ["src/**/*"]
}
</file>

<file path="packages/ui-constants/src/index.ts">
// Color palette used across UI components
export const COLORS = {
	primary: "#f38020",
	success: "#10b981",
	warning: "#f59e0b",
	error: "#ef4444",
	blue: "#3b82f6",
	purple: "#8b5cf6",
	pink: "#ec4899",
} as const;

// Chart color sequence for multi-series charts
export const CHART_COLORS = [
	COLORS.primary,
	COLORS.blue,
	COLORS.purple,
	COLORS.pink,
	COLORS.success,
] as const;

// Time range options for analytics
export type TimeRange = "1h" | "6h" | "24h" | "7d" | "30d";

export const TIME_RANGES: Record<TimeRange, string> = {
	"1h": "Last Hour",
	"6h": "Last 6 Hours",
	"24h": "Last 24 Hours",
	"7d": "Last 7 Days",
	"30d": "Last 30 Days",
} as const;

// Chart dimensions
export const CHART_HEIGHTS = {
	small: 250,
	medium: 300,
	large: 400,
} as const;

// Common chart tooltip styles
export const CHART_TOOLTIP_STYLE = {
	default: {
		backgroundColor: "var(--background)",
		border: "1px solid var(--border)",
		borderRadius: "var(--radius)",
	},
	success: {
		backgroundColor: COLORS.success,
		border: `1px solid ${COLORS.success}`,
		borderRadius: "var(--radius)",
		color: "#fff",
	},
	dark: {
		backgroundColor: "rgba(0,0,0,0.8)",
		border: "1px solid rgba(255,255,255,0.2)",
		borderRadius: "8px",
		backdropFilter: "blur(8px)",
	},
} as const;

// Chart common properties
export const CHART_PROPS = {
	strokeDasharray: "3 3",
	gridClassName: "stroke-muted",
} as const;

// API and data refresh intervals (in milliseconds)
export const REFRESH_INTERVALS = {
	default: 30000, // 30 seconds
	fast: 10000, // 10 seconds
	slow: 60000, // 1 minute
} as const;

// API timeout
export const API_TIMEOUT = 30000; // 30 seconds

// React Query configuration
export const QUERY_CONFIG = {
	staleTime: 10000, // Consider data stale after 10 seconds
} as const;

// API default limits
export const API_LIMITS = {
	requestsDetail: 100,
	requestsSummary: 50,
} as const;
</file>

<file path="packages/ui-constants/package.json">
{
	"name": "@ccflare/ui-constants",
	"version": "1.0.0",
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"scripts": {
		"typecheck": "tsc --noEmit",
		"lint": "biome check --write --unsafe"
	},
	"devDependencies": {
		"@types/bun": "1.1.15",
		"typescript": "5.7.2"
	}
}
</file>

<file path="packages/ui-constants/tsconfig.json">
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"baseUrl": ".",
		"outDir": "./dist",
		"rootDir": "./src"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}
</file>

<file path=".biomeignore">
**/dist
**/dist/**
**/build
**/build/**
**/node_modules
**/node_modules/**
**/*.min.js
**/*.min.css
**/*.bundle.js
packages/dashboard-web/dist
packages/dashboard-web/dist/**
</file>

<file path=".env.example">
# Port for the proxy server (optional, defaults to 8080)
PORT=8080

# Load-balancing strategy: least-requests | round-robin | session | weighted | weighted-round-robin
# - least-requests: Route to account with fewest requests (default)
# - round-robin: Distribute requests evenly across all accounts
# - session: Maintain 5-hour sessions per account
# - weighted: Route based on tier-adjusted request count (respects 1x, 5x, 20x tiers)
# - weighted-round-robin: Round-robin that gives more slots to higher tier accounts
LB_STRATEGY=least-requests

# Log level: DEBUG | INFO | WARN | ERROR (optional, defaults to INFO)
LOG_LEVEL=INFO

# Log format: pretty | json (optional, defaults to pretty)
# - pretty: Human-readable format with timestamps
# - json: Structured JSON logs for log aggregators
LOG_FORMAT=pretty

# Example of how to use the proxy with your application:
# ANTHROPIC_BASE_URL=http://localhost:8080
</file>

<file path=".gitignore">
node_modules/
.env
.env.local
ccflare.db
ccflare.db-wal
ccflare.db-shm
dist/
.DS_Store
*.log
tsconfig.tsbuildinfo
</file>

<file path="biome.json">
{
	"$schema": "https://biomejs.dev/schemas/2.1.2/schema.json",
	"vcs": {
		"enabled": true,
		"clientKind": "git",
		"useIgnoreFile": true
	},
	"files": {
		"ignoreUnknown": false,
		"includes": ["apps/**", "packages/**"]
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "tab"
	},
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "double"
		}
	},
	"assist": {
		"enabled": true,
		"actions": {
			"source": {
				"organizeImports": "on"
			}
		}
	}
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## What is this?

A load balancer proxy for Claude and Claude Code that distributes requests across multiple OAuth accounts to avoid rate limiting.

## Important: After making code changes

Always run:
- `bun run lint` - Fix linting issues  
- `bun run typecheck` - Check for type errors
- `bun run format` - Format code

## Commands

### Running the server
- `bun start` - Start the load balancer (port 8080)

### Managing accounts
- `ccflare --add-account <name>` - Add a new account
- `ccflare --list` - List all accounts
- `ccflare --remove <name>` - Remove an account

### Maintenance
- `ccflare --reset-stats` - Reset usage statistics
- `ccflare --clear-history` - Clear request history
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 snipeship

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
	"private": true,
	"name": "ccflare",
	"workspaces": [
		"apps/*",
		"packages/*"
	],
	"scripts": {
		"ccflare": "bun run build && bun run tui",
		"tui": "bun run apps/tui/src/main.ts",
		"dev": "bun run tui",
		"start": "bun run apps/server/src/server.ts",
		"server": "bun run apps/server/src/server.ts",
		"dev:server": "bun run --hot apps/server/src/server.ts",
		"dev:dashboard": "bun --hot packages/dashboard-web/src/index.tsx",
		"typecheck": "bunx tsc --noEmit",
		"build": "bun run build:dashboard && bun run build:tui",
		"build:dashboard": "bun run --cwd packages/dashboard-web build",
		"build:tui": "bun run --cwd apps/tui build",
		"build:lander": "bun run --cwd apps/lander build",
		"format": "bunx biome format --write .",
		"lint": "bunx --bun biome check --write --unsafe ."
	},
	"engines": {
		"bun": ">=1.2.8"
	},
	"devDependencies": {
		"@biomejs/biome": "2.1.2",
		"bun-types": "latest",
		"@types/bun": "latest",
		"typescript": "^5.0.0"
	},
	"overrides": {
		"react": "^19.0.0",
		"@types/react": "^19.0.0"
	}
}
</file>

<file path="docs/api-http.md">
# ccflare HTTP API Documentation

## Quick Start

```bash
# Check health status
curl http://localhost:8080/health

# Proxy a request to Claude
curl -X POST http://localhost:8080/v1/messages \
  -H "Content-Type: application/json" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "claude-3-opus-20240229",
    "messages": [{"role": "user", "content": "Hello!"}],
    "max_tokens": 100
  }'

# List all accounts
curl http://localhost:8080/api/accounts

# View dashboard
open http://localhost:8080/dashboard
```

## Overview

ccflare provides a RESTful HTTP API for managing accounts, monitoring usage, and proxying requests to Claude. The API runs on port 8080 by default and requires no authentication.

### Base URL

```
http://localhost:8080
```

### Content Type

All API responses are in JSON format with `Content-Type: application/json`.

## Endpoints

### Health Check

#### GET /health

Check the health status of the ccflare service.

**Response:**
```json
{
  "status": "ok",
  "accounts": 5,
  "timestamp": "2024-12-17T10:30:45.123Z",
  "strategy": "session"
}
```

**Example:**
```bash
curl http://localhost:8080/health
```

---

### Claude Proxy

#### /v1/* (All Methods)

Proxy requests to Claude API. All requests to paths starting with `/v1/` are forwarded to Claude using the configured load balancing strategy. This includes POST, GET, and any other HTTP methods that Claude's API supports.

**Supported Endpoints:**
- `POST /v1/messages` - Create chat completions
- `POST /v1/complete` - Text completion (legacy)
- Any other Claude API v1 endpoint

**Note:** There is no `/v1/models` endpoint provided by ccflare. Model listing would need to be done directly through Claude's API if such an endpoint exists.

**Headers:**
- All standard Claude API headers are supported
- `Authorization` header is managed by ccflare (no need to provide)

**Request Body:**
Same as Claude API requirements for the specific endpoint.

**Response:**
Proxied response from Claude API, including streaming responses.

**Automatic Failover:**
If a request fails or an account is rate limited, ccflare automatically retries with the next available account according to the configured load balancing strategy. This ensures high availability and reliability.

**Example:**
```bash
curl -X POST http://localhost:8080/v1/messages \
  -H "Content-Type: application/json" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "claude-3-opus-20240229",
    "messages": [{"role": "user", "content": "Hello!"}],
    "max_tokens": 100
  }'
```

---

### Account Management

#### GET /api/accounts

List all configured accounts with their current status.

**Response:**
```json
[
  {
    "id": "uuid-here",
    "name": "account1",
    "provider": "anthropic",
    "requestCount": 150,
    "totalRequests": 1500,
    "lastUsed": "2024-12-17T10:25:30.123Z",
    "created": "2024-12-01T08:00:00.000Z",
    "tier": 5,
    "paused": false,
    "tokenStatus": "valid",
    "rateLimitStatus": "allowed_warning (5m)",
    "rateLimitReset": "2024-12-17T10:30:00.000Z",
    "rateLimitRemaining": 100,
    "sessionInfo": "Session: 25 requests"
  }
]
```

**Example:**
```bash
curl http://localhost:8080/api/accounts
```

---

### OAuth Flow

#### POST /api/oauth/init

Initialize OAuth flow for adding a new account.

**Request:**
```json
{
  "name": "myaccount",
  "mode": "max",  // "max" or "console" (default: "max")
  "tier": 5       // 1, 5, or 20 (default: 1)
}
```

**Response:**
```json
{
  "success": true,
  "authUrl": "https://console.anthropic.com/oauth/authorize?...",
  "sessionId": "uuid-here",
  "step": "authorize"
}
```

**Example:**
```bash
curl -X POST http://localhost:8080/api/oauth/init \
  -H "Content-Type: application/json" \
  -d '{"name": "myaccount", "mode": "max", "tier": 5}'
```

#### POST /api/oauth/callback

Complete OAuth flow after user authorization.

**Request:**
```json
{
  "sessionId": "uuid-from-init-response",
  "code": "authorization-code-from-oauth"
}
```

**Response:**
```json
{
  "success": true,
  "message": "Account 'myaccount' added successfully!",
  "mode": "Claude Max",
  "tier": 5
}
```

**Example:**
```bash
curl -X POST http://localhost:8080/api/oauth/callback \
  -H "Content-Type: application/json" \
  -d '{"sessionId": "uuid-here", "code": "auth-code"}'
```

---

### Account Management

#### DELETE /api/accounts/:accountId

Remove an account. Requires confirmation.

**Request:**
```json
{
  "confirm": "account-name"
}
```

**Response:**
```json
{
  "success": true,
  "message": "Account 'account-name' removed successfully"
}
```

**Example:**
```bash
curl -X DELETE http://localhost:8080/api/accounts/uuid-here \
  -H "Content-Type: application/json" \
  -d '{"confirm": "myaccount"}'
```

#### POST /api/accounts/:accountId/tier

Update account tier.

**Request:**
```json
{
  "tier": 5  // 1, 5, or 20
}
```

**Response:**
```json
{
  "success": true,
  "tier": 5
}
```

**Example:**
```bash
curl -X POST http://localhost:8080/api/accounts/uuid-here/tier \
  -H "Content-Type: application/json" \
  -d '{"tier": 20}'
```

#### POST /api/accounts/:accountId/pause

Pause an account temporarily.

**Response:**
```json
{
  "success": true,
  "message": "Account 'myaccount' paused"
}
```

**Example:**
```bash
curl -X POST http://localhost:8080/api/accounts/uuid-here/pause
```

#### POST /api/accounts/:accountId/resume

Resume a paused account.

**Response:**
```json
{
  "success": true,
  "message": "Account 'myaccount' resumed"
}
```

**Example:**
```bash
curl -X POST http://localhost:8080/api/accounts/uuid-here/resume
```

---

### Statistics

#### GET /api/stats

Get overall usage statistics.

**Response:**
```json
{
  "totalRequests": 5000,
  "successRate": 98.5,
  "activeAccounts": 4,
  "avgResponseTime": 1250.5,
  "totalTokens": 1500000,
  "totalCostUsd": 125.50,
  "avgTokensPerSecond": null,
  "topModels": [
    {"model": "claude-3-opus-20240229", "count": 3000},
    {"model": "claude-3-sonnet-20240229", "count": 2000}
  ]
}
```

**Example:**
```bash
curl http://localhost:8080/api/stats
```

#### POST /api/stats/reset

Reset all usage statistics.

**Response:**
```json
{
  "success": true,
  "message": "Statistics reset successfully"
}
```

**Example:**
```bash
curl -X POST http://localhost:8080/api/stats/reset
```

---

### Request History

#### GET /api/requests

Get recent request summary.

**Query Parameters:**
- `limit` - Number of requests to return (default: 50)

**Response:**
```json
[
  {
    "id": "request-uuid",
    "timestamp": "2024-12-17T10:30:45.123Z",
    "method": "POST",
    "path": "/v1/messages",
    "accountUsed": "account1",
    "statusCode": 200,
    "success": true,
    "errorMessage": null,
    "responseTimeMs": 1234,
    "failoverAttempts": 0,
    "model": "claude-3-opus-20240229",
    "promptTokens": 50,
    "completionTokens": 100,
    "totalTokens": 150,
    "inputTokens": 50,
    "outputTokens": 100,
    "cacheReadInputTokens": 0,
    "cacheCreationInputTokens": 0,
    "costUsd": 0.0125,
    "agentUsed": null,
    "tokensPerSecond": null
  }
]
```

**Example:**
```bash
curl "http://localhost:8080/api/requests?limit=100"
```

#### GET /api/requests/detail

Get detailed request information including payloads. Request and response bodies are base64-encoded to handle binary data and special characters.

**Query Parameters:**
- `limit` - Number of requests to return (default: 100)

**Response:**
```json
[
  {
    "id": "request-uuid",
    "timestamp": "2024-12-17T10:30:45.123Z",
    "method": "POST",
    "path": "/v1/messages",
    "accountUsed": "account1",
    "statusCode": 200,
    "success": true,
    "payload": {
      "request": {
        "headers": {...},
        "body": "base64-encoded-body"
      },
      "response": {
        "status": 200,
        "headers": {...},
        "body": "base64-encoded-body"
      },
      "meta": {
        "accountId": "uuid",
        "accountName": "account1",
        "retry": 0,
        "timestamp": 1234567890,
        "success": true,
        "rateLimited": false,
        "accountsAttempted": 1
      }
    }
  }
]
```

**Example:**
```bash
curl "http://localhost:8080/api/requests/detail?limit=10"
```

---

### Configuration

#### GET /api/config

Get current configuration.

**Response:**
```json
{
  "lb_strategy": "session",
  "port": 8080,
  "sessionDurationMs": 18000000
}
```

**Example:**
```bash
curl http://localhost:8080/api/config
```

#### GET /api/config/strategy

Get current load balancing strategy.

**Response:**
```json
{
  "strategy": "session"
}
```

**Example:**
```bash
curl http://localhost:8080/api/config/strategy
```

#### POST /api/config/strategy

Update load balancing strategy.

**Request:**
```json
{
  "strategy": "session"
}
```

**Response:**
```json
{
  "success": true,
  "strategy": "session"
}
```

**Available Strategies:**
- `session` - Session-based routing that maintains 5-hour sessions with individual accounts to avoid rate limits and account bans

**⚠️ WARNING:** Only the session strategy is supported. Other strategies have been removed as they can trigger Claude's anti-abuse systems.

**Example:**
```bash
curl -X POST http://localhost:8080/api/config/strategy \
  -H "Content-Type: application/json" \
  -d '{"strategy": "session"}'
```

#### GET /api/strategies

List all available load balancing strategies.

**Response:**
```json
["session"]
```

**Example:**
```bash
curl http://localhost:8080/api/strategies
```

---

### Analytics

#### GET /api/analytics

Get detailed analytics data.

**Query Parameters:**
- `range` - Time range: `1h`, `6h`, `24h`, `7d`, `30d` (default: `24h`)
- `accounts` - Filter by account names (comma-separated list)
- `models` - Filter by model names (comma-separated list)
- `status` - Filter by request status: `all`, `success`, `error` (default: `all`)
- `mode` - Display mode: `normal`, `cumulative` (default: `normal`). Cumulative mode shows running totals over time
- `modelBreakdown` - Include per-model time series data: `true`, `false` (default: `false`)

**Response:**
```json
{
  "meta": {
    "range": "24h",
    "bucket": "1h",
    "cumulative": false
  },
  "totals": {
    "requests": 5000,
    "successRate": 98.5,
    "activeAccounts": 4,
    "avgResponseTime": 1250.5,
    "totalTokens": 1500000,
    "totalCostUsd": 125.50,
    "avgTokensPerSecond": null
  },
  "timeSeries": [
    {
      "ts": 1734430800000,
      "requests": 100,
      "tokens": 15000,
      "costUsd": 1.25,
      "successRate": 98,
      "errorRate": 2,
      "cacheHitRate": 15,
      "avgResponseTime": 1200,
      "avgTokensPerSecond": null
    }
  ],
  "tokenBreakdown": {
    "inputTokens": 500000,
    "cacheReadInputTokens": 100000,
    "cacheCreationInputTokens": 50000,
    "outputTokens": 850000
  },
  "modelDistribution": [
    {"model": "claude-3-opus-20240229", "count": 3000}
  ],
  "accountPerformance": [
    {"name": "account1", "requests": 2500, "successRate": 99}
  ],
  "costByModel": [
    {"model": "claude-3-opus-20240229", "costUsd": 100.50, "requests": 3000, "totalTokens": 1200000}
  ],
  "modelPerformance": [
    {
      "model": "claude-3-opus-20240229",
      "avgResponseTime": 1300,
      "p95ResponseTime": 2500,
      "errorRate": 1.5,
      "avgTokensPerSecond": null,
      "minTokensPerSecond": null,
      "maxTokensPerSecond": null
    }
  ]
}
```

**Examples:**
```bash
# Basic analytics for last 7 days
curl "http://localhost:8080/api/analytics?range=7d"

# Analytics filtered by specific accounts
curl "http://localhost:8080/api/analytics?range=24h&accounts=account1,account2"

# Analytics for specific models with success status only
curl "http://localhost:8080/api/analytics?range=24h&models=claude-3-opus-20240229,claude-3-sonnet-20240229&status=success"

# Combined filters
curl "http://localhost:8080/api/analytics?range=7d&accounts=premium1,premium2&models=claude-3-opus-20240229&status=error"
```

---

### Agent Management

#### GET /api/agents

List all available agents with their preferences.

**Response:**
```json
{
  "agents": [
    {
      "id": "agent-uuid",
      "name": "code-reviewer",
      "description": "Reviews code for quality and best practices",
      "model": "claude-3-5-sonnet-20241022",
      "source": "global",
      "workspace": null
    }
  ],
  "globalAgents": [...],
  "workspaceAgents": [...],
  "workspaces": [
    {
      "name": "my-workspace",
      "path": "/path/to/workspace"
    }
  ]
}
```

**Example:**
```bash
curl http://localhost:8080/api/agents
```

#### POST /api/agents/:agentId/preference

Update model preference for a specific agent.

**Request:**
```json
{
  "model": "claude-3-5-sonnet-20241022"
}
```

**Response:**
```json
{
  "success": true,
  "agentId": "agent-uuid",
  "model": "claude-3-5-sonnet-20241022"
}
```

**Example:**
```bash
curl -X POST http://localhost:8080/api/agents/agent-uuid/preference \
  -H "Content-Type: application/json" \
  -d '{"model": "claude-3-5-sonnet-20241022"}'
```

#### GET /api/workspaces

List all available workspaces with agent counts.

**Response:**
```json
{
  "workspaces": [
    {
      "name": "my-workspace",
      "path": "/path/to/workspace",
      "agentCount": 5
    }
  ]
}
```

**Example:**
```bash
curl http://localhost:8080/api/workspaces
```

---

### Logs

#### GET /api/logs/stream

Stream real-time logs via Server-Sent Events (SSE).

**Response:** SSE stream with log events

**Example:**
```bash
curl -N http://localhost:8080/api/logs/stream
```

#### GET /api/logs/history

Get historical logs.

**Response:**
```json
[
  {
    "timestamp": "2024-12-17T10:30:45.123Z",
    "level": "info",
    "component": "proxy",
    "message": "Request completed",
    "metadata": {...}
  }
]
```

**Example:**
```bash
curl http://localhost:8080/api/logs/history
```

---

## Error Handling

All API errors follow a consistent format:

```json
{
  "error": "Error message",
  "details": {
    // Optional additional error details
  }
}
```

### Common Status Codes

- **200 OK** - Request successful
- **400 Bad Request** - Invalid request parameters
- **404 Not Found** - Resource not found
- **429 Too Many Requests** - Rate limited
- **500 Internal Server Error** - Server error
- **502 Bad Gateway** - Upstream provider error
- **503 Service Unavailable** - All accounts failed

### Rate Limiting

When an account hits rate limits, ccflare automatically fails over to the next available account. If all accounts are rate limited, a 503 error is returned.

Rate limit information is included in account responses:
- `rateLimitStatus` - Current status (e.g., "allowed", "allowed_warning", "rate_limited")
- `rateLimitReset` - When the rate limit resets
- `rateLimitRemaining` - Remaining requests (if available)

---

## Streaming Responses

The proxy endpoints support streaming responses for compatible Claude API calls. When making a streaming request:

1. Include `"stream": true` in your request body
2. The response will be `Content-Type: text/event-stream`
3. Each chunk is delivered as a Server-Sent Event

**Streaming Response Capture:**
ccflare automatically captures streaming response bodies for analytics and debugging purposes:
- Captured data is limited to `CF_STREAM_BODY_MAX_BYTES` (default: 256KB)
- The capture process doesn't interfere with the client's stream
- Captured bodies are stored base64-encoded in the request history
- If the response exceeds the size limit, it's marked as truncated in metadata

**Example:**
```bash
curl -X POST http://localhost:8080/v1/messages \
  -H "Content-Type: application/json" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "claude-3-opus-20240229",
    "messages": [{"role": "user", "content": "Write a poem"}],
    "max_tokens": 100,
    "stream": true
  }'
```

---

## Dashboard

A web dashboard is available at:

```
http://localhost:8080/dashboard
http://localhost:8080/          # Redirects to /dashboard
```

The dashboard provides a visual interface for:
- Monitoring account status and usage
- Viewing real-time analytics
- Managing configuration
- Examining request history

---

## Configuration

### Environment Variables

ccflare can be configured using the following environment variables:

- `PORT` - Server port (default: 8080)
- `LB_STRATEGY` - Load balancing strategy (default: session)
- `SESSION_DURATION_MS` - Session duration in milliseconds (default: 18000000 / 5 hours)
- `CLIENT_ID` - OAuth client ID for Anthropic authentication (default: 9d1c250a-e61b-44d9-88ed-5944d1962f5e)
- `CF_STREAM_BODY_MAX_BYTES` - Maximum bytes to capture from streaming responses (default: 262144 / 256KB)
- `RETRY_ATTEMPTS` - Number of retry attempts for failed requests (default: 3)
- `RETRY_DELAY_MS` - Initial delay between retries in milliseconds (default: 1000)
- `RETRY_BACKOFF` - Exponential backoff multiplier for retries (default: 2)

### Configuration File

In addition to environment variables, ccflare supports configuration through a JSON file. The config file location varies by platform:
- macOS: `~/Library/Application Support/ccflare/config.json`
- Linux: `~/.config/ccflare/config.json`
- Windows: `%APPDATA%\ccflare\config.json`

**Supported Configuration Keys:**
```json
{
  "lb_strategy": "session",
  "client_id": "your-oauth-client-id",
  "retry_attempts": 3,
  "retry_delay_ms": 1000,
  "retry_backoff": 2,
  "session_duration_ms": 18000000,
  "port": 8080,
  "stream_body_max_bytes": 262144
}
```

**Note:** Environment variables take precedence over config file settings.

### Load Balancing Strategies

The following strategy is available:
- `session` - Session-based routing that maintains 5-hour sessions with individual accounts

**⚠️ WARNING:** Only use the session strategy. Other strategies can trigger Claude's anti-abuse systems and result in account bans.

## Notes

1. **No Authentication**: The API endpoints do not require authentication. ccflare manages the OAuth tokens internally for proxying to Claude.

2. **Automatic Failover**: When a request fails or an account is rate limited, ccflare automatically tries the next available account. If no accounts are available, requests are forwarded without authentication as a fallback.

3. **Token Refresh**: Access tokens are automatically refreshed when they expire.

4. **Request Logging**: All requests are logged with detailed metrics including tokens used, cost, and response times. Database writes are performed asynchronously to avoid blocking request processing.

5. **Account Tiers**: Accounts can have different tiers (1, 5, or 20) which affect their weight in certain load balancing strategies.

6. **Session Affinity**: The "session" strategy maintains sticky sessions for consistent routing within a time window.

7. **Rate Limit Tracking**: Rate limit information is automatically extracted from responses and stored for each account, including reset times and remaining requests.

8. **Provider Filtering**: Accounts are automatically filtered by provider when selecting for requests, ensuring compatibility.
</file>

<file path="docs/cli.md">
# ccflare CLI Documentation

The ccflare CLI provides a command-line interface for managing OAuth accounts, monitoring usage statistics, and controlling the load balancer.

## Table of Contents

- [Installation and Setup](#installation-and-setup)
- [Global Options and Help](#global-options-and-help)
- [Command Reference](#command-reference)
  - [Account Management](#account-management)
  - [Statistics and History](#statistics-and-history)
  - [System Commands](#system-commands)
  - [Server and Monitoring](#server-and-monitoring)
- [Usage Examples](#usage-examples)
- [Configuration](#configuration)
- [Environment Variables](#environment-variables)
- [Troubleshooting](#troubleshooting)

## Installation and Setup

### Prerequisites

- Bun runtime (>= 1.2.8)
- Node.js compatible system

### Installation

1. Clone the repository:
```bash
git clone https://github.com/snipe-code/ccflare.git
cd ccflare
```

2. Install dependencies:
```bash
bun install
```

3. Build the CLI:
```bash
bun run build
```

4. Run the CLI:
```bash
ccflare [options]
```

### First-time Setup

1. Add your first OAuth account:
```bash
ccflare --add-account myaccount
```

2. Start the load balancer server:
```bash
ccflare --serve
```

## Global Options and Help

### Getting Help

Display all available commands and options:

```bash
ccflare --help
```

Or use the short form:

```bash
ccflare -h
```

### Help Output Format

```
🎯 ccflare - Load Balancer for Claude

Usage: ccflare [options]

Options:
  --serve              Start API server with dashboard
  --port <number>      Server port (default: 8080, or PORT env var)
  --logs [N]           Stream latest N lines then follow
  --stats              Show statistics (JSON output)
  --add-account <name> Add a new account
    --mode <max|console>  Account mode (default: max)
    --tier <1|5|20>       Account tier (default: 1)
  --list               List all accounts
  --remove <name>      Remove an account
  --pause <name>       Pause an account
  --resume <name>      Resume an account
  --analyze            Analyze database performance
  --reset-stats        Reset usage statistics
  --clear-history      Clear request history
  --help, -h           Show this help message

Interactive Mode:
  ccflare          Launch interactive TUI (default)
```

## Command Reference

### Account Management

#### `--add-account <name>`

Add a new OAuth account to the load balancer pool.

**Syntax:**
```bash
ccflare --add-account <name> [--mode <max|console>] [--tier <1|5|20>]
```

**Options:**
- `--mode`: Account type (optional, defaults to "max")
  - `max`: Claude Max account
  - `console`: Console account
- `--tier`: Account tier (optional, defaults to 1, Max accounts only)
  - `1`: Tier 1 account
  - `5`: Tier 5 account
  - `20`: Tier 20 account

**Interactive Flow:**
1. If mode not provided, defaults to "max"
2. If tier not provided (Max accounts only), defaults to 1
3. Opens browser for OAuth authentication
4. Waits for OAuth callback on localhost:7856
5. Stores account credentials securely in the database

#### `--list`

Display all configured accounts with their current status.

**Syntax:**
```bash
ccflare --list
```

**Output Format:**
```
Accounts:
  - account1 (max mode, tier 5)
  - account2 (console mode, tier 1)
```

#### `--remove <name>`

Remove an account from the configuration.

**Syntax:**
```bash
ccflare --remove <name>
```

**Behavior:**
- Removes account from database immediately
- Cleans up associated session data
- For confirmation prompts, use the older `ccflare-cli remove <name>` command

#### `--pause <name>`

Temporarily exclude an account from the load balancer rotation.

**Syntax:**
```bash
ccflare --pause <name>
```

**Use Cases:**
- Account experiencing issues
- Manual rate limit management
- Maintenance or debugging

#### `--resume <name>`

Re-enable a paused account for load balancing.

**Syntax:**
```bash
ccflare --resume <name>
```

### Statistics and History

#### `--stats`

Display current statistics in JSON format.

**Syntax:**
```bash
ccflare --stats
```

**Output:**
Returns JSON-formatted statistics including account usage, request counts, and performance metrics.

#### `--reset-stats`

Reset request counters for all accounts.

**Syntax:**
```bash
ccflare --reset-stats
```

**Effects:**
- Resets request counts to 0
- Preserves account configuration
- Does not affect rate limit timers

#### `--clear-history`

Remove all request history records.

**Syntax:**
```bash
ccflare --clear-history
```

**Effects:**
- Deletes request log entries
- Preserves account data
- Reports number of records cleared

### System Commands

#### `--analyze`

Analyze database performance and index usage.

**Syntax:**
```bash
ccflare --analyze
```

**Output:**
- Database performance metrics
- Index usage statistics
- Query optimization suggestions

#### Interactive Terminal UI (TUI)

Launch the interactive terminal interface (default mode):

```bash
ccflare
```

**Features:**
- Real-time account monitoring
- Request logs viewing
- Performance analytics
- Interactive account management

### Server and Monitoring

#### `--serve`

Start the API server with dashboard.

**Syntax:**
```bash
ccflare --serve [--port <number>]
```

**Options:**
- `--port`: Server port (default: 8080, or PORT env var)

**Access:**
- API endpoint: `http://localhost:8080`
- Dashboard: `http://localhost:8080/_dashboard`

#### `--logs [N]`

Stream request logs in real-time.

**Syntax:**
```bash
ccflare --logs [N]
```

**Options:**
- `N`: Number of historical lines to display before streaming (optional)

**Examples:**
```bash
# Stream live logs only
ccflare --logs

# Show last 50 lines then stream
ccflare --logs 50
```

## Usage Examples

### Basic Account Setup

```bash
# Add a Claude Max account with tier 5
ccflare --add-account work-account --mode max --tier 5

# Add a Console account
ccflare --add-account personal-account --mode console

# List all accounts
ccflare --list

# View statistics
ccflare --stats
```

### Server Operations

```bash
# Start server on default port
ccflare --serve

# Start server on custom port
ccflare --serve --port 3000

# Stream logs
ccflare --logs

# View last 100 lines then stream
ccflare --logs 100
```

### Managing Rate Limits

```bash
# Pause account hitting rate limits
ccflare --pause work-account

# Resume after cooldown
ccflare --resume work-account

# Reset statistics for fresh start
ccflare --reset-stats
```

### Maintenance Operations

```bash
# Remove account
ccflare --remove old-account

# Clear old request logs
ccflare --clear-history

# Analyze database performance
ccflare --analyze
```

### Interactive Mode

```bash
# Launch interactive TUI (default)
ccflare

# TUI launches with auto-started server
# Navigate with arrow keys, tab between sections
```

### Automation Examples

```bash
# Add multiple accounts via script
for i in {1..3}; do
  ccflare --add-account "account-$i" --mode max --tier 5
done

# Monitor account status
watch -n 5 'ccflare --list'

# Automated cleanup
ccflare --clear-history && ccflare --reset-stats

# Export statistics for monitoring
ccflare --stats > stats.json
```

## Configuration

### Configuration File Location

ccflare stores its configuration in platform-specific directories:

#### macOS/Linux
```
~/.config/ccflare/ccflare.json
```

Or if `XDG_CONFIG_HOME` is set:
```
$XDG_CONFIG_HOME/ccflare/ccflare.json
```

#### Windows
```
%LOCALAPPDATA%\ccflare\ccflare.json
```

Or fallback to:
```
%APPDATA%\ccflare\ccflare.json
```

### Configuration Structure

```json
{
  "lb_strategy": "session",
  "client_id": "optional-custom-client-id",
  "retry_attempts": 3,
  "retry_delay_ms": 1000,
  "retry_backoff": 2,
  "session_duration_ms": 18000000,
  "port": 8080
}
```

### Database Location

The SQLite database follows the same directory structure:
- **macOS/Linux**: `~/.config/ccflare/ccflare.db`
- **Windows**: `%LOCALAPPDATA%\ccflare\ccflare.db`

## Environment Variables

### Core Configuration

| Variable | Description | Default |
|----------|-------------|---------|
| `ccflare_CONFIG_PATH` | Override config file location | Platform default |
| `ccflare_DB_PATH` | Override database location | Platform default |
| `PORT` | Server port | 8080 |
| `CLIENT_ID` | OAuth client ID | 9d1c250a-e61b-44d9-88ed-5944d1962f5e |

### Load Balancing

| Variable | Description | Default |
|----------|-------------|---------|
| `LB_STRATEGY` | Load balancing strategy (only 'session' is supported) | session |

### Retry Configuration

| Variable | Description | Default |
|----------|-------------|---------|
| `RETRY_ATTEMPTS` | Number of retry attempts | 3 |
| `RETRY_DELAY_MS` | Initial retry delay (ms) | 1000 |
| `RETRY_BACKOFF` | Exponential backoff multiplier | 2 |

### Session Management

| Variable | Description | Default |
|----------|-------------|---------|
| `SESSION_DURATION_MS` | OAuth session duration (ms) | 18000000 (5 hours) |

### Logging and Debugging

| Variable | Description | Default |
|----------|-------------|---------|
| `LOG_LEVEL` | Log verbosity (DEBUG/INFO/WARN/ERROR) | INFO |
| `LOG_FORMAT` | Output format (pretty/json) | pretty |
| `ccflare_DEBUG` | Enable debug mode (1/0) - enables console output | 0 |

### Pricing and Features

| Variable | Description | Default |
|----------|-------------|---------|
| `CF_PRICING_REFRESH_HOURS` | Pricing cache duration | 24 |
| `CF_PRICING_OFFLINE` | Offline mode flag (1/0) | 0 |

## Troubleshooting

### Common Issues

#### OAuth Authentication Fails

**Problem**: Browser doesn't open or OAuth callback fails

**Solutions**:
1. Ensure default browser is configured
2. Check firewall settings for localhost:7856
3. Manually copy OAuth URL from terminal
4. Verify network connectivity

#### Account Shows as "Expired"

**Problem**: Token status shows expired

**Solutions**:
1. Remove and re-add the account
2. Check system time synchronization
3. Verify OAuth session hasn't exceeded 5-hour limit

#### Rate Limit Errors

**Problem**: Accounts hitting rate limits frequently

**Solutions**:
1. Add more accounts to the pool
2. Increase session duration for less frequent switching
3. Implement request throttling in client code
4. Monitor usage with `bun cli list`

#### Database Errors

**Problem**: "Database is locked" or corruption errors

**Solutions**:
1. Stop all ccflare processes
2. Check file permissions on database
3. Backup and recreate if corrupted:
   ```bash
   cp ~/.config/ccflare/ccflare.db ~/.config/ccflare/ccflare.db.backup
   rm ~/.config/ccflare/ccflare.db
   ```

### Debug Mode

Enable detailed logging for troubleshooting:

```bash
# Enable debug logging
export ccflare_DEBUG=1
export LOG_LEVEL=DEBUG

# Run with verbose output
ccflare --list

# Stream debug logs
ccflare --logs
```

### Getting Support

1. Check existing documentation in `/docs`
2. Review debug logs for detailed error messages
3. Ensure all dependencies are up to date
4. File an issue with reproduction steps

### Best Practices

1. **Regular Maintenance**
   - Clear history periodically to manage database size
   - Reset stats monthly for accurate metrics
   - Monitor account health with regular `ccflare --list` commands
   - Use `ccflare --analyze` to optimize database performance

2. **Account Management**
   - Use descriptive account names
   - Distribute load across multiple accounts
   - Keep accounts of similar tiers for consistent performance
   - Pause accounts proactively when approaching rate limits

3. **Security**
   - Protect configuration directory permissions
   - Don't share OAuth tokens or session data
   - Rotate accounts periodically
   - Monitor logs with `ccflare --logs` for suspicious activity

4. **Performance**
   - Use higher-tier accounts for heavy workloads
   - Implement client-side retry logic
   - Monitor rate limit patterns with `ccflare --stats`
   - Run server with `ccflare --serve` for production use
</file>

<file path="docs/contributing.md">
# Contributing to ccflare

Welcome to ccflare! We're thrilled that you're interested in contributing to our Claude load balancer project. This document provides guidelines and instructions for contributing to the project.

## Table of Contents

1. [Welcome & Code of Conduct](#welcome--code-of-conduct)
2. [Development Setup](#development-setup)
3. [Project Structure](#project-structure)
4. [Coding Standards](#coding-standards)
5. [Commit Message Format](#commit-message-format)
6. [Pull Request Process](#pull-request-process)
7. [Testing Guidelines](#testing-guidelines)
8. [Documentation Standards](#documentation-standards)
9. [Adding New Features Checklist](#adding-new-features-checklist)
10. [Release Process](#release-process)
11. [Common Development Tasks](#common-development-tasks)

## Welcome & Code of Conduct

First off, thank you for considering contributing to ccflare! We welcome contributions from everyone, regardless of their background or experience level.

### Our Pledge

We are committed to providing a welcoming and inspiring community for all. We pledge to:

- Be respectful and inclusive in our language and actions
- Welcome newcomers and help them get started
- Respect differing viewpoints and experiences
- Show empathy towards other community members
- Focus on what is best for the community and the project

### Expected Behavior

- Use welcoming and inclusive language
- Be respectful of differing viewpoints and experiences
- Gracefully accept constructive criticism
- Focus on what is best for the community
- Show empathy towards other community members

### Unacceptable Behavior

- Harassment, discrimination, or personal attacks
- Trolling, insulting/derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information without explicit permission
- Other conduct which could reasonably be considered inappropriate

## Development Setup

### Prerequisites

Before you begin, ensure you have the following installed:

- **Bun** >= 1.2.8 (required): Install from [bun.sh](https://bun.sh)
- **Git**: For version control
- **SQLite**: Comes bundled with Bun, no separate installation needed

**Note**: Node.js is not required as the project uses Bun exclusively.

### Cloning and Installing

1. **Fork the repository** on GitHub

2. **Clone your fork**:
   ```bash
   git clone https://github.com/YOUR_USERNAME/ccflare.git
   cd ccflare
   ```

3. **Add the upstream remote**:
   ```bash
   git remote add upstream https://github.com/ORIGINAL_OWNER/ccflare.git
   ```

4. **Install dependencies**:
   ```bash
   bun install
   ```

5. **Verify the installation**:
   ```bash
   # Run type checking
   bun run typecheck
   
   # Run linting
   bun run lint
   
   # Run formatting
   bun run format
   ```

### Environment Variables (Optional)

The following environment variables can be used during development:

- `LB_STRATEGY` - Override the default load balancing strategy
- `CLIENT_ID` - Set a custom OAuth client ID
- `RETRY_ATTEMPTS` - Number of retry attempts for failed requests
- `RETRY_DELAY_MS` - Delay between retry attempts in milliseconds

**Note**: Most configuration is handled through the config file and CLI. Environment variables are optional overrides.

### Running the Development Environment

```bash
# Start the server in development mode with hot reload
bun run dev:server

# In another terminal, start the CLI
bun run dev:cli

# Or start the TUI interface
bun run dev

# Or work on the dashboard
bun run dev:dashboard
```

### Running Tests

**Note**: The project is currently in the process of setting up a comprehensive test suite. Test infrastructure is not yet implemented.

When implemented, tests will use Bun's built-in test runner:

```bash
# Run all tests
bun test

# Run tests in watch mode
bun test --watch

# Run tests for a specific package
bun test packages/core
```

### Important Post-Change Commands

After making any code changes, always run these commands before committing:

```bash
# Fix linting issues
bun run lint

# Check for type errors
bun run typecheck

# Format code
bun run format
```

### CLAUDE.md File

The project includes a `CLAUDE.md` file in the root directory that provides guidance to Claude Code (claude.ai/code) when working with the codebase. This file contains:
- Project overview and purpose
- Important commands to run after making changes
- Development and maintenance commands
- Project-specific guidelines

When contributing, ensure any major architectural changes or new patterns are documented in CLAUDE.md to help future AI-assisted development.

## Project Structure

ccflare is organized as a Bun monorepo with clear separation of concerns:

```
ccflare/
├── apps/                    # Deployable applications
│   ├── cli/                # Command-line interface
│   ├── lander/            # Static landing page
│   ├── server/            # Main HTTP server
│   └── tui/               # Terminal UI (Ink-based)
├── packages/              # Shared libraries
│   ├── cli-commands/      # CLI command implementations
│   ├── config/            # Configuration management
│   ├── core/              # Core utilities and types
│   ├── core-di/           # Dependency injection
│   ├── dashboard-web/     # React dashboard
│   ├── database/          # SQLite operations
│   ├── http-api/          # REST API handlers
│   ├── load-balancer/     # Load balancing strategies
│   ├── logger/            # Logging utilities
│   ├── providers/         # AI provider integrations
│   ├── proxy/             # Request proxy logic
│   ├── tui-core/          # TUI screen components
│   └── types/             # Shared TypeScript types
├── docs/                  # Documentation
├── biome.json            # Linting and formatting config
├── package.json          # Root workspace configuration
└── tsconfig.json         # TypeScript configuration
```

### Key Directories

- **`apps/`**: Contains all deployable applications. Each app has its own `package.json` and can be built independently.
- **`packages/`**: Shared code that multiple apps depend on. These are internal packages linked via Bun workspaces.
- **`docs/`**: Project documentation including architecture, data flow, and this contributing guide.

### Package Naming Convention

- Apps: Simple names (e.g., `server`, `cli`, `tui`)
- Packages: Prefixed with `@ccflare/` (e.g., `@ccflare/core`, `@ccflare/database`)

## Coding Standards

We use Biome for both linting and formatting to maintain consistent code quality across the project.

### TypeScript Style Guide

1. **Type Safety**
   - Always use explicit types for function parameters and return values
   - Avoid using `any` - use `unknown` if the type is truly unknown
   - Prefer interfaces over type aliases for object shapes
   - Use const assertions for literal types

   ```typescript
   // Good
   interface Account {
     id: string;
     name: string;
     tier: 1 | 5 | 20;
   }
   
   function getAccount(id: string): Account | null {
     // ...
   }
   
   // Bad
   function getAccount(id: any) {
     // ...
   }
   ```

2. **Async/Await**
   - Always use async/await instead of promises
   - Handle errors with try/catch blocks
   - Use Promise.all for concurrent operations

   ```typescript
   // Good
   async function fetchData() {
     try {
       const [accounts, requests] = await Promise.all([
         getAccounts(),
         getRequests()
       ]);
       return { accounts, requests };
     } catch (error) {
       logger.error('Failed to fetch data', error);
       throw error;
     }
   }
   ```

3. **Error Handling**
   - Create custom error classes for domain-specific errors
   - Always include context in error messages
   - Use error boundaries in React components

4. **Naming Conventions**
   - Use camelCase for variables and functions
   - Use PascalCase for types, interfaces, and classes
   - Use UPPER_SNAKE_CASE for constants
   - Prefix boolean variables with `is`, `has`, or `should`

   ```typescript
   const MAX_RETRIES = 3;
   const isRateLimited = true;
   
   interface AccountStatus {
     hasValidToken: boolean;
     isActive: boolean;
   }
   ```

### Biome Linting Rules

Our Biome configuration enforces:

- Tab indentation (not spaces)
- Double quotes for strings
- Organized imports (automatic with `organizeImports: "on"`)
- All recommended Biome rules
- Consistent code formatting

Run linting and auto-fix issues with:
```bash
bun run lint
```

**Note**: The lint command includes `--write --unsafe` flags which will automatically fix issues where possible.

### Import Conventions

1. **Import Order** (automatically organized by Biome):
   - External packages
   - Internal packages (`@ccflare/*`)
   - Relative imports
   - Type imports

2. **Path Aliases**:
   - Use package imports for cross-package dependencies
   - Use relative imports within the same package
   - Avoid circular dependencies

   ```typescript
   // Good
   import { Database } from '@ccflare/database';
   import { LoadBalancer } from '@ccflare/load-balancer';
   import { formatDate } from './utils';
   import type { Account } from '@ccflare/types';
   
   // Bad
   import { Database } from '../../../packages/database/src';
   ```

## Commit Message Format

We follow the [Conventional Commits](https://www.conventionalcommits.org/) specification for our commit messages.

### Format

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Types

- **feat**: A new feature
- **fix**: A bug fix
- **docs**: Documentation only changes
- **style**: Changes that don't affect code meaning (formatting)
- **refactor**: Code change that neither fixes a bug nor adds a feature
- **perf**: Performance improvements
- **test**: Adding or updating tests
- **build**: Changes to build system or dependencies
- **ci**: Changes to CI configuration
- **chore**: Other changes that don't modify src or test files

### Scope

The scope should be the package or app name:
- `server`, `cli`, `tui`, `lander`
- `core`, `database`, `proxy`, `load-balancer`, etc.

### Examples

```bash
feat(load-balancer): improve session persistence

Enhances the session-based strategy to better handle failover scenarios
while maintaining session affinity. This reduces rate limit occurrences
and improves overall reliability.

Closes #123

---

fix(proxy): handle token refresh race condition

Multiple concurrent requests were causing token refresh stampedes.
Added mutex to ensure only one refresh happens at a time.

---

docs(contributing): add testing guidelines section

---

refactor(database): extract migration logic to separate module

This improves testability and makes the migration system more modular.

BREAKING CHANGE: Database.migrate() method signature has changed
```

## Pull Request Process

### Before Creating a PR

1. **Sync with upstream**:
   ```bash
   git fetch upstream
   git checkout main
   git merge upstream/main
   ```

2. **Create a feature branch**:
   ```bash
   git checkout -b feature/your-feature-name
   # or
   git checkout -b fix/bug-description
   ```

### Branch Naming

Use descriptive branch names with prefixes:
- `feature/` - New features
- `fix/` - Bug fixes
- `docs/` - Documentation updates
- `refactor/` - Code refactoring
- `test/` - Test additions/updates
- `perf/` - Performance improvements

Examples:
- `feature/add-openai-provider`
- `fix/rate-limit-detection`
- `docs/update-api-endpoints`

### PR Template

When creating a PR, include:

```markdown
## Description
Brief description of what this PR does.

## Type of Change
- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] Documentation update

## Changes Made
- List specific changes made
- Include relevant code snippets if helpful
- Mention any dependencies added or removed

## Testing
- [ ] I have run `bun run lint` and fixed all issues
- [ ] I have run `bun run format` to format the code
- [ ] I have run `bun run typecheck` and fixed all type errors
- [ ] I have added tests that prove my fix is effective or that my feature works
- [ ] New and existing unit tests pass locally with my changes

## Screenshots (if applicable)
Add screenshots for UI changes.

## Checklist
- [ ] My code follows the style guidelines of this project
- [ ] I have performed a self-review of my own code
- [ ] I have commented my code, particularly in hard-to-understand areas
- [ ] I have made corresponding changes to the documentation
- [ ] My changes generate no new warnings
- [ ] Any dependent changes have been merged and published

## Related Issues
Closes #(issue number)
```

### Review Process

1. **Manual Checks**: Run `bun run lint`, `bun run typecheck`, and `bun run format` locally
2. **Code Review**: At least one maintainer must review and approve
3. **Testing**: Reviewer may ask for additional tests or manual testing
4. **Documentation**: Ensure docs are updated if needed
5. **Merge**: Maintainer will merge using "Squash and merge"

**Note**: CI/CD is not yet implemented. Contributors must ensure all checks pass locally before submitting PRs. There is also no PR template in the repository yet - please follow the template provided in this guide when creating PRs.

### After PR is Merged

1. Delete your feature branch
2. Update your local main branch
3. Celebrate! 🎉

## Testing Guidelines

**Current Status**: Test infrastructure is not yet implemented. This section describes the planned testing approach.

### Future Test Structure

Tests will be co-located with the code they test:

```
packages/core/
├── src/
│   ├── index.ts
│   ├── index.test.ts
│   ├── utils.ts
│   └── utils.test.ts
└── package.json
```

### Writing Tests (Future Implementation)

1. **Unit Tests**
   - Test individual functions and classes
   - Mock external dependencies
   - Aim for high code coverage
   - Use descriptive test names

   ```typescript
   import { describe, it, expect, mock } from 'bun:test';
   import { calculateAccountWeight } from './utils';
   
   describe('calculateAccountWeight', () => {
     it('should return 1 for pro tier accounts', () => {
       const account = { tier: 1, name: 'pro-account' };
       expect(calculateAccountWeight(account)).toBe(1);
     });
     
     it('should return 5 for max 5x tier accounts', () => {
       const account = { tier: 5, name: 'max-5x-account' };
       expect(calculateAccountWeight(account)).toBe(5);
     });
   });
   ```

2. **Integration Tests**
   - Test interactions between modules
   - Use real database for database tests
   - Test API endpoints end-to-end

3. **E2E Tests** (when implemented)
   - Test complete user workflows
   - Use real browser for dashboard tests
   - Test CLI commands

### Test Best Practices

- Write tests before fixing bugs (regression tests)
- Keep tests focused and independent
- Use meaningful assertions
- Clean up test data after tests
- Use test fixtures for complex data

## Documentation Standards

### Code Documentation

1. **JSDoc Comments**
   - Document all public APIs
   - Include parameter descriptions
   - Add usage examples

   ```typescript
   /**
    * Selects the best account for handling a request based on the configured strategy.
    * 
    * @param accounts - List of available accounts
    * @param strategy - Load balancing strategy to use
    * @returns The selected account or null if no accounts are available
    * 
    * @example
    * const account = selectAccount(accounts, 'session');
    * if (account) {
    *   await forwardRequest(account, request);
    * }
    */
   export function selectAccount(
     accounts: Account[], 
     strategy: LoadBalancingStrategy
   ): Account | null {
     // ...
   }
   ```

2. **README Files**
   - Each package should have a README
   - Include installation, usage, and API docs
   - Add examples and common patterns

3. **Architecture Documentation**
   - Update `/docs` when adding major features
   - Include diagrams for complex flows
   - Document design decisions

### Documentation Checklist

- [ ] All public APIs have JSDoc comments
- [ ] Complex algorithms have explanatory comments
- [ ] Package README is updated
- [ ] Architecture docs reflect changes
- [ ] Examples are tested and working

## Adding New Features Checklist

When adding a new feature, follow this checklist:

### 1. Planning Phase
- [ ] Create an issue describing the feature
- [ ] Discuss implementation approach with maintainers
- [ ] Identify which packages will be affected
- [ ] Consider backward compatibility

### 2. Implementation Phase
- [ ] Create feature branch from latest main
- [ ] Implement feature following coding standards
- [ ] Add unit tests (aim for >80% coverage)
- [ ] Add integration tests if applicable
- [ ] Update TypeScript types
- [ ] Handle errors gracefully

### 3. Documentation Phase
- [ ] Add JSDoc comments to new functions
- [ ] Update package README if needed
- [ ] Update architecture docs for significant changes
- [ ] Add usage examples

### 4. Testing Phase
- [ ] Run all tests locally
- [ ] Test manually in development environment
- [ ] Test with different configurations
- [ ] Verify no performance regressions

### 5. Review Phase
- [ ] Self-review your code
- [ ] Run linting and formatting
- [ ] Ensure all CI checks pass
- [ ] Create PR with detailed description

### 6. Post-Merge Phase
- [ ] Monitor for any issues
- [ ] Update related issues
- [ ] Help with any user questions

## Release Process

### Version Management

We use semantic versioning (SemVer):
- **Major** (X.0.0): Breaking changes
- **Minor** (0.X.0): New features (backward compatible)
- **Patch** (0.0.X): Bug fixes

### Release Workflow

1. **Prepare Release**
   ```bash
   # Update version in package.json files
   # Create/Update CHANGELOG.md (if not exists, create following Keep a Changelog format)
   git checkout -b release/vX.Y.Z
   ```

2. **Create Release PR**
   - Title: `Release vX.Y.Z`
   - Include changelog in description
   - Get approval from maintainers

3. **Merge and Tag**
   ```bash
   git checkout main
   git pull upstream main
   git tag -a vX.Y.Z -m "Release version X.Y.Z"
   git push upstream vX.Y.Z
   ```

4. **Create GitHub Release**
   - Use the tag
   - Copy changelog entries
   - Attach built binaries if applicable

5. **Post-Release**
   - Announce in discussions/Discord
   - Update documentation site
   - Monitor for issues

**Note**: There is no CHANGELOG.md file in the repository yet. When implementing releases, create and maintain a CHANGELOG.md file following the [Keep a Changelog](https://keepachangelog.com/) format.

### Emergency Patches

For critical fixes:
1. Create patch from the release tag
2. Follow expedited review process
3. Release as patch version

## Getting Help

If you need help:

1. **Documentation**: Check the `/docs` folder
2. **Issues**: Search existing issues
3. **Discussions**: Start a GitHub discussion
4. **Discord**: Join our community (if applicable)

## Recognition

Contributors are recognized in:
- GitHub contributors page
- Release notes
- Project README (for significant contributions)

## Common Development Tasks

### Working with the CLI

The CLI functionality is integrated into the TUI application. Use `ccflare` with command-line flags:

```bash
# If ccflare is not installed globally, use:
# bun run tui [options]
# or build and run with: bun run ccflare

# Add a new account
ccflare --add-account <name>
# With options:
ccflare --add-account <name> --mode <max|console> --tier <1|5|20>

# List all accounts
ccflare --list

# Remove an account
ccflare --remove <name>

# Pause/resume accounts
ccflare --pause <name>
ccflare --resume <name>

# Reset usage statistics
ccflare --reset-stats

# Clear request history
ccflare --clear-history

# View statistics (JSON output)
ccflare --stats

# Stream logs
ccflare --logs [N]  # Show N lines of history then follow

# Analyze database performance
ccflare --analyze

# Start server with dashboard
ccflare --serve --port 8080

# Show help
ccflare --help
```

### Running the Server

```bash
# Start the production server (port 8080)
bun run server
# or
bun run start
# or
bun start

# Start the server with hot reload
bun run dev:server
```

### Working with the Dashboard

```bash
# Build the dashboard
bun run build:dashboard

# Run dashboard in development mode
bun run dev:dashboard
```

### Working with the TUI

```bash
# Run the TUI application
bun run tui
# or
bun run dev
# or (builds first, then runs)
bun run ccflare

# Build the TUI
bun run build:tui
```

### Building for Production

```bash
# Build all applications
bun run build

# Build specific applications
bun run build:dashboard
bun run build:tui
bun run build:lander
```

### Troubleshooting Common Issues

1. **TypeScript errors**: Run `bun run typecheck` to identify issues
2. **Formatting issues**: Run `bun run format` to auto-fix
3. **Import errors**: Ensure you're using workspace imports (`@ccflare/*`) for cross-package dependencies
4. **Database issues**: The SQLite database is created automatically in the data directory

Thank you for contributing to ccflare! Your efforts help make Claude AI more accessible to everyone.
</file>

<file path="docs/data-flow.md">
# ccflare Data Flow Documentation

## Overview

ccflare is a load balancer proxy for Claude API that distributes requests across multiple OAuth accounts to avoid rate limiting. This document details the complete data flow through the system, including request lifecycle, error handling, token refresh, rate limit management, and streaming response capture.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Overview of Request Lifecycle](#overview-of-request-lifecycle)
3. [Sequence Diagrams](#sequence-diagrams)
   - [Successful Request Flow](#successful-request-flow)
   - [Rate Limited Request Flow](#rate-limited-request-flow)
   - [Token Refresh Flow](#token-refresh-flow)
   - [Agent Interceptor Flow](#agent-interceptor-flow)
   - [Failed Request with Retry Flow](#failed-request-with-retry-flow)
   - [Streaming Response Flow](#streaming-response-flow)
4. [Error Handling Flows](#error-handling-flows)
5. [Request Retry Logic](#request-retry-logic)
6. [Database Update Patterns](#database-update-patterns)
7. [Asynchronous Database Operations](#asynchronous-database-operations)

## Architecture Overview

ccflare uses a modular architecture with the following key components:

- **Server**: Main HTTP server handling routing between API, dashboard, and proxy requests
- **Proxy**: Core request forwarding logic with retry, rate limiting, and usage tracking
- **Provider System**: Abstraction layer for different AI providers (currently Anthropic)
- **Load Balancer**: Strategy pattern implementation for account selection
- **Agent Interceptor**: Detects agent usage and modifies requests based on agent preferences
- **Post-Processor Worker**: Background worker that handles all usage extraction and database writes via message passing
- **AsyncDbWriter**: Asynchronous database write queue to prevent blocking (100ms processing interval)
- **Response Handler**: Uses Response.clone() for streaming analytics without blocking the client
- **Service Container**: Dependency injection for component management

## Overview of Request Lifecycle

The request lifecycle in ccflare follows these main stages:

1. **Request Reception**: Client sends request to ccflare server
2. **Route Determination**: Server checks if it's an API request, dashboard request, or proxy request
3. **Request Body Preparation**: Request body is buffered for potential modification and reuse
4. **Agent Interception**: System detects agent usage in system prompts and modifies model preference if configured
5. **Account Selection**: Load balancer strategy selects available accounts based on configured algorithm
6. **Token Validation**: System checks if account has valid access token, refreshes if needed
7. **Request Forwarding**: Proxy forwards request to Anthropic API with authentication
8. **Response Handling**: System immediately returns response to client while cloning for analytics
9. **Background Processing**: Post-processor worker receives messages (START, CHUNK, END) for async processing
10. **Data Persistence**: Worker queues database updates via AsyncDbWriter for non-blocking writes
11. **Usage Extraction**: Worker extracts usage data from streaming responses without blocking

## Sequence Diagrams

### Successful Request Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server as ccflare Server
    participant Router as API Router
    participant LoadBalancer as Load Balancer
    participant Proxy
    participant Provider as Anthropic Provider
    participant AsyncWriter as Async DB Writer
    participant DB as Database
    participant Anthropic as Anthropic API

    Client->>Server: HTTP Request to /v1/*
    Server->>Router: Check API routes
    Router-->>Server: No match, continue
    Server->>Proxy: handleProxy(req, url, context)
    
    Note over Proxy: Validate provider can handle path
    Proxy->>Proxy: Prepare request body buffer
    
    Note over Proxy: Agent Interception
    Proxy->>AgentInterceptor: interceptAndModifyRequest(body)
    AgentInterceptor->>AgentInterceptor: Extract system prompt
    AgentInterceptor->>AgentInterceptor: Detect agent usage
    AgentInterceptor->>DB: getAgentPreference(agentId)
    AgentInterceptor-->>Proxy: Modified body with preferred model
    
    Note over Proxy: Generate request ID and metadata
    
    Proxy->>Provider: canHandle(path)?
    Provider-->>Proxy: true
    
    Proxy->>LoadBalancer: getOrderedAccounts(meta, strategy)
    LoadBalancer->>DB: getAllAccounts()
    DB-->>LoadBalancer: Account list
    LoadBalancer->>LoadBalancer: Filter by provider & availability
    LoadBalancer->>LoadBalancer: Apply strategy algorithm
    LoadBalancer-->>Proxy: Ordered account list
    
    loop For each account until success
        Proxy->>Proxy: Check token validity
        alt Token expired
            Proxy->>Provider: refreshAccessTokenSafe()
            Provider->>Anthropic: POST /v1/oauth/token
            Anthropic-->>Provider: New access token
            Provider->>AsyncWriter: enqueue(updateAccountTokens)
            Note over AsyncWriter: Queued for async write
        end
        
        Proxy->>Provider: prepareHeaders(headers, accessToken)
        Proxy->>Provider: buildUrl(path, query)
        Proxy->>Anthropic: Forward request
        Anthropic-->>Proxy: Response (streaming or JSON)
        
        Proxy->>AsyncWriter: enqueue(updateAccountUsage)
        
        Proxy->>Provider: parseRateLimit(response)
        Provider-->>Proxy: Rate limit info
        
        alt Has rate limit metadata
            Proxy->>AsyncWriter: enqueue(updateAccountRateLimitMeta)
        end
        
        alt Response OK
            alt Response OK
                Proxy->>ResponseHandler: forwardToClient(options, context)
                ResponseHandler->>Worker: postMessage(START message)
                Note over Worker: Contains request/response metadata
                
                alt Streaming Response
                    ResponseHandler->>ResponseHandler: response.clone()
                    ResponseHandler-->>Client: Return original response immediately
                    
                    Note over ResponseHandler: Background stream processing
                    ResponseHandler->>ResponseHandler: Read clone stream
                    loop For each chunk
                        ResponseHandler->>Worker: postMessage(CHUNK message)
                    end
                    ResponseHandler->>Worker: postMessage(END message)
                else Non-streaming Response
                    ResponseHandler-->>Client: Return original response immediately
                    
                    Note over ResponseHandler: Background body processing
                    ResponseHandler->>ResponseHandler: response.clone()
                    ResponseHandler->>ResponseHandler: Read clone body
                    ResponseHandler->>Worker: postMessage(END message with body)
                end
            end
        end
    end
    
    Note over AsyncWriter,DB: Background processing
    AsyncWriter->>DB: Process queued writes
```

### Rate Limited Request Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server
    participant Proxy
    participant Provider
    participant DB
    participant Anthropic

    Client->>Server: HTTP Request
    Server->>Proxy: handleProxy()
    
    Proxy->>Proxy: Select account from strategy
    Proxy->>Proxy: Validate/refresh token
    Proxy->>Anthropic: Forward request
    
    alt Hard rate limit (429 or rate_limited status)
        Anthropic-->>Proxy: 429 Rate Limited
        Note over Anthropic: Headers: anthropic-ratelimit-unified-status: rate_limited<br/>anthropic-ratelimit-unified-reset: 1234567890
        
        Proxy->>Provider: parseRateLimit(response)
        Provider-->>Proxy: {isRateLimited: true, resetTime: 1234567890000}
        
        Proxy->>DB: markAccountRateLimited(accountId, resetTime)
        Note over DB: Set rate_limited_until = resetTime
        
        Proxy->>DB: saveRequestPayload(rateLimited: true)
        
        Proxy->>Proxy: Continue to next account
        
        alt No more accounts available
            Proxy->>DB: saveRequest(status: 503, error: "All accounts failed")
            Proxy-->>Client: 503 Service Unavailable
        else Another account available
            Proxy->>Proxy: Try next account
        end
    else Soft warning (allowed_warning)
        Anthropic-->>Proxy: 200 OK
        Note over Anthropic: Headers: anthropic-ratelimit-unified-status: allowed_warning<br/>anthropic-ratelimit-unified-remaining: 50
        
        Proxy->>Provider: parseRateLimit(response)
        Provider-->>Proxy: {isRateLimited: false, statusHeader: "allowed_warning", remaining: 50}
        
        Proxy->>DB: updateAccountRateLimitMeta()
        Note over DB: Update rate limit metadata only
        
        Proxy->>Provider: processResponse()
        Proxy-->>Client: 200 OK (continue normally)
    end
```

### Token Refresh Flow

```mermaid
sequenceDiagram
    participant Proxy
    participant RefreshMap as refreshInFlight Map
    participant Provider
    participant AsyncWriter as Async DB Writer
    participant DB
    participant Anthropic

    Note over Proxy: Multiple requests may need token refresh
    
    Proxy->>Proxy: getValidAccessToken(account)
    
    alt Token expired or missing
        Proxy->>RefreshMap: Check if refresh in progress?
        
        alt No refresh in progress
            Proxy->>RefreshMap: Set refresh promise
            Proxy->>Provider: refreshToken(account, clientId)
            Provider->>Anthropic: POST /v1/oauth/token
            Note over Provider: Body: {grant_type: "refresh_token",<br/>refresh_token: account.refresh_token,<br/>client_id: clientId}
            
            alt Refresh successful
                Anthropic-->>Provider: {access_token: "new_token", expires_in: 3600}
                Provider-->>Proxy: TokenRefreshResult
                Proxy->>AsyncWriter: enqueue(updateAccountTokens)
                Note over AsyncWriter: Token update queued
                Proxy->>RefreshMap: Delete promise
                Proxy-->>Proxy: Return new access token
            else Refresh failed
                Anthropic-->>Provider: Error response
                Provider-->>Proxy: Throw error
                Proxy->>RefreshMap: Delete promise
                Note over Proxy: Refresh failed - will try next account
            end
        else Refresh already in progress
            Proxy->>RefreshMap: Get existing promise
            Note over Proxy: Wait for existing refresh to complete
            RefreshMap-->>Proxy: Resolved access token
        end
    else Token still valid
        Proxy-->>Proxy: Return existing token
    end
    
    Note over AsyncWriter,DB: Background processing
    AsyncWriter->>DB: Process token update
```

### Failed Request with Retry Flow

```mermaid
sequenceDiagram
    participant Client
    participant Server
    participant Proxy
    participant Provider
    participant DB
    participant Anthropic

    Client->>Server: HTTP Request
    Server->>Proxy: handleProxy()
    
    Proxy->>Proxy: Select account
    
    loop Retry up to runtime.retry.attempts times
        Note over Proxy: Retry attempt #1
        
        alt First attempt
            Proxy->>Anthropic: Forward request
        else Retry attempt
            Note over Proxy: Wait retry.delayMs * (backoff ^ attempt)
            Proxy->>Proxy: Sleep for backoff delay
            Proxy->>Anthropic: Retry request
        end
        
        alt Network error
            Anthropic--xProxy: Connection timeout/error
            Proxy->>DB: saveRequestPayload(error, retry count)
            
            alt More retries available
                Note over Proxy: Continue to next retry
            else Max retries reached
                Proxy->>Proxy: Log failure for account
                Proxy->>Proxy: Try next account
            end
        else Success
            Anthropic-->>Proxy: Successful response
            Proxy->>DB: saveRequest(success)
            Proxy-->>Client: Return response
            Note over Proxy: Exit retry loop
        end
    end
    
    alt All accounts and retries exhausted
        Proxy->>DB: saveRequest(status: 503, error: "All accounts failed")
        Proxy->>DB: saveRequestPayload(final failure)
        Proxy-->>Client: 503 Service Unavailable
    end
```

### Streaming Response Flow

```mermaid
sequenceDiagram
    participant Client
    participant ResponseHandler
    participant Worker as Post-Processor Worker
    participant AsyncWriter as Async DB Writer
    participant DB

    Note over ResponseHandler: Streaming response detected
    
    ResponseHandler->>ResponseHandler: isStreamingResponse(response)?
    Note over ResponseHandler: true
    
    ResponseHandler->>Worker: postMessage(START)
    Note over Worker: Initialize request state
    Worker->>AsyncWriter: enqueue(saveRequestMeta)
    Worker->>AsyncWriter: enqueue(updateAccountUsage)
    
    ResponseHandler->>ResponseHandler: response.clone()
    Note over ResponseHandler: Clone for analytics
    
    par Stream to Client
        ResponseHandler-->>Client: Return original response
        Note over Client: Receives stream immediately
    and Analytics Processing
        ResponseHandler->>ResponseHandler: getReader() on clone
        loop While streaming
            ResponseHandler->>ResponseHandler: reader.read()
            ResponseHandler->>Worker: postMessage(CHUNK)
            Worker->>Worker: Process chunk for usage
            Worker->>Worker: Extract tokens from SSE
            Worker->>Worker: Buffer chunks
        end
        ResponseHandler->>Worker: postMessage(END)
    end
    
    Note over Worker: Process final usage data
    Worker->>Worker: Calculate total tokens
    Worker->>Worker: Estimate cost
    Worker->>Worker: Calculate tokens/second
    Worker->>AsyncWriter: enqueue(saveRequest)
    Worker->>AsyncWriter: enqueue(saveRequestPayload)
    
    Note over AsyncWriter,DB: Process queue every 100ms
    AsyncWriter->>DB: Execute batched operations
```

### Post-Processor Worker Message Flow

```mermaid
sequenceDiagram
    participant ResponseHandler
    participant Worker as Post-Processor Worker
    participant TokenEncoder as Tiktoken Encoder
    participant AsyncWriter
    participant DB

    Note over ResponseHandler,Worker: START Phase
    ResponseHandler->>Worker: START message
    Note over Worker: Contains: requestId, accountId, method, path,<br/>headers, body, status, isStream, agent info
    
    Worker->>Worker: Create request state
    Worker->>Worker: Check shouldLogRequest(path, status)
    
    alt Should log request
        Worker->>AsyncWriter: enqueue(saveRequestMeta)
        alt Has accountId
            Worker->>AsyncWriter: enqueue(updateAccountUsage)
        end
    else Skip logging (e.g., .well-known 404)
        Note over Worker: Mark as shouldSkipLogging
    end

    Note over ResponseHandler,Worker: CHUNK Phase (Streaming only)
    loop For each stream chunk
        ResponseHandler->>Worker: CHUNK message with data
        Worker->>Worker: Store chunk in buffer
        Worker->>Worker: Decode chunk to text
        Worker->>Worker: Parse SSE lines
        
        alt message_start event
            Worker->>Worker: Extract initial usage data
            Worker->>Worker: Extract model info
        else content_block_start
            Worker->>Worker: Record firstTokenTimestamp
        else content_block_delta
            Worker->>TokenEncoder: encode(delta text)
            TokenEncoder-->>Worker: Token count
            Worker->>Worker: Update outputTokensComputed
        else message_delta with usage
            Worker->>Worker: Update providerFinalOutputTokens
            Worker->>Worker: Record lastTokenTimestamp
        end
    end

    Note over ResponseHandler,Worker: END Phase
    ResponseHandler->>Worker: END message
    
    alt Not skipping logs
        Worker->>Worker: Calculate final token counts
        Note over Worker: Use provider count if available,<br/>else use computed count
        
        Worker->>Worker: estimateCostUSD(model, tokens)
        Worker->>Worker: Calculate tokens/second
        
        Worker->>AsyncWriter: enqueue(saveRequest)
        Note over AsyncWriter: Includes usage metrics
        
        Worker->>Worker: combineChunks() if streaming
        Worker->>AsyncWriter: enqueue(saveRequestPayload)
        Note over AsyncWriter: Includes full request/response
    end
    
    Worker->>Worker: Clean up request state
```

## Error Handling Flows

### Provider Cannot Handle Path

```mermaid
sequenceDiagram
    participant Client
    participant Proxy
    participant Provider

    Client->>Proxy: Request to unsupported path
    Proxy->>Provider: canHandle(path)?
    Provider-->>Proxy: false
    Proxy-->>Client: 400 Bad Request<br/>{"error": "Provider cannot handle this request path"}
```

### No Available Accounts (Fallback Mode)

```mermaid
sequenceDiagram
    participant Client
    participant Proxy
    participant LoadBalancer
    participant AsyncWriter
    participant DB
    participant Anthropic

    Client->>Proxy: HTTP Request
    Proxy->>LoadBalancer: getOrderedAccounts()
    LoadBalancer->>DB: getAllAccounts()
    DB-->>LoadBalancer: Empty or all rate-limited
    LoadBalancer-->>Proxy: [] (empty array)
    
    Note over Proxy: Fallback to unauthenticated mode
    
    Proxy->>Anthropic: Forward without auth headers
    
    alt Success
        Anthropic-->>Proxy: Response
        
        alt Streaming Response
            Proxy->>ResponseHandler: forwardToClient()
            ResponseHandler->>ResponseHandler: response.clone()
            Proxy-->>Client: Stream response
            Proxy->>AsyncWriter: enqueue(saveRequest)<br/>accountId: NO_ACCOUNT_ID
            Proxy->>AsyncWriter: enqueue(saveRequestPayload)
        else Non-streaming
            Proxy->>AsyncWriter: enqueue(saveRequest)<br/>accountId: NO_ACCOUNT_ID
            Proxy->>AsyncWriter: enqueue(saveRequestPayload)
            Proxy-->>Client: Forward response
        end
    else Failure
        Anthropic-->>Proxy: Error
        Proxy->>AsyncWriter: enqueue(saveRequest with error)
        Proxy-->>Client: 502 Bad Gateway
    end
    
    Note over AsyncWriter,DB: Background processing
    AsyncWriter->>DB: Process queued operations
```

## Request Retry Logic

The retry mechanism follows an exponential backoff strategy:

```mermaid
flowchart TD
    A[Start Request] --> B{Token Valid?}
    B -->|No| C[Refresh Token]
    B -->|Yes| D[Send Request]
    C --> D
    
    D --> E{Response OK?}
    E -->|Yes| F[Process Response]
    E -->|No| G{Rate Limited?}
    
    G -->|Yes| H[Mark Account Limited]
    G -->|No| I{Retries < Max?}
    
    H --> J[Try Next Account]
    I -->|Yes| K[Wait Backoff Delay]
    I -->|No| J
    
    K --> L[Increment Retry]
    L --> D
    
    J --> M{More Accounts?}
    M -->|Yes| B
    M -->|No| N[Return 503 Error]
    
    F --> O[Save Stats & Return]
```

### Retry Configuration

- **Initial delay**: `runtime.retry.delayMs` (default: 1000ms, configurable)
- **Backoff multiplier**: `runtime.retry.backoff` (default: 2, configurable)
- **Max attempts**: `runtime.retry.attempts` (default: 3, configurable)
- **Delay calculation**: `delayMs * (backoff ^ attemptNumber)`
- **Stream body max bytes**: Controlled by CF_STREAM_USAGE_BUFFER_KB env var (default: defined in BUFFER_SIZES constant)
- **Worker processing interval**: AsyncDbWriter processes queue every 100ms
- **Worker shutdown delay**: TIMING.WORKER_SHUTDOWN_DELAY for graceful shutdown

Configuration can be set via:
1. Environment variables: `RETRY_ATTEMPTS`, `RETRY_DELAY_MS`, `RETRY_BACKOFF`
2. Config file: `retry_attempts`, `retry_delay_ms`, `retry_backoff`
3. Default values in code

## Database Update Patterns

### Request Lifecycle Updates

```mermaid
flowchart LR
    subgraph "Per Request Updates (via AsyncDbWriter)"
        A[Request Start] --> B[enqueue: updateAccountUsage]
        B --> C{Response Type}
        C -->|Success| D[enqueue: saveRequest<br/>success=true]
        C -->|Rate Limited| E[enqueue: markAccountRateLimited<br/>+ saveRequest]
        C -->|Error| F[enqueue: saveRequest<br/>with error]
        
        D --> G[enqueue: saveRequestPayload]
        E --> G
        F --> G
        
        D --> H[enqueue: updateAccountRateLimitMeta]
        E --> H
        
        D --> I[extractUsageInfo]
        I --> J[enqueue: updateRequestUsage<br/>with cost/tokens]
        
        D --> K[extractTierInfo]
        K --> L[enqueue: updateAccountTier]
        
        subgraph "Async Processing"
            M[Worker Message Queue] --> N[Post-Processor Worker]
            N --> O[AsyncDbWriter Queue]
            O --> P[Process Jobs (100ms interval)]
            P --> Q[Execute DB Operations]
        end
    end
```

### Account State Management

```mermaid
stateDiagram-v2
    [*] --> Active: Account Added
    Active --> TokenExpired: Token expires
    TokenExpired --> Active: Token refreshed
    Active --> RateLimited: Hit rate limit
    RateLimited --> Active: Reset time reached
    Active --> Paused: Manual pause
    Paused --> Active: Manual unpause
    
    note right of Active
        - Can receive requests
        - Token valid
        - Not rate limited
    end note
    
    note right of RateLimited
        - rate_limited_until set
        - Skipped by strategies
        - Auto-clears after reset
    end note
    
    note right of TokenExpired
        - Triggers refresh flow
        - Blocks until refreshed
    end note
```

### Session Management (Session Strategy)

```mermaid
flowchart TD
    A[Request Arrives] --> B{Active Session?}
    B -->|Yes| C{Session Expired?}
    B -->|No| D[Select New Account]
    
    C -->|No| E[Use Session Account]
    C -->|Yes| F[Reset Session]
    
    D --> G[Start New Session]
    F --> G
    
    G --> H[Set session_start = now]
    H --> I[Set session_request_count = 0]
    
    E --> J[Increment session_request_count]
    I --> J
    
    J --> K[Process Request]
```

### Database Tables Updated

1. **accounts** table:
   - `last_used`: Updated on every request
   - `request_count`: Incremented per request
   - `total_requests`: Lifetime counter
   - `rate_limited_until`: Set when rate limited
   - `access_token` & `expires_at`: Updated on token refresh
   - `account_tier`: Updated when detected from response
   - `session_start` & `session_request_count`: For session strategy
   - `rate_limit_status`, `rate_limit_reset`, `rate_limit_remaining`: Rate limit metadata
   - `provider`: Provider type (e.g., "anthropic")

2. **requests** table:
   - One row per request with status, timing, and usage data
   - Links to account used (or "no-account" for fallback)
   - Stores error messages for failed requests
   - Enhanced usage tracking:
     - `model`: AI model used
     - `input_tokens`, `output_tokens`: Token counts
     - `cache_read_input_tokens`, `cache_creation_input_tokens`: Cache token details
     - `cost_usd`: Calculated cost in USD

3. **request_payloads** table:
   - Stores full request/response bodies (base64 encoded)
   - Includes headers and metadata
   - Enhanced metadata:
     - `isStream`: Whether response was streamed
     - `bodyTruncated`: If stream body exceeded maxBytes
     - `rateLimited`: If request hit rate limits
   - Used for debugging, replay, and analytics

### Update Transaction Flow

```mermaid
sequenceDiagram
    participant Request
    participant AsyncWriter as Async DB Writer
    participant DB
    
    Note over Request,AsyncWriter: During Request Processing
    
    Request->>AsyncWriter: enqueue(updateAccountUsage)
    Request->>AsyncWriter: enqueue(updateAccountRateLimitMeta)
    
    alt Rate Limited
        Request->>AsyncWriter: enqueue(markAccountRateLimited)
    end
    
    Request->>AsyncWriter: enqueue(saveRequest)
    Request->>AsyncWriter: enqueue(saveRequestPayload)
    
    alt Tier Changed
        Request->>AsyncWriter: enqueue(updateAccountTier)
    end
    
    alt Streaming Response
        Note over Request: Response sent to client
        Request->>AsyncWriter: enqueue(updateRequestUsage)
        Note over AsyncWriter: Usage data queued after extraction
    end
    
    Note over AsyncWriter,DB: Background Processing (every 100ms)
    
    loop Process Queue
        AsyncWriter->>AsyncWriter: Check queue
        alt Jobs Available
            AsyncWriter->>DB: BEGIN (implicit)
            AsyncWriter->>DB: Execute queued operations
            Note over DB: UPDATE accounts<br/>INSERT requests<br/>INSERT request_payloads
            AsyncWriter->>DB: COMMIT (implicit)
        end
    end
    
    Note over AsyncWriter: On shutdown: flush remaining jobs
```

## Asynchronous Database Operations

The AsyncDbWriter component ensures non-blocking database operations:

### Architecture

```mermaid
flowchart TD
    subgraph "Request Thread"
        A[Proxy Handler] --> B[Process Request]
        B --> C[Enqueue DB Operations]
        C --> D[Return Response Immediately]
    end
    
    subgraph "AsyncDbWriter"
        E[Job Queue] --> F{Queue Empty?}
        F -->|No| G[Process Job]
        G --> H[Execute DB Operation]
        H --> F
        F -->|Yes| I[Wait 100ms]
        I --> F
    end
    
    C -.-> E
    
    subgraph "On Shutdown"
        J[SIGINT/SIGTERM] --> K[Stop Timer]
        K --> L[Flush Queue]
        L --> M[Exit]
    end
```

### Key Features

1. **Non-blocking Operations**: All database writes are queued, allowing requests to complete without waiting
2. **Batch Processing**: Queue processed every 100ms or immediately when jobs are added
3. **Graceful Shutdown**: Ensures all queued operations complete before process exit
4. **Error Isolation**: Failed DB operations don't affect request processing
5. **Memory Efficient**: Processes queue continuously to prevent unbounded growth

## Summary

The ccflare data flow is designed to:

1. **Maximize availability** through multiple account rotation and retry logic
2. **Prevent stampedes** with singleton token refresh promises
3. **Track everything** for debugging, analytics, and replay capabilities
4. **Handle failures gracefully** with fallback modes and clear error reporting
5. **Respect rate limits** intelligently, distinguishing between hard limits and warnings
6. **Optimize performance** through:
   - Non-blocking async database writes via worker message passing
   - Streaming response passthrough with Response.clone() for analytics
   - Background post-processor worker for all usage extraction
   - Efficient request/response payload storage with base64 encoding
7. **Support analytics** by capturing streaming responses without impacting performance
8. **Enable debugging** through comprehensive request/response payload storage

The system ensures reliable Claude API access while providing comprehensive monitoring and management capabilities through its dashboard and API endpoints.

## Key Implementation Details

### Agent Interceptor Flow

The agent interceptor examines system prompts to:
1. Detect agent usage by matching system prompts
2. Extract workspace paths from CLAUDE.md references
3. Look up agent model preferences in the database
4. Modify the request body to use the preferred model
5. Track which agent was used for analytics

### Post-Processor Worker Architecture

The post-processor worker handles all analytics asynchronously:
1. Receives START message with request/response metadata
2. Processes CHUNK messages for streaming responses, extracting usage from SSE data
3. Receives END message to finalize processing
4. Calculates costs, tokens per second, and other metrics
5. Queues all database operations through AsyncDbWriter
6. Handles graceful shutdown via shutdown message

### Response Handling Strategy

1. **Immediate Response**: Original response is returned to client without modification
2. **Background Analytics**: Response.clone() used for analytics processing
3. **Worker Communication**: All processing delegated to post-processor worker
4. **No Blocking**: Client never waits for analytics or database operations
</file>

<file path="docs/deployment.md">
# ccflare Deployment Documentation

## Overview

ccflare is a load balancer proxy for Claude API accounts that can be deployed in various configurations, from simple local development to production-grade distributed systems. This document covers all deployment options, from single-instance setups to scalable architectures.

> **Recent Updates**: ccflare now includes a Terminal User Interface (TUI) for interactive monitoring and management, alongside the web dashboard. The async database writer improves performance for high-throughput scenarios.
> 
> **Important**: ccflare uses an integrated binary that combines the TUI, CLI commands, and server functionality. The main executable `ccflare` provides all functionality through command-line flags.

## Table of Contents

1. [Deployment Options Overview](#deployment-options-overview)
2. [Local Development Setup](#local-development-setup)
3. [Production Deployment](#production-deployment)
   - [System Requirements](#system-requirements)
   - [Bun Binary Compilation](#bun-binary-compilation)
   - [Process Management](#process-management)
4. [Docker Deployment](#docker-deployment)
5. [Cloudflare Pages (Dashboard Only)](#cloudflare-pages-dashboard-only)
6. [Reverse Proxy Setup](#reverse-proxy-setup)
7. [Monitoring and Logging](#monitoring-and-logging)
8. [Performance Tuning](#performance-tuning)
9. [Scaling Considerations](#scaling-considerations)
10. [Environment Variables Reference](#environment-variables-reference)

## Deployment Options Overview

```mermaid
graph TB
    subgraph "Deployment Options"
        DEV[Local Development<br/>bun start]
        BINARY[Compiled Binary<br/>Single executable]
        DOCKER[Docker Container<br/>Containerized deployment]
        PM2[PM2 Process<br/>Node process manager]
        SYSTEMD[Systemd Service<br/>Linux service]
        K8S[Kubernetes<br/>Container orchestration]
    end
    
    subgraph "Frontend Options"
        EMBEDDED[Embedded Dashboard<br/>Served by server]
        CF_PAGES[Cloudflare Pages<br/>Static hosting]
        NGINX_STATIC[Nginx Static<br/>Separate frontend]
    end
    
    DEV --> EMBEDDED
    BINARY --> EMBEDDED
    BINARY --> CF_PAGES
    DOCKER --> EMBEDDED
    PM2 --> EMBEDDED
    SYSTEMD --> EMBEDDED
    K8S --> CF_PAGES
    K8S --> NGINX_STATIC
```

## Local Development Setup

### Prerequisites

- Bun runtime (>= 1.2.8)
- SQLite (included with Bun - no external database setup required)
- Git
- Node.js compatible system (Linux, macOS, Windows)

### Quick Start

```bash
# Clone the repository
git clone https://github.com/snipeship/ccflare.git
cd ccflare

# Install dependencies
bun install

# Build the project (dashboard and TUI)
bun run build

# Start ccflare (TUI + Server combined)
bun run ccflare

# Or start components separately:
# Terminal UI only
bun run tui

# Server only (without TUI)
bun run server

# Server with hot-reload (development)
bun run dev:server

# In another terminal, add Claude accounts
bun run ccflare --add-account myaccount
```

### Development Configuration

```bash
# Environment variables for development
export PORT=8080
export LB_STRATEGY=session  # Only 'session' strategy is supported
export LOG_LEVEL=DEBUG
export LOG_FORMAT=pretty  # Options: pretty, json

# Start with custom config
bun run ccflare
```

## Production Deployment

### System Requirements

#### Minimum Requirements
- CPU: 2 cores
- RAM: 2GB
- Storage: 10GB (for logs and database)
- OS: Linux (Ubuntu 20.04+, Debian 11+), macOS, Windows Server 2019+

#### Recommended Requirements
- CPU: 4+ cores
- RAM: 4GB+
- Storage: 50GB+ SSD
- Network: Low-latency connection to Claude API

### Bun Binary Compilation

Compile ccflare into a single executable for easy deployment:

```bash
# Build all components (dashboard and TUI)
bun run build

# Build the main ccflare binary (includes TUI, CLI, and server)
cd apps/tui
bun build src/main.ts --compile --outfile dist/ccflare --target=bun

# Build standalone server binary (optional, server-only deployment)
cd ../server
bun build src/server.ts --compile --outfile dist/ccflare-server

# Copy binary to deployment location
cp apps/tui/dist/ccflare /opt/ccflare/
# Make it executable
chmod +x /opt/ccflare/ccflare
```

#### Binary Deployment Structure

```
/opt/ccflare/
├── ccflare             # Main binary (TUI + CLI + Server)
├── config/
│   └── config.json     # Configuration (optional)
└── data/
    ├── ccflare.db      # SQLite database
    └── logs/           # Log files (if configured)
```

**Note**: The configuration and database are automatically created in platform-specific directories:
- **Linux/macOS**: `~/.config/ccflare/`
- **Windows**: `%LOCALAPPDATA%\ccflare\` or `%APPDATA%\ccflare\`

### Process Management

#### PM2 Setup

```bash
# Install PM2 globally
npm install -g pm2

# Create ecosystem file
cat > ecosystem.config.js << 'EOF'
module.exports = {
  apps: [{
    name: 'ccflare',
    script: '/opt/ccflare/ccflare',
    args: '--serve',
    instances: 1,
    exec_mode: 'fork',
    env: {
      PORT: 8080,
      LB_STRATEGY: 'session',
      LOG_LEVEL: 'INFO',
      LOG_FORMAT: 'json',
      CLIENT_ID: '9d1c250a-e61b-44d9-88ed-5944d1962f5e',
      SESSION_DURATION_MS: 18000000,
      RETRY_ATTEMPTS: 3,
      RETRY_DELAY_MS: 1000,
      RETRY_BACKOFF: 2
    },
    error_file: '/opt/ccflare/data/logs/error.log',
    out_file: '/opt/ccflare/data/logs/out.log',
    log_file: '/opt/ccflare/data/logs/combined.log',
    time: true,
    autorestart: true,
    max_restarts: 10,
    min_uptime: '10s',
    watch: false
  }]
};
EOF

# Start with PM2
pm2 start ecosystem.config.js
pm2 save
pm2 startup
```

#### Systemd Service

Create a systemd service file:

```bash
# Create service file
sudo cat > /etc/systemd/system/ccflare.service << 'EOF'
[Unit]
Description=ccflare Load Balancer
After=network.target

[Service]
Type=simple
User=ccflare
Group=ccflare
WorkingDirectory=/opt/ccflare
ExecStart=/opt/ccflare/ccflare --serve
Restart=always
RestartSec=5

# Environment
Environment="PORT=8080"
Environment="LB_STRATEGY=session"
Environment="LOG_LEVEL=INFO"
Environment="LOG_FORMAT=json"
Environment="CLIENT_ID=9d1c250a-e61b-44d9-88ed-5944d1962f5e"
Environment="SESSION_DURATION_MS=18000000"
Environment="RETRY_ATTEMPTS=3"
Environment="RETRY_DELAY_MS=1000"
Environment="RETRY_BACKOFF=2"

# Security
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/ccflare/data

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

[Install]
WantedBy=multi-user.target
EOF

# Create user and directories
sudo useradd -r -s /bin/false ccflare
sudo mkdir -p /opt/ccflare/{config,data/logs}
sudo chown -R ccflare:ccflare /opt/ccflare

# Enable and start service
sudo systemctl daemon-reload
sudo systemctl enable ccflare
sudo systemctl start ccflare
```

## Docker Deployment

> **Important**: Docker files are not included in the repository. The configurations below are examples/templates that you can use as a starting point for creating your own Docker deployment.

### Example Dockerfile

```dockerfile
# Multi-stage build for optimal size
FROM oven/bun:1 AS builder

WORKDIR /app

# Copy package files
COPY package.json bun.lockb ./
COPY apps/ ./apps/
COPY packages/ ./packages/
COPY tsconfig.json ./

# Install dependencies and build
RUN bun install --frozen-lockfile
RUN bun run build
RUN cd apps/server && bun build src/server.ts --compile --outfile dist/ccflare-server
RUN cd apps/cli && bun build src/cli.ts --compile --outfile dist/ccflare-cli

# Runtime stage
FROM debian:bookworm-slim

# Install runtime dependencies
RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Create user
RUN useradd -r -s /bin/false ccflare

# Copy binary and dashboard
COPY --from=builder /app/apps/tui/dist/ccflare /usr/local/bin/ccflare
COPY --from=builder /app/packages/dashboard-web/dist /opt/ccflare/dashboard

# Set permissions
RUN chmod +x /usr/local/bin/ccflare

# Create data directories
RUN mkdir -p /data /config && chown -R ccflare:ccflare /data /config

USER ccflare

# Environment
ENV PORT=8080
ENV ccflare_CONFIG_PATH=/config/ccflare.json

EXPOSE 8080

VOLUME ["/data", "/config"]

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD ["/usr/local/bin/ccflare-server", "health"] || exit 1

ENTRYPOINT ["/usr/local/bin/ccflare", "--serve"]
```

### Example Docker Compose

```yaml
version: '3.8'

services:
  ccflare:
    build: .
    container_name: ccflare
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      - PORT=8080
      - LB_STRATEGY=session
      - LOG_LEVEL=INFO
      - LOG_FORMAT=json
      - CLIENT_ID=9d1c250a-e61b-44d9-88ed-5944d1962f5e
      - SESSION_DURATION_MS=18000000
      - RETRY_ATTEMPTS=3
      - RETRY_DELAY_MS=1000
      - RETRY_BACKOFF=2
    volumes:
      - ./data:/data
      - ./config:/config
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - ccflare-net

  # Optional: Reverse proxy
  nginx:
    image: nginx:alpine
    container_name: ccflare-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      - ccflare
    networks:
      - ccflare-net

networks:
  ccflare-net:
    driver: bridge
```

### Building and Running

```bash
# Build the Docker image
docker build -t ccflare:latest .

# Run with Docker
docker run -d \
  --name ccflare \
  -p 8080:8080 \
  -v $(pwd)/data:/data \
  -v $(pwd)/config:/config \
  -e LB_STRATEGY=session \
  ccflare:latest

# Or use Docker Compose
docker-compose up -d
```

## Cloudflare Pages (Dashboard Only)

Deploy the dashboard as a static site on Cloudflare Pages while running the API server elsewhere:

### Build Configuration

```bash
# Build script for Cloudflare Pages
cd packages/dashboard-web
bun install
bun run build

# Output directory: packages/dashboard-web/dist
```

### Cloudflare Pages Configuration

1. Connect your GitHub repository
2. Set build configuration:
   - Build command: `cd packages/dashboard-web && bun install && bun run build`
   - Build output directory: `packages/dashboard-web/dist`
   - Root directory: `/`

### Environment Variables

```bash
# Set in Cloudflare Pages dashboard
VITE_API_URL=https://api.your-domain.com
```

### Dashboard API Configuration

Update the dashboard to use external API:

```typescript
// packages/dashboard-web/src/lib/api-client.ts
const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8080';
```

## Reverse Proxy Setup

### Nginx Configuration

```nginx
# /etc/nginx/sites-available/ccflare
upstream ccflare_backend {
    server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;
    keepalive 32;
}

server {
    listen 80;
    server_name ccflare.yourdomain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name ccflare.yourdomain.com;

    # SSL configuration
    ssl_certificate /etc/letsencrypt/live/ccflare.yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/ccflare.yourdomain.com/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Proxy settings
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # Timeouts
    proxy_connect_timeout 60s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;

    # Main proxy
    location / {
        proxy_pass http://ccflare_backend;
    }

    # API endpoints
    location /v1/ {
        proxy_pass http://ccflare_backend;
        
        # Increase limits for AI requests
        client_max_body_size 100M;
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # WebSocket support for real-time updates
    location /ws {
        proxy_pass http://ccflare_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_read_timeout 86400;
    }

    # Static assets caching
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        proxy_pass http://ccflare_backend;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

### Caddy Configuration

```caddyfile
ccflare.yourdomain.com {
    # Automatic HTTPS
    tls your-email@example.com

    # Reverse proxy
    reverse_proxy localhost:8080 {
        # Load balancing if multiple instances
        lb_policy least_conn
        lb_try_duration 30s
        
        # Headers
        header_up Host {host}
        header_up X-Real-IP {remote}
        header_up X-Forwarded-For {remote}
        header_up X-Forwarded-Proto {scheme}
        
        # Health check
        health_uri /health
        health_interval 30s
        health_timeout 5s
    }

    # API specific configuration
    handle_path /v1/* {
        reverse_proxy localhost:8080 {
            # Streaming support
            flush_interval -1
            buffer_requests off
            buffer_responses off
            
            # Timeouts
            transport http {
                read_timeout 5m
                write_timeout 5m
            }
        }
    }

    # Compression
    encode gzip

    # Security headers
    header {
        X-Frame-Options SAMEORIGIN
        X-Content-Type-Options nosniff
        X-XSS-Protection "1; mode=block"
        Referrer-Policy strict-origin-when-cross-origin
    }
}
```

## Monitoring and Logging

### Log Management

```mermaid
graph TB
    subgraph "Logging Architecture"
        APP[ccflare Server]
        
        subgraph "Log Outputs"
            FILE[File Logs<br/>/var/log/ccflare/]
            STDOUT[Container Stdout]
            SYSLOG[Syslog]
        end
        
        subgraph "Log Aggregation"
            LOKI[Loki]
            ELK[ELK Stack]
            CLOUDWATCH[CloudWatch]
        end
        
        subgraph "Visualization"
            GRAFANA[Grafana]
            KIBANA[Kibana]
        end
    end
    
    APP --> FILE
    APP --> STDOUT
    APP --> SYSLOG
    
    FILE --> LOKI
    STDOUT --> ELK
    SYSLOG --> CLOUDWATCH
    
    LOKI --> GRAFANA
    ELK --> KIBANA
    CLOUDWATCH --> GRAFANA
```

### Prometheus Metrics (Future Enhancement)

> **Note**: Prometheus metrics support is planned but not yet implemented. The following is an example of how metrics could be integrated:

```typescript
// Example: packages/http-api/src/metrics.ts
import { register, Counter, Histogram, Gauge } from 'prom-client';

export const metrics = {
  requestsTotal: new Counter({
    name: 'ccflare_requests_total',
    help: 'Total number of requests',
    labelNames: ['method', 'status', 'account']
  }),
  
  requestDuration: new Histogram({
    name: 'ccflare_request_duration_seconds',
    help: 'Request duration in seconds',
    labelNames: ['method', 'status'],
    buckets: [0.1, 0.5, 1, 2, 5, 10]
  }),
  
  activeAccounts: new Gauge({
    name: 'ccflare_active_accounts',
    help: 'Number of active accounts',
    labelNames: ['tier']
  }),
  
  rateLimitedAccounts: new Gauge({
    name: 'ccflare_rate_limited_accounts',
    help: 'Number of rate limited accounts'
  })
};
```

### Monitoring Stack

```yaml
# docker-compose.monitoring.yml
version: '3.8'

services:
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    ports:
      - "9090:9090"

  grafana:
    image: grafana/grafana:latest
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_INSTALL_PLUGINS=grafana-clock-panel
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
      - ./grafana/datasources:/etc/grafana/provisioning/datasources
    ports:
      - "3000:3000"

  loki:
    image: grafana/loki:latest
    volumes:
      - ./loki-config.yaml:/etc/loki/local-config.yaml
      - loki_data:/loki
    ports:
      - "3100:3100"

  promtail:
    image: grafana/promtail:latest
    volumes:
      - ./promtail-config.yaml:/etc/promtail/config.yml
      - /var/log:/var/log:ro
      - /opt/ccflare/data/logs:/app/logs:ro
    command: -config.file=/etc/promtail/config.yml

volumes:
  prometheus_data:
  grafana_data:
  loki_data:
```

## Performance Tuning

### System Optimization

```bash
# Increase file descriptor limits
echo "ccflare soft nofile 65536" >> /etc/security/limits.conf
echo "ccflare hard nofile 65536" >> /etc/security/limits.conf

# TCP tuning for high throughput
cat >> /etc/sysctl.conf << EOF
# TCP tuning
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 65535
net.ipv4.tcp_fin_timeout = 15
net.ipv4.tcp_keepalive_time = 300
net.ipv4.tcp_keepalive_probes = 5
net.ipv4.tcp_keepalive_intvl = 15

# Buffer sizes
net.core.rmem_default = 262144
net.core.wmem_default = 262144
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
EOF

# Apply changes
sysctl -p
```

### Application Tuning

```json
// ~/.config/ccflare/config.json (or platform-specific location)
{
  "lb_strategy": "session",
  "client_id": "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
  "retry_attempts": 3,
  "retry_delay_ms": 1000,
  "retry_backoff": 2,
  "session_duration_ms": 18000000,  // 5 hours
  "port": 8080
}
```

**Note**: These settings can also be configured via environment variables, which take precedence over the config file.
```

### Database Optimization

```sql
-- Optimize SQLite for production
PRAGMA journal_mode = WAL;
PRAGMA synchronous = NORMAL;
PRAGMA cache_size = -20000;
PRAGMA temp_store = MEMORY;
PRAGMA mmap_size = 268435456;

-- Create indexes for common queries
CREATE INDEX IF NOT EXISTS idx_requests_timestamp ON requests(timestamp);
CREATE INDEX IF NOT EXISTS idx_requests_account ON requests(account_used);
CREATE INDEX IF NOT EXISTS idx_accounts_active ON accounts(paused, expires_at);
```

## Scaling Considerations

### Horizontal Scaling Architecture

```mermaid
graph TB
    subgraph "Load Balancer Layer"
        LB[HAProxy/Nginx<br/>Load Balancer]
    end
    
    subgraph "Application Instances"
        APP1[ccflare-1<br/>Port 8081]
        APP2[ccflare-2<br/>Port 8082]
        APP3[ccflare-N<br/>Port 808N]
    end
    
    subgraph "Shared Data Layer"
        REDIS[(Redis<br/>Session Store)]
        PG[(PostgreSQL<br/>Main Database)]
        S3[S3-Compatible<br/>Object Storage]
    end
    
    subgraph "Service Discovery"
        CONSUL[Consul/etcd]
    end
    
    LB --> APP1
    LB --> APP2
    LB --> APP3
    
    APP1 --> REDIS
    APP1 --> PG
    APP1 --> S3
    APP1 --> CONSUL
    
    APP2 --> REDIS
    APP2 --> PG
    APP2 --> S3
    APP2 --> CONSUL
    
    APP3 --> REDIS
    APP3 --> PG
    APP3 --> S3
    APP3 --> CONSUL
```

### Database Considerations

ccflare uses SQLite by default, which is suitable for most single-instance deployments. The database is automatically created and managed in the platform-specific configuration directory.

#### SQLite Optimization (Default)

```sql
-- These optimizations are automatically applied by ccflare
PRAGMA journal_mode = WAL;
PRAGMA synchronous = NORMAL;
PRAGMA cache_size = -20000;  -- 20MB cache
PRAGMA temp_store = MEMORY;
PRAGMA mmap_size = 268435456;
```

### Database Migration for Scale

When scaling beyond a single instance, you may need to migrate from SQLite to a shared database like PostgreSQL:

```sql
-- PostgreSQL schema (example for future implementation)
CREATE TABLE accounts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    provider VARCHAR(50) NOT NULL,
    api_key TEXT,
    refresh_token TEXT,
    access_token TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    last_used TIMESTAMPTZ,
    request_count INTEGER DEFAULT 0,
    total_requests INTEGER DEFAULT 0,
    account_tier INTEGER DEFAULT 1,
    rate_limited_until TIMESTAMPTZ,
    session_start TIMESTAMPTZ,
    session_request_count INTEGER DEFAULT 0,
    paused BOOLEAN DEFAULT FALSE,
    rate_limit_status VARCHAR(50),
    rate_limit_reset TIMESTAMPTZ,
    rate_limit_remaining INTEGER
);

CREATE TABLE requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    method VARCHAR(10),
    path TEXT,
    account_used UUID REFERENCES accounts(id),
    status_code INTEGER,
    success BOOLEAN,
    error_message TEXT,
    response_time_ms INTEGER,
    failover_attempts INTEGER DEFAULT 0,
    model VARCHAR(100),
    input_tokens INTEGER,
    output_tokens INTEGER,
    cache_read_input_tokens INTEGER,
    cache_creation_input_tokens INTEGER,
    cost_usd DECIMAL(10, 6)
);

-- Indexes for performance
CREATE INDEX idx_requests_timestamp ON requests(timestamp DESC);
CREATE INDEX idx_requests_account ON requests(account_used);
CREATE INDEX idx_accounts_active ON accounts(paused, expires_at);
CREATE INDEX idx_accounts_rate_limit ON accounts(rate_limited_until);
```

### Kubernetes Deployment

```yaml
# ccflare-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ccflare
  labels:
    app: ccflare
spec:
  replicas: 3
  selector:
    matchLabels:
      app: ccflare
  template:
    metadata:
      labels:
        app: ccflare
    spec:
      containers:
      - name: ccflare
        image: your-registry/ccflare:latest
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: ccflare-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: ccflare-secrets
              key: redis-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: ccflare
spec:
  selector:
    app: ccflare
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
```

### High Availability Checklist

- [ ] Database replication configured
- [ ] Redis sentinel or cluster mode enabled
- [ ] Load balancer health checks configured
- [ ] Automatic failover tested
- [ ] Backup and restore procedures documented
- [ ] Monitoring alerts configured
- [ ] Disaster recovery plan in place
- [ ] Performance baselines established
- [ ] Security audit completed
- [ ] Documentation up to date

## Security Considerations

### Production Security Checklist

1. **Network Security**
   - [ ] Firewall rules configured
   - [ ] SSL/TLS certificates installed
   - [ ] Rate limiting configured
   - [ ] DDoS protection enabled

2. **Application Security**
   - [ ] Authentication implemented for admin endpoints
   - [ ] API keys properly secured
   - [ ] Input validation enabled
   - [ ] Security headers configured

3. **Data Security**
   - [ ] Database encryption at rest
   - [ ] Backup encryption enabled
   - [ ] Access logs configured
   - [ ] Audit trail implemented

4. **Operational Security**
   - [ ] Least privilege user accounts
   - [ ] Regular security updates
   - [ ] Intrusion detection configured
   - [ ] Incident response plan

## Health Monitoring

### Health Check Endpoint

ccflare provides a health check endpoint for monitoring:

```bash
# Check health status
curl http://localhost:8080/health
```

Response format:
```json
{
  "status": "ok",
  "accounts": 5,
  "timestamp": "2025-01-27T12:00:00.000Z",
  "strategy": "session"
}
```

### Monitoring Integration

Use the health endpoint with monitoring tools:

```yaml
# Kubernetes liveness probe
livenessProbe:
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 10
  periodSeconds: 30

# Docker Compose health check  
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
  interval: 30s
  timeout: 10s
  retries: 3
```

## API Endpoints Reference

### Management API

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/health` | GET | Health check and system status |
| `/api/stats` | GET | Account statistics and usage |
| `/api/stats/reset` | POST | Reset usage statistics |
| `/api/requests` | GET | Request history with pagination |
| `/api/accounts` | GET | List all accounts |
| `/api/accounts/:name` | GET | Get specific account details |
| `/api/accounts/:name` | PATCH | Update account (pause/unpause) |
| `/api/accounts/:name` | DELETE | Remove account |
| `/api/config` | GET | Get current configuration |
| `/api/config` | PATCH | Update configuration |

### Analytics API

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/analytics/usage` | GET | Usage analytics with filtering |
| `/api/analytics/costs` | GET | Cost breakdown by model/account |
| `/api/analytics/requests/:id` | GET | Request details with payload |

### Real-time API

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/logs/stream` | GET | Real-time log streaming (SSE) |
| `/api/logs/history` | GET | Historical logs (paginated) |

### Claude API Proxy

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/v1/*` | * | All Claude API endpoints |

## Troubleshooting

### Common Issues

1. **Database Lock Errors**
   ```bash
   # Find the actual database location
   # Linux/macOS:
   sqlite3 ~/.config/ccflare/ccflare.db "PRAGMA journal_mode=WAL;"
   
   # Windows:
   sqlite3 %LOCALAPPDATA%\ccflare\ccflare.db "PRAGMA journal_mode=WAL;"
   ```

2. **High Memory Usage**
   ```bash
   # Check for memory leaks
   node --inspect=0.0.0.0:9229 /opt/ccflare/ccflare-server
   ```

3. **Connection Refused**
   ```bash
   # Check if service is running
   systemctl status ccflare
   # Check logs
   journalctl -u ccflare -f
   ```

4. **Rate Limit Issues**
   ```bash
   # Check account status
   ccflare --list
   # Reset statistics
   ccflare --reset-stats
   ```

## Maintenance

### Regular Tasks

```bash
# Daily: Check recent logs
ccflare --logs 100 | grep ERROR

# Weekly: Database maintenance
# Linux/macOS:
sqlite3 ~/.config/ccflare/ccflare.db "VACUUM;"
sqlite3 ~/.config/ccflare/ccflare.db "ANALYZE;"

# Monthly: Clean old request history
ccflare --clear-history

# Quarterly: Update dependencies (if running from source)
cd /path/to/ccflare
bun update
```

### Backup Procedures

```bash
#!/bin/bash
# backup.sh - Run daily via cron

BACKUP_DIR="/backup/ccflare/$(date +%Y%m%d)"
mkdir -p "$BACKUP_DIR"

# Determine config directory based on OS
if [[ "$OSTYPE" == "darwin"* ]] || [[ "$OSTYPE" == "linux-gnu"* ]]; then
    CONFIG_DIR="$HOME/.config/ccflare"
elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]]; then
    CONFIG_DIR="$LOCALAPPDATA/ccflare"
else
    CONFIG_DIR="$HOME/.config/ccflare"  # Default fallback
fi

# Backup database and config
sqlite3 "$CONFIG_DIR/ccflare.db" ".backup $BACKUP_DIR/ccflare.db"
cp "$CONFIG_DIR/config.json" "$BACKUP_DIR/" 2>/dev/null || true

# Compress
tar -czf "$BACKUP_DIR.tar.gz" "$BACKUP_DIR"
rm -rf "$BACKUP_DIR"

# Keep only last 30 days
find /backup/ccflare -name "*.tar.gz" -mtime +30 -delete
```

## Environment Variables Reference

### Core Configuration

| Variable | Default | Description |
|----------|---------|-------------|
| `PORT` | 8080 | Server port |
| `LB_STRATEGY` | session | Load balancing strategy (only 'session' is supported) |
| `LOG_LEVEL` | INFO | Logging level: `DEBUG`, `INFO`, `WARN`, `ERROR` |
| `LOG_FORMAT` | pretty | Log format: `pretty` (human-readable) or `json` (structured) |
| `ccflare_DEBUG` | 0 | Enable debug mode (1/0) - enables console output |

### Advanced Configuration

| Variable | Default | Description |
|----------|---------|-------------|
| `CLIENT_ID` | 9d1c250a-e61b-44d9-88ed-5944d1962f5e | OAuth client ID for authentication |
| `SESSION_DURATION_MS` | 18000000 | Session duration in milliseconds (5 hours) |
| `RETRY_ATTEMPTS` | 3 | Number of retry attempts for failed requests |
| `RETRY_DELAY_MS` | 1000 | Initial delay between retries in milliseconds |
| `RETRY_BACKOFF` | 2 | Backoff multiplier for exponential retry delays |
| `ccflare_CONFIG_PATH` | Platform-specific | Path to configuration file |
| `ccflare_DB_PATH` | Platform-specific | Path to SQLite database file |

### Configuration File

ccflare also supports a JSON configuration file that takes precedence over environment variables:

```json
{
  "lb_strategy": "session",
  "client_id": "your-client-id",
  "retry_attempts": 5,
  "retry_delay_ms": 2000,
  "retry_backoff": 1.5,
  "session_duration_ms": 7200000,
  "port": 3000
}
```

The configuration file is located at:
- **Linux/macOS**: `~/.config/ccflare/config.json`
- **Windows**: `%APPDATA%\ccflare\config.json`

## Conclusion

ccflare is designed to be flexible and scalable, supporting everything from simple local deployments to complex distributed architectures. Choose the deployment option that best fits your needs and scale as your requirements grow.

### Key Features Summary

- **Integrated Binary**: Single executable combining TUI, CLI, and server functionality
- **Interactive TUI**: Monitor and manage your deployment in real-time
- **Web Dashboard**: Access analytics and logs through a modern web interface  
- **Async Database Writer**: Improved performance for high-throughput scenarios
- **Session-based Load Balancing**: Maintains session affinity for optimal performance
- **Binary Compilation**: Deploy as standalone executable without runtime dependencies

### Additional Resources

- [Main Documentation](./index.md)
- [Configuration Guide](./configuration.md)
- [Load Balancing Strategies](./load-balancing.md)
- [API Reference](./api-http.md)
- [GitHub Repository](https://github.com/snipeship/ccflare)

## Terminal User Interface (TUI)

ccflare includes a powerful Terminal User Interface for interactive monitoring and management.

### Starting the TUI

```bash
# Start ccflare in interactive mode (TUI + Server)
ccflare

# Or from source:
bun run ccflare

# Start server only (no TUI)
ccflare --serve

# View help for all available commands
ccflare --help
```

### TUI Features

- **Real-time Dashboard**: Live system status and metrics
- **Account Management**: View and manage Claude accounts
  - Account status and rate limits
  - Pause/unpause accounts
  - View usage statistics
- **Request Monitor**: Track requests as they happen
  - Request details and timing
  - Success/failure status
  - Token usage per request
- **Log Viewer**: Browse historical logs
  - Filter by level and time
  - Search functionality
  - Export capabilities
- **Statistics Screen**: Comprehensive analytics
  - Usage patterns
  - Cost breakdown
  - Performance metrics

### Keyboard Navigation

| Key | Action |
|-----|--------|
| `Tab` / `Shift+Tab` | Navigate between screens |
| `↑` / `↓` | Navigate within lists |
| `←` / `→` | Switch between tabs |
| `Enter` | Select/view details |
| `Space` | Toggle selection |
| `r` | Refresh current view |
| `f` | Focus search/filter |
| `Esc` | Close dialog/cancel |
| `q` / `Ctrl+C` | Quit TUI |

### Remote API Connection

The ccflare binary can connect to a remote API server for distributed deployments:

```bash
# Set API URL for remote connection
export ccflare_API_URL=https://ccflare.example.com
ccflare --list  # Will query the remote server
```

### TUI Configuration

Customize TUI behavior through environment variables:

```bash
# Refresh intervals (milliseconds)
export TUI_REFRESH_INTERVAL=1000      # Dashboard refresh
export TUI_LOG_POLL_INTERVAL=500      # Log updates

# Display options
export TUI_THEME=dark                 # dark or light
export TUI_COMPACT_MODE=false         # Compact display
```

For support and updates, check the project repository and documentation.
</file>

<file path="docs/index.md">
# ccflare Documentation

## Track Every Request. Go Low-Level. Never Hit Rate Limits Again.

![Build Status](https://img.shields.io/badge/build-passing-brightgreen)
![Version](https://img.shields.io/badge/version-1.0.0-blue)
![License](https://img.shields.io/badge/license-MIT-green)
![Bun](https://img.shields.io/badge/bun-%3E%3D1.2.8-f472b6)

## Overview

ccflare is the ultimate Claude API proxy with intelligent load balancing across multiple accounts. Built with TypeScript and Bun runtime, it provides full visibility into every request, response, and rate limit, ensuring your AI applications never experience downtime due to rate limiting.

### Why ccflare?

When working with Claude API at scale, rate limits can become a significant bottleneck. ccflare solves this by:

- **🚀 Zero Rate Limit Errors**: Automatically distributes requests across multiple accounts with intelligent failover
- **📊 Request-Level Analytics**: Track latency, token usage, and costs in real-time with <10ms overhead
- **🔍 Deep Debugging**: Full request/response logging and error traces for complete visibility
- **💸 Session-Based Routing**: Default 5-hour sessions maximize prompt cache efficiency, reducing costs
- **⚡ Production Ready**: Built for scale with SQLite persistence, OAuth token refresh, and configurable retry logic

## Key Features

### 🎯 Intelligent Load Balancing
- **Session-based** (only supported strategy): Maintains conversation context with 5-hour sessions to avoid rate limits and account bans
- **⚠️ WARNING**: Other strategies (round-robin, least-requests, weighted) have been removed as they can trigger Claude's anti-abuse systems

### 📈 Real-Time Monitoring & Analytics
- **Web Dashboard**: Interactive UI at `/dashboard` with live metrics
- **Terminal UI**: Built-in TUI for server management and monitoring
- **Request Tracking**: Complete history with token usage and costs
- **Performance Metrics**: Response times, success rates, and error tracking

### 🛠️ Developer Experience
- **Zero Config Proxy**: Drop-in replacement for Claude API
- **CLI Management**: Add, remove, and manage accounts easily
- **Automatic Failover**: Seamless switching on rate limits
- **OAuth Token Refresh**: Handles authentication automatically

### 🏗️ Production Ready
- **SQLite Persistence**: Reliable data storage with migrations
- **Configurable Retry Logic**: Smart exponential backoff
- **Account Tiers**: Support for Pro (1x), Max 5x, and Max 20x
- **Extensible Architecture**: Provider-based design for future AI services

## Documentation

### Getting Started
- [Configuration Guide](./configuration.md) - Environment variables and configuration options
- [Architecture Overview](./architecture.md) - System components and design principles
- [Data Flow](./data-flow.md) - Request lifecycle through the system

### Core Features
- [Load Balancing Strategy](./load-balancing.md) - Session-based strategy for safe account usage
- [Provider System](./providers.md) - Provider abstraction and OAuth implementation
- [Database Schema](./database.md) - SQLite structure, migrations, and maintenance

### User Interfaces
- [HTTP API Reference](./api-http.md) - Complete REST API documentation
- [CLI Commands](./cli.md) - Command-line interface reference
- [Terminal UI Guide](./tui.md) - Interactive terminal interface documentation

### Operations
- [Deployment Guide](./deployment.md) - Production deployment with Docker, systemd, PM2, and Kubernetes
- [Security Considerations](./security.md) - Authentication, encryption, and best practices
- [Troubleshooting](./troubleshooting.md) - Common issues and solutions
- [Contributing](./contributing.md) - Development setup and contribution guidelines

## Quick Start

### 1. Install ccflare

```bash
# Clone the repository
git clone https://github.com/snipeship/ccflare.git
cd ccflare

# Install dependencies
bun install
```

### 2. Start ccflare (TUI + Server)

```bash
# Start ccflare with interactive TUI (automatically starts server)
bun run ccflare

# Or start just the server without TUI
bun run server

# Specify session duration (default: 5 hours)
SESSION_DURATION_MS=21600000 bun run server  # 6 hours

# Run TUI directly with Bun (if not using npm scripts)
bun run apps/tui/src/main.ts
```

### 3. Add Your Claude Accounts

```bash
# In another terminal, add your accounts
# Add a work account
bun run apps/tui/src/main.ts --add-account work-account

# Add a personal account  
bun run apps/tui/src/main.ts --add-account personal-account

# Add accounts with specific tiers
bun run apps/tui/src/main.ts --add-account pro-account --mode max --tier 1
bun run apps/tui/src/main.ts --add-account max-account --mode max --tier 5

# Or if you have ccflare command available globally
ccflare --add-account work-account
```

### 4. Configure Your Claude Client

```bash
# Set the base URL to use ccflare
export ANTHROPIC_BASE_URL=http://localhost:8080
```

### 5. Monitor Your Usage

- **Web Dashboard**: Open [http://localhost:8080/dashboard](http://localhost:8080/dashboard) for real-time analytics
- **Terminal UI**: Use the interactive TUI started with `bun run ccflare`
- **CLI**: Check status with `bun run apps/tui/src/main.ts --list`

## Project Structure

```
ccflare/
├── apps/               # Application packages
│   ├── server/        # Main proxy server
│   ├── tui/           # Terminal UI with integrated CLI
│   └── lander/        # Landing page
├── packages/          # Core packages
│   ├── core/          # Core business logic
│   ├── cli-commands/  # CLI command implementations
│   ├── database/      # SQLite database layer
│   ├── dashboard-web/ # Web dashboard UI
│   ├── http-api/      # REST API handlers
│   ├── load-balancer/ # Load balancing strategies
│   ├── logger/        # Logging utilities
│   ├── providers/     # OAuth provider system
│   └── proxy/         # HTTP proxy implementation
└── docs/              # Documentation

```

## Scripts Reference

```bash
# Main commands
bun run ccflare        # Start TUI (builds dashboard first)
bun run server         # Start server only
bun run tui            # Start TUI only
bun run start          # Alias for bun run server

# Development
bun run dev            # Start TUI in development mode
bun run dev:server     # Server with hot reload
bun run dev:dashboard  # Dashboard development

# Build & Quality
bun run build          # Build dashboard and TUI
bun run build:dashboard # Build web dashboard
bun run build:tui      # Build TUI
bun run build:lander   # Build landing page
bun run typecheck      # Check TypeScript types
bun run lint           # Fix linting issues
bun run format         # Format code
```

## CLI Commands

The ccflare CLI is integrated into the TUI application. All CLI functionality is accessed through the same executable:

```bash
# If running without global install, use the full path:
bun run apps/tui/src/main.ts [command]

# The commands below assume you're using the full path

# Account management
bun run apps/tui/src/main.ts --add-account <name>     # Add account
bun run apps/tui/src/main.ts --list                   # List accounts
bun run apps/tui/src/main.ts --remove <name>          # Remove account
bun run apps/tui/src/main.ts --pause <name>           # Pause account
bun run apps/tui/src/main.ts --resume <name>          # Resume account

# Maintenance
bun run apps/tui/src/main.ts --reset-stats            # Reset statistics
bun run apps/tui/src/main.ts --clear-history          # Clear request history
bun run apps/tui/src/main.ts --analyze                # Analyze database performance

# Other options
bun run apps/tui/src/main.ts --serve                  # Start server only
bun run apps/tui/src/main.ts --logs [N]               # Stream logs (optionally show last N lines)
bun run apps/tui/src/main.ts --stats                  # Show statistics (JSON)
bun run apps/tui/src/main.ts --help                   # Show help

# Add account with options
bun run apps/tui/src/main.ts --add-account <name> --mode <max|console> --tier <1|5|20>
```

For more detailed CLI documentation, see [CLI Commands](./cli.md).

## Environment Variables

```bash
# Server Configuration
PORT=8080                        # Server port (default: 8080)
LB_STRATEGY=session             # Load balancing strategy (only 'session' supported)
SESSION_DURATION_MS=18000000    # Session duration in ms (default: 5 hours)

# OAuth Configuration
CLIENT_ID=<your-client-id>      # Custom OAuth client ID (optional)

# Retry Configuration
RETRY_ATTEMPTS=3                # Number of retry attempts (default: 3)
RETRY_DELAY_MS=1000            # Initial retry delay in ms (default: 1000)
RETRY_BACKOFF=2                # Exponential backoff multiplier (default: 2)

# Development
LOG_LEVEL=info                  # Logging level (debug|info|warn|error)
NODE_ENV=production            # Environment mode
```

## Related Resources

### External Links
- [Claude API Documentation](https://docs.anthropic.com/claude/docs) - Official Anthropic API docs
- [Bun Documentation](https://bun.sh/docs) - Bun runtime documentation
- [SQLite Documentation](https://www.sqlite.org/docs.html) - SQLite database docs

### Support
- [GitHub Repository](https://github.com/snipeship/ccflare) - Source code and issues
- [Contributing](./contributing.md) - How to contribute to ccflare

## License

ccflare is open source software licensed under the MIT License. See the [LICENSE](../LICENSE) file for details.

---

<div align="center">
  <p>Built with ❤️ for developers who ship</p>
  <p>
    <a href="#quick-start">Get Started</a> •
    <a href="./architecture.md">Learn More</a> •
    <a href="./contributing.md">Contribute</a>
  </p>
</div>
</file>

<file path="docs/load-balancing.md">
# Load Balancing in ccflare

## Table of Contents
1. [Overview](#overview)
2. [Session-Based Strategy](#session-based-strategy)
3. [Configuration](#configuration)
4. [Account Selection Process](#account-selection-process)
5. [Performance Considerations](#performance-considerations)
6. [Important: Why Only Session-Based Strategy](#important-why-only-session-based-strategy)

## Overview

ccflare implements a session-based load balancing system to distribute requests across multiple Claude OAuth accounts, avoiding rate limits and ensuring high availability. The system maintains configurable sessions (default: 5 hours) with individual accounts to minimize rate limit issues.

### Key Features
- **Account Health Monitoring**: Automatically filters out rate-limited or paused accounts
- **Failover Support**: Returns ordered lists of accounts for automatic failover
- **Session Persistence**: Maintains configurable sessions on specific accounts
- **Real-time Configuration**: Change settings without restarting the server
- **Provider Filtering**: Accounts are filtered by provider compatibility

## Session-Based Strategy

**Description**: Maintains sticky sessions with individual accounts for a configurable duration (default: 5 hours). This is the only load balancing strategy available in ccflare, designed to minimize account switching and reduce the likelihood of hitting rate limits.

**Use Case**: Optimal for production environments where minimizing rate limits is crucial. Particularly effective for applications with sustained user sessions.

**Implementation Details**:
```typescript
export class SessionStrategy implements LoadBalancingStrategy {
    private sessionDurationMs: number;
    private store: StrategyStore | null = null;
    private log = new Logger("SessionStrategy");

    constructor(sessionDurationMs: number = TIME_CONSTANTS.SESSION_DURATION_DEFAULT) {
        this.sessionDurationMs = sessionDurationMs;
    }

    initialize(store: StrategyStore): void {
        this.store = store;
    }

    select(accounts: Account[], _meta: RequestMeta): Account[] {
        const now = Date.now();
        
        // Find account with most recent active session
        let activeAccount: Account | null = null;
        let mostRecentSessionStart = 0;
        
        for (const account of accounts) {
            if (account.session_start && 
                now - account.session_start < this.sessionDurationMs &&
                account.session_start > mostRecentSessionStart) {
                activeAccount = account;
                mostRecentSessionStart = account.session_start;
            }
        }
        
        // Use active account if available
        if (activeAccount && isAccountAvailable(activeAccount, now)) {
            const others = accounts.filter(
                a => a.id !== activeAccount.id && isAccountAvailable(a, now)
            );
            return [activeAccount, ...others]; // Active account first, others as fallback
        }
        
        // No active session - start new one with first available account
        const available = accounts.filter(a => isAccountAvailable(a, now));
        if (available.length === 0) return [];
        
        const chosenAccount = available[0];
        this.resetSessionIfExpired(chosenAccount);
        
        const others = available.filter(a => a.id !== chosenAccount.id);
        return [chosenAccount, ...others];
    }
}
```

**Characteristics**:
- ✅ **Excellent Rate Limit Avoidance**: Minimizes account switching
- ✅ **Predictable Behavior**: Consistent account usage patterns
- ✅ **Good for Long Sessions**: Ideal for extended AI conversations
- ⚠️ **Uneven Load Distribution**: May concentrate load on fewer accounts
- ⚠️ **Session Dependency**: Performance tied to specific account availability

## Configuration

ccflare uses a hierarchical configuration system where environment variables take precedence over configuration file settings.

### Configuration Precedence (highest to lowest)
1. Environment variables
2. Configuration file (`~/.ccflare/config.json`)
3. Default values

### Environment Variables

```bash
# Load balancing strategy (only 'session' is supported)
LB_STRATEGY=session

# Session duration in milliseconds (default: 18000000ms = 5 hours)
SESSION_DURATION_MS=18000000

# Server port (default: 8080)
PORT=8080

# Client ID for OAuth (default: 9d1c250a-e61b-44d9-88ed-5944d1962f5e)
CLIENT_ID=your-client-id

# Retry configuration
RETRY_ATTEMPTS=3
RETRY_DELAY_MS=1000
RETRY_BACKOFF=2
```

### Configuration File

The configuration file is automatically created at `~/.ccflare/config.json` on first run:

```json
{
    "lb_strategy": "session",
    "session_duration_ms": 18000000,
    "port": 8080,
    "client_id": "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
    "retry_attempts": 3,
    "retry_delay_ms": 1000,
    "retry_backoff": 2
}
```

### Time Constants

The following time constants are used throughout the system:
- `SESSION_DURATION_DEFAULT`: 18000000ms (5 hours)
- `SESSION_DURATION_FALLBACK`: 3600000ms (1 hour) - used if configuration is invalid

### Dynamic Configuration

The strategy configuration can be changed at runtime via the HTTP API:

```bash
# Get current strategy
curl http://localhost:8080/api/config/strategy

# Update strategy (only 'session' is valid)
curl -X PUT http://localhost:8080/api/config/strategy \
  -H "Content-Type: application/json" \
  -d '{"strategy": "session"}'

# Get all configuration settings
curl http://localhost:8080/api/config

# Get available strategies
curl http://localhost:8080/api/config/strategies
```

## Account Selection Process

The load balancer follows a specific process when selecting accounts for requests:

### 1. Account Filtering
```typescript
// From proxy/handlers/account-selector.ts
const providerAccounts = allAccounts.filter(
    (account) => account.provider === ctx.provider.name || account.provider === null
);
```
- Accounts are first filtered by provider compatibility
- Only accounts matching the current provider or with null provider are considered

### 2. Availability Check
```typescript
// From core/strategy.ts
export function isAccountAvailable(account: Account, now = Date.now()): boolean {
    return (
        !account.paused &&
        (!account.rate_limited_until || account.rate_limited_until < now)
    );
}
```
- Paused accounts are excluded
- Rate-limited accounts are excluded if their rate limit hasn't expired

### 3. Session Management
The SessionStrategy manages account sessions through the following process:

1. **Active Session Search**: Finds the account with the most recent active session
2. **Session Validation**: Checks if the session is within the configured duration
3. **Account Ordering**: Returns accounts in priority order:
   - Active session account (if available) comes first
   - Other available accounts follow as fallback options

### 4. Session Reset
Sessions are reset when:
- No active session exists
- The current session has expired
- A new account needs to be selected

```typescript
private resetSessionIfExpired(account: Account): void {
    const now = Date.now();
    
    if (!account.session_start || 
        now - account.session_start >= this.sessionDurationMs) {
        // Reset session via StrategyStore
        this.store.resetAccountSession(account.id, now);
        account.session_start = now;
        account.session_request_count = 0;
    }
}
```

### 5. Database Updates
The StrategyStore interface provides methods for session management:
- `resetAccountSession(accountId, timestamp)`: Resets session start time and request count
- `updateAccountRequestCount(accountId, count)`: Updates request count for an account
- `getAccount(accountId)`: Retrieves account information

## Performance Considerations

### Session-Based Performance

The session strategy provides excellent rate limit avoidance at the cost of potentially uneven load distribution:

- **Rate Limit Avoidance**: By maintaining sessions with individual accounts for extended periods, the strategy minimizes the risk of hitting rate limits due to rapid account switching.
- **Load Distribution**: Load may concentrate on fewer accounts during a session window. This is acceptable for most use cases but should be monitored.
- **Failover**: If the active session account becomes unavailable, the system automatically fails over to the next available account.

### Session Storage

Session information is stored directly in the database with the following fields:
- `session_start`: Timestamp when the current session began
- `session_request_count`: Number of requests in the current session
- `rate_limited_until`: Timestamp when rate limiting expires (if applicable)

These fields are updated synchronously to ensure consistency in account selection.

### Monitoring

Monitor these key metrics:
- Account usage distribution
- Rate limit occurrences
- Session duration effectiveness
- Failover frequency

## Important: Why Only Session-Based Strategy

**⚠️ WARNING: Only the session-based load balancer strategy is available in ccflare.**

Other strategies like round-robin, least-requests, or weighted distribution have been removed from the codebase as they can trigger Claude's anti-abuse systems and result in automatic account bans. Here's why they were removed:

### Account Ban Risks

1. **Rapid Account Switching**: Strategies that frequently switch between accounts create suspicious patterns that Claude's systems detect as potential abuse.

2. **Unnatural Usage Patterns**: Round-robin and similar strategies create artificial request patterns that don't match normal human usage.

3. **Rate Limit Triggering**: Frequent account switching increases the likelihood of hitting rate limits across multiple accounts simultaneously.

### Why Session-Based is Safe

The session-based strategy mimics natural user behavior:
- Maintains consistent sessions with individual accounts
- Reduces account switching to once every 5 hours (configurable)
- Creates usage patterns similar to a regular Claude user
- Minimizes the risk of triggering anti-abuse systems

### Best Practices

1. **Always use session-based strategy**: This is the only strategy that won't risk your accounts
2. **Configure appropriate session duration**: Default 5 hours is recommended
3. **Monitor account health**: Watch for any rate limit issues or warnings
4. **Avoid custom strategies**: Do not implement custom load balancing strategies unless you fully understand the risks

If you need different behavior, adjust the session duration rather than switching strategies:
```json
{
    "lb_strategy": "session",
    "session_duration_ms": 18000000  // 5 hours (recommended)
}
```

## LoadBalancingStrategy Interface

For reference, here's the interface that all load balancing strategies must implement:

```typescript
// From types/context.ts
export interface LoadBalancingStrategy {
    /**
     * Return a filtered & ordered list of candidate accounts.
     * Accounts that are rate-limited should be filtered out.
     * The first account in the list should be tried first.
     */
    select(accounts: Account[], meta: RequestMeta): Account[];

    /**
     * Optional initialization method to inject dependencies
     * Used for strategies that need access to a StrategyStore
     */
    initialize?(store: StrategyStore): void;
}
```

The `RequestMeta` object contains:
- `id`: Unique request identifier
- `method`: HTTP method
- `path`: Request path
- `timestamp`: Request timestamp
- `agentUsed`: Optional agent identifier

Currently, only the `SessionStrategy` implementation exists in the codebase at `/packages/load-balancer/src/strategies/index.ts`.
</file>

<file path="docs/providers.md">
# Providers System Documentation

## Quick Reference

### Currently Supported Providers
- **Anthropic** - Single provider with two modes:
  - **console mode**: Standard Claude API (console.anthropic.com)
  - **max mode**: Claude Code (claude.ai)

### Key Points
- All API requests route to `https://api.anthropic.com`
- OAuth is the preferred authentication method with PKCE security
- Recent updates include enhanced streaming response capture for analytics
- Provider system is extensible for future providers (OpenAI, Gemini, etc.)
- Default OAuth client ID: `9d1c250a-e61b-44d9-88ed-5944d1962f5e` (configurable via environment or config file)

## Table of Contents
- [Overview](#overview)
- [Provider Registry Pattern](#provider-registry-pattern)
- [OAuth Authentication Flow](#oauth-authentication-flow)
- [AnthropicProvider Implementation](#anthropicprovider-implementation)
- [Provider Interface](#provider-interface)
- [Account Tier System](#account-tier-system)
- [Rate Limit Handling](#rate-limit-handling)
- [Token Storage and Security](#token-storage-and-security)
- [Adding New Providers](#adding-new-providers)

## Overview

The ccflare providers system is a modular architecture designed to support multiple AI service providers through a unified interface. Currently, it implements support for Anthropic's services through a single provider that can operate in two modes:

### Supported Providers

1. **Anthropic Provider** - Provides access to:
   - **Claude API** (console mode) - Standard API access via console.anthropic.com
   - **Claude Code** (max mode) - Enhanced access via claude.ai

The providers system handles:
- OAuth authentication flows with PKCE security
- Token lifecycle management (refresh, expiration)
- Provider-specific request routing and header management
- Rate limit detection and handling
- Usage tracking and tier detection
- Response processing and transformation
- Streaming response capture for analytics

## Provider Registry Pattern

The provider registry implements a singleton pattern to manage all available providers in the system. This centralized approach ensures consistent provider access and automatic OAuth capability detection.

### Registry Architecture

```typescript
class ProviderRegistry {
  private providers = new Map<string, Provider>();
  private oauthProviders = new Map<string, OAuthProvider>();
  
  registerProvider(provider: Provider): void
  getProvider(name: string): Provider | undefined
  getOAuthProvider(name: string): OAuthProvider | undefined
  listProviders(): string[]
  listOAuthProviders(): string[]
  unregisterProvider(name: string): boolean  // Useful for testing
  clear(): void  // Clear all providers (useful for testing)
}
```

### Auto-Registration

Providers are automatically registered when the package is imported:

```typescript
// In packages/providers/src/index.ts
import { registry } from "./registry";
import { AnthropicProvider } from "./providers/anthropic/provider";

registry.registerProvider(new AnthropicProvider());
```

### OAuth Detection

The registry automatically detects OAuth-capable providers through duck typing:

```typescript
if ("supportsOAuth" in provider && provider.supportsOAuth()) {
  const oauthProvider = provider.getOAuthProvider();
  this.oauthProviders.set(provider.name, oauthProvider);
}
```

## OAuth Authentication Flow

The OAuth implementation follows the OAuth 2.0 specification with PKCE (Proof Key for Code Exchange) for enhanced security.

### PKCE Flow Sequence

```mermaid
sequenceDiagram
    participant User
    participant CLI
    participant Browser
    participant AuthServer as Anthropic Auth
    participant API as Anthropic API
    
    User->>CLI: bun cli add <account>
    CLI->>CLI: Generate PKCE verifier & challenge
    CLI->>Browser: Open auth URL with challenge
    Browser->>AuthServer: Authorization request
    AuthServer->>User: Login prompt
    User->>AuthServer: Credentials
    AuthServer->>Browser: Redirect with code
    Browser->>CLI: Code callback
    CLI->>AuthServer: Exchange code + verifier
    AuthServer->>CLI: Refresh & access tokens
    CLI->>CLI: Store tokens securely
    
    Note over CLI,API: Token Refresh Flow
    CLI->>API: API request with access token
    API-->>CLI: 401 Unauthorized
    CLI->>AuthServer: Refresh token request
    AuthServer->>CLI: New access token
    CLI->>API: Retry with new token
    API->>CLI: Success response
```

### PKCE Implementation

The PKCE implementation generates cryptographically secure challenges:

```typescript
export async function generatePKCE(): Promise<PKCEChallenge> {
  // Generate 32-byte random verifier
  const verifierBytes = new Uint8Array(32);
  crypto.getRandomValues(verifierBytes);
  const verifier = base64urlEncode(verifierBytes);
  
  // Create SHA-256 challenge
  const data = new TextEncoder().encode(verifier);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const challenge = base64urlEncode(new Uint8Array(hashBuffer));
  
  return { verifier, challenge };
}
```

### OAuth Configuration

The Anthropic provider supports two OAuth modes with different authorization endpoints:

```typescript
getOAuthConfig(mode: "console" | "max" = "console"): OAuthConfig {
  const baseUrl = mode === "console" 
    ? "https://console.anthropic.com"  // Standard Claude API
    : "https://claude.ai";              // Claude Code
    
  return {
    authorizeUrl: `${baseUrl}/oauth/authorize`,
    tokenUrl: "https://console.anthropic.com/v1/oauth/token", // Always uses console endpoint
    clientId: "", // Provided by configuration
    scopes: ["org:create_api_key", "user:profile", "user:inference"],
    redirectUri: "https://console.anthropic.com/oauth/code/callback",
    mode,
  };
}
```

**Mode Differences:**
- **console mode**: Uses the standard Claude API via console.anthropic.com
- **max mode**: Uses Claude Code via claude.ai for enhanced capabilities
- Both modes use the same API endpoint (api.anthropic.com) for actual requests

**Client ID Configuration:**
The OAuth client ID can be configured in multiple ways (in order of precedence):
1. Config file: `client_id` field
2. Environment variable: `CLIENT_ID`
3. Default value: `9d1c250a-e61b-44d9-88ed-5944d1962f5e`

## AnthropicProvider Implementation

The AnthropicProvider extends the BaseProvider class and implements Anthropic-specific functionality.

### Request Routing

The provider handles all request paths and routes them to the standard Anthropic API endpoint:

```typescript
canHandle(_path: string): boolean {
  // Handle all paths for now since this is Anthropic-specific
  return true;
}

buildUrl(path: string, query: string): string {
  return `https://api.anthropic.com${path}${query}`;
}
```

**Important**: Both console and max modes use the same API endpoint. The mode only affects:
- OAuth authorization flow (which frontend to use)
- Account tier capabilities
- Rate limits based on subscription type

### Key Features

1. **Token Refresh**: Handles OAuth token refresh automatically with detailed error logging
2. **Rate Limit Detection**: Distinguishes between hard limits and soft warnings
3. **Usage Extraction**: Parses token usage from both streaming and non-streaming responses
   - For streaming: Captures initial usage from `message_start` event (capped at 64KB)
   - For non-streaming: Extracts complete usage from JSON response
   - Includes cache token breakdown (cache read, cache creation)
4. **Tier Detection**: Automatically detects account tier based on rate limit tokens
5. **Header Management**: 
   - Removes compression headers (`accept-encoding`, `content-encoding`)
   - Sanitizes proxy headers using `sanitizeProxyHeaders` utility
   - Adds Bearer token authentication
6. **Streaming Response Capture**: Captures initial streaming responses for analytics
7. **Cost Tracking**: Extracts cost information from `anthropic-billing-cost` header

### Rate Limit Status Types

```typescript
// Hard limits that block account usage
const HARD_LIMIT_STATUSES = new Set([
  "rate_limited",
  "blocked", 
  "queueing_hard",
  "payment_required"
]);

// Soft warnings that don't block usage
const SOFT_WARNING_STATUSES = new Set([
  "allowed_warning",
  "queueing_soft"
]);
```

### Usage Information Extraction

The provider extracts detailed usage information from responses:

```typescript
interface UsageInfo {
  model?: string;
  promptTokens?: number;
  completionTokens?: number;
  totalTokens?: number;
  costUsd?: number;
  inputTokens?: number;
  cacheReadInputTokens?: number;
  cacheCreationInputTokens?: number;
  outputTokens?: number;
}
```

## Provider Interface

All providers must implement the core Provider interface:

```typescript
export interface Provider {
  name: string;
  
  // Request routing
  canHandle(path: string): boolean;
  buildUrl(path: string, query: string): string;
  
  // Authentication
  refreshToken(account: Account, clientId: string): Promise<TokenRefreshResult>;
  prepareHeaders(headers: Headers, accessToken?: string): Headers;
  
  // Rate limiting
  parseRateLimit(response: Response): RateLimitInfo;
  
  // Response processing
  processResponse(response: Response, account: Account | null): Promise<Response>;
  
  // Optional features
  extractTierInfo?(response: Response): Promise<number | null>;
  extractUsageInfo?(response: Response): Promise<UsageInfo | null>;
  isStreamingResponse?(response: Response): boolean;
}
```

### BaseProvider Class

The BaseProvider abstract class provides default implementations for common functionality:

- **Header preparation**: Adds Bearer token (if provided) and removes host header
- **Rate limit parsing**: Checks unified headers first, then falls back to 429 status with retry-after header
- **Response processing**: Default pass-through implementation
- **Streaming detection**: Checks for `text/event-stream` or `stream` in content-type header
- **Tier extraction**: Default returns null (no tier info)
- **Usage extraction**: Default returns null (no usage info)

## Account Tier System

ccflare supports three account tiers based on Anthropic's subscription levels:

| Tier | Value | Rate Limit | Description |
|------|-------|------------|-------------|
| Free | 1 | 40,000 tokens/min | Free tier accounts |
| Pro | 5 | 200,000 tokens/min | Individual pro subscriptions |
| Team | 20 | 800,000+ tokens/min | Team/enterprise accounts |

### Automatic Tier Detection

The system automatically detects account tiers from API responses:

```typescript
async extractTierInfo(response: Response): Promise<number | null> {
  const json = await response.clone().json();
  if (json.usage?.rate_limit_tokens) {
    const rateLimit = json.usage.rate_limit_tokens;
    if (rateLimit >= 800000) return 20;  // Team tier
    if (rateLimit >= 200000) return 5;   // Pro tier
    return 1;  // Free tier
  }
  return null;
}
```

### Tier-Based Load Balancing

Higher tier accounts receive proportionally more requests:
- Free accounts: 1x weight
- Pro accounts: 5x weight  
- Team accounts: 20x weight

## Rate Limit Handling

The provider system implements sophisticated rate limit detection and handling.

### Unified Rate Limit Headers

Anthropic uses unified headers for rate limit information:

```typescript
interface RateLimitInfo {
  isRateLimited: boolean;
  resetTime?: number;
  statusHeader?: string;
  remaining?: number;
}
```

### Rate Limit Detection

```typescript
parseRateLimit(response: Response): RateLimitInfo {
  const statusHeader = response.headers.get("anthropic-ratelimit-unified-status");
  const resetHeader = response.headers.get("anthropic-ratelimit-unified-reset");
  const remainingHeader = response.headers.get("anthropic-ratelimit-unified-remaining");
  
  // Only hard limits block the account
  const isRateLimited = HARD_LIMIT_STATUSES.has(statusHeader) || 
                       response.status === 429;
  
  return {
    isRateLimited,
    resetTime: resetHeader ? Number(resetHeader) * 1000 : undefined,
    statusHeader: statusHeader || undefined,
    remaining: remainingHeader ? Number(remainingHeader) : undefined
  };
}
```

### Account Blocking

When rate limited, accounts are temporarily blocked:
- `rate_limited_until`: Timestamp when the account becomes available
- `rate_limit_status`: Current limit status (e.g., "rate_limited", "allowed_warning")
- `rate_limit_reset`: Time when the rate limit resets
- `rate_limit_remaining`: Remaining requests in current window

## Token Storage and Security

### Security Considerations

1. **Token Encryption**: Access and refresh tokens should be encrypted at rest
2. **Secure Storage**: Use environment-specific secure storage (e.g., OS keychain)
3. **Token Rotation**: Regularly refresh access tokens before expiration
4. **Minimal Exposure**: Never log or expose tokens in error messages

### Authentication Methods

The system supports two authentication methods:

1. **OAuth Authentication** (Recommended)
   - Used for both console and max modes
   - Provides automatic token refresh
   - Better security with short-lived access tokens
   - Supports PKCE for enhanced security

2. **API Key Authentication** (Legacy)
   - Direct API key usage stored in `account.api_key`
   - No automatic refresh capability
   - Simpler but less secure
   - Maintained for backward compatibility

### Token Lifecycle

```typescript
interface Account {
  // OAuth tokens
  refresh_token: string;      // Long-lived refresh token
  access_token: string | null; // Short-lived access token
  expires_at: number | null;   // Token expiration timestamp
  
  // API key (alternative auth)
  api_key: string | null;      // Direct API key authentication
}
```

**Note**: The current implementation prioritizes OAuth authentication. API key support is maintained for backward compatibility but OAuth is the preferred method.

### Token Refresh Strategy

1. **Proactive Refresh**: Refresh tokens 5 minutes before expiration
2. **Reactive Refresh**: Refresh on 401 responses
3. **Retry Logic**: Implement exponential backoff for refresh failures
4. **Concurrent Request Handling**: Prevent multiple simultaneous refreshes

## Adding New Providers

To add a new provider, follow these steps:

### 1. Create Provider Structure

```
packages/providers/src/providers/newprovider/
├── index.ts       # Exports
├── provider.ts    # Main provider implementation
└── oauth.ts       # OAuth implementation (if supported)
```

### 2. Implement the Provider Interface

```typescript
import { BaseProvider } from "../../base";
import type { Account, TokenRefreshResult } from "../../types";

export class NewProvider extends BaseProvider {
  name = "newprovider";
  
  async refreshToken(account: Account, clientId: string): Promise<TokenRefreshResult> {
    // Implement token refresh logic
  }
  
  buildUrl(path: string, query: string): string {
    return `https://api.newprovider.com${path}${query}`;
  }
  
  // Override other methods as needed
}
```

### 3. Implement OAuth Support (Optional)

```typescript
export class NewProviderOAuth implements OAuthProvider {
  getOAuthConfig(mode?: string): OAuthConfig {
    return {
      authorizeUrl: "https://newprovider.com/oauth/authorize",
      tokenUrl: "https://newprovider.com/oauth/token",
      clientId: "",
      scopes: ["read", "write"],
      redirectUri: "http://localhost:8080/callback"
    };
  }
  
  async exchangeCode(code: string, verifier: string, config: OAuthConfig): Promise<TokenResult> {
    // Implement code exchange
  }
  
  generateAuthUrl(config: OAuthConfig, pkce: PKCEChallenge): string {
    // Build authorization URL
  }
}
```

### 4. Register the Provider

```typescript
// In packages/providers/src/index.ts
import { NewProvider } from "./providers/newprovider/provider";
registry.registerProvider(new NewProvider());
```

### 5. Update Types and Configuration

1. Add provider-specific configuration options
2. Update documentation
3. Add provider-specific tests
4. Update CLI commands to support the new provider

### Provider Checklist

- [ ] Implement all required Provider interface methods
- [ ] Handle provider-specific headers and authentication
- [ ] Implement rate limit detection for the provider's format
- [ ] Add usage tracking if supported by the provider
- [ ] Implement OAuth flow if the provider supports it
- [ ] Add comprehensive error handling
- [ ] Write unit and integration tests
- [ ] Document provider-specific features and limitations
- [ ] Update load balancer logic if needed

## Best Practices

1. **Error Handling**: Always provide meaningful error messages
2. **Logging**: Use structured logging for debugging
3. **Testing**: Test both success and failure scenarios
4. **Documentation**: Keep provider documentation up to date
5. **Security**: Never expose sensitive tokens or credentials
6. **Performance**: Cache provider configurations when possible
7. **Compatibility**: Maintain backward compatibility when updating

## Recent Updates

- **Streaming Response Capture**: Added initial capture of streaming responses for analytics (commit 55446bf)
  - Captures up to 64KB of streaming data to extract usage information
  - Extracts model and token usage from `message_start` event
  - Prevents hanging by properly canceling stream readers
- **Enhanced Analytics**: Improved usage tracking and cost estimation for both streaming and non-streaming responses
  - Includes cache token breakdown (cache read vs cache creation)
  - Extracts billing cost from response headers
- **Header Sanitization**: Added `sanitizeProxyHeaders` utility for proper proxy header handling (commit f0f179e)

## Future Enhancements

1. **Multi-Provider Support**: Add support for OpenAI, Google Gemini, and other AI providers
2. **Provider Health Checks**: Monitor provider availability and performance
3. **Dynamic Provider Loading**: Load providers from external packages
4. **Provider Metrics**: Track success rates, latency, and costs per provider
5. **Fallback Strategies**: Automatic fallback to alternative providers on failure
6. **Provider-Specific Features**: Expose unique capabilities of each provider (e.g., vision, tools, etc.)
7. **Path-Based Routing**: Route specific API paths to different providers based on capabilities
</file>

<file path="docs/security.md">
# Security Documentation

**Last Security Review**: July 30, 2025

This document outlines the security considerations, practices, and recommendations for the ccflare load balancer system.

## ⚠️ Critical Security Notice

**IMPORTANT**: ccflare is designed for local development and trusted environments. The current implementation has several security limitations:

1. **No Authentication**: All API endpoints and the dashboard are publicly accessible
2. **Network Exposure**: Server binds to all interfaces (0.0.0.0) by default
3. **Plaintext Token Storage**: OAuth tokens are stored unencrypted in SQLite
4. **No HTTPS**: Communication is over HTTP without TLS encryption
5. **Full Request Logging**: All request/response payloads are stored (up to 10MB for streaming)

**Recommended Usage**: 
- Run only in isolated, trusted networks
- Use firewall rules to restrict access to localhost
- Implement reverse proxy with authentication for production use
- Regularly rotate OAuth tokens
- Monitor access logs for unauthorized usage

## ⚠️ Immediate Security Actions Required

Based on the latest security review, the following critical issues require immediate attention:

1. **No Authentication**: All endpoints are publicly accessible. Implement API key authentication immediately.
2. **Network Exposure**: Server binds to 0.0.0.0. Use firewall rules or bind to localhost only.
3. **Plaintext Tokens**: OAuth tokens stored unencrypted. Implement AES-256-GCM encryption.
4. **No CORS Protection**: Server does not set any CORS headers, allowing requests from any origin.

## Table of Contents

1. [Security Overview](#security-overview)
2. [Threat Model](#threat-model)
3. [OAuth Token Security](#oauth-token-security)
4. [Rate Limit Handling](#rate-limit-handling)
5. [Network Security](#network-security)
6. [Data Privacy](#data-privacy)
7. [Access Control](#access-control)
8. [Security Best Practices](#security-best-practices)
9. [Vulnerability Disclosure](#vulnerability-disclosure)
10. [Common Security Pitfalls](#common-security-pitfalls)

## Security Overview

ccflare is a load balancer proxy that manages multiple OAuth accounts to distribute requests to the Claude API. The system handles sensitive authentication tokens and request/response data, requiring careful security considerations.

### Key Security Components

- **OAuth Token Management**: Handles refresh tokens, access tokens, and token rotation using the official Anthropic OAuth flow
- **Request Proxying**: Forwards API requests with authentication headers, with fallback to unauthenticated mode
- **Data Storage**: SQLite database storing account credentials and request history
- **Network Binding**: Server binds to all interfaces (0.0.0.0) on port 8080 by default
- **Request/Response Logging**: Full payload storage for debugging and analytics with streaming response capture
- **Asynchronous DB Operations**: Non-blocking database writes for improved performance

## Threat Model

### Assets to Protect

1. **OAuth Tokens**: Refresh tokens and access tokens for Claude API access
2. **Request Data**: User prompts and API request payloads
3. **Response Data**: Claude's responses containing potentially sensitive information
4. **Account Metadata**: Usage statistics, rate limit information, and tier data

### Threat Actors

1. **External Attackers**: Attempting to access the proxy from outside the local network
2. **Local Malicious Software**: Processes on the same machine trying to access stored tokens
3. **Supply Chain Attacks**: Compromised dependencies or packages
4. **Insider Threats**: Users with legitimate access misusing the system

### Attack Vectors

1. **Network Exposure**: Proxy accidentally exposed to public internet
2. **Database Access**: Direct access to SQLite database file
3. **Token Theft**: Extraction of OAuth tokens from storage or memory
4. **Request Interception**: MITM attacks on API requests
5. **Log File Access**: Unauthorized access to request/response logs

## OAuth Token Security

### Current Implementation

#### Token Storage
```typescript
// packages/database/src/migrations.ts
CREATE TABLE IF NOT EXISTS accounts (
    id TEXT PRIMARY KEY,
    refresh_token TEXT NOT NULL,  // Stored in plaintext
    access_token TEXT,             // Stored in plaintext
    expires_at INTEGER
)
```

**Security Concern**: Tokens are currently stored in plaintext in the SQLite database.

#### OAuth Flow Implementation
```typescript
// packages/providers/src/providers/anthropic/oauth.ts
// Uses PKCE (Proof Key for Code Exchange) for enhanced security
generateAuthUrl(config: OAuthConfig, pkce: PKCEChallenge): string {
    url.searchParams.set("code_challenge", pkce.challenge);
    url.searchParams.set("code_challenge_method", "S256");
    // ...
}

// Session-based OAuth flow with secure verifier storage
// packages/database/src/migrations.ts
CREATE TABLE IF NOT EXISTS oauth_sessions (
    id TEXT PRIMARY KEY,
    account_name TEXT NOT NULL,
    verifier TEXT NOT NULL,  // PKCE verifier stored securely
    mode TEXT NOT NULL,
    tier INTEGER DEFAULT 1,
    created_at INTEGER NOT NULL,
    expires_at INTEGER NOT NULL  // Auto-cleanup of expired sessions
)

// Scopes requested from Anthropic
scopes: ["org:create_api_key", "user:profile", "user:inference"]
```

**Security Strengths**: 
- Implements PKCE flow for protection against authorization code interception
- Uses SHA256 for code challenge generation
- Requests minimal necessary scopes

#### Token Refresh Pattern
```typescript
// packages/proxy/src/proxy.ts
async function refreshAccessTokenSafe(account: Account, ctx: ProxyContext): Promise<string> {
    // Prevents token refresh stampede with in-flight tracking
    if (!ctx.refreshInFlight.has(account.id)) {
        const refreshPromise = ctx.provider.refreshToken(account, ctx.runtime.clientId)
            .then((result: TokenRefreshResult) => {
                ctx.dbOps.updateAccountTokens(account.id, result.accessToken, result.expiresAt);
                return result.accessToken;
            })
            .finally(() => {
                ctx.refreshInFlight.delete(account.id);
            });
        ctx.refreshInFlight.set(account.id, refreshPromise);
    }
    return ctx.refreshInFlight.get(account.id)!;
}
```

**Security Strengths**: 
- Implements stampede prevention to avoid multiple concurrent refresh attempts
- Automatic token rotation before expiry
- In-memory tracking of ongoing refresh operations

### Future Improvements

#### 1. Token Encryption at Rest
```typescript
// Proposed implementation
interface EncryptedToken {
    iv: string;
    encryptedData: string;
    authTag: string;
}

async function encryptToken(token: string, key: Buffer): Promise<EncryptedToken> {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
    const encrypted = Buffer.concat([cipher.update(token, 'utf8'), cipher.final()]);
    const authTag = cipher.getAuthTag();
    
    return {
        iv: iv.toString('base64'),
        encryptedData: encrypted.toString('base64'),
        authTag: authTag.toString('base64')
    };
}
```

#### 2. Key Management
- Use environment variable for encryption key: `ccflare_ENCRYPTION_KEY`
- Implement key derivation from master password
- Consider integration with OS keychain/credential store

#### 3. Token Rotation
- Implement automatic token rotation before expiry
- Add configurable rotation intervals
- Log rotation events for audit trail

## Rate Limit Handling

### Current Implementation

The system implements sophisticated rate limit detection and handling:

```typescript
// packages/providers/src/providers/anthropic/provider.ts
parseRateLimit(response: Response): RateLimitInfo {
    const statusHeader = response.headers.get("anthropic-ratelimit-unified-status");
    const resetHeader = response.headers.get("anthropic-ratelimit-unified-reset");
    
    // Distinguishes between hard limits (blocking) and soft warnings
    const isRateLimited = HARD_LIMIT_STATUSES.has(statusHeader || "") || response.status === 429;
    
    return {
        isRateLimited,
        resetTime: resetHeader ? Number(resetHeader) * 1000 : undefined,
        statusHeader: statusHeader || undefined,
        remaining: remainingHeader ? Number(remainingHeader) : undefined
    };
}
```

### Protection Mechanisms

1. **Account Quarantine**: Rate-limited accounts are automatically excluded from rotation
2. **Reset Time Tracking**: Precise tracking of when accounts become available again
3. **Soft vs Hard Limits**: Differentiates between warnings and actual blocks
4. **Failover Strategy**: Automatically tries next available account on rate limit

## Network Security

### Current Configuration

#### Default Binding
```typescript
// apps/server/src/server.ts
const server = serve({
    port: runtime.port,  // Port 8080 by default
    async fetch(req) {
        // Handle requests
    }
});
```

**Security Concern**: The server binds to port 8080 on all interfaces (0.0.0.0) by default, potentially exposing it to the network.

### Recommended Configuration

#### 1. Network Isolation
**Important**: The server currently binds to all network interfaces. To secure the deployment:

```bash
# Use firewall rules to restrict access
sudo ufw allow from 127.0.0.1 to any port 8080
sudo ufw deny 8080

# Or use iptables
iptables -A INPUT -p tcp --dport 8080 -s 127.0.0.1 -j ACCEPT
iptables -A INPUT -p tcp --dport 8080 -j DROP
```

**Recommended Enhancement**: Modify the server to support a HOST environment variable:
```typescript
// Proposed server.ts modification
const server = serve({
    port: runtime.port,
    hostname: process.env.HOST || "0.0.0.0", // Allow binding configuration
    async fetch(req) {
        // Handle requests
    }
});
```

#### 2. Reverse Proxy Setup
```nginx
# Nginx configuration example
server {
    listen 443 ssl http2;
    server_name ccflare.internal;
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Security headers
        add_header X-Content-Type-Options nosniff;
        add_header X-Frame-Options DENY;
        add_header X-XSS-Protection "1; mode=block";
    }
}
```

#### 3. TLS/HTTPS Setup
- Use TLS termination at reverse proxy level
- Ensure strong cipher suites (TLS 1.2+)
- Implement HSTS headers
- Consider mutual TLS for additional security

## Data Privacy

### Request/Response Logging

#### Current Implementation
```typescript
// packages/proxy/src/proxy.ts
// Standard responses
const payload = {
    request: {
        headers: Object.fromEntries(req.headers.entries()),
        body: requestBody ? "[streamed]" : null  // Request bodies marked as streamed
    },
    response: {
        status: response.status,
        headers: Object.fromEntries(response.headers.entries()),
        body: responseBody ? Buffer.from(responseBody).toString("base64") : null
    }
};

// Streaming responses (current implementation)
// packages/proxy/src/response-handler.ts
if (isStream && response.body) {
    // Clone response for background analytics consumption
    const analyticsClone = response.clone();
    
    (async () => {
        try {
            const reader = analyticsClone.body?.getReader();
            if (!reader) return;
            
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                    // Send chunks to worker for processing
                    const chunkMsg: ChunkMessage = {
                        type: "chunk",
                        requestId,
                        data: value,
                    };
                    ctx.usageWorker.postMessage(chunkMsg);
                }
            }
        } catch (err) {
            // Handle errors...
        }
    })();
    
    // Return original response untouched
    return response;
}
```

**Privacy Concerns**: 
- Full request/response bodies are stored, potentially containing sensitive information
- Streaming responses are cloned and processed chunk by chunk in background workers
- Chunks are accumulated in memory without explicit size limits in the worker process
- Request bodies are encoded as base64 in logs
- Error payloads include full error details and request metadata
- Asynchronous writes may delay data persistence

### Storage Security Considerations

1. **Base64 Encoding**: Request/response bodies are Base64 encoded but not encrypted
2. **Database File Access**: SQLite database file can be read by any process with file system access
3. **No Data Sanitization**: Sensitive patterns (API keys, passwords, PII) are not redacted
4. **Unlimited Retention**: No automatic cleanup of old request payloads

### PII Considerations

1. **User Prompts**: May contain personal information, proprietary code, or confidential data
2. **API Keys**: While not stored in payloads, they appear in logs
3. **Response Content**: Claude's responses may echo back sensitive information

### Log Retention

#### Current State
- No automatic log rotation or cleanup
- Request payloads stored indefinitely in SQLite database
- File logs written to disk without rotation

#### Recommended Practices

1. **Implement Log Rotation**
```typescript
// Proposed log rotation configuration
interface LogRotationConfig {
    maxAge: number;        // Days to retain logs
    maxSize: number;       // Max size per log file in MB
    compress: boolean;     // Compress old logs
    deleteOnRotate: boolean; // Delete after rotation
}
```

2. **Data Minimization**
- Add option to disable request/response body logging
- Implement selective logging based on endpoint
- Add data redaction for sensitive patterns

3. **Cleanup Commands**
```bash
# Add to CLI
bun cli cleanup --older-than 30d
bun cli cleanup --type requests --force
```

## Access Control

### Current State
- **No authentication required**: All endpoints are publicly accessible when network-reachable
- **Dashboard**: Accessible without authentication at `/dashboard`
- **API endpoints**: All `/api/*` endpoints are unprotected
- **No CORS headers**: The server does not set any CORS headers, effectively allowing requests from any origin
- **No rate limiting**: Individual clients can make unlimited requests to API endpoints
- **Proxy endpoint**: The `/v1/*` proxy endpoint has no authentication (relies on OAuth tokens for upstream authentication)

### Security Implications
1. **Data Exposure**: Anyone with network access can view account information, request logs, and analytics
2. **Configuration Changes**: Unprotected configuration endpoints allow unauthorized strategy changes
3. **Account Management**: Account addition/removal endpoints are exposed
4. **Resource Exhaustion**: No rate limiting can lead to DoS vulnerabilities

### Recommended Authentication Implementation

#### 1. API Key Authentication
```typescript
// Proposed middleware
async function authenticateRequest(req: Request): Promise<boolean> {
    const apiKey = req.headers.get('X-API-Key');
    if (!apiKey) return false;
    
    const hashedKey = await crypto.subtle.digest(
        'SHA-256', 
        new TextEncoder().encode(apiKey)
    );
    
    return timingSafeEqual(hashedKey, storedHashedKey);
}
```

#### 2. Dashboard Authentication
- Implement session-based authentication
- Add rate limiting on login attempts
- Consider OAuth integration for SSO

#### 3. Role-Based Access Control
```typescript
enum Permission {
    VIEW_DASHBOARD = 'dashboard.view',
    MANAGE_ACCOUNTS = 'accounts.manage',
    VIEW_LOGS = 'logs.view',
    MAKE_REQUESTS = 'api.request'
}

interface User {
    id: string;
    username: string;
    permissions: Permission[];
}
```

## Security Best Practices

### Deployment Checklist

- [ ] **Network Configuration**
  - [ ] Bind server to localhost only
  - [ ] Configure firewall rules
  - [ ] Set up reverse proxy with TLS
  - [ ] Disable unnecessary network services

- [ ] **Token Security**
  - [ ] Store encryption key securely (environment variable or secret manager)
  - [ ] Implement token encryption at rest
  - [ ] Regular token rotation schedule
  - [ ] Monitor for token leaks in logs

- [ ] **Access Control**
  - [ ] Implement authentication for all endpoints
  - [ ] Use strong, unique API keys
  - [ ] Enable audit logging
  - [ ] Regular access reviews

- [ ] **Data Protection**
  - [ ] Configure log rotation
  - [ ] Implement data retention policies
  - [ ] Regular database backups
  - [ ] Encrypt sensitive backups

- [ ] **Monitoring**
  - [ ] Set up alerts for suspicious activity
  - [ ] Monitor rate limit patterns
  - [ ] Track authentication failures
  - [ ] Regular security audits

### Development Practices

1. **Dependency Management**
   - Regular dependency updates: `bun update`
   - Security audit: `bun audit`
   - Lock file verification
   - Supply chain security checks

2. **Code Security**
   - Input validation on all endpoints
   - Output encoding for web responses
   - Parameterized database queries (already implemented)
   - Secure random number generation for IDs

3. **Error Handling**
   - Avoid exposing stack traces in production
   - Generic error messages to users
   - Detailed error logging internally
   - Rate limit error responses

## Vulnerability Disclosure

### Reporting Process

1. **Discovery**: If you discover a security vulnerability, please report it responsibly
2. **Contact**: Email security concerns to the project maintainers
3. **Information to Include**:
   - Description of the vulnerability
   - Steps to reproduce
   - Potential impact
   - Suggested fixes (if any)

### Response Timeline

- **Acknowledgment**: Within 48 hours
- **Initial Assessment**: Within 7 days
- **Fix Development**: Based on severity
- **Disclosure**: Coordinated with reporter

### Severity Levels

1. **Critical**: Token exposure, RCE, authentication bypass
2. **High**: Data exposure, privilege escalation
3. **Medium**: Information disclosure, DoS
4. **Low**: Minor information leaks

## Common Security Pitfalls

### 1. Exposed Development Instance
**Risk**: Running ccflare with default settings exposes it to the network
**Mitigation**: Always bind to localhost in development

### 2. Token in Logs
**Risk**: OAuth tokens appearing in debug logs
**Mitigation**: Implement log sanitization, never log full tokens

### 3. Shared Database Access
**Risk**: Multiple users accessing the same SQLite database
**Mitigation**: Implement proper file permissions, consider client/server database

### 4. Unencrypted Backups
**Risk**: Database backups containing plaintext tokens
**Mitigation**: Encrypt backups, secure backup storage

### 5. Insufficient Rate Limiting
**Risk**: Single client overwhelming the proxy
**Mitigation**: Implement per-client rate limiting

### 6. CORS Misconfiguration
**Risk**: Dashboard API accessible from unauthorized origins (currently no CORS headers are set)
**Mitigation**: Implement CORS headers:
```typescript
// Recommended implementation in server.ts or API router
function addSecurityHeaders(response: Response): Response {
    const headers = new Headers(response.headers);
    headers.set('Access-Control-Allow-Origin', process.env.ALLOWED_ORIGINS || 'http://localhost:8080');
    headers.set('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS');
    headers.set('Access-Control-Allow-Headers', 'Content-Type, X-API-Key');
    headers.set('Access-Control-Max-Age', '86400');
    headers.set('X-Content-Type-Options', 'nosniff');
    headers.set('X-Frame-Options', 'DENY');
    headers.set('X-XSS-Protection', '1; mode=block');
    headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
    
    return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
    });
}
```

### 7. Dependency Vulnerabilities
**Risk**: Known vulnerabilities in dependencies
**Mitigation**: Regular updates, security scanning

### 8. Weak Randomness
**Risk**: Predictable IDs or tokens
**Mitigation**: Use crypto.randomUUID() and crypto.getRandomValues()

### 9. Streaming Response Capture
**Risk**: Large streaming responses consuming excessive memory/storage
**Mitigation**: Implement size limits in worker chunk accumulation; monitor memory usage for large streams

### 10. Asynchronous Database Writes
**Risk**: Data loss if application crashes before async writes complete
**Mitigation**: Graceful shutdown handlers ensure queue is flushed

## Recent Security Updates

### Response Header Sanitization (July 2025)
- **Change**: Added `sanitizeProxyHeaders` utility function
- **Security Benefit**: Removes hop-by-hop headers (content-encoding, content-length, transfer-encoding) to prevent header injection attacks
- **Implementation**: Applied in Anthropic provider's `prepareProxyResponse` method

### Streaming Response Processing (Current)
- **Change**: Streaming responses are cloned and processed in background workers
- **Security Consideration**: Chunks are accumulated in memory without explicit size limits, though processed incrementally
- **Implementation**: Uses Response.clone() to avoid blocking the original stream
- **Recommendation**: Implement memory monitoring and chunk size limits in worker

### Session-Based OAuth Flow
- **Change**: Migrated from direct account creation to session-based OAuth endpoints
- **Security Benefit**: Improved PKCE flow with session management
- **Implementation**: Stores verifier securely in oauth_sessions table with expiration

### Agent-Based Model Selection
- **Feature**: Added ability to override model selection based on agent preferences
- **Security Consideration**: Model modifications are tracked in request metadata
- **Implementation**: Intercepts and modifies request body before proxying

### Asynchronous Database Writer
- **Change**: Introduced AsyncDbWriter for non-blocking database operations
- **Security Consideration**: Ensures request payloads are persisted even under high load
- **Implementation**: Queue-based system with graceful shutdown handling

### Unauthenticated Fallback Mode
- **Feature**: System can operate without any configured accounts
- **Security Implication**: Requests are forwarded to Claude API without authentication
- **Use Case**: Testing or environments where users provide their own API keys

## Security Roadmap

### Phase 1: Authentication & Access Control (Priority: CRITICAL)
- Implement API key authentication middleware
- Add rate limiting per client/IP
- Implement CORS headers with proper origin restrictions
- Add audit logging for all API access

### Phase 2: Token Encryption (Priority: High)
- Implement AES-256-GCM encryption for stored tokens
- Add key management system (environment variable or OS keychain)
- Migration tool for existing plaintext tokens
- Secure key rotation mechanism

### Phase 3: Network Hardening (Priority: High)
- Add HOST binding configuration (localhost by default)
- TLS support in proxy server
- Certificate pinning for API calls
- IP allowlisting capability

### Phase 4: Memory & Resource Protection (Priority: Medium)
- Implement streaming response size limits
- Add memory monitoring for worker processes
- Request body size validation
- Database size management and rotation

### Phase 5: Advanced Security (Priority: Low)
- Hardware security module (HSM) integration
- Multi-factor authentication
- Anomaly detection system
- Security scanning integration

## Environment Variables

### Security-Related Environment Variables

```bash
# Logging and Debugging
LOG_LEVEL=INFO                  # Set to ERROR in production
LOG_FORMAT=json                 # Use json for structured logging
ccflare_DEBUG=0            # Set to 1 only for debugging

# Configuration
ccflare_CONFIG_PATH=/path/to/config.json  # Custom config location
CLIENT_ID=your-client-id       # OAuth client ID

# Server Configuration
PORT=8080                      # Server port
LB_STRATEGY=session           # Load balancing strategy

# Retry Configuration
RETRY_ATTEMPTS=3              # Number of retry attempts
RETRY_DELAY_MS=1000          # Initial retry delay
RETRY_BACKOFF=2              # Backoff multiplier
SESSION_DURATION_MS=18000000 # Session duration (5 hours)
```

### Security Considerations for Environment Variables

1. **Never commit `.env` files** containing sensitive values
2. **Use secret management** tools in production (e.g., HashiCorp Vault, AWS Secrets Manager)
3. **Restrict file permissions** on environment files: `chmod 600 .env`
4. **Audit environment access** in containerized deployments

## Security Monitoring and Detection

### Logging and Auditing

#### Current Logging Capabilities
- All API requests are logged with timestamps and response codes
- Request/response payloads are stored for analysis
- Account usage and rate limit events are tracked
- Error conditions are logged with details

#### Recommended Monitoring
1. **Access Patterns**
   - Monitor for unusual request volumes
   - Track access from unexpected IP addresses
   - Detect repeated failed requests
   - Watch for configuration changes

2. **Token Usage**
   - Monitor token refresh frequency
   - Detect unusual account switching patterns
   - Track rate limit exhaustion events
   - Alert on authentication failures

3. **System Health**
   - Database size growth
   - Memory usage patterns
   - Response time anomalies
   - Error rate spikes

### Security Event Detection

```bash
# Example monitoring queries

# Find requests from non-localhost IPs (requires reverse proxy logs)
grep -v "127.0.0.1\|::1" access.log

# Monitor for high request volumes
sqlite3 ccflare.db "SELECT COUNT(*) as count, account_used 
FROM requests 
WHERE timestamp > strftime('%s', 'now', '-1 hour') * 1000 
GROUP BY account_used 
ORDER BY count DESC"

# Check for configuration changes
sqlite3 ccflare.db "SELECT * FROM audit_log WHERE action LIKE '%config%'"
```

### Incident Response

1. **Suspected Token Compromise**
   - Immediately pause affected accounts via API
   - Rotate OAuth tokens through Anthropic console
   - Review request logs for unauthorized usage
   - Update tokens in ccflare

2. **Unauthorized Access**
   - Implement firewall rules immediately
   - Review all recent API requests
   - Check for data exfiltration
   - Consider rotating all tokens

3. **Rate Limit Abuse**
   - Identify source of excessive requests
   - Implement IP-based blocking
   - Review load balancing strategy
   - Consider implementing request queuing

## Security Testing & Auditing

### Running Security Checks

1. **Dependency Audit**
```bash
# Check for known vulnerabilities in dependencies
bun audit

# Update dependencies to latest secure versions
bun update
```

2. **Code Security Analysis**
```bash
# Run linting with security rules
bun run lint

# Type checking can catch security issues
bun run typecheck
```

3. **Manual Security Checklist**
- [ ] Verify no hardcoded credentials in code
- [ ] Check for exposed sensitive endpoints
- [ ] Review error messages for information leakage
- [ ] Test rate limiting effectiveness
- [ ] Verify token rotation works correctly
- [ ] Check database file permissions
- [ ] Review log files for sensitive data

### Security Testing Commands

```bash
# Test unauthorized access (should fail in secured setup)
curl http://localhost:8080/api/accounts

# Test CORS headers (should be restricted)
curl -H "Origin: http://evil.com" \
     -H "Access-Control-Request-Method: GET" \
     -H "Access-Control-Request-Headers: X-Requested-With" \
     -X OPTIONS \
     http://localhost:8080/api/accounts

# Check for exposed internal headers
curl -I http://localhost:8080/api/health
```

## Conclusion

Security is an ongoing process. This documentation should be reviewed and updated regularly as the system evolves and new threats emerge. All contributors should familiarize themselves with these security considerations and follow the best practices outlined above.

### Key Takeaways
1. **ccflare prioritizes functionality over security** - suitable for development, not production
2. **Network isolation is critical** - always restrict access to trusted networks
3. **Token security requires enhancement** - implement encryption for production use
4. **Authentication is missing** - all endpoints are currently public
5. **Monitoring is essential** - regular review of logs can detect security issues early
6. **Regular updates needed** - keep dependencies and documentation current

### Immediate Actions for Production Use
1. Implement authentication middleware before exposing to any network
2. Bind server to localhost only
3. Set up reverse proxy with TLS
4. Encrypt OAuth tokens in database
5. Implement rate limiting
6. Add security headers (CORS, CSP, etc.)

For security-related questions or concerns, please refer to the vulnerability disclosure process or contact the project maintainers directly.
</file>

<file path="docs/troubleshooting.md">
# Troubleshooting Guide

This guide helps you diagnose and resolve common issues with ccflare.

## Table of Contents

1. [OAuth Authentication Problems](#oauth-authentication-problems)
2. [Rate Limiting Issues](#rate-limiting-issues)
3. [Connection Problems](#connection-problems)
4. [Performance Issues](#performance-issues)
5. [Account Management Issues](#account-management-issues)
6. [Configuration Problems](#configuration-problems)
7. [Database Issues](#database-issues)
8. [Streaming and Analytics Issues](#streaming-and-analytics-issues)
9. [Logging and Debugging](#logging-and-debugging)
10. [Common Error Messages](#common-error-messages)
11. [Environment Variables Reference](#environment-variables-reference)
12. [FAQ](#faq)
13. [Getting Help](#getting-help)

## OAuth Authentication Problems

### Invalid Tokens

**Symptom**: Requests fail with 401 Unauthorized errors

**Error Message**: `Failed to refresh access token`

**Solutions**:
1. Check if the access token has expired:
   ```bash
   ccflare --list
   ```
   Look for accounts with expired tokens (expires_at in the past)

2. Refresh the token manually:
   - Remove and re-add the account:
     ```bash
     ccflare --remove <account-name>
     ccflare --add-account <account-name>
     ```

3. Verify the refresh token is still valid in your Anthropic console

### Expired Tokens

**Symptom**: Token refresh attempts fail repeatedly

**Error Message**: `Token expired or missing for account: [name]`

**Solutions**:
1. ccflare automatically attempts to refresh expired tokens
2. If automatic refresh fails, re-authenticate the account
3. Check for refresh token stampede prevention - multiple simultaneous refresh attempts are prevented

### PKCE Failures

**Symptom**: OAuth authorization fails during account setup

**Error Messages**:
- `Token exchange failed: [error]`
- `Invalid code_verifier`
- `Refresh promise not found for account`

**Solutions**:
1. Ensure you're using the complete authorization code including the state fragment (format: `code#state`)
2. Don't modify or truncate the authorization code
3. Complete the OAuth flow within the time limit (codes expire quickly)
4. Try the authorization flow again from the beginning
5. Ensure only one refresh attempt happens at a time (refresh stampede prevention is active)

### Token Refresh Failures

**Symptom**: Automatic token refresh fails

**Error Messages**:
- `Failed to refresh access token`
- `Token refresh failed: [error]`

**Solutions**:
1. Check if the refresh token was revoked in your Anthropic console
2. Verify the CLIENT_ID environment variable matches your OAuth app
3. Remove and re-add the account:
   ```bash
   ccflare --remove <account-name>
   ccflare --add-account <account-name>
   ```
4. Check for multiple simultaneous refresh attempts in logs

## Rate Limiting Issues

### Identifying Rate Limits

ccflare detects rate limits through response headers and HTTP status codes:

1. **Rate Limited Responses**: 
   - HTTP 429 responses
   - Rate limit headers in responses
   - Account is marked unavailable for selection

**How to Check Rate Limit Status**:
```bash
# View account status including rate limits
ccflare --list

# Check logs for rate limit messages
cat /tmp/ccflare-logs/app.log | grep "rate limited"

# View rate limit reset times in the dashboard
curl http://localhost:8080/api/accounts | jq '.[] | {name, rate_limit_status, rate_limit_reset}'
```

### Recovery Strategies

**When an account is rate-limited**:
1. ccflare automatically rotates to the next available account
2. Rate-limited accounts are marked with a reset timestamp
3. Accounts automatically become available again after the reset time

**Manual recovery steps**:
1. Add more accounts to your pool:
   ```bash
   ccflare --add-account account2
   ```

2. Check rate limit reset times in the dashboard:
   ```
   http://localhost:8080/dashboard
   ```

3. Monitor account-specific rate limits:
   ```bash
   # View rate limit details for each account
   ccflare --list
   # Look for rate_limit_status and rate_limit_reset columns
   ```

4. Pause/resume accounts as needed:
   ```bash
   ccflare --pause <account-name>
   ccflare --resume <account-name>
   ```

## Connection Problems

### Network Timeouts

**Symptom**: Requests hang or timeout

**Error Messages**:
- `ECONNREFUSED`
- `ETIMEDOUT`
- `Failed to forward unauthenticated request`
- `All accounts failed to proxy the request`

**Solutions**:
1. Check your internet connection
2. Verify the Anthropic API is accessible:
   ```bash
   curl -I https://api.anthropic.com/v1/messages
   ```
3. Check proxy settings if behind a corporate firewall
4. Increase retry configuration in config file

### Proxy Configuration

**Configuring HTTP proxy**:
```bash
# Set proxy environment variables before starting
export HTTP_PROXY=http://proxy.company.com:8080
export HTTPS_PROXY=http://proxy.company.com:8080
bun start
```

**Bypass proxy for local requests**:
```bash
export NO_PROXY=localhost,127.0.0.1
```

## Performance Issues

### Slow Responses

**Symptoms**:
- High response times in logs
- Dashboard shows increased latency

**Solutions**:
1. Check account distribution:
   - Ensure accounts aren't all rate-limited
   - Verify load balancing strategy is appropriate

2. Optimize retry settings:
   ```json
   {
     "retry_attempts": 2,
     "retry_delay_ms": 500,
     "retry_backoff": 1.5
   }
   ```

3. Use session-based routing for conversational workloads:
   ```bash
   # Set strategy to session for better performance with conversations
   # Session is the default and only supported strategy
   ```

### High Memory Usage

**Symptom**: Process consuming excessive memory

**Solutions**:
1. Check log file size (auto-rotates at 10MB):
   ```bash
   ls -lh /tmp/ccflare-logs/app.log
   ```

2. Clear request history:
   ```bash
   ccflare --clear-history
   ```

3. Restart the server to clear in-memory caches:
   ```bash
   # Graceful shutdown with Ctrl+C
   # Then restart
   bun start
   # Or
   ccflare --serve
   ```

## Account Management Issues

### Account Not Being Used

**Symptom**: Specific account never receives requests

**Check**:
1. Account status:
   ```bash
   ccflare --list
   # Look for: paused, rate_limited, or expired
   ```

2. Session persistence:
   - Check if account has an active session
   - Verify session hasn't expired

**Solutions**:
1. Resume the account if paused:
   ```bash
   ccflare --resume <account-name>
   ```
2. Wait for rate limit to reset
3. Re-add the account if expired

### Account Selection Problems

**Symptom**: Uneven distribution of requests

**Solutions**:
1. Check current strategy:
   ```bash
   # Session strategy is the default and only supported strategy
   ```

2. Session strategy behavior:
   - `session`: Maintains 1-hour sessions with individual accounts (default: 3600000ms)
   - This is the only supported strategy to avoid account bans
   - Adjust session_duration_ms if needed

## Configuration Problems

### Config File Location

Default locations by platform:
- **macOS**: `~/.config/ccflare/ccflare.json`
- **Linux**: `~/.config/ccflare/ccflare.json`
- **Windows**: `%LOCALAPPDATA%\ccflare\ccflare.json` or `%APPDATA%\ccflare\ccflare.json`

### Invalid Configuration

**Symptom**: Server fails to start or uses default values

**Error Messages**:
- `Failed to parse config file`
- `Invalid strategy: [name]`

**Solutions**:
1. Validate JSON syntax:
   ```bash
   cat ~/.config/ccflare/ccflare.json | jq .
   ```

2. Reset to defaults:
   ```bash
   # Backup current config
   cp ~/.config/ccflare/ccflare.json ~/.config/ccflare/config.backup.json
   # Remove corrupted config
   rm ~/.config/ccflare/ccflare.json
   # Restart server to create new config
   bun start
   ```

### Environment Variable Override

Environment variables override config file settings:
- `CLIENT_ID`: OAuth client ID
- `PORT`: Server port (default: 8080)
- `LB_STRATEGY`: Load balancing strategy
- `RETRY_ATTEMPTS`: Number of retry attempts
- `RETRY_DELAY_MS`: Initial retry delay
- `SESSION_DURATION_MS`: Session duration for session strategy

## Database Issues

### Database Path Problems

**Symptom**: Server fails to start with database errors

**Error Messages**:
- `Database file not found`
- `Permission denied`
- `Cannot create database`

**Solutions**:
1. Check database file permissions:
   ```bash
   # macOS/Linux
   ls -la ~/.config/ccflare/ccflare.db
   
   # Windows
   dir %LOCALAPPDATA%\ccflare\ccflare.db
   ```

2. Create the directory if it doesn't exist:
   ```bash
   # macOS/Linux
   mkdir -p ~/.config/ccflare
   
   # Windows
   mkdir %LOCALAPPDATA%\ccflare
   ```

3. Use a custom database path:
   ```bash
   export ccflare_DB_PATH=/path/to/custom/ccflare.db
   bun start
   ```

### Database Migration Failures

**Symptom**: Server logs show migration errors

**Error Messages**:
- `ALTER TABLE failed`
- `Column already exists`
- `Migration failed`

**Solutions**:
1. The migration system is idempotent - errors about existing columns are harmless
2. If migrations fail repeatedly:
   ```bash
   # Backup existing database
   cp ~/.config/ccflare/ccflare.db ~/.config/ccflare/ccflare.db.backup
   
   # Remove and let it recreate
   rm ~/.config/ccflare/ccflare.db
   bun start
   ```

3. Check for database corruption:
   ```bash
   sqlite3 ~/.config/ccflare/ccflare.db "PRAGMA integrity_check;"
   ```

### Async Database Writer Issues

**Symptom**: Database writes appear delayed or missing

**Error Messages**:
- `Failed to execute DB job`
- `Async DB writer queue flushed`

**Solutions**:
1. The async writer batches writes every 100ms for performance
2. During shutdown, ensure graceful termination (Ctrl+C) to flush pending writes
3. Check logs for async writer errors:
   ```bash
   grep "async-db-writer" /tmp/ccflare-logs/app.log
   ```

### Database Lock Errors

**Symptom**: Multiple processes accessing the database

**Error Messages**:
- `database is locked`
- `SQLITE_BUSY`

**Solutions**:
1. Ensure only one instance of ccflare is running:
   ```bash
   ps aux | grep "bun start" | grep -v grep
   ps aux | grep "ccflare --serve" | grep -v grep
   ```

2. Kill any zombie processes:
   ```bash
   pkill -f "bun start"
   pkill -f "ccflare --serve"
   ```

3. Check for hanging database connections:
   ```bash
   lsof ~/.config/ccflare/ccflare.db
   ```

## Streaming and Analytics Issues

### Streaming Response Capture Problems

**Symptom**: Analytics data missing for streaming responses

**Error Messages**:
- `Stream tee error`
- `Failed to capture streaming response`
- `Buffer truncated at 1MB`

**Solutions**:
1. Streaming responses are captured up to 1MB for analytics
2. Large responses will be truncated but still forwarded completely to the client
3. Check if streaming is working:
   ```bash
   # Look for streaming response logs
   grep "Streaming response" /tmp/ccflare-logs/app.log
   ```

### Analytics Data Issues

**Symptom**: Dashboard shows incorrect or missing analytics

**Error Messages**:
- `Failed to fetch analytics data`
- `Analytics error:`

**Solutions**:
1. Check if requests are being recorded:
   ```bash
   # Count recent requests in database
   sqlite3 ~/.config/ccflare/ccflare.db "SELECT COUNT(*) FROM requests WHERE timestamp > strftime('%s', 'now', '-1 hour') * 1000;"
   ```

2. Verify analytics endpoint:
   ```bash
   # Test analytics API
   curl "http://localhost:8080/api/analytics?range=1h"
   ```

3. Clear and rebuild analytics data:
   ```bash
   ccflare --clear-history
   ```

4. Reset account statistics without clearing history:
   ```bash
   ccflare --reset-stats
   ```

### Usage Tracking Problems

**Symptom**: Token usage and costs not updating

**Solutions**:
1. Usage is extracted from response headers and streaming data
2. Check for usage extraction errors:
   ```bash
   grep "extractUsageInfo" /tmp/ccflare-logs/app.log
   ```

3. Verify model pricing data:
   ```bash
   # Pricing updates every 24 hours by default
   grep "Fetching latest pricing" /tmp/ccflare-logs/app.log
   ```

4. Force offline pricing mode:
   ```bash
   export CF_PRICING_OFFLINE=1
   bun start
   ```

## Logging and Debugging

### Log File Locations

Logs are stored in the system's temporary directory:
- **All platforms**: `/tmp/ccflare-logs/app.log`
- **Windows**: `%TEMP%\ccflare-logs\app.log`

### Enabling Debug Mode

**Method 1: Environment Variable**
```bash
export ccflare_DEBUG=1
export LOG_LEVEL=DEBUG
bun start
```

**Method 2: Verbose Logging**
```bash
# View real-time logs
tail -f /tmp/ccflare-logs/app.log
```

### Log Formats

**JSON Format** (for parsing):
```bash
export LOG_FORMAT=json
bun start
```

**Pretty Format** (default):
```
[2024-01-20T10:30:45.123Z] INFO: [Proxy] Request completed for account1: 200 in 1234ms
```

### Reading Logs

**Filter by log level**:
```bash
# View only errors
grep "ERROR" /tmp/ccflare-logs/app.log

# View warnings and errors
grep -E "WARN|ERROR" /tmp/ccflare-logs/app.log
```

**Filter by component**:
```bash
# View only proxy logs
grep "\[Proxy\]" /tmp/ccflare-logs/app.log

# View only server logs
grep "\[Server\]" /tmp/ccflare-logs/app.log
```

## Common Error Messages

### Authentication and Token Errors

#### "No active accounts available - forwarding request without authentication"
**Meaning**: All accounts are either paused, rate-limited, or expired

**Solution**: 
- Add new accounts or wait for rate limits to reset
- Check account status: `ccflare --list`
- Requests will be forwarded without authentication (may fail)

#### "Refresh promise not found for account"
**Meaning**: Internal error during token refresh process

**Solution**:
- Restart the server to clear refresh state
- Check for concurrent refresh attempts in logs

#### "Failed to refresh access token"
**Meaning**: OAuth refresh token is invalid or revoked

**Solution**:
- Remove and re-add the account
- Check if the OAuth app still has permissions in Anthropic console

### Request Processing Errors

#### "Provider cannot handle path"
**Meaning**: Request path doesn't match expected Anthropic API patterns

**Solution**: 
- Ensure requests are to `/v1/*` endpoints
- Check if you're using the correct base URL
- Valid paths: `/v1/messages`, `/v1/complete`, etc.

#### "All accounts failed to proxy the request"
**Meaning**: Every account attempted but all failed

**Response**:
```json
{
  "error": "All accounts failed to proxy the request",
  "attempts": 3,
  "lastError": "Error message here"
}
```

**Solutions**:
1. Check individual account errors in logs
2. Verify network connectivity
3. Ensure at least one account has valid credentials
4. Check for API outages

#### "Failed to forward unauthenticated request"
**Meaning**: Request forwarding without authentication failed

**Solutions**:
1. Check network connectivity
2. Verify Anthropic API is accessible
3. Check for proxy configuration issues
4. Look for timeout errors in logs

#### "Failed to proxy request with account"
**Meaning**: Error occurred while proxying with a specific account

**Solutions**:
1. Check the specific account's status
2. Look for token expiration or rate limits
3. Verify network connectivity

### Database Errors

#### "Failed to execute DB job"
**Meaning**: Async database write failed

**Solutions**:
1. Check disk space
2. Verify database file permissions
3. Look for detailed error in logs

#### "database is locked"
**Meaning**: Another process is accessing the database

**Solutions**:
1. Ensure only one ccflare instance is running
2. Kill any zombie processes
3. Wait for current operations to complete

### Analytics and Streaming Errors

#### "Stream tee error"
**Meaning**: Failed to capture streaming response for analytics

**Solutions**:
1. This doesn't affect the actual response to the client
2. Check for memory issues if frequent
3. Large responses may exceed 1MB capture limit

#### "Failed to fetch analytics data"
**Meaning**: Analytics query failed

**Solutions**:
1. Check if database is accessible
2. Verify time range parameters
3. Clear history if data is corrupted: `ccflare --clear-history`

### Configuration Errors

#### "Failed to parse config file"
**Meaning**: JSON syntax error in config file

**Solutions**:
1. Validate JSON syntax: `cat ~/.config/ccflare/ccflare.json | jq .`
2. Check for trailing commas or missing quotes
3. Reset to defaults by deleting config file

#### "Invalid strategy: [name]"
**Meaning**: Unknown load balancing strategy specified

**Solutions**:
1. Only valid strategy: `session`
2. Check spelling in config or environment variable
3. The default is already `session`

### HTTP Status Codes

#### 400 Bad Request
**Common Causes**:
- Invalid request format
- Missing required parameters
- Invalid account name or ID

#### 401 Unauthorized
**Common Causes**:
- Expired access token
- Invalid OAuth credentials
- No active accounts available

#### 403 Forbidden
**Common Causes**:
- Account doesn't have required permissions
- OAuth app restrictions

#### 429 Too Many Requests
**Common Causes**:
- Account rate limited
- All accounts exhausted
- Check rate limit headers for reset time

#### 500 Internal Server Error
**Common Causes**:
- Unexpected server error
- Database connection issues
- Check logs for stack trace

### Startup Errors

#### "Address already in use"
**Meaning**: Port is already occupied

**Solutions**:
1. Check if another instance is running: `lsof -i :8080`
2. Use a different port: `PORT=3000 bun start`
3. Kill the process using the port

#### "Cannot create database"
**Meaning**: Unable to create or access database file

**Solutions**:
1. Check directory permissions
2. Ensure parent directory exists
3. Use custom path: `export ccflare_DB_PATH=/custom/path/db.db`

## Environment Variables Reference

### Core Configuration

| Variable | Description | Default | Example |
|----------|-------------|---------|---------|
| `CLIENT_ID` | OAuth client ID for Anthropic | None | `my-oauth-client-id` |
| `PORT` | Server port | 8080 | `3000` |
| `LB_STRATEGY` | Load balancing strategy | `session` | Only `session` is supported |
| `RETRY_ATTEMPTS` | Number of retry attempts | 3 | `5` |
| `RETRY_DELAY_MS` | Initial retry delay in ms | 1000 | `500` |
| `RETRY_BACKOFF` | Retry backoff multiplier | 2 | `1.5` |
| `SESSION_DURATION_MS` | Session duration for session strategy | 3600000 (1 hour) | `1800000` |

### Paths and Storage

| Variable | Description | Default | Example |
|----------|-------------|---------|---------|
| `ccflare_CONFIG_PATH` | Custom config file location | Platform-specific | `/opt/ccflare/config.json` |
| `ccflare_DB_PATH` | Custom database location | Platform-specific | `/opt/ccflare/data.db` |

### Logging and Debugging

| Variable | Description | Default | Example |
|----------|-------------|---------|---------|
| `ccflare_DEBUG` | Enable debug mode | `0` | `1` |
| `LOG_LEVEL` | Log level | `INFO` | `DEBUG`, `WARN`, `ERROR` |
| `LOG_FORMAT` | Log format | `pretty` | `json` |

### Proxy Settings

| Variable | Description | Default | Example |
|----------|-------------|---------|---------|
| `HTTP_PROXY` | HTTP proxy URL | None | `http://proxy.company.com:8080` |
| `HTTPS_PROXY` | HTTPS proxy URL | None | `http://proxy.company.com:8080` |
| `NO_PROXY` | Bypass proxy for hosts | None | `localhost,127.0.0.1` |

### Advanced Settings

| Variable | Description | Default | Example |
|----------|-------------|---------|---------|
| `CF_PRICING_OFFLINE` | Use offline pricing data | `0` | `1` |
| `CF_PRICING_REFRESH_HOURS` | Hours between pricing updates | `24` | `12` |

### Usage Examples

```bash
# Development setup with debug logging
export ccflare_DEBUG=1
export LOG_LEVEL=DEBUG
export LOG_FORMAT=json
bun start

# Production setup with custom paths
export ccflare_CONFIG_PATH=/etc/ccflare/config.json
export ccflare_DB_PATH=/var/lib/ccflare/data.db
export PORT=3000
bun start

# Corporate proxy setup
export HTTP_PROXY=http://proxy.corp.com:8080
export HTTPS_PROXY=http://proxy.corp.com:8080
export NO_PROXY=localhost,127.0.0.1,internal.corp.com
bun start
```

## FAQ

### Q: How do I know if ccflare is working?

**A**: Check the health endpoint:
```bash
curl http://localhost:8080/health
```

Expected response:
```json
{
  "status": "ok",
  "accounts": {
    "total": 3,
    "active": 2,
    "paused": 1
  },
  "uptime": 3600000
}
```

### Q: Can I use ccflare with multiple client applications?

**A**: Yes, ccflare acts as a transparent proxy. Point any Claude API client to `http://localhost:8080` instead of `https://api.anthropic.com`.

### Q: How do I backup my accounts?

**A**: The account data is stored in the SQLite database. Backup locations:
- **macOS/Linux**: `~/.config/ccflare/ccflare.db`
- **Windows**: `%LOCALAPPDATA%\ccflare\ccflare.db` or `%APPDATA%\ccflare\ccflare.db`

### Q: What happens during a graceful shutdown?

**A**: When receiving SIGINT (Ctrl+C) or SIGTERM:
1. Stops accepting new requests
2. Waits for in-flight requests to complete (with timeout)
3. Flushes async database writer queue
4. Closes database connections
5. Flushes logs to disk
6. Exits cleanly

### Q: How do I migrate to a new machine?

**A**: Copy these files to the new machine:
1. Database file (`ccflare.db`)
2. Config file (`ccflare.json`)
3. Set the same CLIENT_ID environment variable
4. Ensure Bun is installed on the new machine

### Q: Why is my analytics data missing or incorrect?

**A**: Several reasons can cause analytics issues:
1. Streaming responses are only captured up to 1MB
2. Database writes are async and may be delayed
3. Usage data depends on response headers from Anthropic
4. Check if requests are being recorded: `sqlite3 ~/.config/ccflare/ccflare.db "SELECT COUNT(*) FROM requests;"`

### Q: How do I handle rate limits effectively?

**A**: Best practices for rate limit handling:
1. Add multiple accounts to your pool
2. Maintain proper session duration (default 1 hour)
3. Monitor rate limit warnings in logs
4. Set up alerts for rate-limited accounts
5. Consider implementing request queuing in your application

### Q: Can I use ccflare in production?

**A**: Yes, with these considerations:
1. Use environment variables for sensitive configuration
2. Set up proper logging and monitoring
3. Use a persistent database path (not /tmp)
4. Configure appropriate retry settings
5. Add sufficient accounts for your load
6. Use systemd or similar for process management

### Q: Why are some accounts not being used?

**A**: Accounts may be skipped for several reasons:
1. **Paused**: Manually paused via CLI
2. **Rate Limited**: Temporarily unavailable due to rate limits
3. **Expired Token**: Needs re-authentication
4. **Session**: Account may have an active session
5. Check status: `ccflare --list`

### Q: How do I troubleshoot slow responses?

**A**: Steps to diagnose performance issues:
1. Check response times in logs or analytics
2. Verify no accounts are rate limited
3. Look for retry attempts in logs
4. Consider session duration settings
5. Check network latency to Anthropic API
6. Monitor database performance

### Q: What's the difference between running with bun start vs ccflare --serve?

**A**: Both commands start the server:
- `bun start`: Runs the server using the npm script
- `ccflare --serve`: Runs the server directly via the CLI binary
- Both are functionally equivalent

## Getting Help

### Reporting Bugs

When reporting issues, include:

1. **System Information**:
   ```bash
   bun --version
   node --version
   echo $OSTYPE
   ```

2. **Error Logs**:
   ```bash
   # Last 100 lines of logs
   tail -n 100 /tmp/ccflare-logs/app.log
   ```

3. **Configuration** (sanitized):
   ```bash
   # Remove sensitive data before sharing
   cat ~/.config/ccflare/ccflare.json | jq 'del(.client_id)'
   ```

4. **Steps to Reproduce**:
   - Exact commands run
   - Expected behavior
   - Actual behavior

### Debug Information Script

Save this as `debug-info.sh`:
```bash
#!/bin/bash
echo "=== ccflare Debug Info ==="
echo "Date: $(date)"
echo "System: $(uname -a)"
echo "Bun Version: $(bun --version)"
echo "Node Version: $(node --version 2>/dev/null || echo 'Node not installed')"
echo ""

echo "=== Environment Variables ==="
env | grep -E "ccflare|CLIENT_ID|PORT|LB_STRATEGY|LOG_|PROXY" | sort
echo ""

echo "=== Process Info ==="
ps aux | grep -E "bun start|ccflare" | grep -v grep
echo ""

echo "=== Port Check ==="
lsof -i :${PORT:-8080} 2>/dev/null || echo "Port ${PORT:-8080} not in use"
echo ""

echo "=== Database Info ==="
if [ -f "$HOME/.config/ccflare/ccflare.db" ]; then
    echo "Database size: $(du -h "$HOME/.config/ccflare/ccflare.db" | cut -f1)"
    echo "Request count: $(sqlite3 "$HOME/.config/ccflare/ccflare.db" "SELECT COUNT(*) FROM requests;" 2>/dev/null || echo "Could not query")"
    echo "Account count: $(sqlite3 "$HOME/.config/ccflare/ccflare.db" "SELECT COUNT(*) FROM accounts;" 2>/dev/null || echo "Could not query")"
else
    echo "Database not found at default location"
fi
echo ""

echo "=== Recent Errors (last 24h) ==="
if [ -f "/tmp/ccflare-logs/app.log" ]; then
    grep "ERROR" /tmp/ccflare-logs/app.log | tail -20
else
    echo "Log file not found"
fi
echo ""

echo "=== Recent Rate Limits ==="
if [ -f "/tmp/ccflare-logs/app.log" ]; then
    grep -E "rate.?limit" /tmp/ccflare-logs/app.log | tail -10
else
    echo "Log file not found"
fi
echo ""

echo "=== Account Status ==="
ccflare --list 2>/dev/null || echo "Could not get account list"
echo ""

echo "=== API Health Check ==="
curl -s http://localhost:${PORT:-8080}/health | jq . 2>/dev/null || echo "Health check failed"
echo ""

echo "=== Recent Analytics (1h) ==="
curl -s "http://localhost:${PORT:-8080}/api/analytics?range=1h" | jq '.overview' 2>/dev/null || echo "Analytics unavailable"
```

Make the script executable:
```bash
chmod +x debug-info.sh
./debug-info.sh > debug-report.txt
```

### Community Support

- Check existing issues in the repository
- Review this troubleshooting guide
- Search logs for specific error messages
- Try running in debug mode for more details

### Performance Monitoring

Monitor key metrics via the dashboard API:
```bash
# Get current stats
curl http://localhost:8080/api/stats | jq .

# Get request history with filters
curl "http://localhost:8080/api/requests?limit=10&status=error" | jq .

# Get analytics with time ranges
curl "http://localhost:8080/api/analytics?range=1h" | jq .
curl "http://localhost:8080/api/analytics?range=24h" | jq .
curl "http://localhost:8080/api/analytics?range=7d" | jq .

# Get analytics with filters
curl "http://localhost:8080/api/analytics?range=1h&model=claude-3-opus&status=success" | jq .

# Monitor real-time logs
tail -f /tmp/ccflare-logs/app.log | grep -E "INFO|WARN|ERROR"
```

### Quick Troubleshooting Checklist

When experiencing issues, check these in order:

1. **Service Health**
   ```bash
   curl http://localhost:8080/health
   ```

2. **Account Status**
   ```bash
   ccflare --list
   ```

3. **Recent Errors**
   ```bash
   grep ERROR /tmp/ccflare-logs/app.log | tail -20
   ```

4. **Rate Limits**
   ```bash
   grep "rate.?limit" /tmp/ccflare-logs/app.log | tail -10
   ```

5. **Network Connectivity**
   ```bash
   curl -I https://api.anthropic.com/v1/messages
   ```

6. **Database Health**
   ```bash
   sqlite3 ~/.config/ccflare/ccflare.db "PRAGMA integrity_check;"
   ```

### Common Quick Fixes

| Problem | Quick Fix |
|---------|-----------|
| All accounts rate limited | Add more accounts: `ccflare --add-account newaccount` |
| Token expired | Re-authenticate: `ccflare --remove account && ccflare --add-account account` |
| Database locked | Kill duplicate processes: `pkill -f "bun start"` |
| Port in use | Use different port: `PORT=3000 bun start` |
| Config corrupted | Reset config: `rm ~/.config/ccflare/ccflare.json` |
| Analytics missing | Clear history: `ccflare --clear-history` |
| Slow responses | Check session duration settings (default 1 hour) |

Remember: Most issues can be resolved by checking logs, verifying account status, and ensuring proper network connectivity. When in doubt, restart the service with debug logging enabled: `ccflare_DEBUG=1 LOG_LEVEL=DEBUG bun start`
</file>

<file path="docs/tui.md">
# ccflare TUI Documentation

## Overview

The ccflare Terminal User Interface (TUI) provides an interactive way to manage your Claude API load balancer. Built with React and Ink, it offers real-time monitoring, account management, and comprehensive analytics all from your terminal.

### Key Features

- **Interactive Navigation**: Menu-driven interface with intuitive keyboard shortcuts
- **Real-time Updates**: Live monitoring of requests, logs, and statistics
- **Account Management**: Add, remove, and monitor OAuth accounts with PKCE flow
- **Request History**: View detailed request/response information with token usage, costs, and model names
- **Statistics Dashboard**: Track usage, costs, token metrics, and performance
- **Analytics Dashboard**: Advanced visualizations with charts, time-range selection, and multiple views
- **Load Balancer Strategy**: View and change the active load balancing strategy
- **Log Streaming**: Real-time log viewer with pause/resume and historical logs
- **Auto-start Server**: The API server starts automatically when launching the TUI
- **Graceful Shutdown**: Proper cleanup of resources on exit

## Installation and Launching

### Prerequisites

- Bun runtime (v1.2.8 or higher)
- ccflare project dependencies installed
- Terminal with 256-color support (recommended)
- Minimum terminal size: 80x24

### Launching the TUI

There are two ways to launch the TUI:

```bash
# Using the package.json script (recommended)
bun run dev

# Direct execution
bun run apps/tui/src/main.ts
```

The TUI will automatically start the API server on port 8080 (or your configured port) when launched.

### Command Line Options

The TUI supports both interactive and non-interactive command line operations:

```bash
# Show help
bun run dev --help
bun run dev -h

# Start server only (no TUI)
bun run dev --serve [--port 8080]

# View logs  
bun run dev --logs [N]  # Stream logs (optionally show last N lines first)

# View statistics (JSON output)
bun run dev --stats

# Account management
bun run dev --add-account <name> [--mode max|console] [--tier 1|5|20]
bun run dev --list
bun run dev --remove <name>
bun run dev --pause <name>
bun run dev --resume <name>

# Maintenance
bun run dev --reset-stats
bun run dev --clear-history

# Performance analysis
bun run dev --analyze
```

## Navigation and Keyboard Shortcuts

### Global Navigation

- **Arrow Keys (↑/↓)**: Navigate through menu items in SelectInput components
- **Arrow Keys (←/→)**: Navigate between pages in paginated views
- **Enter**: Select the highlighted option
- **ESC**: Go back to the previous screen or cancel operations
- **q**: Quit the current screen (works in list/view screens)
- **Ctrl+C**: Force quit the TUI from any screen

### Screen-Specific Shortcuts

#### Home Screen
- Use arrow keys to navigate the main menu
- Press Enter to select an option
- Select "Exit" or press Ctrl+C to quit the TUI

#### Server Status Screen
- **d**: Open the web dashboard in your default browser (uses the `open` package)
- **q/ESC**: Return to home screen

#### Accounts Management Screen
- **Enter**: Select an account to remove or select "Add Account"
- **ESC**: Cancel current operation or go back
- During account addition:
  - Type account name and press Enter
  - Use arrow keys to select mode (max/console)
  - Use arrow keys to select tier (1/5/20)
  - Browser opens automatically for OAuth
  - Type authorization code and press Enter

#### Request History Screen
- **↑/↓**: Navigate through requests (shows 10 items per page)
- **←/→**: Navigate between pages
- **Enter/Space**: View detailed information for selected request
- **r**: Manually refresh the request list
- **q/ESC**: Go back (or exit details view if open)
- Auto-refreshes every 10 seconds
- Displays model name, token count, and cost for each request

#### Statistics Dashboard Screen
- **r**: Manually refresh statistics
- **q/ESC**: Return to home screen
- Auto-refreshes every 5 seconds
- Shows token usage breakdown (input, cache read, cache creation, output)
- Displays total cost in USD

#### Logs Viewer Screen
- **Space**: Pause/resume log streaming
- **c**: Clear the current log display
- **q/ESC**: Return to home screen
- Loads last 200 historical logs on startup
- Maintains a buffer of 200 logs maximum

## Screen Descriptions

### 1. Home Screen

The main menu presents all available options using Ink's SelectInput component:

```
🎯 ccflare TUI

Select an option:
  🚀 Server
  👥 Manage Accounts
  📊 View Statistics
  📈 Analytics Dashboard
  📜 View Requests
  📋 View Logs
  ⚖️  Load Balancer
  ❌ Exit
```

### 2. Server Status Screen

Shows the auto-started server status and provides quick access to the web dashboard:

```
🚀 Server

✓ Server running at http://localhost:8080

Press 'd' to open dashboard in browser

Press 'q' or ESC to go back
```

The server is automatically started when the TUI launches and cleaned up on exit.

### 3. Accounts Management Screen

Manage your OAuth accounts with an interactive interface:

```
👥 Manage Accounts

2 account(s) configured

  work-account (tier 5)
  personal (tier 1)
  ➕ Add Account
  ← Back
```

#### Adding an Account

The add account flow uses PKCE OAuth and guides you through:
1. **Account Name**: Enter a unique identifier using TextInput
2. **Mode Selection**: Choose between "Max (recommended)" or "Console" using SelectInput
3. **Tier Selection**: Select "Tier 1 (default)", "Tier 5", or "Tier 20"
4. **OAuth Authentication**: Browser opens automatically with PKCE flow
5. **Code Entry**: Enter the authorization code after authentication

```
Complete Authentication

A browser window should have opened for authentication.
After authorizing, enter the code below:

Authorization code: [input field]

Press ESC to cancel
```

#### Removing an Account

Safety confirmation required - type the exact account name to confirm deletion:

```
⚠️ Confirm Account Removal

You are about to remove account 'work-account'.
This action cannot be undone.

Type work-account to confirm: [input field]

Press ENTER to confirm, ESC to cancel
```

### 4. Request History Screen

View recent API requests with detailed information:

```
📜 Request History
Use ↑/↓ to navigate, ENTER to view details

▶ 10:23:45 - 200 - work-acc... 
  10:23:44 - 429 - personal... [RATE LIMITED]
  10:23:43 - 200 - work-acc...
  10:23:42 - ERROR - personal... - Connection timeout...

... and 35 more requests

Press 'r' to refresh • 'q' or ESC to go back
```

The screen displays 10 requests per page with:
- Timestamp (local time)
- Status code with color coding (green: 2xx, yellow: 4xx, red: 5xx/errors)
- Account name or ID (truncated to 8 characters)
- Model name (e.g., "opus", "sonnet", "haiku")
- Token count
- Cost in USD
- Rate limit indicators
- Error messages (truncated to 20 characters)
- Page navigation with ←/→ arrows

#### Detail View

Press Enter or Space on a request to see:

```
📜 Request Details

ID: req_abc123...
Time: 10:23:45 AM
Account: work-account
Model: claude-3.5-sonnet
Response Time: 1234ms
Retry: 1
Rate Limited

Token Usage:
  Input: 1,234 tokens
  Cache Read: 123 tokens  
  Cache Creation: 12 tokens
  Output: 456 tokens
  Total: 1,825 tokens
  Cost: $0.0234

Request Headers:
  content-type: application/json
  authorization: Bearer sk-ant-...

Request Body:
{"model": "claude-3-opus-20240229", "messages": [...]}...

Response Status: 200

Response Body:
{"id": "msg_123...", "content": [...]}...

Press 'q' or ESC to go back
```

### 5. Statistics Dashboard Screen

Real-time statistics with automatic updates every 5 seconds:

```
📊 Statistics

Overall Stats
  Total Requests: 1,245
  Success Rate: 98.5%
  Active Accounts: 2
  Avg Response Time: 234ms
  Total Tokens: 1,234,567
    ├─ Input: 234,567
    ├─ Cache Read: 12,345
    ├─ Cache Creation: 1,234
    └─ Output: 123,456
  Total Cost: $12.45

Account Usage
  work-account: 845 requests (99% success)
  personal: 400 requests (97% success)

Recent Errors
  Failed to refresh token for expired-account
  Connection timeout after 30s
  Rate limit exceeded for account personal

Press 'r' to refresh • 'q' or ESC to go back
```

Features:
- Auto-refreshes every 5 seconds
- Shows detailed token usage breakdown (only non-zero values)
- Displays total cost in USD with 2 decimal precision
- Lists up to 5 recent errors
- Account-specific request counts and success rates

### 6. Analytics Dashboard Screen

Advanced analytics with interactive charts and visualizations:

```
📈 Analytics Dashboard - Last 24 Hours                    View: overview

Time: [1] 1h [2] 6h [3] 24h [4] 7d | View: [o]verview [t]okens [p]erf [c]ost [d]models

Request Volume & Performance

Requests ▁▂▃▄▅▆▇█▇▆▅▄▃▂▁ Current: 145
Tokens   ▁▂▃▄▅▆▇█▇▆▅▄▃▂▁ Current: 123.5k
Cost     ▁▂▃▄▅▆▇█▇▆▅▄▃▂▁ Current: $0.45

Response Time (ms)
┌────────────────────────────────────────────────┐
│1200├───────────────────────────────────────────┤│
│    │      ╱╲    ╱╲                             ││
│ 800├────╱──╲──╱──╲─────────────────────────────┤│
│    │  ╱      ╲╱    ╲                           ││
│ 400├─╱──────────────╲─────────────────────────┤│
│    │                    ╲                       ││
│   0└────────────────────────╲───────────────────┘│
└────────────────────────────────────────────────┘

[m] Menu • [r] Refresh • [q/ESC] Back
```

#### Analytics Views

1. **Overview** (o): Request volume sparklines, response time chart
2. **Token Usage** (t): Token breakdown bar chart, efficiency metrics
3. **Performance** (p): Account performance comparison, success rates
4. **Cost Analysis** (c): Cost trends, projections, per-request costs
5. **Model Distribution** (d): Pie chart of model usage, performance by model

#### Keyboard Shortcuts

- **1-4**: Select time range (1h, 6h, 24h, 7d)
- **o/t/p/c/d**: Quick switch between views
- **m**: Open view selection menu
- **r**: Manual refresh
- **q/ESC**: Return to home

Features:
- Interactive charts (sparklines, line charts, bar charts, pie charts)
- Time-range selection for different analysis periods
- Auto-refreshes every 30 seconds
- Multiple specialized views for different metrics
- Real-time data visualization

### 7. Load Balancer Screen

View the active load balancing strategy:

```
⚖️ Load Balancer Strategy

Current Strategy: session

Available Strategies:
  → session

Note: Only the session strategy is available.
Other strategies have been removed to prevent
account bans from Claude's anti-abuse systems.
Press ESC or q to go back
```

#### Features

- View current active strategy
- List all available strategies
- Change strategy interactively
- Confirmation messages for changes

#### Keyboard Shortcuts

- **Enter**: Open strategy selection menu
- **↑/↓**: Navigate strategies (in selection mode)
- **q/ESC**: Return to home (or cancel selection)

### 8. Logs Viewer Screen

Stream logs with pause and clear capabilities:

```
📜 Logs

[INFO] Request received from 127.0.0.1
[INFO] Using account: work-account
[WARN] Rate limit approaching for personal
[ERROR] Failed to refresh token for expired-account
[INFO] Request completed in 234ms

SPACE: Pause • 'c': Clear • 'q'/ESC: Back
```

When paused, the header shows:
```
📜 Logs (PAUSED)
```

Features:
- Loads historical logs on startup (shows "Loading logs..." initially)
- Maintains a rolling buffer of 200 log entries
- Real-time streaming when not paused
- Color-coded log levels:
  - ERROR: red
  - WARN: yellow
  - INFO: green
  - DEBUG: gray
- Space bar toggles pause/resume
- Clear function empties the current display

## Interactive Features

### Account OAuth Flow (PKCE)

The TUI uses PKCE (Proof Key for Code Exchange) for secure OAuth authentication:

1. Select "Add Account" from the Accounts screen
2. Enter a unique account name using the text input
3. Choose the mode using SelectInput:
   - **Max (recommended)**: Full Claude API access
   - **Console**: Limited console access
4. Select the tier based on your subscription (1, 5, or 20)
5. Browser opens automatically with PKCE parameters
6. Complete the authorization in your browser
7. Return to the TUI and enter the authorization code
8. Account is validated and added to the database

### Real-time Updates

- **Statistics**: Auto-refreshes every 5 seconds
- **Logs**: Streams in real-time (pauseable with Space)
- **Requests**: Auto-refreshes every 10 seconds (manual with 'r')
- **Account Status**: Updates when accounts are added/removed

## Color Coding and Indicators

### Status Colors

- **Green**: Success (2xx status), healthy, running, INFO logs
- **Yellow**: Warning, client errors (4xx), WARN logs
- **Red**: Error, server errors (5xx), failures, ERROR logs
- **Orange**: Rate limited (429 status)
- **Cyan**: Selected items, headers, TUI branding
- **Gray/Dim**: Supplementary information, DEBUG logs
- **Inverse**: Currently highlighted menu item

### Status Indicators

- **✓**: Success or server running
- **⚠️**: Warning or confirmation required
- **▶**: Currently selected item in lists
- **├─ └─**: Tree structure for token breakdown
- **[RATE LIMITED]**: Account hit rate limits
- **[PAUSED]**: Log streaming is paused
- **...**: Truncated content or more items available

## Tips and Tricks

### Performance Optimization

1. **Pause logs** when not actively monitoring to reduce CPU usage (Space key)
2. **Clear logs** periodically to free memory with 'c' key
3. **Auto-refresh intervals** are optimized (5s for stats, 10s for requests)
4. **200-log buffer** prevents excessive memory usage

### Account Management Best Practices

1. **Name accounts meaningfully**: Use descriptive names like "work-production" or "personal-dev"
2. **Monitor rate limits**: Check Statistics screen for account-specific success rates
3. **Distribute load**: Add multiple accounts to improve throughput
4. **PKCE OAuth**: More secure than standard OAuth flow
5. **Tier selection**: Choose the appropriate tier for your subscription level

### Troubleshooting

1. **TUI not responding**: Press ESC to go back, Ctrl+C to force quit
2. **Server already running**: The TUI auto-starts the server; check for existing processes
3. **OAuth issues**: Ensure browser allows pop-ups; check authorization code carefully
4. **Account removal**: Must type exact account name for safety
5. **Performance issues**: Pause log streaming or clear buffer

### Advanced Usage

1. **Multiple instances**: Use `--port` flag to run on different ports
2. **Headless operation**: Use CLI flags for CI/CD integration
3. **JSON output**: `--stats` flag outputs machine-readable statistics
4. **Direct server**: Use `--serve` to run server without TUI
5. **Batch operations**: Chain commands with `&&` in scripts

## Integration with CI/CD

The TUI's command-line interface is designed for automation:

```bash
# Add account in CI/CD pipeline
bun run dev --add-account ci-account --mode max --tier 5

# Check statistics programmatically
STATS=$(bun run dev --stats)
REQUESTS=$(echo $STATS | jq '.totalRequests')
SUCCESS_RATE=$(echo $STATS | jq '.successRate')

# Monitor logs in background
bun run dev --logs 100 | grep ERROR > error.log &

# Start server without TUI
bun run dev --serve --port 8081

# Account management
bun run dev --pause production-account
bun run dev --resume production-account

# Performance analysis
bun run dev --analyze

# Maintenance tasks
bun run dev --reset-stats
bun run dev --clear-history
```

## Architecture Notes

- **Built with Ink**: React-based terminal UI framework
- **Dependency Injection**: Uses @ccflare/core-di for service management
- **Database**: SQLite-based storage with DatabaseFactory singleton
- **Async Operations**: AsyncDbWriter for non-blocking database operations
- **Graceful Shutdown**: Proper cleanup of resources and server on exit

## Known Limitations

1. **Terminal Requirements**: 
   - Minimum 80x24 terminal size
   - Best with 256-color support
   - May have issues in some Windows terminals
2. **Interactive Components**:
   - SelectInput requires arrow key support
   - TextInput may conflict with some terminal multiplexers
3. **Concurrent Access**: 
   - TUI is designed for single-user access
   - Database operations are synchronized
4. **Browser Integration**:
   - OAuth flow requires browser access
   - Dashboard opening depends on system default browser

## Troubleshooting Common Issues

### TUI Won't Start

```bash
# Check if port is in use
lsof -i :8080

# Kill existing process if needed
kill -9 <PID>

# Start with different port
bun run dev --port 8081
```

### Account Authentication Fails

1. Check browser allows pop-ups for OAuth
2. Ensure you're logged into Claude
3. Verify PKCE flow completed successfully
4. Check authorization code is entered correctly
5. Try removing and re-adding the account

### Performance Issues

1. Pause log streaming with Space key
2. Clear log buffer with 'c' key
3. Check terminal emulator performance settings
4. Ensure adequate system resources

### Data Issues

1. Use `--reset-stats` to clear statistics
2. Use `--clear-history` to remove old requests
3. Check database file permissions
4. Verify disk space availability

## Recent Changes

- **Analytics Dashboard**: New screen with interactive charts and time-range analysis
- **Load Balancer Screen**: View and change load balancing strategies
- **Enhanced Request View**: Shows model names, token counts, and costs in list view
- **Pagination**: Request history now uses arrow keys for page navigation
- **Account Management**: New --pause and --resume commands for account control
- **Performance Analysis**: New --analyze command for database performance insights
- **PKCE OAuth**: Enhanced security for account authentication
- **Token Metrics**: Detailed token usage and cost tracking
- **Async Database**: Improved performance with AsyncDbWriter
- **Historical Logs**: Load previous logs on startup
- **Account Confirmation**: Safety dialog for account removal
- **Graceful Shutdown**: Proper cleanup on exit

## Support

For issues or feature requests:
- Check the error messages in the logs screen
- Review this documentation
- Submit issues to the GitHub repository
- Ensure you're running the latest version
</file>

<file path="packages/cli-commands/src/commands/help.ts">
/**
 * Get help text for CLI commands
 */
export function getHelpText(): string {
	return `
Usage: ccflare-cli <command> [options]

Commands:
  add <name> [--mode <max|console>] [--tier <1|5|20>]
    Add a new account using OAuth
    --mode: Account type (optional, will prompt if not provided)
    --tier: Account tier (1, 5, or 20) (optional, will prompt for Max accounts)

  list
    List all accounts with their details

  remove <name> [--force]
    Remove an account
    --force: Skip confirmation prompt

  pause <name>
    Pause an account to exclude it from load balancing

  resume <name>
    Resume a paused account to include it in load balancing

  reset-stats
    Reset request counts for all accounts

  clear-history
    Clear request history

  analyze
    Analyze database performance and index usage

  help
    Show this help message

Examples:
  ccflare-cli add myaccount --mode max --tier 5
  ccflare-cli list
  ccflare-cli remove myaccount
  ccflare-cli pause myaccount
  ccflare-cli resume myaccount
`;
}
</file>

<file path="packages/cli-commands/src/utils/browser.ts">
import { spawn } from "node:child_process";
import open from "open";

/**
 * Try to open the user's default browser with the given URL.
 * Returns true on success, false otherwise.
 */
export async function openBrowser(url: string): Promise<boolean> {
	try {
		await open(url, { wait: false });
		return true;
	} catch (_err) {
		// Fallback – Windows quoting is critical!
		try {
			if (process.platform === "win32") {
				// Use powershell -Command Start-Process 'url'
				spawn(
					"powershell.exe",
					["-NoProfile", "-Command", "Start-Process", `'${url}'`],
					{
						detached: true,
						stdio: "ignore",
					},
				).unref();
			} else if (process.platform === "darwin") {
				spawn("open", [url], { detached: true, stdio: "ignore" }).unref();
			} else {
				// Linux generic fallback
				spawn("xdg-open", [url], { detached: true, stdio: "ignore" }).unref();
			}
			return true;
		} catch {
			return false;
		}
	}
}
</file>

<file path="packages/cli-commands/package.json">
{
	"name": "@ccflare/cli-commands",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/core-di": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/oauth-flow": "workspace:*",
		"open": "^10.0.0"
	}
}
</file>

<file path="packages/core/src/validation.ts">
/**
 * Input validation and sanitization utilities
 */
import { ValidationError } from "./errors";

/**
 * Validates and sanitizes a string input
 */
export function validateString(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		minLength?: number;
		maxLength?: number;
		pattern?: RegExp;
		allowedValues?: readonly string[];
		transform?: (value: string) => string;
	} = {},
): string | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Ensure it's a string
	if (typeof value !== "string") {
		throw new ValidationError(`${field} must be a string`, field, value);
	}

	// Apply transformation if provided
	const sanitized = options.transform ? options.transform(value) : value;

	// Validate length
	if (options.minLength !== undefined && sanitized.length < options.minLength) {
		throw new ValidationError(
			`${field} must be at least ${options.minLength} characters long`,
			field,
			value,
		);
	}

	if (options.maxLength !== undefined && sanitized.length > options.maxLength) {
		throw new ValidationError(
			`${field} must be at most ${options.maxLength} characters long`,
			field,
			value,
		);
	}

	// Validate pattern
	if (options.pattern && !options.pattern.test(sanitized)) {
		throw new ValidationError(`${field} has an invalid format`, field, value);
	}

	// Validate allowed values
	if (options.allowedValues && !options.allowedValues.includes(sanitized)) {
		throw new ValidationError(
			`${field} must be one of: ${options.allowedValues.join(", ")}`,
			field,
			value,
		);
	}

	return sanitized;
}

/**
 * Validates and sanitizes a number input
 */
export function validateNumber(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		min?: number;
		max?: number;
		integer?: boolean;
		allowedValues?: readonly number[];
	} = {},
): number | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Convert string to number if needed
	let num: number;
	if (typeof value === "string") {
		num = Number(value);
		if (Number.isNaN(num)) {
			throw new ValidationError(
				`${field} must be a valid number`,
				field,
				value,
			);
		}
	} else if (typeof value === "number") {
		num = value;
	} else {
		throw new ValidationError(`${field} must be a number`, field, value);
	}

	// Validate integer
	if (options.integer && !Number.isInteger(num)) {
		throw new ValidationError(`${field} must be an integer`, field, value);
	}

	// Validate range
	if (options.min !== undefined && num < options.min) {
		throw new ValidationError(
			`${field} must be at least ${options.min}`,
			field,
			value,
		);
	}

	if (options.max !== undefined && num > options.max) {
		throw new ValidationError(
			`${field} must be at most ${options.max}`,
			field,
			value,
		);
	}

	// Validate allowed values
	if (options.allowedValues && !options.allowedValues.includes(num)) {
		throw new ValidationError(
			`${field} must be one of: ${options.allowedValues.join(", ")}`,
			field,
			value,
		);
	}

	return num;
}

/**
 * Validates and sanitizes a boolean input
 */
export function validateBoolean(
	value: unknown,
	field: string,
	options: { required?: boolean } = {},
): boolean | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Handle boolean
	if (typeof value === "boolean") {
		return value;
	}

	// Handle string booleans
	if (typeof value === "string") {
		const lower = value.toLowerCase();
		if (lower === "true" || lower === "1" || lower === "yes") {
			return true;
		}
		if (lower === "false" || lower === "0" || lower === "no") {
			return false;
		}
	}

	// Handle numbers
	if (typeof value === "number") {
		return value !== 0;
	}

	throw new ValidationError(`${field} must be a boolean`, field, value);
}

/**
 * Validates and sanitizes an array input
 */
export function validateArray<T>(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		minLength?: number;
		maxLength?: number;
		itemValidator?: (item: unknown, index: number) => T;
	} = {},
): T[] | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Ensure it's an array
	if (!Array.isArray(value)) {
		throw new ValidationError(`${field} must be an array`, field, value);
	}

	// Validate length
	if (options.minLength !== undefined && value.length < options.minLength) {
		throw new ValidationError(
			`${field} must contain at least ${options.minLength} items`,
			field,
			value,
		);
	}

	if (options.maxLength !== undefined && value.length > options.maxLength) {
		throw new ValidationError(
			`${field} must contain at most ${options.maxLength} items`,
			field,
			value,
		);
	}

	// Validate items
	if (options.itemValidator) {
		return value.map((item, index) => {
			try {
				return options.itemValidator?.(item, index);
			} catch (error) {
				if (error instanceof ValidationError) {
					throw new ValidationError(
						`${field}[${index}]: ${error.message}`,
						`${field}[${index}]`,
						item,
					);
				}
				throw error;
			}
		}) as T[];
	}

	return value as T[];
}

/**
 * Validates and sanitizes an object input
 */
export function validateObject<T extends Record<string, unknown>>(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		schema?: {
			[K in keyof T]: (value: unknown) => T[K];
		};
	} = {},
): T | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Ensure it's an object
	if (typeof value !== "object" || Array.isArray(value)) {
		throw new ValidationError(`${field} must be an object`, field, value);
	}

	// Validate schema
	if (options.schema) {
		const result = {} as T;
		const obj = value as Record<string, unknown>;

		for (const [key, validator] of Object.entries(options.schema)) {
			try {
				result[key as keyof T] = validator(obj[key]);
			} catch (error) {
				if (error instanceof ValidationError) {
					throw new ValidationError(
						`${field}.${key}: ${error.message}`,
						`${field}.${key}`,
						obj[key],
					);
				}
				throw error;
			}
		}

		return result;
	}

	return value as T;
}

/**
 * Common string sanitizers
 */
export const sanitizers = {
	trim: (value: string) => value.trim(),
	lowercase: (value: string) => value.toLowerCase(),
	uppercase: (value: string) => value.toUpperCase(),
	removeWhitespace: (value: string) => value.replace(/\s+/g, ""),
	alphanumeric: (value: string) => value.replace(/[^a-zA-Z0-9]/g, ""),
	alphanumericWithSpaces: (value: string) =>
		value.replace(/[^a-zA-Z0-9\s]/g, ""),
	email: (value: string) => value.trim().toLowerCase(),
	url: (value: string) => {
		try {
			const parsed = new URL(value);
			return parsed.toString();
		} catch {
			throw new ValidationError("Invalid URL format", "url", value);
		}
	},
};

/**
 * Common validation patterns
 */
export const patterns = {
	email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
	uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
	alphanumeric: /^[a-zA-Z0-9]+$/,
	alphanumericWithSpaces: /^[a-zA-Z0-9\s]+$/,
	// Account name: alphanumeric with spaces, hyphens, underscores, plus @ and . for email addresses
	accountName: /^[a-zA-Z0-9\s\-_@.+]+$/,
	// Path pattern for API endpoints
	apiPath: /^\/v1\/[a-zA-Z0-9\-_/]*$/,
};
</file>

<file path="packages/dashboard-web/src/components/accounts/AccountAddForm.tsx">
import { useState } from "react";
import { Button } from "../ui/button";
import { Input } from "../ui/input";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";

interface AccountAddFormProps {
	onAddAccount: (params: {
		name: string;
		mode: "max" | "console";
		tier: number;
	}) => Promise<{ authUrl: string; sessionId: string }>;
	onCompleteAccount: (params: {
		sessionId: string;
		code: string;
	}) => Promise<void>;
	onCancel: () => void;
	onSuccess: () => void;
	onError: (error: string) => void;
}

export function AccountAddForm({
	onAddAccount,
	onCompleteAccount,
	onCancel,
	onSuccess,
	onError,
}: AccountAddFormProps) {
	const [authStep, setAuthStep] = useState<"form" | "code">("form");
	const [authCode, setAuthCode] = useState("");
	const [sessionId, setSessionId] = useState("");
	const [newAccount, setNewAccount] = useState({
		name: "",
		mode: "max" as "max" | "console",
		tier: 1,
	});

	const handleAddAccount = async () => {
		if (!newAccount.name) {
			onError("Account name is required");
			return;
		}
		// Step 1: Initialize OAuth flow
		const { authUrl, sessionId } = await onAddAccount(newAccount);
		setSessionId(sessionId);

		// Open auth URL in new tab
		if (typeof window !== "undefined") {
			window.open(authUrl, "_blank");
		}

		// Move to code entry step
		setAuthStep("code");
	};

	const handleCodeSubmit = async () => {
		if (!authCode) {
			onError("Authorization code is required");
			return;
		}
		// Step 2: Complete OAuth flow
		await onCompleteAccount({
			sessionId,
			code: authCode,
		});

		// Success! Reset form
		setAuthStep("form");
		setAuthCode("");
		setSessionId("");
		setNewAccount({ name: "", mode: "max", tier: 1 });
		onSuccess();
	};

	const handleCancel = () => {
		setAuthStep("form");
		setAuthCode("");
		setSessionId("");
		setNewAccount({ name: "", mode: "max", tier: 1 });
		onCancel();
	};

	return (
		<div className="space-y-4 mb-6 p-4 border rounded-lg">
			<h4 className="font-medium">
				{authStep === "form" ? "Add New Account" : "Enter Authorization Code"}
			</h4>
			{authStep === "form" && (
				<>
					<div className="space-y-2">
						<Label htmlFor="name">Account Name</Label>
						<Input
							id="name"
							value={newAccount.name}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
								setNewAccount({
									...newAccount,
									name: (e.target as HTMLInputElement).value,
								})
							}
							placeholder="e.g., work-account or user@example.com"
						/>
					</div>
					<div className="space-y-2">
						<Label htmlFor="mode">Mode</Label>
						<Select
							value={newAccount.mode}
							onValueChange={(value: "max" | "console") =>
								setNewAccount({ ...newAccount, mode: value })
							}
						>
							<SelectTrigger id="mode">
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="max">Max (Recommended)</SelectItem>
								<SelectItem value="console">Console</SelectItem>
							</SelectContent>
						</Select>
					</div>
					<div className="space-y-2">
						<Label htmlFor="tier">Tier</Label>
						<Select
							value={String(newAccount.tier)}
							onValueChange={(value: string) =>
								setNewAccount({ ...newAccount, tier: parseInt(value) })
							}
						>
							<SelectTrigger id="tier">
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="1">Tier 1 (Default)</SelectItem>
								<SelectItem value="5">Tier 5</SelectItem>
								<SelectItem value="20">Tier 20</SelectItem>
							</SelectContent>
						</Select>
					</div>
				</>
			)}
			{authStep === "form" ? (
				<div className="flex gap-2">
					<Button onClick={handleAddAccount}>Continue</Button>
					<Button variant="outline" onClick={handleCancel}>
						Cancel
					</Button>
				</div>
			) : (
				<>
					<div className="space-y-2">
						<p className="text-sm text-muted-foreground">
							A new browser tab has opened for authentication. After
							authorizing, copy the code and paste it below.
						</p>
						<Label htmlFor="code">Authorization Code</Label>
						<Input
							id="code"
							value={authCode}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
								setAuthCode((e.target as HTMLInputElement).value)
							}
							placeholder="Paste authorization code here"
						/>
					</div>
					<div className="flex gap-2">
						<Button onClick={handleCodeSubmit}>Complete Setup</Button>
						<Button variant="outline" onClick={handleCancel}>
							Cancel
						</Button>
					</div>
				</>
			)}
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/accounts/RateLimitProgress.tsx">
import { useEffect, useState } from "react";
import { cn } from "../../lib/utils";
import { Progress } from "../ui/progress";

interface RateLimitProgressProps {
	resetIso: string | null;
	className?: string;
}

const WINDOW_MS = 5 * 60 * 60 * 1000; // 5 hours in milliseconds

export function RateLimitProgress({
	resetIso,
	className,
}: RateLimitProgressProps) {
	const [now, setNow] = useState(Date.now());

	useEffect(() => {
		const interval = setInterval(() => setNow(Date.now()), 10000); // Update every 10 seconds
		return () => clearInterval(interval);
	}, []);

	if (!resetIso) return null;

	const resetTime = new Date(resetIso).getTime();
	const startTime = resetTime - WINDOW_MS;
	const elapsed = now - startTime;
	const percentage = Math.min(100, Math.max(0, (elapsed / WINDOW_MS) * 100));
	const remainingMs = Math.max(0, resetTime - now);
	const remainingMinutes = Math.ceil(remainingMs / 60000);
	const remainingHours = Math.floor(remainingMinutes / 60);
	const remainingMins = remainingMinutes % 60;

	// Format time remaining
	let timeText = "";
	if (remainingMs <= 0) {
		timeText = "Ready to refresh";
	} else if (remainingHours > 0) {
		timeText = `${remainingHours}h ${remainingMins}m until refresh`;
	} else {
		timeText = `${remainingMinutes}m until refresh`;
	}

	return (
		<div className={cn("space-y-2", className)}>
			<div className="flex items-center justify-between">
				<span className="text-xs text-muted-foreground">Rate limit window</span>
				<span className="text-xs font-medium text-muted-foreground">
					{percentage.toFixed(0)}%
				</span>
			</div>
			<Progress value={percentage} className="h-2" />
			<div className="flex items-center justify-between">
				<span className="text-xs text-muted-foreground">{timeText}</span>
				{remainingMs > 0 && (
					<span className="text-xs text-muted-foreground">
						Resets at {new Date(resetTime).toLocaleTimeString()}
					</span>
				)}
			</div>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/accounts/RenameAccountDialog.tsx">
import { useState } from "react";
import { Button } from "../ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "../ui/dialog";
import { Input } from "../ui/input";
import { Label } from "../ui/label";

interface RenameAccountDialogProps {
	isOpen: boolean;
	currentName: string;
	onClose: () => void;
	onRename: (newName: string) => void;
	isLoading?: boolean;
}

export function RenameAccountDialog({
	isOpen,
	currentName,
	onClose,
	onRename,
	isLoading = false,
}: RenameAccountDialogProps) {
	const [newName, setNewName] = useState(currentName);
	const [error, setError] = useState("");

	const handleSubmit = (e: React.FormEvent) => {
		e.preventDefault();

		// Validate new name
		const trimmedName = newName.trim();
		if (!trimmedName) {
			setError("Account name cannot be empty");
			return;
		}
		if (trimmedName === currentName) {
			setError("New name must be different from current name");
			return;
		}
		if (trimmedName.length > 100) {
			setError("Account name must be 100 characters or less");
			return;
		}

		setError("");
		onRename(trimmedName);
	};

	const handleOpenChange = (open: boolean) => {
		if (!open) {
			setNewName(currentName);
			setError("");
			onClose();
		}
	};

	return (
		<Dialog open={isOpen} onOpenChange={handleOpenChange}>
			<DialogContent>
				<form onSubmit={handleSubmit}>
					<DialogHeader>
						<DialogTitle>Rename Account</DialogTitle>
						<DialogDescription>
							Enter a new name for account "{currentName}"
						</DialogDescription>
					</DialogHeader>
					<div className="grid gap-4 py-4">
						<div className="grid gap-2">
							<Label htmlFor="new-name">New Name</Label>
							<Input
								id="new-name"
								value={newName}
								onChange={(e) => {
									setNewName(e.target.value);
									setError("");
								}}
								placeholder="Enter new account name"
								autoFocus
								disabled={isLoading}
							/>
							{error && <p className="text-sm text-destructive">{error}</p>}
						</div>
					</div>
					<DialogFooter>
						<Button
							type="button"
							variant="outline"
							onClick={() => handleOpenChange(false)}
							disabled={isLoading}
						>
							Cancel
						</Button>
						<Button type="submit" disabled={isLoading}>
							{isLoading ? "Renaming..." : "Rename"}
						</Button>
					</DialogFooter>
				</form>
			</DialogContent>
		</Dialog>
	);
}
</file>

<file path="packages/dashboard-web/src/components/agents/index.ts">
export { AgentCard } from "./AgentCard";
export { AgentEditDialog } from "./AgentEditDialog";
export { WorkspaceCard } from "./WorkspaceCard";
</file>

<file path="packages/dashboard-web/src/components/analytics/TokenSpeedAnalytics.tsx">
import { formatTokensPerSecond } from "@ccflare/ui-common";
import { Activity, Zap } from "lucide-react";
import type { TimeRange } from "../../constants";
import { ModelTokenSpeedChart } from "../charts/ModelTokenSpeedChart";
import { TokenSpeedChart } from "../charts/TokenSpeedChart";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";

interface TokenSpeedAnalyticsProps {
	timeSeriesData: Array<{
		time: string;
		avgTokensPerSecond: number;
		[key: string]: string | number;
	}>;
	modelPerformance: Array<{
		model: string;
		avgTokensPerSecond: number | null;
		minTokensPerSecond: number | null;
		maxTokensPerSecond: number | null;
	}>;
	loading?: boolean;
	timeRange: TimeRange;
}

export function TokenSpeedAnalytics({
	timeSeriesData,
	modelPerformance,
	loading = false,
	timeRange,
}: TokenSpeedAnalyticsProps) {
	// Calculate overall statistics
	const validSpeeds = timeSeriesData
		.map((d) => d.avgTokensPerSecond)
		.filter((speed) => speed > 0);

	const overallAvgSpeed =
		validSpeeds.length > 0
			? validSpeeds.reduce((sum, speed) => sum + speed, 0) / validSpeeds.length
			: 0;

	// Get the true maximum speed from model performance data
	const maxSpeed = Math.max(
		...modelPerformance
			.map((m) => m.maxTokensPerSecond || 0)
			.filter((speed) => speed > 0),
		0,
	);

	// Find fastest model by peak speed
	const fastestModel = modelPerformance
		.filter((m) => m.maxTokensPerSecond !== null && m.maxTokensPerSecond > 0)
		.sort(
			(a, b) => (b.maxTokensPerSecond || 0) - (a.maxTokensPerSecond || 0),
		)[0];

	return (
		<div className="space-y-6">
			{/* Statistics Cards */}
			<div className="grid grid-cols-1 md:grid-cols-3 gap-4">
				<Card>
					<CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
						<CardTitle className="text-sm font-medium">
							Average Output Speed
						</CardTitle>
						<Activity className="h-4 w-4 text-muted-foreground" />
					</CardHeader>
					<CardContent>
						<div className="text-2xl font-bold">
							{formatTokensPerSecond(overallAvgSpeed)}
						</div>
						<p className="text-xs text-muted-foreground">
							Across all models and requests
						</p>
					</CardContent>
				</Card>

				<Card>
					<CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
						<CardTitle className="text-sm font-medium">Peak Speed</CardTitle>
						<Zap className="h-4 w-4 text-muted-foreground" />
					</CardHeader>
					<CardContent>
						<div className="text-2xl font-bold">
							{formatTokensPerSecond(maxSpeed)}
						</div>
						<p className="text-xs text-muted-foreground">
							Maximum observed in {timeRange}
						</p>
					</CardContent>
				</Card>

				<Card>
					<CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
						<CardTitle className="text-sm font-medium">Fastest Model</CardTitle>
						<Zap className="h-4 w-4 text-muted-foreground" />
					</CardHeader>
					<CardContent>
						<div className="text-2xl font-bold">
							{fastestModel?.model || "N/A"}
						</div>
						<p className="text-xs text-muted-foreground">
							{fastestModel
								? `Peak: ${formatTokensPerSecond(fastestModel.maxTokensPerSecond || 0)}`
								: "No data"}
						</p>
					</CardContent>
				</Card>
			</div>

			{/* Charts */}
			<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
				<Card>
					<CardHeader>
						<CardTitle className="flex items-center gap-2">
							<Activity className="h-5 w-5" />
							Output Speed Over Time
						</CardTitle>
					</CardHeader>
					<CardContent>
						<TokenSpeedChart
							data={timeSeriesData}
							loading={loading}
							height={300}
							timeRange={timeRange}
						/>
					</CardContent>
				</Card>

				<Card>
					<CardHeader>
						<CardTitle className="flex items-center gap-2">
							<Zap className="h-5 w-5" />
							Speed by Model
						</CardTitle>
					</CardHeader>
					<CardContent>
						<ModelTokenSpeedChart
							data={modelPerformance}
							loading={loading}
							height={300}
						/>
					</CardContent>
				</Card>
			</div>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/BaseAreaChart.tsx">
import type { ReactNode } from "react";
import {
	Area,
	AreaChart,
	CartesianGrid,
	Legend,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import {
	type CommonChartProps,
	getChartHeight,
	getTooltipStyles,
	isChartEmpty,
} from "./chart-utils";

interface BaseAreaChartProps extends CommonChartProps {
	dataKey: string;
	color?: string;
	gradientId?: string;
	customGradient?: ReactNode;
	strokeWidth?: number;
	fillOpacity?: number;
}

export function BaseAreaChart({
	data,
	dataKey,
	xAxisKey = "time",
	loading = false,
	height = "medium",
	color = COLORS.primary,
	gradientId = "colorGradient",
	customGradient,
	strokeWidth = 2,
	fillOpacity = 1,
	xAxisAngle = 0,
	xAxisTextAnchor = "middle",
	xAxisHeight = 30,
	xAxisTickFormatter,
	yAxisDomain,
	yAxisTickFormatter,
	tooltipFormatter,
	tooltipLabelFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	showLegend = false,
	legendHeight = 36,
	margin,
	className = "",
	error = null,
	emptyState,
	onChartClick,
}: BaseAreaChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = isChartEmpty(data);
	const tooltipStyles = getTooltipStyles(tooltipStyle);

	const defaultGradient = (
		<linearGradient id={gradientId} x1="0" y1="0" x2="0" y2="1">
			<stop offset="5%" stopColor={color} stopOpacity={0.8} />
			<stop offset="95%" stopColor={color} stopOpacity={0.1} />
		</linearGradient>
	);

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<AreaChart data={data} margin={margin} onClick={onChartClick}>
					<defs>{customGradient || defaultGradient}</defs>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						className={CHART_PROPS.gridClassName}
					/>
					<XAxis
						dataKey={xAxisKey}
						className="text-xs"
						angle={xAxisAngle}
						textAnchor={xAxisTextAnchor}
						height={xAxisHeight}
						tickFormatter={xAxisTickFormatter}
					/>
					<YAxis
						className="text-xs"
						domain={yAxisDomain}
						tickFormatter={yAxisTickFormatter}
					/>
					<Tooltip
						contentStyle={tooltipStyles}
						formatter={tooltipFormatter}
						labelFormatter={tooltipLabelFormatter}
					/>
					{showLegend && <Legend height={legendHeight} />}
					<Area
						type="monotone"
						dataKey={dataKey}
						stroke={color}
						strokeWidth={strokeWidth}
						fillOpacity={fillOpacity}
						fill={`url(#${gradientId})`}
						animationDuration={animationDuration}
					/>
				</AreaChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/BaseBarChart.tsx">
import {
	Bar,
	BarChart,
	CartesianGrid,
	Legend,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import {
	type CommonChartProps,
	getChartHeight,
	getTooltipStyles,
	isChartEmpty,
} from "./chart-utils";

interface BarConfig {
	dataKey: string;
	fill?: string;
	name?: string;
	yAxisId?: string;
	radius?: [number, number, number, number];
}

interface BaseBarChartProps extends CommonChartProps {
	bars: BarConfig | BarConfig[];
	layout?: "horizontal" | "vertical";
	xAxisType?: "number" | "category";
	yAxisType?: "number" | "category";
	yAxisWidth?: number;
	yAxisOrientation?: "left" | "right";
	secondaryYAxis?: boolean;
}

export function BaseBarChart({
	data,
	bars,
	xAxisKey = "name",
	loading = false,
	height = "medium",
	layout = "horizontal",
	xAxisAngle = 0,
	xAxisTextAnchor = "middle",
	xAxisHeight = 30,
	xAxisTickFormatter,
	xAxisType = layout === "vertical" ? "number" : "category",
	yAxisType = layout === "vertical" ? "category" : "number",
	yAxisWidth,
	yAxisDomain,
	yAxisTickFormatter,
	yAxisOrientation = "left",
	secondaryYAxis = false,
	tooltipFormatter,
	tooltipLabelFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	showLegend = false,
	legendHeight = 36,
	margin,
	className = "",
	error = null,
	emptyState,
	onChartClick,
}: BaseBarChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = isChartEmpty(data);
	const tooltipStyles = getTooltipStyles(tooltipStyle);
	const barConfigs = Array.isArray(bars) ? bars : [bars];

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<BarChart
					data={data}
					layout={layout}
					margin={margin}
					onClick={onChartClick}
				>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						className={CHART_PROPS.gridClassName}
					/>
					{layout === "vertical" ? (
						<>
							<XAxis
								type={xAxisType as "number"}
								className="text-xs"
								tickFormatter={xAxisTickFormatter}
							/>
							<YAxis
								dataKey={xAxisKey}
								type={yAxisType as "category"}
								className="text-xs"
								width={yAxisWidth}
								tickFormatter={yAxisTickFormatter}
							/>
						</>
					) : (
						<>
							<XAxis
								dataKey={xAxisKey}
								type={xAxisType as "category"}
								className="text-xs"
								angle={xAxisAngle}
								textAnchor={xAxisTextAnchor}
								height={xAxisHeight}
								tickFormatter={xAxisTickFormatter}
							/>
							<YAxis
								yAxisId={secondaryYAxis ? "left" : undefined}
								type={yAxisType as "number"}
								className="text-xs"
								domain={yAxisDomain}
								orientation={yAxisOrientation}
								tickFormatter={yAxisTickFormatter}
							/>
							{secondaryYAxis && (
								<YAxis
									yAxisId="right"
									orientation="right"
									className="text-xs"
									tickFormatter={yAxisTickFormatter}
								/>
							)}
						</>
					)}
					<Tooltip
						contentStyle={tooltipStyles}
						formatter={tooltipFormatter}
						labelFormatter={tooltipLabelFormatter}
					/>
					{showLegend && <Legend height={legendHeight} />}
					{barConfigs.map((barConfig) => (
						<Bar
							key={barConfig.dataKey}
							dataKey={barConfig.dataKey}
							fill={barConfig.fill || COLORS.primary}
							name={barConfig.name || barConfig.dataKey}
							yAxisId={barConfig.yAxisId}
							radius={barConfig.radius}
							animationDuration={animationDuration}
						/>
					))}
				</BarChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/BaseLineChart.tsx">
import {
	CartesianGrid,
	Legend,
	Line,
	LineChart,
	ReferenceLine,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import {
	type CommonChartProps,
	getChartHeight,
	getTooltipStyles,
	isChartEmpty,
} from "./chart-utils";

interface LineConfig {
	dataKey: string;
	stroke?: string;
	strokeWidth?: number;
	dot?: boolean;
	name?: string;
}

interface ReferenceLineConfig {
	y: number;
	stroke?: string;
	strokeDasharray?: string;
	label?: string;
}

interface BaseLineChartProps extends CommonChartProps {
	lines: LineConfig | LineConfig[];
	referenceLines?: ReferenceLineConfig[];
}

export function BaseLineChart({
	data,
	lines,
	xAxisKey = "time",
	loading = false,
	height = "medium",
	xAxisAngle = 0,
	xAxisTextAnchor = "middle",
	xAxisHeight = 30,
	xAxisTickFormatter,
	yAxisDomain,
	yAxisTickFormatter,
	tooltipFormatter,
	tooltipLabelFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	showLegend = false,
	legendHeight = 36,
	referenceLines = [],
	margin,
	className = "",
	error = null,
	emptyState,
	onChartClick,
}: BaseLineChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = isChartEmpty(data);
	const tooltipStyles = getTooltipStyles(tooltipStyle);
	const lineConfigs = Array.isArray(lines) ? lines : [lines];

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<LineChart data={data} margin={margin} onClick={onChartClick}>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						className={CHART_PROPS.gridClassName}
					/>
					<XAxis
						dataKey={xAxisKey}
						className="text-xs"
						angle={xAxisAngle}
						textAnchor={xAxisTextAnchor}
						height={xAxisHeight}
						tickFormatter={xAxisTickFormatter}
					/>
					<YAxis
						className="text-xs"
						domain={yAxisDomain}
						tickFormatter={yAxisTickFormatter}
					/>
					<Tooltip
						contentStyle={tooltipStyles}
						formatter={tooltipFormatter}
						labelFormatter={tooltipLabelFormatter}
					/>
					{showLegend && <Legend height={legendHeight} />}
					{lineConfigs.map((lineConfig, _index) => (
						<Line
							key={lineConfig.dataKey}
							type="monotone"
							dataKey={lineConfig.dataKey}
							stroke={lineConfig.stroke || COLORS.primary}
							strokeWidth={lineConfig.strokeWidth || 2}
							dot={lineConfig.dot ?? false}
							name={lineConfig.name || lineConfig.dataKey}
							animationDuration={animationDuration}
						/>
					))}
					{referenceLines.map((refLine) => (
						<ReferenceLine
							key={`ref-line-${refLine.y}`}
							y={refLine.y}
							stroke={refLine.stroke || COLORS.primary}
							strokeDasharray={
								refLine.strokeDasharray || CHART_PROPS.strokeDasharray
							}
							label={refLine.label}
						/>
					))}
				</LineChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/BaseScatterChart.tsx">
import type { ReactNode } from "react";
import {
	CartesianGrid,
	ResponsiveContainer,
	Scatter,
	ScatterChart,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import {
	type CHART_HEIGHTS,
	CHART_PROPS,
	type CHART_TOOLTIP_STYLE,
	COLORS,
} from "../../constants";
import { ChartContainer } from "./ChartContainer";
import { getChartHeight, getTooltipStyles, isChartEmpty } from "./chart-utils";
import type {
	ChartClickHandler,
	ChartDataPoint,
	TooltipFormatterFunction,
} from "./types";

interface BaseScatterChartProps {
	data: ChartDataPoint[];
	xKey: string;
	yKey: string;
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	fill?: string;
	xAxisLabel?: string;
	yAxisLabel?: string;
	xAxisDomain?: [number | "auto", number | "auto"];
	xAxisTickFormatter?: (value: number | string) => string;
	yAxisDomain?: [number | "auto", number | "auto"];
	yAxisTickFormatter?: (value: number | string) => string;
	tooltipFormatter?: TooltipFormatterFunction;
	tooltipStyle?: keyof typeof CHART_TOOLTIP_STYLE | object;
	animationDuration?: number;
	margin?: { top?: number; right?: number; bottom?: number; left?: number };
	className?: string;
	error?: Error | null;
	emptyState?: ReactNode;
	onDotClick?: ChartClickHandler;
	renderLabel?: (entry: ChartDataPoint) => ReactNode;
}

export function BaseScatterChart({
	data,
	xKey,
	yKey,
	loading = false,
	height = "medium",
	fill = COLORS.primary,
	xAxisLabel,
	yAxisLabel,
	xAxisDomain,
	xAxisTickFormatter,
	yAxisDomain,
	yAxisTickFormatter,
	tooltipFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	margin,
	className = "",
	error = null,
	emptyState,
	onDotClick,
	renderLabel,
}: BaseScatterChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = isChartEmpty(data);
	const tooltipStyles = getTooltipStyles(tooltipStyle);

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<ScatterChart margin={margin}>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						className={CHART_PROPS.gridClassName}
					/>
					<XAxis
						dataKey={xKey}
						name={xAxisLabel || xKey}
						className="text-xs"
						domain={xAxisDomain}
						tickFormatter={xAxisTickFormatter}
						label={
							xAxisLabel
								? {
										value: xAxisLabel,
										position: "insideBottom",
										offset: -5,
									}
								: undefined
						}
					/>
					<YAxis
						dataKey={yKey}
						name={yAxisLabel || yKey}
						className="text-xs"
						domain={yAxisDomain}
						tickFormatter={yAxisTickFormatter}
						label={
							yAxisLabel
								? {
										value: yAxisLabel,
										angle: -90,
										position: "insideLeft",
									}
								: undefined
						}
					/>
					<Tooltip contentStyle={tooltipStyles} formatter={tooltipFormatter} />
					<Scatter
						name="Data"
						data={data}
						fill={fill}
						animationDuration={animationDuration}
						onClick={onDotClick}
					>
						{renderLabel &&
							data.map((entry) => (
								<text
									key={`label-${entry[xKey]}-${entry[yKey]}`}
									x={entry[xKey]}
									y={entry[yKey]}
									dy={-10}
									textAnchor="middle"
									className="text-xs fill-foreground"
								>
									{renderLabel(entry)}
								</text>
							))}
					</Scatter>
				</ScatterChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/chart-utils.ts">
import { CHART_HEIGHTS, CHART_TOOLTIP_STYLE } from "../../constants";
import type { ChartClickHandler, ChartDataPoint } from "./types";

/**
 * Calculate chart height from height prop
 */
export function getChartHeight(
	height: keyof typeof CHART_HEIGHTS | number,
): number {
	return typeof height === "number" ? height : CHART_HEIGHTS[height];
}

/**
 * Check if chart data is empty
 */
export function isChartEmpty(data: ChartDataPoint[] | undefined): boolean {
	return !data || data.length === 0;
}

/**
 * Get tooltip styles from prop
 */
export function getTooltipStyles(
	tooltipStyle: keyof typeof CHART_TOOLTIP_STYLE | object,
): object {
	return typeof tooltipStyle === "string"
		? CHART_TOOLTIP_STYLE[tooltipStyle]
		: tooltipStyle;
}

/**
 * Common chart axis props
 */
export interface CommonAxisProps {
	xAxisKey?: string;
	xAxisAngle?: number;
	xAxisTextAnchor?: "start" | "middle" | "end";
	xAxisHeight?: number;
	xAxisTickFormatter?: (value: number | string) => string;
	yAxisDomain?: [number | "auto", number | "auto"];
	yAxisTickFormatter?: (value: number | string) => string;
}

/**
 * Common chart props shared across all chart types
 */
export interface CommonChartProps extends CommonAxisProps {
	data: ChartDataPoint[];
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	className?: string;
	error?: Error | null;
	emptyState?: React.ReactNode;
	margin?: { top?: number; right?: number; bottom?: number; left?: number };
	showLegend?: boolean;
	legendHeight?: number;
	tooltipFormatter?: (value: number, name: string) => [string, string];
	tooltipLabelFormatter?: (label: string) => string;
	tooltipStyle?: keyof typeof CHART_TOOLTIP_STYLE | object;
	animationDuration?: number;
	onChartClick?: ChartClickHandler;
}
</file>

<file path="packages/dashboard-web/src/components/charts/CostChart.tsx">
import { formatCost } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactCurrency } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";

interface CostChartProps {
	data: Array<{
		time: string;
		cost: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}

export function CostChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: CostChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	const gradient = (
		<linearGradient id="colorCost" x1="0" y1="0" x2="0" y2="1">
			<stop
				offset="0%"
				stopColor={viewMode === "cumulative" ? COLORS.warning : COLORS.primary}
				stopOpacity={0.9}
			/>
			<stop
				offset="100%"
				stopColor={viewMode === "cumulative" ? COLORS.warning : COLORS.primary}
				stopOpacity={0.1}
			/>
		</linearGradient>
	);

	return (
		<BaseAreaChart
			data={data}
			dataKey="cost"
			loading={loading}
			height={height}
			color={viewMode === "cumulative" ? COLORS.warning : COLORS.primary}
			gradientId="colorCost"
			customGradient={gradient}
			strokeWidth={viewMode === "cumulative" ? 3 : 2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			yAxisTickFormatter={formatCompactCurrency}
			tooltipFormatter={(value) => [formatCost(Number(value)), "Cost"]}
			tooltipLabelFormatter={(label) =>
				viewMode === "cumulative" ? `Cumulative at ${label}` : label
			}
			animationDuration={1000}
		/>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/ModelPerformanceChart.tsx">
import { formatPercentage } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseScatterChart } from "./BaseScatterChart";

interface ModelPerformanceChartProps {
	data: Array<{
		model: string;
		avgTime: number;
		errorRate: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
}

export function ModelPerformanceChart({
	data,
	loading = false,
	height = 300,
}: ModelPerformanceChartProps) {
	return (
		<BaseScatterChart
			data={data}
			xKey="avgTime"
			yKey="errorRate"
			loading={loading}
			height={height}
			fill={COLORS.primary}
			xAxisLabel="Avg Response Time (ms)"
			xAxisTickFormatter={formatCompactNumber}
			yAxisLabel="Error Rate %"
			tooltipFormatter={(value, name) => {
				if (name === "avgTime") return [`${value}ms`, "Avg Time"];
				if (name === "errorRate")
					return [formatPercentage(Number(value)), "Error Rate"];
				return [`${value}`, name || ""];
			}}
			tooltipStyle={{
				backgroundColor: COLORS.success,
				border: `1px solid ${COLORS.success}`,
				borderRadius: "var(--radius)",
				color: "#fff",
			}}
			renderLabel={(entry) => entry.model}
		/>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/ModelPerformanceComparison.tsx">
import { getModelShortName } from "@ccflare/core";
import { formatCost, formatTokensPerSecond } from "@ccflare/ui-common";
import {
	Area,
	AreaChart,
	Bar,
	CartesianGrid,
	ComposedChart,
	Legend,
	Line,
	ResponsiveContainer,
	Scatter,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_HEIGHTS, CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import { getTooltipStyles } from "./chart-utils";

interface ModelComparisonData {
	model: string;
	avgTokensPerSecond: number | null;
	costPer1kTokens: number;
	avgResponseTime: number;
	errorRate: number;
	totalRequests: number;
}

interface ModelPerformanceComparisonProps {
	data: ModelComparisonData[];
	loading?: boolean;
	height?: number;
	viewMode?: "speed-cost" | "performance" | "efficiency";
}

// Model-based color palette
const MODEL_COLORS: Record<string, string> = {
	"claude-3.5-sonnet": COLORS.purple,
	"claude-3.5-haiku": COLORS.success,
	"claude-3-opus": COLORS.blue,
	"claude-opus-4": COLORS.pink,
};

function getModelColor(model: string): string {
	// Try to find color by short name first
	const shortName = getModelShortName(model);
	if (MODEL_COLORS[shortName]) return MODEL_COLORS[shortName];

	// Check for exact match
	if (MODEL_COLORS[model]) return MODEL_COLORS[model];

	// Check for partial matches
	for (const [key, color] of Object.entries(MODEL_COLORS)) {
		if (model.includes(key) || key.includes(model)) {
			return color;
		}
	}

	return COLORS.primary;
}

export function ModelPerformanceComparison({
	data,
	loading = false,
	height = CHART_HEIGHTS.large,
	viewMode = "speed-cost",
}: ModelPerformanceComparisonProps) {
	// Filter and prepare data
	const chartData = data
		.filter((d) => d.avgTokensPerSecond !== null && d.avgTokensPerSecond > 0)
		.sort((a, b) => (b.avgTokensPerSecond || 0) - (a.avgTokensPerSecond || 0));

	if (viewMode === "speed-cost") {
		return (
			<ChartContainer
				loading={loading}
				height={height}
				isEmpty={chartData.length === 0}
				emptyState={
					<div className="text-muted-foreground">
						No model performance data available
					</div>
				}
			>
				<ResponsiveContainer width="100%" height={height}>
					<ComposedChart
						data={chartData}
						margin={{ top: 20, right: 30, left: 20, bottom: 80 }}
					>
						<defs>
							<linearGradient id="speedGradient" x1="0" y1="0" x2="0" y2="1">
								<stop offset="0%" stopColor={COLORS.purple} stopOpacity={0.9} />
								<stop
									offset="100%"
									stopColor={COLORS.purple}
									stopOpacity={0.3}
								/>
							</linearGradient>
							<linearGradient id="costGradient" x1="0" y1="0" x2="0" y2="1">
								<stop
									offset="0%"
									stopColor={COLORS.warning}
									stopOpacity={0.9}
								/>
								<stop
									offset="100%"
									stopColor={COLORS.warning}
									stopOpacity={0.3}
								/>
							</linearGradient>
							<filter id="glow">
								<feGaussianBlur stdDeviation="3" result="coloredBlur" />
								<feMerge>
									<feMergeNode in="coloredBlur" />
									<feMergeNode in="SourceGraphic" />
								</feMerge>
							</filter>
						</defs>
						<CartesianGrid
							strokeDasharray={CHART_PROPS.strokeDasharray}
							stroke="rgba(255,255,255,0.1)"
						/>
						<XAxis
							dataKey="model"
							angle={-45}
							textAnchor="end"
							height={80}
							interval={0}
							fontSize={12}
							stroke="rgba(255,255,255,0.5)"
						/>
						<YAxis
							yAxisId="speed"
							orientation="left"
							stroke={COLORS.purple}
							fontSize={12}
							label={{
								value: "Tokens/Second",
								angle: -90,
								position: "insideLeft",
								style: { textAnchor: "middle", fill: COLORS.purple },
							}}
						/>
						<YAxis
							yAxisId="cost"
							orientation="right"
							stroke={COLORS.warning}
							fontSize={12}
							label={{
								value: "Cost per 1K Tokens ($)",
								angle: 90,
								position: "insideRight",
								style: { textAnchor: "middle", fill: COLORS.warning },
							}}
						/>
						<Tooltip
							contentStyle={{
								backgroundColor: "rgba(0,0,0,0.8)",
								border: "1px solid rgba(255,255,255,0.2)",
								borderRadius: "8px",
								backdropFilter: "blur(8px)",
							}}
							formatter={(value: number, name: string) => {
								if (name === "Speed")
									return [formatTokensPerSecond(value), name];
								if (name === "Cost/1K") return [formatCost(value), name];
								return [value, name];
							}}
						/>
						<Legend
							verticalAlign="top"
							height={36}
							iconType="rect"
							wrapperStyle={{ paddingBottom: "10px" }}
						/>
						<Bar
							yAxisId="speed"
							dataKey="avgTokensPerSecond"
							name="Speed"
							fill="url(#speedGradient)"
							filter="url(#glow)"
						/>
						<Line
							yAxisId="cost"
							type="monotone"
							dataKey="costPer1kTokens"
							name="Cost/1K"
							stroke={COLORS.warning}
							strokeWidth={3}
							dot={{ fill: COLORS.warning, r: 4 }}
							filter="url(#glow)"
						/>
					</ComposedChart>
				</ResponsiveContainer>
			</ChartContainer>
		);
	}

	if (viewMode === "performance") {
		return (
			<ChartContainer
				loading={loading}
				height={height}
				isEmpty={chartData.length === 0}
				emptyState={
					<div className="text-muted-foreground">
						No model performance data available
					</div>
				}
			>
				<ResponsiveContainer width="100%" height={height}>
					<ComposedChart
						data={chartData}
						margin={{ top: 20, right: 30, left: 20, bottom: 80 }}
					>
						<defs>
							<linearGradient id="responseGradient" x1="0" y1="0" x2="0" y2="1">
								<stop offset="0%" stopColor={COLORS.blue} stopOpacity={0.9} />
								<stop offset="100%" stopColor={COLORS.blue} stopOpacity={0.3} />
							</linearGradient>
						</defs>
						<CartesianGrid
							strokeDasharray={CHART_PROPS.strokeDasharray}
							className={CHART_PROPS.gridClassName}
						/>
						<XAxis
							dataKey="model"
							angle={-45}
							textAnchor="end"
							height={80}
							interval={0}
							fontSize={12}
						/>
						<YAxis
							yAxisId="time"
							orientation="left"
							fontSize={12}
							label={{
								value: "Response Time (ms)",
								angle: -90,
								position: "insideLeft",
								style: { textAnchor: "middle" },
							}}
						/>
						<YAxis
							yAxisId="error"
							orientation="right"
							fontSize={12}
							label={{
								value: "Error Rate (%)",
								angle: 90,
								position: "insideRight",
								style: { textAnchor: "middle" },
							}}
						/>
						<Tooltip
							contentStyle={getTooltipStyles("dark")}
							formatter={(value: number, name: string) => {
								if (name === "Response Time") return [`${value}ms`, name];
								if (name === "Error Rate") return [`${value}%`, name];
								return [value, name];
							}}
						/>
						<Legend verticalAlign="top" height={36} iconType="rect" />
						<Bar
							yAxisId="time"
							dataKey="avgResponseTime"
							name="Response Time"
							fill="url(#responseGradient)"
						/>
						<Scatter
							yAxisId="error"
							dataKey="errorRate"
							name="Error Rate"
							fill={COLORS.error}
						/>
					</ComposedChart>
				</ResponsiveContainer>
			</ChartContainer>
		);
	}

	// Efficiency view: Speed vs Cost scatter plot
	return (
		<ChartContainer
			loading={loading}
			height={height}
			isEmpty={chartData.length === 0}
			emptyState={
				<div className="text-muted-foreground">
					No model efficiency data available
				</div>
			}
		>
			<ResponsiveContainer width="100%" height={height}>
				<AreaChart
					data={chartData}
					margin={{ top: 20, right: 30, left: 60, bottom: 80 }}
				>
					<defs>
						{chartData.map((model, index) => (
							<linearGradient
								key={model.model}
								id={`gradient-${index}`}
								x1="0"
								y1="0"
								x2="0"
								y2="1"
							>
								<stop
									offset="0%"
									stopColor={getModelColor(model.model)}
									stopOpacity={0.9}
								/>
								<stop
									offset="100%"
									stopColor={getModelColor(model.model)}
									stopOpacity={0.1}
								/>
							</linearGradient>
						))}
					</defs>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						stroke="rgba(255,255,255,0.1)"
					/>
					<XAxis
						dataKey="model"
						angle={-45}
						textAnchor="end"
						height={80}
						interval={0}
						fontSize={12}
					/>
					<YAxis
						fontSize={12}
						label={{
							value: "Efficiency Score",
							angle: -90,
							position: "insideLeft",
							style: { textAnchor: "middle" },
						}}
					/>
					<Tooltip
						contentStyle={{
							backgroundColor: "rgba(0,0,0,0.8)",
							border: "1px solid rgba(255,255,255,0.2)",
							borderRadius: "8px",
							backdropFilter: "blur(8px)",
						}}
						content={({ active, payload }) => {
							if (!active || !payload?.[0]) return null;
							const data = payload[0].payload;
							return (
								<div className="p-3 space-y-1">
									<p className="font-semibold">{data.model}</p>
									<p className="text-sm">
										Speed: {formatTokensPerSecond(data.avgTokensPerSecond)}
									</p>
									<p className="text-sm">
										Cost/1K: {formatCost(data.costPer1kTokens)}
									</p>
									<p className="text-sm">
										Efficiency:{" "}
										{(
											(data.avgTokensPerSecond || 0) / data.costPer1kTokens
										).toFixed(2)}
									</p>
								</div>
							);
						}}
					/>
					<Area
						type="monotone"
						dataKey={(data: ModelComparisonData) =>
							(data.avgTokensPerSecond || 0) / data.costPer1kTokens
						}
						stroke={COLORS.primary}
						strokeWidth={2}
						fill="url(#gradient-0)"
						name="Efficiency Score"
					/>
				</AreaChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/RequestVolumeChart.tsx">
import { formatNumber } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";

interface RequestVolumeChartProps {
	data: Array<{
		time: string;
		requests: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}

export function RequestVolumeChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: RequestVolumeChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	const gradient =
		viewMode === "cumulative" ? (
			<linearGradient id="colorRequests" x1="0" y1="0" x2="0" y2="1">
				<stop offset="0%" stopColor={COLORS.purple} stopOpacity={0.9} />
				<stop offset="50%" stopColor={COLORS.primary} stopOpacity={0.7} />
				<stop offset="100%" stopColor={COLORS.blue} stopOpacity={0.3} />
			</linearGradient>
		) : undefined;

	return (
		<BaseAreaChart
			data={data}
			dataKey="requests"
			loading={loading}
			height={height}
			color={viewMode === "cumulative" ? COLORS.purple : COLORS.primary}
			gradientId="colorRequests"
			customGradient={gradient}
			strokeWidth={viewMode === "cumulative" ? 3 : 2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			yAxisTickFormatter={formatCompactNumber}
			tooltipFormatter={(value) => [formatNumber(value as number), "Requests"]}
			tooltipLabelFormatter={(label) =>
				viewMode === "cumulative" ? `Cumulative at ${label}` : label
			}
			animationDuration={1000}
		/>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/TokenSpeedChart.tsx">
import { formatTokensPerSecond } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";

interface TokenSpeedChartProps {
	data: Array<{
		time: string;
		avgTokensPerSecond: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	timeRange?: string;
}

export function TokenSpeedChart({
	data,
	loading = false,
	height = 400,
	timeRange = "24h",
}: TokenSpeedChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	// Filter out null values for better chart display
	const filteredData = data.map((point) => ({
		...point,
		avgTokensPerSecond: point.avgTokensPerSecond || 0,
	}));

	const gradient = (
		<linearGradient id="colorSpeed" x1="0" y1="0" x2="0" y2="1">
			<stop offset="0%" stopColor={COLORS.purple} stopOpacity={0.9} />
			<stop offset="100%" stopColor={COLORS.purple} stopOpacity={0.1} />
		</linearGradient>
	);

	return (
		<BaseAreaChart
			data={filteredData}
			dataKey="avgTokensPerSecond"
			loading={loading}
			height={height}
			color={COLORS.purple}
			gradientId="colorSpeed"
			customGradient={gradient}
			strokeWidth={2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			yAxisTickFormatter={formatCompactNumber}
			tooltipFormatter={(value) => [
				formatTokensPerSecond(value as number),
				"Output Speed",
			]}
			animationDuration={1000}
		/>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/TokenUsageChart.tsx">
import { formatTokens } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";

interface TokenUsageChartProps {
	data: Array<{
		time: string;
		tokens: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}

export function TokenUsageChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: TokenUsageChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	const gradient = (
		<linearGradient id="colorTokens" x1="0" y1="0" x2="0" y2="1">
			<stop
				offset="0%"
				stopColor={viewMode === "cumulative" ? COLORS.blue : COLORS.primary}
				stopOpacity={0.9}
			/>
			<stop
				offset="100%"
				stopColor={viewMode === "cumulative" ? COLORS.blue : COLORS.primary}
				stopOpacity={0.1}
			/>
		</linearGradient>
	);

	return (
		<BaseAreaChart
			data={data}
			dataKey="tokens"
			loading={loading}
			height={height}
			color={viewMode === "cumulative" ? COLORS.blue : COLORS.primary}
			gradientId="colorTokens"
			customGradient={gradient}
			strokeWidth={viewMode === "cumulative" ? 3 : 2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			yAxisTickFormatter={formatCompactNumber}
			tooltipFormatter={(value) => [formatTokens(value as number), "Tokens"]}
			tooltipLabelFormatter={(label) =>
				viewMode === "cumulative" ? `Cumulative at ${label}` : label
			}
			animationDuration={1000}
		/>
	);
}
</file>

<file path="packages/dashboard-web/src/components/conversation/index.ts">
export { Message } from "./Message";
export { MessageBubble } from "./MessageBubble";
export { ThinkingBlock } from "./ThinkingBlock";
export { ToolResultBlock } from "./ToolResultBlock";
export { ToolUsageBlock } from "./ToolUsageBlock";
</file>

<file path="packages/dashboard-web/src/components/conversation/ThinkingBlock.tsx">
import { MessageSquare } from "lucide-react";
import React from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";

interface ThinkingBlockProps {
	content: string;
}

const MAX_CHARS_COLLAPSE = 200;

function ThinkingBlockComponent({ content }: ThinkingBlockProps) {
	const { display, isLong, isExpanded, toggle } = useCollapsible(
		content,
		MAX_CHARS_COLLAPSE,
	);

	return (
		<div className="p-3 bg-yellow-50 dark:bg-yellow-900/10 border border-yellow-200 dark:border-yellow-800 rounded-lg">
			<div className="flex items-center justify-between mb-1">
				<div className="flex items-center gap-2">
					<MessageSquare className="w-3 h-3 text-yellow-600 dark:text-yellow-400" />
					<span className="text-xs font-medium text-yellow-600 dark:text-yellow-400">
						Thinking
					</span>
				</div>
				{isLong && (
					<Button
						variant="ghost"
						size="sm"
						className="h-5 px-2 text-xs"
						onClick={toggle}
					>
						{isExpanded ? "Show less" : "Show more"}
					</Button>
				)}
			</div>
			<div className="text-xs text-yellow-700 dark:text-yellow-300 whitespace-pre overflow-x-auto">
				{display}
			</div>
		</div>
	);
}

export const ThinkingBlock = React.memo(ThinkingBlockComponent);
</file>

<file path="packages/dashboard-web/src/components/conversation/ToolResultBlock.tsx">
import { FileText } from "lucide-react";
import React from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";

interface ToolResultBlockProps {
	content: string;
}

const MAX_CHARS_COLLAPSE = 200;

function ToolResultBlockComponent({ content }: ToolResultBlockProps) {
	const { display, isLong, isExpanded, toggle } = useCollapsible(
		content,
		MAX_CHARS_COLLAPSE,
	);

	return (
		<div className="p-3 bg-green-50 dark:bg-green-900/10 border border-green-200 dark:border-green-800 rounded-lg">
			<div className="flex items-center justify-between mb-1">
				<div className="flex items-center gap-2">
					<FileText className="w-3 h-3 text-green-600 dark:text-green-400" />
					<span className="text-xs font-medium text-green-600 dark:text-green-400">
						Tool Result
					</span>
				</div>
				{isLong && (
					<Button
						variant="ghost"
						size="sm"
						className="h-6 px-2 text-xs"
						onClick={toggle}
					>
						{isExpanded ? "Show less" : "Show more"}
					</Button>
				)}
			</div>
			<div className="text-xs bg-green-100/50 dark:bg-green-900/20 p-2 rounded mt-1 overflow-hidden">
				<pre
					className={`overflow-x-auto whitespace-pre text-left ${
						isExpanded && isLong ? "max-h-96 overflow-y-auto pr-2" : ""
					}`}
				>
					{display}
				</pre>
			</div>
		</div>
	);
}

export const ToolResultBlock = React.memo(ToolResultBlockComponent);
</file>

<file path="packages/dashboard-web/src/components/conversation/ToolUsageBlock.tsx">
import { Terminal } from "lucide-react";
import React, { useMemo } from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";

interface ToolUsageBlockProps {
	toolName: string;
	input?: Record<string, unknown>;
}

const MAX_CHARS_COLLAPSE = 200;

function ToolUsageBlockComponent({ toolName, input }: ToolUsageBlockProps) {
	const inputStr = useMemo(
		() => (input ? JSON.stringify(input, null, 2) : ""),
		[input],
	);

	const { display, isLong, isExpanded, toggle } = useCollapsible(
		inputStr,
		MAX_CHARS_COLLAPSE,
	);
	const hasInput = input && Object.keys(input).length > 0;

	return (
		<div className="p-3 bg-blue-50 dark:bg-blue-900/10 border border-blue-200 dark:border-blue-800 rounded-lg">
			<div className="flex items-center justify-between mb-1">
				<div className="flex items-center gap-2">
					<Terminal className="w-3 h-3 text-blue-600 dark:text-blue-400" />
					<span className="text-xs font-medium text-blue-600 dark:text-blue-400">
						Tool: {toolName}
					</span>
				</div>
				{hasInput && isLong && (
					<Button
						variant="ghost"
						size="sm"
						className="h-6 px-2 text-xs"
						onClick={toggle}
					>
						{isExpanded ? "Show less" : "Show more"}
					</Button>
				)}
			</div>
			{hasInput && (
				<pre
					className={`text-xs bg-blue-100/50 dark:bg-blue-900/20 p-2 rounded mt-1 overflow-x-auto whitespace-pre text-left ${
						isExpanded && isLong ? "max-h-96 overflow-y-auto pr-2" : ""
					}`}
				>
					{display}
				</pre>
			)}
		</div>
	);
}

export const ToolUsageBlock = React.memo(ToolUsageBlockComponent);
</file>

<file path="packages/dashboard-web/src/components/overview/DataRetentionCard.tsx">
import { useEffect, useState } from "react";
import {
	useCleanupNow,
	useCompactDb,
	useRetention,
	useSetRetention,
} from "../../hooks/queries";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Input } from "../ui/input";

export function DataRetentionCard() {
	const { data, isLoading } = useRetention();
	const setRetention = useSetRetention();
	const cleanupNow = useCleanupNow();
	const compactDb = useCompactDb();
	const [payloadDays, setPayloadDays] = useState<number>(
		data?.payloadDays ?? 7,
	);
	const [requestDays, setRequestDays] = useState<number>(
		data?.requestDays ?? 365,
	);

	useEffect(() => {
		if (typeof data?.payloadDays === "number") setPayloadDays(data.payloadDays);
		if (typeof data?.requestDays === "number") setRequestDays(data.requestDays);
	}, [data?.payloadDays, data?.requestDays]);

	const disabled = isLoading || setRetention.isPending;
	const validPayload =
		Number.isFinite(payloadDays) && payloadDays >= 1 && payloadDays <= 365;
	const validRequests =
		Number.isFinite(requestDays) && requestDays >= 1 && requestDays <= 3650;

	return (
		<Card className="card-hover">
			<CardHeader>
				<CardTitle>Payload Retention</CardTitle>
				<CardDescription>
					Automatically delete request/response payloads older than this window.
					Analytics remain intact.
				</CardDescription>
			</CardHeader>
			<CardContent className="space-y-3">
				<div className="flex items-center gap-2">
					<div className="flex items-center gap-2">
						<span className="text-sm font-medium w-28">Payloads</span>
						<Input
							type="number"
							min={1}
							max={365}
							value={payloadDays}
							onChange={(e) =>
								setPayloadDays(parseInt(e.target.value || "0", 10))
							}
							className="w-24"
						/>
						<span className="text-sm text-muted-foreground">days</span>
					</div>
					<Button
						size="sm"
						disabled={disabled || !validPayload}
						onClick={() => setRetention.mutate({ payloadDays })}
					>
						Save
					</Button>
				</div>

				<div className="flex items-center gap-2">
					{[7, 14, 30, 90].map((d) => (
						<Button
							key={d}
							variant="outline"
							size="sm"
							onClick={() => setPayloadDays(d)}
						>
							{d}d
						</Button>
					))}
				</div>

				<div className="flex items-center gap-2 pt-2">
					<div className="flex items-center gap-2">
						<span className="text-sm font-medium w-28">Requests</span>
						<Input
							type="number"
							min={1}
							max={3650}
							value={requestDays}
							onChange={(e) =>
								setRequestDays(parseInt(e.target.value || "0", 10))
							}
							className="w-24"
						/>
						<span className="text-sm text-muted-foreground">days</span>
					</div>
					<Button
						size="sm"
						disabled={disabled || !validRequests}
						onClick={() => setRetention.mutate({ requestDays })}
					>
						Save
					</Button>
				</div>

				<div className="pt-2">
					<Button
						variant="secondary"
						size="sm"
						onClick={() => cleanupNow.mutate()}
						disabled={cleanupNow.isPending}
					>
						Clean up now
					</Button>
					<Button
						variant="outline"
						size="sm"
						className="ml-2"
						onClick={() => compactDb.mutate()}
						disabled={compactDb.isPending}
					>
						Compact database
					</Button>
				</div>

				{cleanupNow.data && (
					<p className="text-xs text-muted-foreground">
						Removed {cleanupNow.data.removedRequests} requests and{" "}
						{cleanupNow.data.removedPayloads} payloads older than{" "}
						{new Date(cleanupNow.data.cutoffIso).toLocaleString()}.
					</p>
				)}

				{compactDb.isSuccess && (
					<p className="text-xs text-muted-foreground">
						Database compacted. File size should reduce on disk.
					</p>
				)}
			</CardContent>
		</Card>
	);
}
</file>

<file path="packages/dashboard-web/src/components/overview/MetricCard.tsx">
import { formatPercentage } from "@ccflare/ui-common";
import { Info, TrendingDown, TrendingUp } from "lucide-react";
import { Card, CardContent } from "../ui/card";
import { Popover, PopoverContent, PopoverTrigger } from "../ui/popover";

export interface MetricCardProps {
	title: string;
	value: string | number;
	change?: number;
	icon: React.ComponentType<{ className?: string }>;
	trend?: "up" | "down" | "flat";
	trendPeriod?: string;
}

export function MetricCard({
	title,
	value,
	change,
	icon: Icon,
	trend,
	trendPeriod,
}: MetricCardProps) {
	const trendElement = trend !== "flat" && change !== undefined && (
		<div
			className={`flex items-center gap-1 text-sm font-medium ${
				trend === "up" ? "text-success" : "text-destructive"
			}`}
		>
			{trend === "up" ? (
				<TrendingUp className="h-4 w-4" />
			) : (
				<TrendingDown className="h-4 w-4" />
			)}
			<span>{formatPercentage(Math.abs(change), 0)}</span>
		</div>
	);

	return (
		<Card>
			<CardContent className="p-6">
				<div className="flex items-center justify-between mb-4">
					<Icon className="h-8 w-8 text-muted-foreground/20" />
					{trendPeriod && trendElement ? (
						<Popover>
							<PopoverTrigger asChild>
								<div className="flex items-center gap-1 cursor-help">
									{trendElement}
									<Info className="h-3 w-3 text-muted-foreground" />
								</div>
							</PopoverTrigger>
							<PopoverContent className="w-auto p-2 text-xs">
								<p>Compared to {trendPeriod}</p>
							</PopoverContent>
						</Popover>
					) : (
						trendElement
					)}
				</div>
				<div className="space-y-1">
					<p className="text-sm text-muted-foreground">{title}</p>
					<p className="text-2xl font-bold">{value}</p>
				</div>
			</CardContent>
		</Card>
	);
}
</file>

<file path="packages/dashboard-web/src/components/overview/RateLimitInfo.tsx">
import type { AccountResponse } from "@ccflare/types";
import { format } from "date-fns";
import { AlertCircle } from "lucide-react";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";

interface RateLimitInfoProps {
	accounts: AccountResponse[];
}

export function RateLimitInfo({ accounts }: RateLimitInfoProps) {
	const rateLimitedAccounts = accounts.filter((acc) => {
		const status = acc.rateLimitStatus.toLowerCase();
		return (
			status !== "ok" && status !== "paused" && !status.startsWith("allowed")
		);
	});

	if (rateLimitedAccounts.length === 0) {
		return null;
	}

	return (
		<Card>
			<CardHeader>
				<CardTitle>Rate Limit Info</CardTitle>
				<CardDescription>Rate limit information about accounts</CardDescription>
			</CardHeader>
			<CardContent>
				<div className="space-y-3">
					{rateLimitedAccounts.map((account) => {
						const resetTime = account.rateLimitReset
							? new Date(account.rateLimitReset)
							: null;
						const now = new Date();
						const timeUntilReset = resetTime
							? Math.max(0, resetTime.getTime() - now.getTime())
							: null;
						const minutesLeft = timeUntilReset
							? Math.ceil(timeUntilReset / 60000)
							: null;

						const statusLower = account.rateLimitStatus.toLowerCase();
						const isHardLimit =
							statusLower.includes("hard") ||
							(statusLower.includes("limit") &&
								!statusLower.includes("warning"));
						const bgClass = isHardLimit ? "bg-destructive/10" : "bg-warning/10";
						const iconColor = isHardLimit ? "text-destructive" : "text-warning";

						return (
							<div
								key={account.id}
								className={`flex items-center justify-between p-4 rounded-lg ${bgClass}`}
							>
								<div className="flex items-center gap-3">
									<AlertCircle className={`h-5 w-5 ${iconColor}`} />
									<div>
										<p className="font-medium">{account.name}</p>
										<p className="text-sm text-muted-foreground">
											{account.rateLimitStatus}
											{account.rateLimitRemaining !== null &&
												` • ${account.rateLimitRemaining} requests remaining`}
										</p>
									</div>
								</div>
								<div className="text-right">
									{resetTime && (
										<>
											<p className="text-sm font-medium">
												Resets in {minutesLeft}m
											</p>
											<p className="text-xs text-muted-foreground">
												{format(resetTime, "HH:mm:ss")}
											</p>
										</>
									)}
								</div>
							</div>
						);
					})}
				</div>
			</CardContent>
		</Card>
	);
}
</file>

<file path="packages/dashboard-web/src/components/overview/TimeRangeSelector.tsx">
import { Clock } from "lucide-react";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";

interface TimeRangeSelectorProps {
	value: string;
	onChange: (value: string) => void;
}

const TIME_RANGES = [
	{ value: "1h", label: "Last hour" },
	{ value: "6h", label: "Last 6 hours" },
	{ value: "24h", label: "Last 24 hours" },
	{ value: "7d", label: "Last 7 days" },
	{ value: "30d", label: "Last 30 days" },
];

export function TimeRangeSelector({ value, onChange }: TimeRangeSelectorProps) {
	return (
		<div className="flex items-center gap-2">
			<Clock className="h-4 w-4 text-muted-foreground" />
			<Select value={value} onValueChange={onChange}>
				<SelectTrigger className="w-[150px]">
					<SelectValue />
				</SelectTrigger>
				<SelectContent>
					{TIME_RANGES.map((range) => (
						<SelectItem key={range.value} value={range.value}>
							{range.label}
						</SelectItem>
					))}
				</SelectContent>
			</Select>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/ui/card.tsx">
import * as React from "react";

import { cn } from "../../lib/utils";

const Card = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn(
			"rounded-lg border bg-card text-card-foreground shadow-sm hover:shadow-md transition-shadow duration-200",
			className,
		)}
		{...props}
	/>
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn("flex flex-col space-y-1.5 p-6", className)}
		{...props}
	/>
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
	HTMLParagraphElement,
	React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
	<h3
		ref={ref}
		className={cn("font-semibold leading-none tracking-tight", className)}
		{...props}
	/>
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
	HTMLParagraphElement,
	React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
	<p
		ref={ref}
		className={cn("text-sm text-muted-foreground", className)}
		{...props}
	/>
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn("flex items-center p-6 pt-0", className)}
		{...props}
	/>
));
CardFooter.displayName = "CardFooter";

export {
	Card,
	CardHeader,
	CardTitle,
	CardDescription,
	CardContent,
	CardFooter,
};
</file>

<file path="packages/dashboard-web/src/components/ui/dialog.tsx">
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "../../lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const _DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Overlay>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
	<DialogPrimitive.Overlay
		ref={ref}
		className={cn(
			"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
			className,
		)}
		{...props}
	/>
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
	<DialogPortal>
		<DialogOverlay />
		<DialogPrimitive.Content
			ref={ref}
			className={cn(
				"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
				className,
			)}
			{...props}
		>
			{children}
			<DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
				<X className="h-4 w-4" />
				<span className="sr-only">Close</span>
			</DialogPrimitive.Close>
		</DialogPrimitive.Content>
	</DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
	className,
	...props
}: React.HTMLAttributes<HTMLDivElement>) => (
	<div
		className={cn(
			"flex flex-col space-y-1.5 text-center sm:text-left",
			className,
		)}
		{...props}
	/>
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
	className,
	...props
}: React.HTMLAttributes<HTMLDivElement>) => (
	<div
		className={cn(
			"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
			className,
		)}
		{...props}
	/>
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Title>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
	<DialogPrimitive.Title
		ref={ref}
		className={cn(
			"text-lg font-semibold leading-none tracking-tight",
			className,
		)}
		{...props}
	/>
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Description>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
	<DialogPrimitive.Description
		ref={ref}
		className={cn("text-sm text-muted-foreground", className)}
		{...props}
	/>
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
	Dialog,
	DialogTrigger,
	DialogContent,
	DialogHeader,
	DialogFooter,
	DialogTitle,
	DialogDescription,
};
</file>

<file path="packages/dashboard-web/src/components/ui/progress.tsx">
import * as ProgressPrimitive from "@radix-ui/react-progress";
import * as React from "react";
import { cn } from "../../lib/utils";

const Progress = React.forwardRef<
	React.ElementRef<typeof ProgressPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
	<ProgressPrimitive.Root
		ref={ref}
		className={cn(
			"relative h-2 w-full overflow-hidden rounded-full bg-secondary",
			className,
		)}
		{...props}
	>
		<ProgressPrimitive.Indicator
			className="h-full w-full flex-1 bg-primary transition-all duration-700 ease-out"
			style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
		/>
	</ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
</file>

<file path="packages/dashboard-web/src/components/ui/textarea.tsx">
import * as React from "react";

import { cn } from "../../lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };
</file>

<file path="packages/dashboard-web/src/components/AccountsTab.tsx">
import { AlertCircle, Plus } from "lucide-react";
import { useState } from "react";
import { type Account, api } from "../api";
import { useAccounts, useRenameAccount } from "../hooks/queries";
import { useApiError } from "../hooks/useApiError";
import {
	AccountAddForm,
	AccountList,
	DeleteConfirmationDialog,
	RenameAccountDialog,
} from "./accounts";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";

export function AccountsTab() {
	const { formatError } = useApiError();
	const {
		data: accounts,
		isLoading: loading,
		error,
		refetch: loadAccounts,
	} = useAccounts();
	const renameAccount = useRenameAccount();

	const [adding, setAdding] = useState(false);
	const [confirmDelete, setConfirmDelete] = useState<{
		show: boolean;
		accountName: string;
		confirmInput: string;
	}>({
		show: false,
		accountName: "",
		confirmInput: "",
	});
	const [renameDialog, setRenameDialog] = useState<{
		isOpen: boolean;
		account: Account | null;
	}>({
		isOpen: false,
		account: null,
	});
	const [actionError, setActionError] = useState<string | null>(null);

	const handleAddAccount = async (params: {
		name: string;
		mode: "max" | "console";
		tier: number;
	}) => {
		try {
			const result = await api.initAddAccount(params);
			setActionError(null);
			return result;
		} catch (err) {
			setActionError(formatError(err));
			throw err;
		}
	};

	const handleCompleteAccount = async (params: {
		sessionId: string;
		code: string;
	}) => {
		try {
			await api.completeAddAccount(params);
			await loadAccounts();
			setAdding(false);
			setActionError(null);
		} catch (err) {
			setActionError(formatError(err));
			throw err;
		}
	};

	const handleRemoveAccount = (name: string) => {
		setConfirmDelete({ show: true, accountName: name, confirmInput: "" });
	};

	const handleConfirmDelete = async () => {
		if (confirmDelete.confirmInput !== confirmDelete.accountName) {
			setActionError(
				"Account name does not match. Please type the exact account name.",
			);
			return;
		}

		try {
			await api.removeAccount(
				confirmDelete.accountName,
				confirmDelete.confirmInput,
			);
			await loadAccounts();
			setConfirmDelete({ show: false, accountName: "", confirmInput: "" });
			setActionError(null);
		} catch (err) {
			setActionError(formatError(err));
		}
	};

	const handleRename = (account: Account) => {
		setRenameDialog({ isOpen: true, account });
	};

	const handleConfirmRename = async (newName: string) => {
		if (!renameDialog.account) return;

		try {
			await renameAccount.mutateAsync({
				accountId: renameDialog.account.id,
				newName,
			});
			setRenameDialog({ isOpen: false, account: null });
			setActionError(null);
		} catch (err) {
			setActionError(formatError(err));
		}
	};

	const handlePauseToggle = async (account: Account) => {
		try {
			if (account.paused) {
				await api.resumeAccount(account.id);
			} else {
				await api.pauseAccount(account.id);
			}
			await loadAccounts();
		} catch (err) {
			setActionError(formatError(err));
		}
	};

	if (loading) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-muted-foreground">Loading accounts...</p>
				</CardContent>
			</Card>
		);
	}

	const displayError = error ? formatError(error) : actionError;

	return (
		<div className="space-y-4">
			{displayError && (
				<Card className="border-destructive">
					<CardContent className="pt-6">
						<div className="flex items-center gap-2">
							<AlertCircle className="h-4 w-4 text-destructive" />
							<p className="text-destructive">{displayError}</p>
						</div>
					</CardContent>
				</Card>
			)}

			<Card>
				<CardHeader>
					<div className="flex items-center justify-between">
						<div>
							<CardTitle>Accounts</CardTitle>
							<CardDescription>Manage your Claude accounts</CardDescription>
						</div>
						{!adding && (
							<Button onClick={() => setAdding(true)} size="sm">
								<Plus className="mr-2 h-4 w-4" />
								Add Account
							</Button>
						)}
					</div>
				</CardHeader>
				<CardContent>
					{adding && (
						<AccountAddForm
							onAddAccount={handleAddAccount}
							onCompleteAccount={handleCompleteAccount}
							onCancel={() => {
								setAdding(false);
								setActionError(null);
							}}
							onSuccess={() => {
								setAdding(false);
							}}
							onError={setActionError}
						/>
					)}

					<AccountList
						accounts={accounts}
						onPauseToggle={handlePauseToggle}
						onRemove={handleRemoveAccount}
						onRename={handleRename}
					/>
				</CardContent>
			</Card>

			{confirmDelete.show && (
				<DeleteConfirmationDialog
					accountName={confirmDelete.accountName}
					confirmInput={confirmDelete.confirmInput}
					onConfirmInputChange={(value) =>
						setConfirmDelete({
							...confirmDelete,
							confirmInput: value,
						})
					}
					onConfirm={handleConfirmDelete}
					onCancel={() => {
						setConfirmDelete({
							show: false,
							accountName: "",
							confirmInput: "",
						});
						setActionError(null);
					}}
				/>
			)}

			{renameDialog.isOpen && renameDialog.account && (
				<RenameAccountDialog
					isOpen={renameDialog.isOpen}
					currentName={renameDialog.account.name}
					onClose={() => setRenameDialog({ isOpen: false, account: null })}
					onRename={handleConfirmRename}
					isLoading={renameAccount.isPending}
				/>
			)}
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/LogsTab.tsx">
import { Pause, Play, Trash2 } from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { api, type LogEntry } from "../api";
import { useLogHistory } from "../hooks/queries";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";

export function LogsTab() {
	const [logs, setLogs] = useState<LogEntry[]>([]);
	const [paused, setPaused] = useState(false);
	const [autoScroll, setAutoScroll] = useState(true);
	const eventSourceRef = useRef<EventSource | null>(null);
	const logsEndRef = useRef<HTMLDivElement>(null);

	const startStreaming = useCallback(() => {
		eventSourceRef.current = api.streamLogs((log: LogEntry) => {
			setLogs((prev) => [...prev.slice(-999), log]); // Keep last 1000 logs
			// Auto-scroll to bottom when new log arrives
			if (autoScroll && logsEndRef.current) {
				setTimeout(() => {
					logsEndRef.current?.scrollIntoView({ behavior: "smooth" });
				}, 0);
			}
		});
	}, [autoScroll]);

	const stopStreaming = useCallback(() => {
		if (eventSourceRef.current) {
			eventSourceRef.current.close();
			eventSourceRef.current = null;
		}
	}, []);

	// Load historical logs on mount
	const { data: history, isLoading: loading, error } = useLogHistory();

	useEffect(() => {
		if (history) {
			setLogs(history);
			// Auto-scroll to bottom after loading history
			if (autoScroll && logsEndRef.current) {
				setTimeout(() => {
					logsEndRef.current?.scrollIntoView({ behavior: "smooth" });
				}, 0);
			}
		}
	}, [history, autoScroll]);

	useEffect(() => {
		if (!paused && !loading) {
			startStreaming();
		}

		return () => {
			stopStreaming();
		};
	}, [paused, loading, startStreaming, stopStreaming]);

	useEffect(() => {
		if (autoScroll && logsEndRef.current) {
			logsEndRef.current.scrollIntoView({ behavior: "smooth" });
		}
	}, [autoScroll]);

	const clearLogs = () => {
		setLogs([]);
	};

	const togglePause = () => {
		setPaused(!paused);
	};

	const getLogColor = (level: string | undefined) => {
		if (!level) return "";
		switch (level.toUpperCase()) {
			case "ERROR":
				return "text-destructive";
			case "WARN":
				return "text-yellow-600";
			case "INFO":
				return "text-green-600";
			case "DEBUG":
				return "text-muted-foreground";
			default:
				return "";
		}
	};

	const formatTimestamp = (ts: number) => {
		return new Date(ts).toLocaleTimeString();
	};

	return (
		<Card>
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle>Live Logs</CardTitle>
						<CardDescription>
							Real-time log stream {paused && "(Paused)"}
						</CardDescription>
					</div>
					<div className="flex gap-2">
						<Button onClick={togglePause} variant="outline" size="sm">
							{paused ? (
								<>
									<Play className="mr-2 h-4 w-4" />
									Resume
								</>
							) : (
								<>
									<Pause className="mr-2 h-4 w-4" />
									Pause
								</>
							)}
						</Button>
						<Button onClick={clearLogs} variant="outline" size="sm">
							<Trash2 className="mr-2 h-4 w-4" />
							Clear
						</Button>
					</div>
				</div>
			</CardHeader>
			<CardContent>
				<div className="space-y-1 max-h-[500px] overflow-y-auto font-mono text-sm">
					{loading ? (
						<p className="text-muted-foreground">Loading logs...</p>
					) : error ? (
						<p className="text-destructive">
							Error: {error instanceof Error ? error.message : String(error)}
						</p>
					) : logs.length === 0 ? (
						<p className="text-muted-foreground">No logs yet...</p>
					) : (
						logs.map((log, i) => (
							<div key={`${log.ts}-${i}`} className="flex gap-2">
								<span className="text-muted-foreground">
									{formatTimestamp(log.ts)}
								</span>
								<span className={`font-medium ${getLogColor(log.level)}`}>
									[{log.level || "LOG"}]
								</span>
								<span className="flex-1">{log.msg}</span>
							</div>
						))
					)}
					<div ref={logsEndRef} />
				</div>
				<div className="mt-4 flex items-center gap-2">
					<input
						type="checkbox"
						id="autoscroll"
						checked={autoScroll}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
							setAutoScroll((e.target as HTMLInputElement).checked)
						}
						className="rounded border-gray-300"
					/>
					<label htmlFor="autoscroll" className="text-sm text-muted-foreground">
						Auto-scroll to bottom
					</label>
				</div>
			</CardContent>
		</Card>
	);
}
</file>

<file path="packages/dashboard-web/src/components/RequestDetailsModal.tsx">
import { formatCost, formatTimestamp, formatTokens } from "@ccflare/ui-common";
import { Eye } from "lucide-react";
import { useState } from "react";
import type { RequestPayload, RequestSummary } from "../api";
import { ConversationView } from "./ConversationView";
import { CopyButton } from "./CopyButton";
import { TokenUsageDisplay } from "./TokenUsageDisplay";
import { Badge } from "./ui/badge";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogHeader,
	DialogTitle,
} from "./ui/dialog";
import { Label } from "./ui/label";
import { Switch } from "./ui/switch";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/tabs";

interface RequestDetailsModalProps {
	request: RequestPayload;
	summary: RequestSummary | undefined;
	isOpen: boolean;
	onClose: () => void;
}

export function RequestDetailsModal({
	request,
	summary,
	isOpen,
	onClose,
}: RequestDetailsModalProps) {
	const [beautifyMode, setBeautifyMode] = useState(true);

	const decodeBase64 = (str: string | null): string => {
		if (!str) return "No data";
		try {
			if (str === "[streamed]") {
				return "[Streaming data not captured]";
			}
			return atob(str);
		} catch (error) {
			console.error("Failed to decode base64:", error, "Input:", str);
			return `Failed to decode: ${str}`;
		}
	};

	const formatJson = (str: string): string => {
		try {
			const parsed = JSON.parse(str);
			return JSON.stringify(parsed, null, 2);
		} catch {
			// If it's not valid JSON, return as-is
			return str;
		}
	};

	const formatHeaders = (headers: Record<string, string>): string => {
		if (!beautifyMode) {
			return Object.entries(headers)
				.map(([key, value]) => `${key}: ${value}`)
				.join("\n");
		}
		return JSON.stringify(headers, null, 2);
	};

	const formatBody = (body: string | null): string => {
		const decoded = decodeBase64(body);
		if (!beautifyMode) return decoded;
		return formatJson(decoded);
	};

	const _isError = request.error || !request.meta.success;
	const statusCode = request.response?.status;

	return (
		<Dialog open={isOpen} onOpenChange={onClose}>
			<DialogContent className="max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
				<DialogHeader>
					<DialogTitle className="flex items-center gap-2">
						<Eye className="h-5 w-5" />
						Request Details
					</DialogTitle>
					<DialogDescription className="flex items-center justify-between">
						<div className="flex items-center gap-2 flex-wrap">
							<span className="font-mono text-sm">
								{formatTimestamp(request.meta.timestamp)}
							</span>
							{statusCode && (
								<Badge
									variant={
										statusCode >= 200 && statusCode < 300
											? "success"
											: statusCode >= 400 && statusCode < 500
												? "warning"
												: "destructive"
									}
								>
									{statusCode}
								</Badge>
							)}
							{summary?.model && (
								<Badge variant="secondary">{summary.model}</Badge>
							)}
							{summary?.agentUsed && (
								<Badge variant="secondary">Agent: {summary.agentUsed}</Badge>
							)}
							{summary?.totalTokens && (
								<Badge variant="outline">
									{formatTokens(summary.totalTokens)} tokens
								</Badge>
							)}
							{summary?.costUsd && summary.costUsd > 0 && (
								<Badge variant="default">{formatCost(summary.costUsd)}</Badge>
							)}
							{request.meta.rateLimited && (
								<Badge variant="warning">Rate Limited</Badge>
							)}
						</div>
						<div className="flex items-center gap-2">
							<Label htmlFor="beautify-mode" className="text-sm">
								Beautify
							</Label>
							<Switch
								id="beautify-mode"
								checked={beautifyMode}
								onCheckedChange={setBeautifyMode}
							/>
						</div>
					</DialogDescription>
				</DialogHeader>

				<Tabs defaultValue="conversation" className="flex-1 overflow-hidden">
					<TabsList className="grid w-full grid-cols-5">
						<TabsTrigger value="conversation">Conversation</TabsTrigger>
						<TabsTrigger value="request">Request</TabsTrigger>
						<TabsTrigger value="response">Response</TabsTrigger>
						<TabsTrigger value="metadata">Metadata</TabsTrigger>
						<TabsTrigger value="tokens">Token Usage</TabsTrigger>
					</TabsList>

					<TabsContent value="conversation" className="mt-4 flex-1 min-h-0">
						<ConversationView
							requestBody={decodeBase64(request.request.body)}
							responseBody={decodeBase64(request.response?.body || null)}
						/>
					</TabsContent>

					<TabsContent
						value="request"
						className="mt-4 space-y-4 overflow-y-auto max-h-[60vh]"
					>
						<div>
							<div className="flex items-center justify-between mb-2">
								<h3 className="font-semibold">Headers</h3>
								<CopyButton
									variant="ghost"
									size="sm"
									getValue={() => formatHeaders(request.request.headers)}
								>
									Copy
								</CopyButton>
							</div>
							<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
								{formatHeaders(request.request.headers)}
							</pre>
						</div>

						{request.request.body && (
							<div>
								<div className="flex items-center justify-between mb-2">
									<h3 className="font-semibold">Body</h3>
									<CopyButton
										variant="ghost"
										size="sm"
										getValue={() => formatBody(request.request.body)}
									>
										Copy
									</CopyButton>
								</div>
								<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
									{formatBody(request.request.body)}
								</pre>
							</div>
						)}
					</TabsContent>

					<TabsContent
						value="response"
						className="mt-4 space-y-4 overflow-y-auto max-h-[60vh]"
					>
						{request.response ? (
							<>
								<div>
									<div className="flex items-center justify-between mb-2">
										<h3 className="font-semibold">Headers</h3>
										<CopyButton
											variant="ghost"
											size="sm"
											getValue={() =>
												request.response
													? formatHeaders(request.response.headers)
													: ""
											}
										>
											Copy
										</CopyButton>
									</div>
									<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
										{formatHeaders(request.response.headers)}
									</pre>
								</div>

								{request.response.body && (
									<div>
										<div className="flex items-center justify-between mb-2">
											<h3 className="font-semibold">Body</h3>
											<CopyButton
												variant="ghost"
												size="sm"
												getValue={() =>
													request.response
														? formatBody(request.response.body)
														: ""
												}
											>
												Copy
											</CopyButton>
										</div>
										<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
											{formatBody(request.response.body)}
										</pre>
									</div>
								)}
							</>
						) : (
							<div className="text-center text-muted-foreground py-8">
								{request.error ? (
									<>
										<p className="text-destructive font-medium">
											Error: {request.error}
										</p>
										<p className="mt-2">No response data available</p>
									</>
								) : (
									<p>No response data available</p>
								)}
							</div>
						)}
					</TabsContent>

					<TabsContent
						value="metadata"
						className="mt-4 overflow-y-auto max-h-[60vh]"
					>
						<div>
							<div className="flex items-center justify-between mb-2">
								<h3 className="font-semibold">Request Metadata</h3>
								<CopyButton
									variant="ghost"
									size="sm"
									getValue={() =>
										beautifyMode
											? JSON.stringify(request.meta, null, 2)
											: JSON.stringify(request.meta)
									}
								>
									Copy
								</CopyButton>
							</div>
							<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
								{beautifyMode
									? JSON.stringify(request.meta, null, 2)
									: JSON.stringify(request.meta)}
							</pre>
						</div>
					</TabsContent>

					<TabsContent
						value="tokens"
						className="mt-4 overflow-y-auto max-h-[60vh]"
					>
						<TokenUsageDisplay summary={summary} />
					</TabsContent>
				</Tabs>
			</DialogContent>
		</Dialog>
	);
}
</file>

<file path="packages/dashboard-web/src/hooks/useCollapsible.ts">
import { useMemo, useState } from "react";

export const useCollapsible = (content: string, limit: number) => {
	const [isExpanded, setIsExpanded] = useState(false);

	const isLong = useMemo(
		() => content && content.length > limit,
		[content, limit],
	);

	const display = useMemo(() => {
		if (isExpanded || !isLong) {
			return content;
		}
		return content ? `${content.slice(0, limit)}...` : "";
	}, [content, limit, isExpanded, isLong]);

	const toggle = () => setIsExpanded((prev) => !prev);

	return {
		display,
		isLong,
		isExpanded,
		toggle,
	};
};
</file>

<file path="packages/dashboard-web/src/lib/chart-utils.ts">
/**
 * Format numbers in compact notation for chart axes
 * 1000 -> 1k
 * 1000000 -> 1M
 * 1000000000 -> 1B
 */
export function formatCompactNumber(value: number | string): string {
	const numValue = typeof value === "string" ? Number(value) : value;
	if (Number.isNaN(numValue)) return String(value);

	const absValue = Math.abs(numValue);
	const sign = numValue < 0 ? "-" : "";

	if (absValue >= 1e9) {
		return `${sign}${(absValue / 1e9).toFixed(1).replace(/\.0$/, "")}B`;
	}
	if (absValue >= 1e6) {
		return `${sign}${(absValue / 1e6).toFixed(1).replace(/\.0$/, "")}M`;
	}
	if (absValue >= 1e3) {
		return `${sign}${(absValue / 1e3).toFixed(1).replace(/\.0$/, "")}k`;
	}
	return `${sign}${absValue.toString()}`;
}

/**
 * Format currency in compact notation
 * $1234 -> $1.2k
 */
export function formatCompactCurrency(value: number | string): string {
	return `$${formatCompactNumber(value)}`;
}
</file>

<file path="packages/dashboard-web/src/frontend.tsx">
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { App } from "./App";

const elem =
	typeof document !== "undefined" ? document.getElementById("root") : null;
if (!elem) {
	throw new Error("Root element not found");
}
const app = (
	<StrictMode>
		<BrowserRouter>
			<App />
		</BrowserRouter>
	</StrictMode>
);

if (import.meta.hot) {
	// With hot module reloading, `import.meta.hot.data` is persisted.
	if (!import.meta.hot.data.root) {
		import.meta.hot.data.root = createRoot(elem);
	}
	const root = import.meta.hot.data.root;
	root.render(app);
} else {
	// The hot module reloading API is not available in production.
	createRoot(elem).render(app);
}
</file>

<file path="packages/database/src/repositories/account.repository.ts">
import { type Account, type AccountRow, toAccount } from "@ccflare/types";
import { BaseRepository } from "./base.repository";

export class AccountRepository extends BaseRepository<Account> {
	findAll(): Account[] {
		const rows = this.query<AccountRow>(`
			SELECT 
				id, name, provider, api_key, refresh_token, access_token,
				expires_at, created_at, last_used, request_count, total_requests,
				rate_limited_until, session_start, session_request_count,
				COALESCE(account_tier, 1) as account_tier,
				COALESCE(paused, 0) as paused,
				rate_limit_reset, rate_limit_status, rate_limit_remaining
			FROM accounts
		`);
		return rows.map(toAccount);
	}

	findById(accountId: string): Account | null {
		const row = this.get<AccountRow>(
			`
			SELECT 
				id, name, provider, api_key, refresh_token, access_token,
				expires_at, created_at, last_used, request_count, total_requests,
				rate_limited_until, session_start, session_request_count,
				COALESCE(account_tier, 1) as account_tier,
				COALESCE(paused, 0) as paused,
				rate_limit_reset, rate_limit_status, rate_limit_remaining
			FROM accounts
			WHERE id = ?
		`,
			[accountId],
		);

		return row ? toAccount(row) : null;
	}

	updateTokens(
		accountId: string,
		accessToken: string,
		expiresAt: number,
		refreshToken?: string,
	): void {
		if (refreshToken) {
			this.run(
				`UPDATE accounts SET access_token = ?, expires_at = ?, refresh_token = ? WHERE id = ?`,
				[accessToken, expiresAt, refreshToken, accountId],
			);
		} else {
			this.run(
				`UPDATE accounts SET access_token = ?, expires_at = ? WHERE id = ?`,
				[accessToken, expiresAt, accountId],
			);
		}
	}

	incrementUsage(accountId: string, sessionDurationMs: number): void {
		const now = Date.now();
		this.run(
			`
			UPDATE accounts 
			SET 
				last_used = ?,
				request_count = request_count + 1,
				total_requests = total_requests + 1,
				session_start = CASE
					WHEN session_start IS NULL OR ? - session_start >= ? THEN ?
					ELSE session_start
				END,
				session_request_count = CASE
					WHEN session_start IS NULL OR ? - session_start >= ? THEN 1
					ELSE session_request_count + 1
				END
			WHERE id = ?
		`,
			[now, now, sessionDurationMs, now, now, sessionDurationMs, accountId],
		);
	}

	setRateLimited(accountId: string, until: number): void {
		this.run(`UPDATE accounts SET rate_limited_until = ? WHERE id = ?`, [
			until,
			accountId,
		]);
	}

	updateRateLimitMeta(
		accountId: string,
		status: string,
		reset: number | null,
		remaining?: number | null,
	): void {
		this.run(
			`UPDATE accounts SET rate_limit_status = ?, rate_limit_reset = ?, rate_limit_remaining = ? WHERE id = ?`,
			[status, reset, remaining ?? null, accountId],
		);
	}

	updateTier(accountId: string, tier: number): void {
		this.run(`UPDATE accounts SET account_tier = ? WHERE id = ?`, [
			tier,
			accountId,
		]);
	}

	pause(accountId: string): void {
		this.run(`UPDATE accounts SET paused = 1 WHERE id = ?`, [accountId]);
	}

	resume(accountId: string): void {
		this.run(`UPDATE accounts SET paused = 0 WHERE id = ?`, [accountId]);
	}

	resetSession(accountId: string, timestamp: number): void {
		this.run(
			`UPDATE accounts SET session_start = ?, session_request_count = 0 WHERE id = ?`,
			[timestamp, accountId],
		);
	}

	updateRequestCount(accountId: string, count: number): void {
		this.run(`UPDATE accounts SET session_request_count = ? WHERE id = ?`, [
			count,
			accountId,
		]);
	}

	rename(accountId: string, newName: string): void {
		this.run(`UPDATE accounts SET name = ? WHERE id = ?`, [newName, accountId]);
	}
}
</file>

<file path="packages/database/src/repositories/agent-preference.repository.ts">
import { BaseRepository } from "./base.repository";

export interface AgentPreference {
	agentId: string;
	model: string;
	updatedAt: number;
}

export class AgentPreferenceRepository extends BaseRepository<AgentPreference> {
	/**
	 * Get model preference for a specific agent
	 */
	getPreference(agentId: string): { model: string } | null {
		const row = this.get<{ model: string }>(
			`SELECT model FROM agent_preferences WHERE agent_id = ?`,
			[agentId],
		);
		return row;
	}

	/**
	 * Get all agent preferences
	 */
	getAllPreferences(): Array<{ agent_id: string; model: string }> {
		return this.query<{ agent_id: string; model: string }>(
			`SELECT agent_id, model FROM agent_preferences`,
		);
	}

	/**
	 * Set model preference for an agent
	 */
	setPreference(agentId: string, model: string): void {
		this.run(
			`INSERT OR REPLACE INTO agent_preferences (agent_id, model, updated_at) VALUES (?, ?, ?)`,
			[agentId, model, Date.now()],
		);
	}

	/**
	 * Delete preference for an agent
	 */
	deletePreference(agentId: string): boolean {
		const changes = this.runWithChanges(
			`DELETE FROM agent_preferences WHERE agent_id = ?`,
			[agentId],
		);
		return changes > 0;
	}

	/**
	 * Set preferences for all agents in bulk
	 */
	setBulkPreferences(agentIds: string[], model: string): void {
		if (agentIds.length === 0) {
			return;
		}

		const now = Date.now();
		const placeholders = agentIds.map(() => "(?, ?, ?)").join(", ");
		const values = agentIds.flatMap((id) => [id, model, now]);

		this.run(
			`INSERT OR REPLACE INTO agent_preferences (agent_id, model, updated_at) VALUES ${placeholders}`,
			values,
		);
	}
}
</file>

<file path="packages/database/src/repositories/request.repository.ts">
import { BaseRepository } from "./base.repository";

export interface RequestData {
	id: string;
	method: string;
	path: string;
	accountUsed: string | null;
	statusCode: number | null;
	success: boolean;
	errorMessage: string | null;
	responseTime: number;
	failoverAttempts: number;
	agentUsed?: string;
	usage?: {
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
		tokensPerSecond?: number;
	};
}

export class RequestRepository extends BaseRepository<RequestData> {
	saveMeta(
		id: string,
		method: string,
		path: string,
		accountUsed: string | null,
		statusCode: number | null,
		timestamp?: number,
	): void {
		this.run(
			`
			INSERT INTO requests (
				id, timestamp, method, path, account_used, 
				status_code, success, error_message, response_time_ms, failover_attempts
			)
			VALUES (?, ?, ?, ?, ?, ?, 0, NULL, 0, 0)
		`,
			[id, timestamp || Date.now(), method, path, accountUsed, statusCode],
		);
	}

	save(data: RequestData): void {
		const { usage } = data;
		this.run(
			`
			INSERT OR REPLACE INTO requests (
				id, timestamp, method, path, account_used, 
				status_code, success, error_message, response_time_ms, failover_attempts,
				model, prompt_tokens, completion_tokens, total_tokens, cost_usd,
				input_tokens, cache_read_input_tokens, cache_creation_input_tokens, output_tokens,
				agent_used, output_tokens_per_second
			)
			VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			[
				data.id,
				Date.now(),
				data.method,
				data.path,
				data.accountUsed,
				data.statusCode,
				data.success ? 1 : 0,
				data.errorMessage,
				data.responseTime,
				data.failoverAttempts,
				usage?.model || null,
				usage?.promptTokens || null,
				usage?.completionTokens || null,
				usage?.totalTokens || null,
				usage?.costUsd || null,
				usage?.inputTokens || null,
				usage?.cacheReadInputTokens || null,
				usage?.cacheCreationInputTokens || null,
				usage?.outputTokens || null,
				data.agentUsed || null,
				usage?.tokensPerSecond || null,
			],
		);
	}

	updateUsage(requestId: string, usage: RequestData["usage"]): void {
		if (!usage) return;

		this.run(
			`
			UPDATE requests
			SET 
				model = COALESCE(?, model),
				prompt_tokens = COALESCE(?, prompt_tokens),
				completion_tokens = COALESCE(?, completion_tokens),
				total_tokens = COALESCE(?, total_tokens),
				cost_usd = COALESCE(?, cost_usd),
				input_tokens = COALESCE(?, input_tokens),
				cache_read_input_tokens = COALESCE(?, cache_read_input_tokens),
				cache_creation_input_tokens = COALESCE(?, cache_creation_input_tokens),
				output_tokens = COALESCE(?, output_tokens),
				output_tokens_per_second = COALESCE(?, output_tokens_per_second)
			WHERE id = ?
		`,
			[
				usage.model || null,
				usage.promptTokens || null,
				usage.completionTokens || null,
				usage.totalTokens || null,
				usage.costUsd || null,
				usage.inputTokens || null,
				usage.cacheReadInputTokens || null,
				usage.cacheCreationInputTokens || null,
				usage.outputTokens || null,
				usage.tokensPerSecond || null,
				requestId,
			],
		);
	}

	// Payload management
	savePayload(id: string, data: unknown): void {
		const json = JSON.stringify(data);
		this.run(
			`INSERT OR REPLACE INTO request_payloads (id, json) VALUES (?, ?)`,
			[id, json],
		);
	}

	getPayload(id: string): unknown | null {
		const row = this.get<{ json: string }>(
			`SELECT json FROM request_payloads WHERE id = ?`,
			[id],
		);

		if (!row) return null;

		try {
			return JSON.parse(row.json);
		} catch {
			return null;
		}
	}

	listPayloads(limit = 50): Array<{ id: string; json: string }> {
		return this.query<{ id: string; json: string }>(
			`
			SELECT rp.id, rp.json 
			FROM request_payloads rp
			JOIN requests r ON rp.id = r.id
			ORDER BY r.timestamp DESC
			LIMIT ?
		`,
			[limit],
		);
	}

	listPayloadsWithAccountNames(
		limit = 50,
	): Array<{ id: string; json: string; account_name: string | null }> {
		return this.query<{
			id: string;
			json: string;
			account_name: string | null;
		}>(
			`
			SELECT rp.id, rp.json, a.name as account_name
			FROM request_payloads rp
			JOIN requests r ON rp.id = r.id
			LEFT JOIN accounts a ON r.account_used = a.id
			ORDER BY r.timestamp DESC
			LIMIT ?
		`,
			[limit],
		);
	}

	// Analytics queries
	getRecentRequests(limit = 100): Array<{
		id: string;
		timestamp: number;
		method: string;
		path: string;
		account_used: string | null;
		status_code: number | null;
		success: boolean;
		response_time_ms: number | null;
	}> {
		return this.query<{
			id: string;
			timestamp: number;
			method: string;
			path: string;
			account_used: string | null;
			status_code: number | null;
			success: 0 | 1;
			response_time_ms: number | null;
		}>(
			`
			SELECT id, timestamp, method, path, account_used, status_code, success, response_time_ms
			FROM requests
			ORDER BY timestamp DESC
			LIMIT ?
		`,
			[limit],
		).map((row) => ({
			...row,
			success: row.success === 1,
		}));
	}

	getRequestStats(since?: number): {
		totalRequests: number;
		successfulRequests: number;
		failedRequests: number;
		avgResponseTime: number | null;
	} {
		const whereClause = since ? "WHERE timestamp > ?" : "";
		const params = since ? [since] : [];

		const result = this.get<{
			total_requests: number;
			successful_requests: number;
			failed_requests: number;
			avg_response_time: number | null;
		}>(
			`
			SELECT 
				COUNT(*) as total_requests,
				SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_requests,
				SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) as failed_requests,
				AVG(response_time_ms) as avg_response_time
			FROM requests
			${whereClause}
		`,
			params,
		);

		return {
			totalRequests: result?.total_requests || 0,
			successfulRequests: result?.successful_requests || 0,
			failedRequests: result?.failed_requests || 0,
			avgResponseTime: result?.avg_response_time || null,
		};
	}

	/**
	 * Aggregate statistics with optional time range
	 * Consolidates duplicate SQL queries from stats handlers
	 */
	aggregateStats(rangeMs?: number): {
		totalRequests: number;
		successfulRequests: number;
		avgResponseTime: number | null;
		totalTokens: number;
		totalCostUsd: number;
		inputTokens: number;
		outputTokens: number;
		cacheReadInputTokens: number;
		cacheCreationInputTokens: number;
		avgTokensPerSecond: number | null;
	} {
		const whereClause = rangeMs ? "WHERE timestamp > ?" : "";
		const params = rangeMs ? [Date.now() - rangeMs] : [];

		const result = this.get<{
			total_requests: number;
			successful_requests: number;
			avg_response_time: number | null;
			total_tokens: number | null;
			total_cost_usd: number | null;
			input_tokens: number | null;
			output_tokens: number | null;
			cache_read_input_tokens: number | null;
			cache_creation_input_tokens: number | null;
			avg_tokens_per_second: number | null;
		}>(
			`
			SELECT 
				COUNT(*) as total_requests,
				SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_requests,
				AVG(response_time_ms) as avg_response_time,
				SUM(total_tokens) as total_tokens,
				SUM(cost_usd) as total_cost_usd,
				SUM(input_tokens) as input_tokens,
				SUM(output_tokens) as output_tokens,
				SUM(cache_read_input_tokens) as cache_read_input_tokens,
				SUM(cache_creation_input_tokens) as cache_creation_input_tokens,
				AVG(output_tokens_per_second) as avg_tokens_per_second
			FROM requests
			${whereClause}
		`,
			params,
		);

		return {
			totalRequests: result?.total_requests || 0,
			successfulRequests: result?.successful_requests || 0,
			avgResponseTime: result?.avg_response_time || null,
			totalTokens: result?.total_tokens || 0,
			totalCostUsd: result?.total_cost_usd || 0,
			inputTokens: result?.input_tokens || 0,
			outputTokens: result?.output_tokens || 0,
			cacheReadInputTokens: result?.cache_read_input_tokens || 0,
			cacheCreationInputTokens: result?.cache_creation_input_tokens || 0,
			avgTokensPerSecond: result?.avg_tokens_per_second || null,
		};
	}

	/**
	 * Get top models by usage
	 */
	getTopModels(limit = 10): Array<{ model: string; count: number }> {
		return this.query<{ model: string; count: number }>(
			`
			SELECT model, COUNT(*) as count
			FROM requests
			WHERE model IS NOT NULL
			GROUP BY model
			ORDER BY count DESC
			LIMIT ?
		`,
			[limit],
		);
	}

	/**
	 * Get recent error messages
	 */
	getRecentErrors(limit = 10): string[] {
		const errors = this.query<{ error_message: string }>(
			`
			SELECT error_message
			FROM requests
			WHERE success = 0 AND error_message IS NOT NULL
			ORDER BY timestamp DESC
			LIMIT ?
		`,
			[limit],
		);
		return errors.map((e: { error_message: string }) => e.error_message);
	}

	getRequestsByAccount(since?: number): Array<{
		accountId: string;
		accountName: string | null;
		requestCount: number;
		successRate: number;
	}> {
		const whereClause = since ? "WHERE r.timestamp > ?" : "";
		const params = since ? [since] : [];

		return this.query<{
			account_id: string;
			account_name: string | null;
			request_count: number;
			success_rate: number;
		}>(
			`
			SELECT 
				r.account_used as account_id,
				a.name as account_name,
				COUNT(*) as request_count,
				SUM(CASE WHEN r.success = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as success_rate
			FROM requests r
			LEFT JOIN accounts a ON r.account_used = a.id
			${whereClause}
			GROUP BY r.account_used
			ORDER BY request_count DESC
		`,
			params,
		).map((row) => ({
			accountId: row.account_id,
			accountName: row.account_name,
			requestCount: row.request_count,
			successRate: row.success_rate,
		}));
	}

	deleteOlderThan(cutoffTs: number): number {
		return this.runWithChanges(`DELETE FROM requests WHERE timestamp < ?`, [
			cutoffTs,
		]);
	}

	deleteOrphanedPayloads(): number {
		return this.runWithChanges(
			`DELETE FROM request_payloads WHERE id NOT IN (SELECT id FROM requests)`,
		);
	}

	deletePayloadsOlderThan(cutoffTs: number): number {
		return this.runWithChanges(
			`DELETE FROM request_payloads WHERE id IN (SELECT id FROM requests WHERE timestamp < ?)`,
			[cutoffTs],
		);
	}
}
</file>

<file path="packages/database/src/repositories/system-kv.repository.ts">
import { BaseRepository } from "./base.repository";

interface SystemKVRow {
	key: string;
	value: string;
}

export class SystemKVRepository extends BaseRepository<SystemKVRow> {
	getValue(key: string): string | null {
		const row = super.get<SystemKVRow>(
			"SELECT value FROM system_kv_store WHERE key = ?",
			[key],
		);

		return row?.value ?? null;
	}

	setValue(key: string, value: string): void {
		this.run(
			"INSERT OR REPLACE INTO system_kv_store (key, value) VALUES (?, ?)",
			[key, value],
		);
	}
}
</file>

<file path="packages/http-api/src/handlers/agents.ts">
import { agentRegistry } from "@ccflare/agents";
import { validateString } from "@ccflare/core";
import type { DatabaseOperations } from "@ccflare/database";
import {
	BadRequest,
	errorResponse,
	HttpError,
	jsonResponse,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import { ALLOWED_MODELS } from "@ccflare/types";

const log = new Logger("AgentsHandler");

export function createAgentsListHandler(dbOps: DatabaseOperations) {
	return async (): Promise<Response> => {
		try {
			const agents = await agentRegistry.getAgents();
			const preferences = dbOps.getAllAgentPreferences();

			// Create a map of preferences for easy lookup
			const prefMap = new Map(preferences.map((p) => [p.agent_id, p.model]));

			// Merge preferences with agents
			const agentsWithPreferences = agents.map((agent) => ({
				...agent,
				model: prefMap.get(agent.id) || agent.model,
			}));

			// Group agents by source
			const globalAgents = agentsWithPreferences.filter(
				(a) => a.source === "global",
			);
			const workspaceAgents = agentsWithPreferences.filter(
				(a) => a.source === "workspace",
			);

			// Get workspaces
			const workspaces = agentRegistry.getWorkspaces();

			return jsonResponse({
				agents: agentsWithPreferences,
				globalAgents,
				workspaceAgents,
				workspaces,
			});
		} catch (error) {
			log.error("Error fetching agents:", error);
			return jsonResponse({ error: "Failed to fetch agents" }, 500);
		}
	};
}

export function createAgentPreferenceUpdateHandler(dbOps: DatabaseOperations) {
	return async (req: Request, agentId: string): Promise<Response> => {
		try {
			const body = await req.json();
			const { model } = body;

			if (!model) {
				throw BadRequest("Model is required");
			}

			// Validate model is in allowed list
			if (!ALLOWED_MODELS.includes(model)) {
				throw BadRequest(
					`Invalid model. Allowed models: ${ALLOWED_MODELS.join(", ")}`,
				);
			}

			// Update preference
			dbOps.setAgentPreference(agentId, model);

			return jsonResponse({
				success: true,
				agentId,
				model,
			});
		} catch (error) {
			log.error("Error updating agent preference:", error);
			if (error instanceof HttpError) {
				return jsonResponse({ error: error.message }, error.status);
			}
			return jsonResponse({ error: "Failed to update agent preference" }, 500);
		}
	};
}

export function createWorkspacesListHandler() {
	return async (): Promise<Response> => {
		try {
			const workspaces = agentRegistry.getWorkspaces();

			// Add agent count for each workspace
			const agents = await agentRegistry.getAgents();
			const workspacesWithStats = workspaces.map((workspace) => {
				const agentCount = agents.filter(
					(a) => a.source === "workspace" && a.workspace === workspace.path,
				).length;

				return {
					...workspace,
					agentCount,
				};
			});

			return jsonResponse({ workspaces: workspacesWithStats });
		} catch (error) {
			log.error("Error fetching workspaces:", error);
			return jsonResponse({ error: "Failed to fetch workspaces" }, 500);
		}
	};
}

export function createBulkAgentPreferenceUpdateHandler(
	dbOps: DatabaseOperations,
) {
	return async (req: Request): Promise<Response> => {
		const log = new Logger("BulkAgentPreferenceUpdate");

		try {
			const body = await req.json();

			// Validate input
			const modelValidation = validateString(body.model, "model", {
				required: true,
			});

			if (!modelValidation) {
				return errorResponse(BadRequest("Model is required"));
			}

			// Validate model is in allowed list
			const allowedModels = ALLOWED_MODELS as readonly string[];
			if (!allowedModels.includes(modelValidation)) {
				return errorResponse(
					BadRequest(
						`Invalid model. Allowed models: ${ALLOWED_MODELS.join(", ")}`,
					),
				);
			}

			// Get all agents from the registry
			const agents = await agentRegistry.getAgents();
			const agentIds = agents.map((agent) => agent.id);

			if (agentIds.length === 0) {
				return jsonResponse({ message: "No agents found to update" });
			}

			// Update all agent preferences in bulk
			dbOps.setBulkAgentPreferences(agentIds, modelValidation);

			log.info(
				`Updated ${agentIds.length} agent preferences to model: ${modelValidation}`,
			);

			return jsonResponse({
				success: true,
				updatedCount: agentIds.length,
				model: modelValidation,
			});
		} catch (error) {
			log.error("Error updating agent preferences in bulk:", error);

			if (error instanceof Error) {
				return errorResponse(BadRequest(error.message));
			}

			return jsonResponse({ error: "Failed to update agent preferences" }, 500);
		}
	};
}
</file>

<file path="packages/http-api/src/handlers/maintenance.ts">
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import { jsonResponse } from "@ccflare/http-common";
import type { CleanupResponse } from "../types";

export function createCleanupHandler(
	dbOps: DatabaseOperations,
	config: Config,
) {
	return (): Response => {
		const payloadDays = config.getDataRetentionDays();
		const requestDays = config.getRequestRetentionDays();
		const payloadMs = payloadDays * 24 * 60 * 60 * 1000;
		const requestMs = requestDays * 24 * 60 * 60 * 1000;
		const { removedRequests, removedPayloads } = dbOps.cleanupOldRequests(
			payloadMs,
			requestMs,
		);
		const cutoffIso = new Date(
			Date.now() - Math.min(payloadMs, requestMs),
		).toISOString();
		const payload: CleanupResponse = {
			removedRequests,
			removedPayloads,
			cutoffIso,
		};
		return jsonResponse(payload);
	};
}

export function createCompactHandler(dbOps: DatabaseOperations) {
	return (): Response => {
		dbOps.compact();
		return jsonResponse({ ok: true });
	};
}
</file>

<file path="packages/http-api/src/handlers/oauth.ts">
import { Config } from "@ccflare/config";
import { patterns, validateNumber, validateString } from "@ccflare/core";
import type { DatabaseOperations } from "@ccflare/database";
import {
	BadRequest,
	errorResponse,
	InternalServerError,
	jsonResponse,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import { createOAuthFlow } from "@ccflare/oauth-flow";

const log = new Logger("OAuthHandler");

/**
 * Create an OAuth initialization handler
 */
export function createOAuthInitHandler(dbOps: DatabaseOperations) {
	return async (req: Request): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate account name
			const name = validateString(body.name, "name", {
				required: true,
				minLength: 1,
				maxLength: 100,
				pattern: patterns.accountName,
			});

			if (!name) {
				return errorResponse(BadRequest("Valid account name is required"));
			}

			// Validate mode
			const mode = (validateString(body.mode, "mode", {
				allowedValues: ["max", "console"] as const,
			}) || "max") as "max" | "console";

			// Validate tier
			const tier =
				validateNumber(body.tier, "tier", {
					allowedValues: [1, 5, 20] as const,
				}) || 1;

			const config = new Config();
			const oauthFlow = await createOAuthFlow(dbOps, config);

			try {
				// Begin OAuth flow using consolidated logic
				const flowResult = await oauthFlow.begin({
					name,
					mode,
				});

				// Store tier in session for later use
				dbOps.createOAuthSession(
					flowResult.sessionId,
					name,
					flowResult.pkce.verifier,
					mode,
					tier,
					10, // 10 minute TTL
				);

				return jsonResponse({
					success: true,
					authUrl: flowResult.authUrl,
					sessionId: flowResult.sessionId,
					step: "authorize",
				});
			} catch (error) {
				if (
					error instanceof Error &&
					error.message.includes("already exists")
				) {
					return errorResponse(BadRequest(error.message));
				}
				return errorResponse(InternalServerError((error as Error).message));
			}
		} catch (error) {
			log.error("OAuth init error:", error);
			return errorResponse(
				error instanceof Error
					? error
					: new Error("Failed to initialize OAuth"),
			);
		}
	};
}

/**
 * Create an OAuth callback handler
 */
export function createOAuthCallbackHandler(dbOps: DatabaseOperations) {
	return async (req: Request): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate session ID
			const sessionId = validateString(body.sessionId, "sessionId", {
				required: true,
				pattern: patterns.uuid,
			});

			if (!sessionId) {
				return errorResponse(BadRequest("Session ID is required"));
			}

			// Validate code
			const code = validateString(body.code, "code", {
				required: true,
				minLength: 1,
			});

			if (!code) {
				return errorResponse(BadRequest("Authorization code is required"));
			}

			// Get stored PKCE verifier from database
			const oauthSession = dbOps.getOAuthSession(sessionId);
			if (!oauthSession) {
				return errorResponse(
					BadRequest("OAuth session expired or invalid. Please try again."),
				);
			}

			const {
				accountName: name,
				verifier,
				mode: savedMode,
				tier: savedTier,
			} = oauthSession;

			try {
				// Create OAuth flow instance
				const config = new Config();
				const oauthFlow = await createOAuthFlow(dbOps, config);

				// We need to reconstruct the flow data since we can't pass the full BeginResult through HTTP
				// The OAuth flow will handle the token exchange and account creation
				const oauthProvider = await import("@ccflare/providers").then((m) =>
					m.getOAuthProvider("anthropic"),
				);
				if (!oauthProvider) {
					throw new Error("OAuth provider not found");
				}
				const runtime = config.getRuntime();
				const oauthConfig = oauthProvider.getOAuthConfig(savedMode);
				oauthConfig.clientId = runtime.clientId;

				const flowData = {
					sessionId,
					authUrl: "", // Not needed for complete
					pkce: { verifier, challenge: "" }, // Only verifier is needed
					oauthConfig,
					mode: savedMode || "max", // Add mode to match BeginResult type
				};

				await oauthFlow.complete(
					{ sessionId, code, tier: savedTier, name },
					flowData,
				);

				// Clean up OAuth session from database
				dbOps.deleteOAuthSession(sessionId);

				return jsonResponse({
					success: true,
					message: `Account '${name}' added successfully!`,
					mode: savedMode === "max" ? "Claude Max" : "Claude Console",
					tier: savedTier,
				});
			} catch (error) {
				return errorResponse(
					error instanceof Error
						? error
						: new Error("Failed to complete OAuth flow"),
				);
			}
		} catch (error) {
			log.error("OAuth callback error:", error);
			return errorResponse(
				error instanceof Error
					? error
					: new Error("Failed to process OAuth callback"),
			);
		}
	};
}
</file>

<file path="packages/http-api/src/types.ts">
// Re-export all types from the centralized types package
export type {
	AccountDeleteRequest,
	AccountResponse,
	AnalyticsResponse,
	APIContext,
	CleanupResponse,
	CompactResponse,
	ConfigResponse,
	HealthResponse,
	ModelPerformance,
	RequestResponse,
	RetentionGetResponse,
	RetentionSetRequest,
	StatsResponse,
	StrategyUpdateRequest,
	TierUpdateRequest,
	TimePoint,
	TokenBreakdown,
} from "@ccflare/types";
</file>

<file path="packages/http-common/src/index.ts">
// Export error handling utilities

// Export HTTP client
export * from "./client";
export * from "./errors";
// Export header utilities
export * from "./headers";
// Export response utilities
export * from "./responses";
</file>

<file path="packages/providers/src/base.ts">
import type { Account } from "@ccflare/types";
import type { Provider, RateLimitInfo, TokenRefreshResult } from "./types";

export abstract class BaseProvider implements Provider {
	abstract name: string;

	/**
	 * Check if this provider can handle the given request path
	 * Default implementation: handle all paths
	 */
	canHandle(_path: string): boolean {
		return true;
	}

	/**
	 * Refresh the access token for an account
	 * Must be implemented by each provider
	 */
	abstract refreshToken(
		account: Account,
		clientId: string,
	): Promise<TokenRefreshResult>;

	/**
	 * Build the target URL for the provider
	 * Must be implemented by each provider
	 */
	abstract buildUrl(path: string, query: string): string;

	/**
	 * Prepare headers for the provider request
	 * Default implementation: Add Bearer token (if provided) and remove host header
	 * @param headers - Original request headers
	 * @param accessToken - OAuth access token (for Bearer authentication)
	 * @param apiKey - API key (provider-specific header)
	 */
	prepareHeaders(
		headers: Headers,
		accessToken?: string,
		_apiKey?: string,
	): Headers {
		const newHeaders = new Headers(headers);
		if (accessToken) {
			newHeaders.set("Authorization", `Bearer ${accessToken}`);
		}
		// Note: API key handling is provider-specific and should be
		// implemented in the provider subclass
		newHeaders.delete("host");
		return newHeaders;
	}

	/**
	 * Parse rate limit information from response
	 * Default implementation: Check unified headers first, then fall back to 429 status
	 *
	 * Note: The default implementation considers any unified status other than "allowed"
	 * to be a hard rate limit. Providers should override this method if they need to
	 * distinguish between soft warnings (e.g., "allowed_warning") and hard limits.
	 */
	parseRateLimit(response: Response): RateLimitInfo {
		// Check for unified rate limit headers (used by Anthropic and others)
		const statusHeader = response.headers.get(
			"anthropic-ratelimit-unified-status",
		);
		const resetHeader = response.headers.get(
			"anthropic-ratelimit-unified-reset",
		);

		if (statusHeader || resetHeader) {
			const resetTime = resetHeader ? Number(resetHeader) * 1000 : undefined; // Convert to ms
			return {
				isRateLimited: statusHeader !== "allowed",
				resetTime,
				statusHeader: statusHeader || undefined,
			};
		}

		// Fall back to traditional 429 check
		if (response.status !== 429) {
			return { isRateLimited: false };
		}

		// Try to extract reset time from headers
		const retryAfter = response.headers.get("retry-after");
		let resetTime: number | undefined;

		if (retryAfter) {
			// Retry-After can be seconds or HTTP date
			const seconds = Number(retryAfter);
			if (!Number.isNaN(seconds)) {
				resetTime = Date.now() + seconds * 1000;
			} else {
				resetTime = new Date(retryAfter).getTime();
			}
		}

		return { isRateLimited: true, resetTime };
	}

	/**
	 * Process the response before returning to client
	 * Default implementation: Return response as-is
	 */
	async processResponse(
		response: Response,
		_account: Account | null,
	): Promise<Response> {
		return response;
	}

	/**
	 * Extract tier information from response if available
	 * Default implementation: Return null (no tier info)
	 */
	async extractTierInfo?(_response: Response): Promise<number | null> {
		return null;
	}

	/**
	 * Extract usage information from response if available
	 * Default implementation: Return null (no usage info)
	 */
	async extractUsageInfo?(_response: Response): Promise<{
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
	} | null> {
		return null;
	}

	/**
	 * Check if the response is a streaming response
	 * Default implementation: Check for text/event-stream or stream in content-type
	 */
	isStreamingResponse?(response: Response): boolean {
		const contentType = response.headers.get("content-type") ?? "";
		return (
			contentType.includes("text/event-stream") ||
			contentType.includes("stream")
		);
	}
}
</file>

<file path="packages/providers/src/types.ts">
import type { Account } from "@ccflare/types";

export interface TokenRefreshResult {
	accessToken: string;
	expiresAt: number;
	refreshToken: string; // Always required - either new token or existing one
}

export interface RateLimitInfo {
	isRateLimited: boolean;
	resetTime?: number;
	statusHeader?: string;
	remaining?: number;
}

export interface Provider {
	name: string;

	/**
	 * Check if this provider can handle the given request path
	 */
	canHandle(path: string): boolean;

	/**
	 * Refresh the access token for an account
	 */
	refreshToken(account: Account, clientId: string): Promise<TokenRefreshResult>;

	/**
	 * Build the target URL for the provider
	 */
	buildUrl(path: string, query: string): string;

	/**
	 * Prepare headers for the provider request
	 * @param headers - Original request headers
	 * @param accessToken - OAuth access token (for Bearer authentication)
	 * @param apiKey - API key (provider-specific header)
	 */
	prepareHeaders(
		headers: Headers,
		accessToken?: string,
		apiKey?: string,
	): Headers;

	/**
	 * Parse rate limit information from response
	 */
	parseRateLimit(response: Response): RateLimitInfo;

	/**
	 * Process the response before returning to client
	 */
	processResponse(
		response: Response,
		account: Account | null,
	): Promise<Response>;

	/**
	 * Extract tier information from response if available
	 */
	extractTierInfo?(response: Response): Promise<number | null>;

	/**
	 * Extract usage information from response if available
	 */
	extractUsageInfo?(response: Response): Promise<{
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
	} | null>;

	/**
	 * Check if the response is a streaming response
	 */
	isStreamingResponse?(response: Response): boolean;
}

// OAuth-specific types
export interface OAuthProviderConfig {
	authorizeUrl: string;
	tokenUrl: string;
	clientId: string;
	scopes: string[];
	redirectUri: string;
	mode?: string;
}

export interface OAuthProvider {
	getOAuthConfig(mode?: string): OAuthProviderConfig;
	exchangeCode(
		code: string,
		verifier: string,
		config: OAuthProviderConfig,
	): Promise<TokenResult>;
	generateAuthUrl(config: OAuthProviderConfig, pkce: PKCEChallenge): string;
}

export interface PKCEChallenge {
	verifier: string;
	challenge: string;
}

export interface TokenResult {
	refreshToken: string;
	accessToken: string;
	expiresAt: number;
}
</file>

<file path="packages/proxy/src/handlers/index.ts">
export { selectAccountsForRequest } from "./account-selector";
export {
	type AgentInterceptResult,
	interceptAndModifyRequest,
} from "./agent-interceptor";
export { proxyUnauthenticated, proxyWithAccount } from "./proxy-operations";
export { ERROR_MESSAGES, type ProxyContext, TIMING } from "./proxy-types";
export {
	createRequestMetadata,
	prepareRequestBody,
	validateProviderPath,
} from "./request-handler";
export { handleProxyError } from "./response-processor";
export { applySystemPromptInterception } from "./system-prompt-interceptor";
export { getValidAccessToken } from "./token-manager";
</file>

<file path="packages/proxy/src/handlers/proxy-operations.ts">
import { logError, ProviderError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type { Account, RequestMeta } from "@ccflare/types";
import { forwardToClient } from "../response-handler";
import { ERROR_MESSAGES, type ProxyContext } from "./proxy-types";
import { makeProxyRequest } from "./request-handler";
import { handleProxyError, processProxyResponse } from "./response-processor";
import { getValidAccessToken } from "./token-manager";

const log = new Logger("ProxyOperations");

/**
 * Handles proxy request without authentication
 * @param req - The incoming request
 * @param url - The parsed URL
 * @param requestMeta - Request metadata
 * @param requestBodyBuffer - Buffered request body
 * @param createBodyStream - Function to create body stream
 * @param ctx - The proxy context
 * @returns Promise resolving to the response
 * @throws {ProviderError} If the unauthenticated request fails
 */
export async function proxyUnauthenticated(
	req: Request,
	url: URL,
	requestMeta: RequestMeta,
	requestBodyBuffer: ArrayBuffer | null,
	createBodyStream: () => ReadableStream<Uint8Array> | undefined,
	ctx: ProxyContext,
): Promise<Response> {
	log.warn(ERROR_MESSAGES.NO_ACCOUNTS);

	const targetUrl = ctx.provider.buildUrl(url.pathname, url.search);
	const headers = ctx.provider.prepareHeaders(
		req.headers,
		undefined,
		undefined,
	);

	try {
		const response = await makeProxyRequest(
			targetUrl,
			req.method,
			headers,
			createBodyStream,
			!!req.body,
		);

		return forwardToClient(
			{
				requestId: requestMeta.id,
				method: req.method,
				path: url.pathname,
				account: null,
				requestHeaders: req.headers,
				requestBody: requestBodyBuffer,
				response,
				timestamp: requestMeta.timestamp,
				retryAttempt: 0,
				failoverAttempts: 0,
				agentUsed: requestMeta.agentUsed,
			},
			ctx,
		);
	} catch (error) {
		logError(error, log);
		throw new ProviderError(
			ERROR_MESSAGES.UNAUTHENTICATED_FAILED,
			ctx.provider.name,
			502,
			{
				originalError: error instanceof Error ? error.message : String(error),
			},
		);
	}
}

/**
 * Attempts to proxy a request with a specific account
 * @param req - The incoming request
 * @param url - The parsed URL
 * @param account - The account to use
 * @param requestMeta - Request metadata
 * @param requestBodyBuffer - Buffered request body
 * @param createBodyStream - Function to create body stream
 * @param failoverAttempts - Number of failover attempts
 * @param ctx - The proxy context
 * @returns Promise resolving to response or null if failed
 */
export async function proxyWithAccount(
	req: Request,
	url: URL,
	account: Account,
	requestMeta: RequestMeta,
	requestBodyBuffer: ArrayBuffer | null,
	createBodyStream: () => ReadableStream<Uint8Array> | undefined,
	failoverAttempts: number,
	ctx: ProxyContext,
): Promise<Response | null> {
	try {
		log.info(`Attempting request with account: ${account.name}`);

		// Get valid access token
		const accessToken = await getValidAccessToken(account, ctx);

		// Prepare request
		const headers = ctx.provider.prepareHeaders(
			req.headers,
			accessToken,
			account.api_key || undefined,
		);
		const targetUrl = ctx.provider.buildUrl(url.pathname, url.search);

		// Make the request
		const response = await makeProxyRequest(
			targetUrl,
			req.method,
			headers,
			createBodyStream,
			!!req.body,
		);

		// Process response and check for rate limit
		const isRateLimited = processProxyResponse(response, account, ctx);
		if (isRateLimited) {
			return null; // Signal to try next account
		}

		// Forward response to client
		return forwardToClient(
			{
				requestId: requestMeta.id,
				method: req.method,
				path: url.pathname,
				account,
				requestHeaders: req.headers,
				requestBody: requestBodyBuffer,
				response,
				timestamp: requestMeta.timestamp,
				retryAttempt: 0,
				failoverAttempts,
				agentUsed: requestMeta.agentUsed,
			},
			ctx,
		);
	} catch (err) {
		handleProxyError(err, account, log);
		return null;
	}
}
</file>

<file path="packages/proxy/src/handlers/response-processor.ts">
import { logError, RateLimitError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type { Provider } from "@ccflare/providers";
import type { Account } from "@ccflare/types";
import type { ProxyContext } from "./proxy-types";

const log = new Logger("ResponseProcessor");

/**
 * Handles rate limit response for an account
 * @param account - The rate-limited account
 * @param rateLimitInfo - Parsed rate limit information
 * @param ctx - The proxy context
 */
export function handleRateLimitResponse(
	account: Account,
	rateLimitInfo: ReturnType<Provider["parseRateLimit"]>,
	ctx: ProxyContext,
): void {
	if (!rateLimitInfo.resetTime) return;

	log.warn(
		`Account ${account.name} rate-limited until ${new Date(
			rateLimitInfo.resetTime,
		).toISOString()}`,
	);

	const resetTime = rateLimitInfo.resetTime;
	ctx.asyncWriter.enqueue(() =>
		ctx.dbOps.markAccountRateLimited(account.id, resetTime),
	);

	const rateLimitError = new RateLimitError(
		account.id,
		rateLimitInfo.resetTime,
		rateLimitInfo.remaining,
	);
	logError(rateLimitError, log);
}

/**
 * Updates account metadata in the background
 * @param account - The account to update
 * @param response - The response to extract metadata from
 * @param ctx - The proxy context
 */
export function updateAccountMetadata(
	account: Account,
	response: Response,
	ctx: ProxyContext,
): void {
	// Update basic usage
	ctx.asyncWriter.enqueue(() => ctx.dbOps.updateAccountUsage(account.id));

	// Extract and update rate limit info for every response
	const rateLimitInfo = ctx.provider.parseRateLimit(response);
	// Only update rate limit metadata when we have actual rate limit headers
	if (rateLimitInfo.statusHeader) {
		const status = rateLimitInfo.statusHeader;
		ctx.asyncWriter.enqueue(() =>
			ctx.dbOps.updateAccountRateLimitMeta(
				account.id,
				status,
				rateLimitInfo.resetTime ?? null,
				rateLimitInfo.remaining,
			),
		);
	}

	// Extract tier info if supported
	if (ctx.provider.extractTierInfo) {
		const extractTierInfo = ctx.provider.extractTierInfo.bind(ctx.provider);
		(async () => {
			const tier = await extractTierInfo(response.clone() as Response);
			if (tier && tier !== account.account_tier) {
				log.info(
					`Updating account ${account.name} tier from ${account.account_tier} to ${tier}`,
				);
				ctx.asyncWriter.enqueue(() =>
					ctx.dbOps.updateAccountTier(account.id, tier),
				);
			}
		})();
	}
}

/**
 * Processes a successful proxy response
 * @param response - The provider response
 * @param account - The account used
 * @param ctx - The proxy context
 * @returns Whether the response is rate-limited
 */
export function processProxyResponse(
	response: Response,
	account: Account,
	ctx: ProxyContext,
): boolean {
	const isStream = ctx.provider.isStreamingResponse?.(response) ?? false;
	const rateLimitInfo = ctx.provider.parseRateLimit(response);

	// Handle rate limit
	if (!isStream && rateLimitInfo.isRateLimited && rateLimitInfo.resetTime) {
		handleRateLimitResponse(account, rateLimitInfo, ctx);
		// Also update metadata for rate-limited responses
		updateAccountMetadata(account, response, ctx);
		return true; // Signal rate limit
	}

	// Update account metadata in background
	updateAccountMetadata(account, response, ctx);
	return false;
}

/**
 * Handles errors that occur during proxy operations
 * @param error - The error that occurred
 * @param account - The account that failed (optional)
 * @param logger - Logger instance
 */
export function handleProxyError(
	error: unknown,
	account: Account | null,
	logger: Logger,
): void {
	logError(error, logger);
	if (account) {
		logger.error(`Failed to proxy request with account ${account.name}`);
	} else {
		logger.error("Failed to proxy request");
	}
}
</file>

<file path="packages/proxy/src/handlers/token-manager.ts">
import { ServiceUnavailableError, TokenRefreshError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type { TokenRefreshResult } from "@ccflare/providers";
import type { Account } from "@ccflare/types";
import { TOKEN_REFRESH_BACKOFF_MS, TOKEN_SAFETY_WINDOW_MS } from "../constants";
import { ERROR_MESSAGES, type ProxyContext } from "./proxy-types";

const log = new Logger("TokenManager");

// Track refresh failures for backoff
const refreshFailures = new Map<string, number>();

/**
 * Safely refreshes an access token with deduplication
 * @param account - The account to refresh token for
 * @param ctx - The proxy context
 * @returns Promise resolving to the new access token
 * @throws {TokenRefreshError} If token refresh fails
 * @throws {ServiceUnavailableError} If refresh promise is not found
 */
export async function refreshAccessTokenSafe(
	account: Account,
	ctx: ProxyContext,
): Promise<string> {
	// Check for recent refresh failures and implement backoff
	const lastFailure = refreshFailures.get(account.id);
	if (lastFailure && Date.now() - lastFailure < TOKEN_REFRESH_BACKOFF_MS) {
		log.warn(`Account ${account.name} is in refresh backoff period`);
		throw new ServiceUnavailableError(
			`Token refresh for account ${account.name} is in backoff period after recent failure`,
		);
	}

	// Check if a refresh is already in progress for this account
	if (!ctx.refreshInFlight.has(account.id)) {
		// Create a new refresh promise and store it
		const refreshPromise = ctx.provider
			.refreshToken(account, ctx.runtime.clientId)
			.then((result: TokenRefreshResult) => {
				// 1. Persist to database asynchronously
				ctx.asyncWriter.enqueue(() =>
					ctx.dbOps.updateAccountTokens(
						account.id,
						result.accessToken,
						result.expiresAt,
						result.refreshToken,
					),
				);

				// 2. Update the live in-memory account object immediately
				// This prevents subsequent requests from seeing stale token data
				account.access_token = result.accessToken;
				account.expires_at = result.expiresAt;
				if (result.refreshToken) {
					account.refresh_token = result.refreshToken;
				}
				account.last_used = Date.now();

				// Clear any previous failure record on successful refresh
				refreshFailures.delete(account.id);

				log.info(`Successfully refreshed token for account: ${account.name}`);
				return result.accessToken;
			})
			.catch((error) => {
				// Record the failure timestamp for backoff
				refreshFailures.set(account.id, Date.now());
				log.error(`Token refresh failed for account ${account.name}`, error);
				throw new TokenRefreshError(account.id, error as Error);
			})
			.finally(() => {
				// Clean up the map when done (success or failure)
				ctx.refreshInFlight.delete(account.id);
			});
		ctx.refreshInFlight.set(account.id, refreshPromise);
	}

	// Return the existing or new refresh promise
	const promise = ctx.refreshInFlight.get(account.id);
	if (!promise) {
		throw new ServiceUnavailableError(
			`${ERROR_MESSAGES.REFRESH_NOT_FOUND} ${account.id}`,
		);
	}
	return promise;
}

/**
 * Gets a valid access token for an account, refreshing if necessary
 * @param account - The account to get token for
 * @param ctx - The proxy context
 * @returns Promise resolving to a valid access token
 */
export async function getValidAccessToken(
	account: Account,
	ctx: ProxyContext,
): Promise<string> {
	// API key accounts don't use access tokens
	if (!account.refresh_token && account.api_key) {
		// Return empty string - the API key will be used in prepareHeaders
		return "";
	}

	// Check if token exists and won't expire within the safety window
	if (
		account.access_token &&
		account.expires_at &&
		account.expires_at - Date.now() > TOKEN_SAFETY_WINDOW_MS
	) {
		return account.access_token;
	}

	// Token is expired, missing, or will expire soon
	const reason = !account.access_token
		? "missing"
		: !account.expires_at
			? "no expiry"
			: account.expires_at <= Date.now()
				? "expired"
				: "expiring soon";

	log.info(`Token ${reason} for account: ${account.name}`);
	return await refreshAccessTokenSafe(account, ctx);
}
</file>

<file path="packages/proxy/src/constants.ts">
// Token management constants
export const TOKEN_SAFETY_WINDOW_MS = 30_000; // 30 seconds - proactive refresh window
export const TOKEN_REFRESH_BACKOFF_MS = 60_000; // 60 seconds - backoff after refresh failure
</file>

<file path="packages/tui-core/src/analytics.ts">
import { DatabaseFactory } from "@ccflare/database";

export interface TimeSeriesDataPoint {
	time: number;
	requests: number;
	tokens: number;
	cost: number;
	responseTime: number;
	errorRate: number;
	cacheHitRate: number;
	successRate: number;
}

export interface ModelDistribution {
	model: string;
	count: number;
	percentage: number;
}

export interface Analytics {
	timeSeries: TimeSeriesDataPoint[];
	modelDistribution: ModelDistribution[];
}

function getRangeConfig(range: string): {
	startMs: number;
	bucketMs: number;
} {
	const now = Date.now();
	const hour = 60 * 60 * 1000;
	const day = 24 * hour;

	switch (range) {
		case "1h":
			return {
				startMs: now - hour,
				bucketMs: 5 * 60 * 1000, // 5 minutes
			};
		case "6h":
			return {
				startMs: now - 6 * hour,
				bucketMs: 15 * 60 * 1000, // 15 minutes
			};
		case "24h":
			return {
				startMs: now - day,
				bucketMs: 30 * 60 * 1000, // 30 minutes
			};
		case "7d":
			return {
				startMs: now - 7 * day,
				bucketMs: 60 * 60 * 1000, // 1 hour
			};
		default:
			return {
				startMs: now - day,
				bucketMs: 30 * 60 * 1000, // 30 minutes
			};
	}
}

export async function getAnalytics(timeRange: string): Promise<Analytics> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	const { startMs, bucketMs } = getRangeConfig(timeRange);

	// Get time series data
	const timeSeriesQuery = db.prepare(`
		SELECT
			(timestamp / ?) * ? as ts,
			COUNT(*) as requests,
			SUM(COALESCE(total_tokens, 0)) as tokens,
			SUM(COALESCE(cost_usd, 0)) as cost,
			AVG(response_time_ms) as avg_response_time,
			SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as error_rate,
			SUM(COALESCE(cache_read_input_tokens, 0)) * 100.0 / 
				NULLIF(SUM(COALESCE(input_tokens, 0) + COALESCE(cache_read_input_tokens, 0) + COALESCE(cache_creation_input_tokens, 0)), 0) as cache_hit_rate,
			SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as success_rate
		FROM requests
		WHERE timestamp > ?
		GROUP BY ts
		ORDER BY ts
	`);

	const timeSeries = timeSeriesQuery.all(bucketMs, bucketMs, startMs) as Array<{
		ts: number;
		requests: number;
		tokens: number;
		cost: number;
		avg_response_time: number;
		error_rate: number;
		cache_hit_rate: number;
		success_rate: number;
	}>;

	// Get model distribution
	const modelDistQuery = db.prepare(`
		SELECT
			model,
			COUNT(*) as count
		FROM requests
		WHERE timestamp > ? AND model IS NOT NULL
		GROUP BY model
		ORDER BY count DESC
	`);

	const modelDistData = modelDistQuery.all(startMs) as Array<{
		model: string;
		count: number;
	}>;

	const totalModelRequests = modelDistData.reduce((sum, m) => sum + m.count, 0);

	const modelDistribution = modelDistData.map((m) => ({
		model: m.model,
		count: m.count,
		percentage:
			totalModelRequests > 0 ? (m.count / totalModelRequests) * 100 : 0,
	}));

	return {
		timeSeries: timeSeries.map((point) => ({
			time: point.ts,
			requests: point.requests || 0,
			tokens: point.tokens || 0,
			cost: point.cost || 0,
			responseTime: point.avg_response_time || 0,
			errorRate: point.error_rate || 0,
			cacheHitRate: point.cache_hit_rate || 0,
			successRate: point.success_rate || 0,
		})),
		modelDistribution,
	};
}
</file>

<file path="packages/tui-core/src/args.ts">
import { parseArgs as nodeParseArgs } from "node:util";

export interface ParsedArgs {
	help?: boolean;
	serve?: boolean;
	port?: number;
	logs?: boolean | number;
	stats?: boolean;
	addAccount?: string;
	mode?: "max" | "console";
	tier?: 1 | 5 | 20;
	list?: boolean;
	remove?: string;
	pause?: string;
	resume?: string;
	analyze?: boolean;
	resetStats?: boolean;
	clearHistory?: boolean;
	getModel?: boolean;
	setModel?: string;
}

export function parseArgs(args: string[]): ParsedArgs {
	try {
		const { values } = nodeParseArgs({
			args,
			options: {
				help: { type: "boolean", short: "h" },
				serve: { type: "boolean" },
				port: { type: "string" },
				logs: { type: "string" },
				stats: { type: "boolean" },
				"add-account": { type: "string" },
				mode: { type: "string" },
				tier: { type: "string" },
				list: { type: "boolean" },
				remove: { type: "string" },
				pause: { type: "string" },
				resume: { type: "string" },
				analyze: { type: "boolean" },
				"reset-stats": { type: "boolean" },
				"clear-history": { type: "boolean" },
				"get-model": { type: "boolean" },
				"set-model": { type: "string" },
			},
			allowPositionals: true,
		});

		const result: ParsedArgs = {};

		if (values.help) result.help = true;
		if (values.serve) result.serve = true;
		if (values.port) result.port = parseInt(values.port, 10);
		if (values.logs !== undefined) {
			result.logs = values.logs ? parseInt(values.logs, 10) : true;
		}
		if (values.stats) result.stats = true;
		if (values["add-account"]) result.addAccount = values["add-account"];
		if (values.mode) result.mode = values.mode as "max" | "console";
		if (values.tier) result.tier = parseInt(values.tier, 10) as 1 | 5 | 20;
		if (values.list) result.list = true;
		if (values.remove) result.remove = values.remove;
		if (values.pause) result.pause = values.pause;
		if (values.resume) result.resume = values.resume;
		if (values.analyze) result.analyze = true;
		if (values["reset-stats"]) result.resetStats = true;
		if (values["clear-history"]) result.clearHistory = true;
		if (values["get-model"]) result.getModel = true;
		if (values["set-model"]) result.setModel = values["set-model"];

		return result;
	} catch (error) {
		console.error("Error parsing arguments:", error);
		return { help: true };
	}
}
</file>

<file path="packages/tui-core/src/index.ts">
export * from "./accounts";
export * from "./analytics";
export * from "./args";
export * from "./logs";
export * from "./requests";
export * from "./stats";
export * from "./strategy";
</file>

<file path="packages/types/src/account.ts">
// AccountTier represents the tier level (1, 5, or 20)
export type AccountTier = number;

// Database row types that match the actual database schema
export interface AccountRow {
	id: string;
	name: string;
	provider: string | null;
	api_key: string | null;
	refresh_token: string;
	access_token: string | null;
	expires_at: number | null;
	created_at: number;
	last_used: number | null;
	request_count: number;
	total_requests: number;
	rate_limited_until?: number | null;
	session_start?: number | null;
	session_request_count?: number;
	account_tier: number;
	paused?: 0 | 1;
	rate_limit_reset?: number | null;
	rate_limit_status?: string | null;
	rate_limit_remaining?: number | null;
}

// Domain model - used throughout the application
export interface Account {
	id: string;
	name: string;
	provider: string;
	api_key: string | null;
	refresh_token: string;
	access_token: string | null;
	expires_at: number | null;
	request_count: number;
	total_requests: number;
	last_used: number | null;
	created_at: number;
	rate_limited_until: number | null;
	session_start: number | null;
	session_request_count: number;
	account_tier: number; // 1, 5, or 20
	paused: boolean;
	rate_limit_reset: number | null;
	rate_limit_status: string | null;
	rate_limit_remaining: number | null;
}

// API response type - what clients receive
export interface AccountResponse {
	id: string;
	name: string;
	provider: string;
	requestCount: number;
	totalRequests: number;
	lastUsed: string | null;
	created: string;
	tier: number;
	paused: boolean;
	tokenStatus: "valid" | "expired";
	tokenExpiresAt: string | null; // ISO timestamp of token expiration
	rateLimitStatus: string;
	rateLimitReset: string | null;
	rateLimitRemaining: number | null;
	sessionInfo: string;
}

// UI display type - used in TUI and web dashboard
export interface AccountDisplay {
	id: string;
	name: string;
	provider: string;
	tierDisplay: string;
	created: Date;
	lastUsed: Date | null;
	requestCount: number;
	totalRequests: number;
	tokenStatus: "valid" | "expired";
	rateLimitStatus: string;
	sessionInfo: string;
	paused: boolean;
	tier?: number;
	account_tier?: number;
	rate_limited_until?: number | null;
	session_start?: number | null;
	session_request_count?: number;
	access_token?: string | null;
}

// CLI list item type
export interface AccountListItem {
	id: string;
	name: string;
	provider: string;
	tier: number;
	tierDisplay: string;
	created: Date;
	lastUsed: Date | null;
	requestCount: number;
	totalRequests: number;
	paused: boolean;
	tokenStatus: "valid" | "expired";
	rateLimitStatus: string;
	sessionInfo: string;
	mode: "max" | "console";
}

// Account creation types
export interface AddAccountOptions {
	name: string;
	mode?: "max" | "console";
	tier?: 1 | 5 | 20;
}

export interface AccountDeleteRequest {
	confirm: string;
}

// Type mappers
export function toAccount(row: AccountRow): Account {
	return {
		id: row.id,
		name: row.name,
		provider: row.provider || "anthropic",
		api_key: row.api_key,
		refresh_token: row.refresh_token,
		access_token: row.access_token,
		expires_at: row.expires_at,
		created_at: row.created_at,
		last_used: row.last_used,
		request_count: row.request_count,
		total_requests: row.total_requests,
		rate_limited_until: row.rate_limited_until || null,
		session_start: row.session_start || null,
		session_request_count: row.session_request_count || 0,
		account_tier: row.account_tier || 1,
		paused: row.paused === 1,
		rate_limit_reset: row.rate_limit_reset || null,
		rate_limit_status: row.rate_limit_status || null,
		rate_limit_remaining: row.rate_limit_remaining || null,
	};
}

export function toAccountResponse(account: Account): AccountResponse {
	const tokenStatus = account.access_token ? "valid" : "expired";
	const isRateLimited =
		account.rate_limited_until && account.rate_limited_until > Date.now();
	const rateLimitStatus =
		isRateLimited && account.rate_limited_until
			? `Rate limited until ${new Date(account.rate_limited_until).toLocaleString()}`
			: "OK";

	const sessionInfo = account.session_start
		? `Session: ${account.session_request_count} requests`
		: "No active session";

	return {
		id: account.id,
		name: account.name,
		provider: account.provider,
		requestCount: account.request_count,
		totalRequests: account.total_requests,
		lastUsed: account.last_used
			? new Date(account.last_used).toISOString()
			: null,
		created: new Date(account.created_at).toISOString(),
		tier: account.account_tier,
		paused: account.paused,
		tokenStatus,
		tokenExpiresAt: account.expires_at
			? new Date(account.expires_at).toISOString()
			: null,
		rateLimitStatus,
		rateLimitReset: account.rate_limit_reset
			? new Date(account.rate_limit_reset).toISOString()
			: null,
		rateLimitRemaining: account.rate_limit_remaining,
		sessionInfo,
	};
}

export function toAccountDisplay(account: Account): AccountDisplay {
	const tokenStatus = account.access_token ? "valid" : "expired";
	const isRateLimited =
		account.rate_limited_until && account.rate_limited_until > Date.now();
	const rateLimitStatus =
		isRateLimited && account.rate_limited_until
			? `Rate limited until ${new Date(account.rate_limited_until).toLocaleString()}`
			: "OK";

	const sessionInfo = account.session_start
		? `Session: ${account.session_request_count} requests`
		: "No active session";

	return {
		id: account.id,
		name: account.name,
		provider: account.provider,
		tierDisplay: `Tier ${account.account_tier}`,
		created: new Date(account.created_at),
		lastUsed: account.last_used ? new Date(account.last_used) : null,
		requestCount: account.request_count,
		totalRequests: account.total_requests,
		tokenStatus,
		rateLimitStatus,
		sessionInfo,
		paused: account.paused,
		tier: account.account_tier,
		account_tier: account.account_tier,
		rate_limited_until: account.rate_limited_until,
		session_start: account.session_start,
		session_request_count: account.session_request_count,
		access_token: account.access_token,
	};
}
</file>

<file path="packages/types/src/agent-constants.ts">
import type { AgentTool } from "./agent";

export const ALL_TOOLS: AgentTool[] = [
	"Bash",
	"Glob",
	"Grep",
	"LS",
	"Read",
	"Edit",
	"MultiEdit",
	"Write",
	"NotebookRead",
	"NotebookEdit",
	"WebFetch",
	"TodoWrite",
	"WebSearch",
];

export const TOOL_PRESETS = {
	all: [] as AgentTool[], // empty means don't set tools property
	edit: ["Edit", "MultiEdit", "Write", "NotebookEdit"] as AgentTool[],
	"read-only": [
		"Glob",
		"Grep",
		"LS",
		"Read",
		"NotebookRead",
		"WebFetch",
		"TodoWrite",
		"WebSearch",
	] as AgentTool[],
	execution: ["Bash"] as AgentTool[],
} as const;
</file>

<file path="packages/types/src/conversation.ts">
export type Role = "user" | "assistant" | "system";

export interface ToolUse {
	id?: string;
	name: string;
	input?: Record<string, unknown>;
}

export interface ToolResult {
	tool_use_id: string;
	content: string;
}

export enum ContentBlockType {
	Text = "text",
	ToolUse = "tool_use",
	ToolResult = "tool_result",
	Thinking = "thinking",
}

export interface ContentBlock {
	type: ContentBlockType;
	text?: string;
	thinking?: string;
	id?: string;
	name?: string;
	input?: Record<string, unknown>;
	tool_use_id?: string;
	content?: string;
}

export interface MessageData {
	role: Role;
	content: string;
	contentBlocks?: ContentBlock[];
	tools?: ToolUse[];
	toolResults?: ToolResult[];
}
</file>

<file path="packages/types/src/stats.ts">
// Stats types
export interface Stats {
	totalRequests: number;
	successRate: number;
	activeAccounts: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	topModels: Array<{ model: string; count: number }>;
	avgTokensPerSecond: number | null;
}

export interface StatsResponse {
	totalRequests: number;
	successRate: number;
	activeAccounts: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	topModels: Array<{ model: string; count: number }>;
	avgTokensPerSecond: number | null;
}

export interface StatsWithAccounts extends Stats {
	accounts: Array<{
		name: string;
		requestCount: number;
		successRate: number;
	}>;
	recentErrors: string[];
}

// Analytics types
export interface TimePoint {
	ts: number; // period start (ms)
	model?: string; // Optional model name for per-model time series
	requests: number;
	tokens: number;
	costUsd: number;
	successRate: number; // 0-100
	errorRate: number; // 0-100
	cacheHitRate: number; // 0-100
	avgResponseTime: number; // ms
	avgTokensPerSecond: number | null;
}

export interface TokenBreakdown {
	inputTokens: number;
	cacheReadInputTokens: number;
	cacheCreationInputTokens: number;
	outputTokens: number;
}

export interface ModelPerformance {
	model: string;
	avgResponseTime: number;
	p95ResponseTime: number;
	errorRate: number;
	avgTokensPerSecond: number | null;
	minTokensPerSecond: number | null;
	maxTokensPerSecond: number | null;
}

export interface AnalyticsResponse {
	meta?: {
		range: string;
		bucket: string;
		cumulative?: boolean;
	};
	totals: {
		requests: number;
		successRate: number;
		activeAccounts: number;
		avgResponseTime: number;
		totalTokens: number;
		totalCostUsd: number;
		avgTokensPerSecond: number | null;
	};
	timeSeries: TimePoint[];
	tokenBreakdown: TokenBreakdown;
	modelDistribution: Array<{ model: string; count: number }>;
	accountPerformance: Array<{
		name: string;
		requests: number;
		successRate: number;
	}>;
	costByModel: Array<{
		model: string;
		costUsd: number;
		requests: number;
		totalTokens?: number;
	}>;
	modelPerformance: ModelPerformance[];
}

// Health check response
export interface HealthResponse {
	status: string;
	accounts: number;
	timestamp: string;
	strategy: string;
}

// Config types
export interface ConfigResponse {
	lb_strategy: string;
	port: number;
	sessionDurationMs: number;
	default_agent_model: string;
}

export interface StrategyUpdateRequest {
	strategy: string;
}

export interface TierUpdateRequest {
	tier: number;
}
</file>

<file path="packages/ui-common/src/utils/generate-message-key.ts">
import type { MessageData } from "@ccflare/types";

export const genMessageKey = (msg: MessageData, index: number): string => {
	const preview = msg.content?.slice(0, 20).replace(/\s/g, "-");
	return [
		"msg",
		msg.role,
		index,
		preview ||
			msg.tools?.[0]?.name ||
			msg.toolResults?.[0]?.tool_use_id ||
			"empty",
	].join("-");
};
</file>

<file path="packages/ui-common/src/presenters.ts">
import type {
	Account,
	AccountDisplay,
	AccountResponse,
	Request,
	RequestResponse,
	StatsResponse,
	StatsWithAccounts,
} from "@ccflare/types";
import {
	formatCost,
	formatDuration,
	formatPercentage,
	formatTimestamp,
	formatTokens,
} from "./formatters";

/**
 * Account presenter - formats account data for display
 */
export class AccountPresenter {
	constructor(private account: Account | AccountResponse | AccountDisplay) {}

	get tierDisplay(): string {
		let tier: number | undefined;
		if ("tier" in this.account) {
			tier = this.account.tier;
		} else if ("account_tier" in this.account) {
			tier = this.account.account_tier;
		}
		return `Tier ${tier || 1}`;
	}

	get tokenStatus(): "valid" | "expired" {
		if ("tokenStatus" in this.account) {
			return this.account.tokenStatus;
		}
		if ("access_token" in this.account) {
			return this.account.access_token ? "valid" : "expired";
		}
		return "expired";
	}

	get rateLimitStatus(): string {
		if ("rateLimitStatus" in this.account) {
			return this.account.rateLimitStatus;
		}

		if (
			"rate_limited_until" in this.account &&
			this.account.rate_limited_until
		) {
			const isRateLimited = this.account.rate_limited_until > Date.now();
			return isRateLimited
				? `Rate limited until ${formatTimestamp(this.account.rate_limited_until)}`
				: "OK";
		}
		return "OK";
	}

	get sessionInfo(): string {
		if ("sessionInfo" in this.account) {
			return this.account.sessionInfo;
		}

		if ("session_start" in this.account && this.account.session_start) {
			const count =
				"session_request_count" in this.account
					? this.account.session_request_count
					: 0;
			return `Session: ${count} requests`;
		}
		return "No active session";
	}

	get requestCount(): number {
		return "requestCount" in this.account
			? this.account.requestCount
			: this.account.request_count;
	}

	get totalRequests(): number {
		return "totalRequests" in this.account
			? this.account.totalRequests
			: this.account.total_requests;
	}

	get isPaused(): boolean {
		if ("paused" in this.account) {
			return this.account.paused;
		}
		return false;
	}

	get isRateLimited(): boolean {
		if ("rate_limited_until" in this.account) {
			return Boolean(
				this.account.rate_limited_until &&
					this.account.rate_limited_until > Date.now(),
			);
		}
		const status = this.rateLimitStatus.toLowerCase();
		return status !== "ok" && !status.startsWith("allowed");
	}
}

/**
 * Request presenter - formats request data for display
 */
export class RequestPresenter {
	constructor(private request: Request | RequestResponse) {}

	get statusDisplay(): string {
		const code = this.request.statusCode;
		if (!code) return "N/A";
		return code.toString();
	}

	get responseTimeDisplay(): string {
		const time = this.request.responseTimeMs;
		if (!time) return "N/A";
		return formatDuration(time);
	}

	get tokensDisplay(): string {
		return formatTokens(this.request.totalTokens);
	}

	get costDisplay(): string {
		return formatCost(this.request.costUsd);
	}

	get isSuccess(): boolean {
		return this.request.success;
	}

	get hasTokenUsage(): boolean {
		return Boolean(this.request.inputTokens || this.request.outputTokens);
	}
}

/**
 * Stats presenter - formats stats data for display
 */
export class StatsPresenter {
	constructor(private stats: StatsResponse | StatsWithAccounts) {}

	get successRateDisplay(): string {
		return formatPercentage(this.stats.successRate);
	}

	get avgResponseTimeDisplay(): string {
		return formatDuration(this.stats.avgResponseTime);
	}

	get totalTokensDisplay(): string {
		return formatTokens(this.stats.totalTokens);
	}

	get totalCostDisplay(): string {
		return formatCost(this.stats.totalCostUsd);
	}

	get topModel(): string | null {
		if (!this.stats.topModels || this.stats.topModels.length === 0) {
			return null;
		}
		return this.stats.topModels[0].model;
	}

	get hasAccounts(): boolean {
		return "accounts" in this.stats && this.stats.accounts.length > 0;
	}
}
</file>

<file path="metaPlanPrompt.md">
You are an expert AI Software Architect. Your sole purpose is to analyze a user's feature request against a provided codebase and produce a detailed, phased implementation plan. This plan must be structured as a series of atomic, sequential tickets formatted in XML. These tickets will be executed by a downstream agentic AI coding tool, so each ticket must be a complete, high-quality, and self-contained prompt for that tool.

**CORE DIRECTIVE:**
Decompose the user's request into the smallest possible, logical, and sequential steps. Each step will become a ticket. Tightly related, trivial steps can be bundled into a single ticket. The final output must be a single XML block containing the complete roadmap.

**AMBIGUITY HANDLING:**
If the user's <<BRIEF>> is too vague or ambiguous to create a concrete, actionable plan, you must not invent details. Instead, respond by stating that the brief is unclear and ask up to 3 specific clarifying questions that would enable you to generate the roadmap.

**INPUT CONTRACT:**
You will receive the user's feature request within a <<BRIEF>> block and the relevant codebase context within a <files> block. Analyze these inputs to understand the goal, the current state of the code, and the required changes.

**TICKET GENERATION PRINCIPLES:**
Each ticket you generate must be a production-ready prompt for the downstream AI coding agent. Adhere to the following principles:
1.  **Role & Context:** The ticket's description must define the context for the coding agent (e.g., "This ticket modifies the backend API for analytics...").
2.  **Clarity & Unambiguity:** Implementation steps must be explicit and sequential. For complex logic, instruct the agent to "think step-by-step."
3.  **Simplicity & Pragmatism:** Favor straightforward, simple solutions over complex ones unless a compelling reason exists and is documented in the roadmap's context. Avoid over-engineering.
4.  **Code Quality & Best Practices:** All generated code must be clean, maintainable, and adhere to software engineering best practices, including DRY (Don't Repeat Yourself) and debuggability (through clear error handling and logging). The plan must include refactoring and cleanup steps to remove any dead or redundant code.
5.  **Integrated Testing:** Each ticket that implements or modifies code must also include corresponding instructions to create, update, or remove relevant tests. Testing is not a separate phase but an integral part of implementation.
6.  **Completeness:** A ticket must contain all information required for its implementation. The coding agent will not have access to the full roadmap, only the ticket it is currently assigned.

**YOUR WORKFLOW:**
1.  **Analyze the Goal:** Deeply understand the user's intent in the <<BRIEF>>.
2.  **Scan the Codebase:** Identify all relevant files, architectural patterns, data structures, and potential impact areas within the provided <files>.
3.  **Create a Phased Plan:** Mentally break down the feature into logical phases (e.g., Database Schema -> Backend API -> Frontend Component -> Testing -> Documentation). Identify potential risks, alternatives, and breaking changes to document in the roadmap.
4.  **Decompose into Atomic Tickets:** Within each phase, break the work into the smallest possible, verifiable steps. This includes tickets for implementation, testing, and cleanup.
5.  **Write the Tickets:** Author each ticket according to the XML format specified below.
6.  **Map Dependencies:** Use the `depends_on` attribute to define the precise execution order.
7.  **Assemble the Roadmap:** Combine all context and tickets into the final `<roadmap>` XML structure.

**OUTPUT FORMAT (XML):**
You MUST produce your entire response within a single, valid XML block. The structure is as follows:
<example>
<roadmap name="[A_CONCISE_CAMELCASE_NAME_FOR_THE_FEATURE]" version="1.0">
    <!-- A high-level summary of the overall goal and implementation strategy. -->
    <context>
        [Provide a 2-4 sentence overview of the feature to be implemented and the general approach. Mention the key packages or apps that will be modified.]
    </context>

    <!-- A brief, high-level summary of potential risks, challenges, or alternative implementation strategies considered. -->
    <risks_and_alternatives>
        [Provide a bulleted list of potential risks (e.g., "Modifying the core auth logic is risky and requires careful testing.") or alternatives considered (e.g., "Alternative considered: Using a separate microservice, but rejected due to complexity.")]
    </risks_and_alternatives>

    <!-- A series of one or more tickets. -->
    <ticket id="[A_UNIQUE_TICKET_ID, e.g., 'BE-01']" depends_on="[COMMA_SEPARATED_LIST_OF_TICKET_IDS, or 'ROOT' if none]" is_breaking_change="true|false">
        <!-- A clear, imperative title for the ticket. -->
        <title>[CONCISE_TICKET_TITLE]</title>

        <!-- A detailed description of the ticket's purpose and rationale. If is_breaking_change is true, this section MUST start with 'BREAKING CHANGE:' followed by an explanation of the impact. -->
        <description>
            [WHAT this ticket accomplishes and WHY it's necessary. Explain its role in the larger feature.]
        </description>

        <!-- Detailed, step-by-step instructions for the AI coding agent. This section must be extremely clear. -->
        <implementation_notes>
            [Provide a numbered or bulleted list of implementation steps. Be specific about logic, function signatures, variable names, and error handling. Reference existing code patterns and adhere to best practices (DRY, simplicity, debuggability). If a new external dependency is required, explicitly state the package name and the command to add it (e.g., `bun add <package-name>`). For any code changes, this section must also include instructions to add, modify, or delete corresponding tests. If a change makes an existing test obsolete, explicitly instruct its removal. **For documentation files (like README.md), provide a high-level outline of the topics to cover rather than the exact prose.**]
        </implementation_notes>

        <!-- A list of all file modifications required for this ticket. This must include modifications to test files. -->
        <files>
            <!-- One <file> tag for each file to be created, modified, or deleted. Use the DELETE action to remove obsolete code or tests. -->
            <file path="[FULL_PATH_TO_THE_FILE_FROM_REPO_ROOT]" action="CREATE|MODIFY|DELETE">
                <!--
                For CREATE: Describe the initial content and structure of the new file.
                For MODIFY: Provide precise instructions for the changes (e.g., "Add a new function `...`", "Update the `...` interface to include `...`").
                For DELETE: Briefly state the reason for deletion (e.g., "Refactored into new module, this file is now redundant.").
                -->
                [DETAILED_INSTRUCTIONS_FOR_THIS_FILE]
            </file>
        </files>

        <!-- A list of steps to verify that the ticket was implemented correctly. This serves as the ticket's acceptance criteria. -->
        <verification_steps>
            [Provide a numbered or bulleted list of criteria. Include manual verification steps, commands to run (e.g., `bun run typecheck`, `bun test`), and relevant non-functional requirements like security validation. Do not include performance-related criteria.]
        </verification_steps>
    </ticket>
</roadmap>
<example>
</file>

<file path="tsconfig.json">
{
	"compilerOptions": {
		"lib": ["ESNext", "DOM", "DOM.Iterable"],
		"module": "esnext",
		"target": "esnext",
		"moduleResolution": "bundler",
		"moduleDetection": "force",
		"allowImportingTsExtensions": true,
		"noEmit": true,
		"strict": true,
		"skipLibCheck": true,
		"allowSyntheticDefaultImports": true,
		"forceConsistentCasingInFileNames": true,
		"allowJs": true,
		"types": ["bun-types"],
		"jsx": "react-jsx",
		"baseUrl": ".",
		"paths": {
			"@ccflare/*": ["packages/*/src"]
		}
	},
	"include": ["packages/*/src/**/*", "apps/*/src/**/*"]
}
</file>

<file path="apps/server/src/server.ts">
import { dirname } from "node:path";
import { Config, type RuntimeConfig } from "@ccflare/config";
import {
	CACHE,
	DEFAULT_STRATEGY,
	HTTP_STATUS,
	NETWORK,
	registerDisposable,
	setPricingLogger,
	shutdown,
	TIME_CONSTANTS,
} from "@ccflare/core";
import { container, SERVICE_KEYS } from "@ccflare/core-di";
// Import React dashboard assets
import dashboardManifest from "@ccflare/dashboard-web/dist/manifest.json";
import type { DatabaseOperations } from "@ccflare/database";
import { AsyncDbWriter, DatabaseFactory } from "@ccflare/database";
import { APIRouter } from "@ccflare/http-api";
import { SessionStrategy } from "@ccflare/load-balancer";
import { Logger } from "@ccflare/logger";
import { getProvider } from "@ccflare/providers";
import {
	getUsageWorker,
	handleProxy,
	type ProxyContext,
	terminateUsageWorker,
} from "@ccflare/proxy";
import { serve } from "bun";

// Helper function to resolve dashboard assets with fallback
function resolveDashboardAsset(assetPath: string): string | null {
	try {
		// Try resolving as a package first
		return Bun.resolveSync(
			`@ccflare/dashboard-web/dist${assetPath}`,
			dirname(import.meta.path),
		);
	} catch {
		// Fallback to relative path within the repo (development / mono-repo usage)
		try {
			return Bun.resolveSync(
				`../../../packages/dashboard-web/dist${assetPath}`,
				dirname(import.meta.path),
			);
		} catch {
			return null;
		}
	}
}

// Helper function to serve dashboard files with proper headers
function serveDashboardFile(
	assetPath: string,
	contentType?: string,
	cacheControl?: string,
): Response {
	const fullPath = resolveDashboardAsset(assetPath);
	if (!fullPath) {
		return new Response("Not Found", { status: HTTP_STATUS.NOT_FOUND });
	}

	// Auto-detect content type if not provided
	if (!contentType) {
		if (assetPath.endsWith(".js")) contentType = "application/javascript";
		else if (assetPath.endsWith(".css")) contentType = "text/css";
		else if (assetPath.endsWith(".html")) contentType = "text/html";
		else if (assetPath.endsWith(".json")) contentType = "application/json";
		else if (assetPath.endsWith(".svg")) contentType = "image/svg+xml";
		else contentType = "text/plain";
	}

	return new Response(Bun.file(fullPath), {
		headers: {
			"Content-Type": contentType,
			"Cache-Control": cacheControl || CACHE.CACHE_CONTROL_NO_CACHE,
		},
	});
}

// Module-level server instance
let serverInstance: ReturnType<typeof serve> | null = null;
let stopRetentionJob: (() => void) | null = null;

// Startup maintenance (one-shot): cleanup + compact
function runStartupMaintenance(config: Config, dbOps: DatabaseOperations) {
	const log = new Logger("StartupMaintenance");
	try {
		const payloadDays = config.getDataRetentionDays();
		const requestDays = config.getRequestRetentionDays();
		const { removedRequests, removedPayloads } = dbOps.cleanupOldRequests(
			payloadDays * 24 * 60 * 60 * 1000,
			requestDays * 24 * 60 * 60 * 1000,
		);
		log.info(
			`Startup cleanup removed ${removedRequests} requests and ${removedPayloads} payloads (payload=${payloadDays}d, requests=${requestDays}d)`,
		);
	} catch (err) {
		log.error(`Startup cleanup error: ${err}`);
	}
	try {
		dbOps.compact();
		log.info("Database compacted at startup");
	} catch (err) {
		log.error(`Database compaction error: ${err}`);
	}
	// Return a no-op stopper for compatibility
	return () => {};
}

// Export for programmatic use
export default function startServer(options?: {
	port?: number;
	withDashboard?: boolean;
}) {
	// Return existing server if already running
	if (serverInstance) {
		return {
			port: serverInstance.port,
			stop: () => {
				if (serverInstance) {
					serverInstance.stop();
					serverInstance = null;
				}
			},
		};
	}

	const { port = NETWORK.DEFAULT_PORT, withDashboard = true } = options || {};

	// Initialize DI container
	container.registerInstance(SERVICE_KEYS.Config, new Config());
	container.registerInstance(SERVICE_KEYS.Logger, new Logger("Server"));

	// Initialize components
	const config = container.resolve<Config>(SERVICE_KEYS.Config);
	const runtime = config.getRuntime();
	// Override port if provided
	if (port !== runtime.port) {
		runtime.port = port;
	}
	DatabaseFactory.initialize(undefined, runtime);
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	const log = container.resolve<Logger>(SERVICE_KEYS.Logger);
	container.registerInstance(SERVICE_KEYS.Database, dbOps);

	// Initialize async DB writer
	const asyncWriter = new AsyncDbWriter();
	container.registerInstance(SERVICE_KEYS.AsyncWriter, asyncWriter);
	registerDisposable(asyncWriter);

	// Initialize pricing logger
	const pricingLogger = new Logger("Pricing");
	container.registerInstance(SERVICE_KEYS.PricingLogger, pricingLogger);
	setPricingLogger(pricingLogger);

	const apiRouter = new APIRouter({ db, config, dbOps });

	// Run startup maintenance once (cleanup + compact)
	stopRetentionJob = runStartupMaintenance(config, dbOps);

	// Initialize load balancing strategy (will be created after runtime config)

	// Get the provider
	const provider = getProvider("anthropic");
	if (!provider) {
		throw new Error("Anthropic provider not available");
	}

	// Create runtime config
	const runtimeConfig: RuntimeConfig = {
		clientId: config.get(
			"client_id",
			"9d1c250a-e61b-44d9-88ed-5944d1962f5e",
		) as string,
		retry: {
			attempts: config.get("retry_attempts", 3) as number,
			delayMs: config.get("retry_delay_ms", 1000) as number,
			backoff: config.get("retry_backoff", 2) as number,
		},
		sessionDurationMs: config.get(
			"session_duration_ms",
			TIME_CONSTANTS.SESSION_DURATION_DEFAULT,
		) as number,
		port,
	};

	// Now create the strategy with runtime config
	const strategy = new SessionStrategy(runtimeConfig.sessionDurationMs);
	strategy.initialize(dbOps);

	// Proxy context
	const proxyContext: ProxyContext = {
		strategy,
		dbOps,
		runtime: runtimeConfig,
		provider,
		refreshInFlight: new Map(),
		asyncWriter,
		usageWorker: getUsageWorker(),
	};

	// Hot reload strategy configuration
	config.on("change", (changeType, fieldName) => {
		if (fieldName === "strategy") {
			log.info(`Strategy configuration changed: ${changeType}`);
			const newStrategyName = config.getStrategy();
			// For now, only SessionStrategy is supported
			if (newStrategyName === "session") {
				const strategy = new SessionStrategy(runtimeConfig.sessionDurationMs);
				strategy.initialize(dbOps);
				proxyContext.strategy = strategy;
			}
		}
	});

	// Main server
	serverInstance = serve({
		port: runtime.port,
		idleTimeout: NETWORK.IDLE_TIMEOUT_MAX, // Max allowed by Bun
		async fetch(req) {
			const url = new URL(req.url);

			// Try API routes first
			const apiResponse = await apiRouter.handleRequest(url, req);
			if (apiResponse) {
				return apiResponse;
			}

			// Dashboard routes (only if enabled)
			if (withDashboard) {
				// Serve dashboard static assets
				if ((dashboardManifest as Record<string, string>)[url.pathname]) {
					return serveDashboardFile(
						url.pathname,
						undefined,
						CACHE.CACHE_CONTROL_STATIC,
					);
				}

				// For all non-API routes, serve the dashboard index.html (client-side routing)
				// This allows React Router to handle all dashboard routes without maintaining a list
				if (
					!url.pathname.startsWith("/api/") &&
					!url.pathname.startsWith("/v1/")
				) {
					return serveDashboardFile("/index.html", "text/html");
				}
			}

			// All other paths go to proxy
			return handleProxy(req, url, proxyContext);
		},
	});

	// Log server startup
	console.log(`
🎯 ccflare Server v${process.env.npm_package_version || "1.0.0"}
🌐 Port: ${serverInstance.port}
📊 Dashboard: ${withDashboard ? `http://localhost:${serverInstance.port}` : "disabled"}
🔗 API Base: http://localhost:${serverInstance.port}/api

Available endpoints:
- POST   http://localhost:${serverInstance.port}/v1/*            → Proxy to Claude API
- GET    http://localhost:${serverInstance.port}/api/accounts    → List accounts
- POST   http://localhost:${serverInstance.port}/api/accounts    → Add account
- DELETE http://localhost:${serverInstance.port}/api/accounts/:id → Remove account
- GET    http://localhost:${serverInstance.port}/api/stats       → View statistics
- POST   http://localhost:${serverInstance.port}/api/stats/reset → Reset statistics
- GET    http://localhost:${serverInstance.port}/api/config      → View configuration
- PATCH  http://localhost:${serverInstance.port}/api/config      → Update configuration

⚡ Ready to proxy requests...
`);

	// Log configuration
	console.log(
		`⚙️  Current strategy: ${config.getStrategy()} (default: ${DEFAULT_STRATEGY})`,
	);

	// Log initial account status
	const accounts = dbOps.getAllAccounts();
	const activeAccounts = accounts.filter(
		(a) => !a.paused && (!a.expires_at || a.expires_at > Date.now()),
	);
	log.info(
		`Loaded ${accounts.length} accounts (${activeAccounts.length} active)`,
	);
	if (activeAccounts.length === 0) {
		log.warn(
			"No active accounts available - requests will be forwarded without authentication",
		);
	}

	return {
		port: serverInstance.port,
		stop: () => {
			if (serverInstance) {
				serverInstance.stop();
				serverInstance = null;
			}
		},
	};
}

// Graceful shutdown handler
async function handleGracefulShutdown(signal: string) {
	console.log(`\n👋 Received ${signal}, shutting down gracefully...`);
	try {
		if (stopRetentionJob) {
			stopRetentionJob();
			stopRetentionJob = null;
		}
		terminateUsageWorker();
		await shutdown();
		console.log("✅ Shutdown complete");
		process.exit(0);
	} catch (error) {
		console.error("❌ Error during shutdown:", error);
		process.exit(1);
	}
}

// Register signal handlers
process.on("SIGINT", () => handleGracefulShutdown("SIGINT"));
process.on("SIGTERM", () => handleGracefulShutdown("SIGTERM"));

// Run server if this is the main entry point
if (import.meta.main) {
	startServer();
}
</file>

<file path="apps/tui/src/components/AnalyticsScreen.tsx">
import { getModelShortName } from "@ccflare/core";
import * as tuiCore from "@ccflare/tui-core";
import { formatCost, formatNumber, formatPercentage } from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import SelectInput from "ink-select-input";
import Spinner from "ink-spinner";
import { useCallback, useEffect, useState } from "react";
import { BarChart, LineChart, PieChart, SparklineChart } from "./charts";

interface AnalyticsScreenProps {
	onBack: () => void;
}

type TimeRange = "1h" | "6h" | "24h" | "7d";
type ChartView = "overview" | "tokens" | "performance" | "costs" | "models";

const TIME_RANGE_LABELS: Record<TimeRange, string> = {
	"1h": "Last Hour",
	"6h": "Last 6 Hours",
	"24h": "Last 24 Hours",
	"7d": "Last 7 Days",
};

export function AnalyticsScreen({ onBack }: AnalyticsScreenProps) {
	const [timeRange, setTimeRange] = useState<TimeRange>("24h");
	const [chartView, setChartView] = useState<ChartView>("overview");
	const [stats, setStats] = useState<tuiCore.Stats | null>(null);
	const [loading, setLoading] = useState(true);
	interface TimeSeriesDataPoint {
		time: string;
		requests: number;
		tokens: number;
		cost: number;
		responseTime: number;
		errorRate: number;
		cacheHitRate: number;
		successRate: number;
	}

	const [timeSeriesData, setTimeSeriesData] = useState<TimeSeriesDataPoint[]>(
		[],
	);
	const [showMenu, setShowMenu] = useState(false);
	const [modelDistribution, setModelDistribution] = useState<
		tuiCore.ModelDistribution[]
	>([]);

	useInput((input, key) => {
		if (key.escape) {
			if (showMenu) {
				setShowMenu(false);
			} else {
				onBack();
			}
		}
		if (input === "q" && !showMenu) {
			onBack();
		}
		if (input === "r" && !showMenu) {
			loadData();
		}
		if (input === "m" && !showMenu) {
			setShowMenu(true);
		}
		// Time range shortcuts
		if (!showMenu) {
			if (input === "1") setTimeRange("1h");
			if (input === "2") setTimeRange("6h");
			if (input === "3") setTimeRange("24h");
			if (input === "4") setTimeRange("7d");
			// View shortcuts
			if (input === "o") setChartView("overview");
			if (input === "t") setChartView("tokens");
			if (input === "p") setChartView("performance");
			if (input === "c") setChartView("costs");
			if (input === "d") setChartView("models");
		}
	});

	const loadData = useCallback(async () => {
		try {
			setLoading(true);
			// Get basic stats
			const data = await tuiCore.getStats();
			setStats(data);

			// Get analytics with time series data
			const analytics = await tuiCore.getAnalytics(timeRange);

			// Transform time series data for display
			const transformedTimeSeries = analytics.timeSeries.map((point) => {
				const time = new Date(point.time);
				return {
					time:
						timeRange === "7d"
							? time.toLocaleDateString("en", { weekday: "short" })
							: time.toLocaleTimeString("en", {
									hour: "2-digit",
									minute: "2-digit",
								}),
					requests: point.requests,
					tokens: point.tokens,
					cost: point.cost,
					responseTime: point.responseTime,
					errorRate: point.errorRate,
					cacheHitRate: point.cacheHitRate,
					successRate: point.successRate,
				};
			});

			setTimeSeriesData(transformedTimeSeries);
			setLoading(false);
		} catch (_error) {
			setLoading(false);
		}
	}, [timeRange]);

	useEffect(() => {
		loadData();
		const interval = setInterval(loadData, 30000); // Refresh every 30 seconds
		return () => clearInterval(interval);
	}, [loadData]);

	useEffect(() => {
		if (!loading) {
			tuiCore.getAnalytics(timeRange).then((analytics) => {
				setModelDistribution(analytics.modelDistribution);
			});
		}
	}, [timeRange, loading]);

	if (loading || !stats) {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					📈 Analytics Dashboard
				</Text>
				<Box marginTop={1}>
					<Text color="green">
						<Spinner type="dots" />
					</Text>
					<Text> Loading analytics data...</Text>
				</Box>
			</Box>
		);
	}

	// Menu for selecting time range
	if (showMenu) {
		const menuItems = [
			{ label: "📊 Overview", value: "overview" },
			{ label: "🪙 Token Usage", value: "tokens" },
			{ label: "⚡ Performance", value: "performance" },
			{ label: "💰 Cost Analysis", value: "costs" },
			{ label: "🤖 Model Distribution", value: "models" },
			{ label: "← Back", value: "back" },
		];

		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					Select Analytics View
				</Text>
				<Box marginTop={1}>
					<SelectInput
						items={menuItems}
						onSelect={(item) => {
							if (item.value === "back") {
								setShowMenu(false);
							} else {
								setChartView(item.value as ChartView);
								setShowMenu(false);
							}
						}}
					/>
				</Box>
			</Box>
		);
	}

	// Prepare data for charts
	const requestSparkline = timeSeriesData.map((d) => d.requests);
	const tokenSparkline = timeSeriesData.map((d) => d.tokens);
	const costSparkline = timeSeriesData.map((d) => d.cost);
	const responseTimeData = timeSeriesData.map((d) => ({
		x: d.time,
		y: d.responseTime,
	}));

	// Model distribution for pie chart
	const modelData = modelDistribution.slice(0, 3).map((model, index) => ({
		label: model.model,
		value: model.count,
		color: ["magenta", "cyan", "yellow"][index] as
			| "magenta"
			| "cyan"
			| "yellow",
	}));

	// Account performance for bar chart
	const accountBarData = stats.accounts.map((account) => ({
		label: account.name,
		value: account.requestCount,
		color:
			account.successRate >= 95
				? ("green" as const)
				: account.successRate >= 80
					? ("yellow" as const)
					: ("red" as const),
	}));

	const renderChart = () => {
		switch (chartView) {
			case "overview":
				return (
					<Box flexDirection="column">
						<Box marginBottom={1}>
							<Text bold underline>
								Request Volume & Performance
							</Text>
						</Box>

						{/* Sparklines */}
						<Box flexDirection="column" marginBottom={2}>
							<SparklineChart
								data={requestSparkline}
								label="Requests"
								color="cyan"
								showCurrent={true}
							/>
							<SparklineChart
								data={tokenSparkline}
								label="Tokens  "
								color="yellow"
								showCurrent={true}
							/>
							<SparklineChart
								data={costSparkline}
								label="Cost    "
								color="green"
								showCurrent={true}
							/>
						</Box>

						{/* Response time line chart */}
						<LineChart
							data={responseTimeData.slice(-20)}
							title="Response Time (ms)"
							height={8}
							width={50}
							color="magenta"
						/>
					</Box>
				);

			case "tokens":
				return (
					<Box flexDirection="column">
						{/* Token breakdown bar chart */}
						{stats.tokenDetails && (
							<BarChart
								title="Token Usage Breakdown"
								data={[
									{
										label: "Input",
										value: stats.tokenDetails.inputTokens,
										color: "yellow",
									},
									{
										label: "Cache Read",
										value: stats.tokenDetails.cacheReadInputTokens,
										color: "cyan",
									},
									{
										label: "Cache Create",
										value: stats.tokenDetails.cacheCreationInputTokens,
										color: "blue",
									},
									{
										label: "Output",
										value: stats.tokenDetails.outputTokens,
										color: "green",
									},
								]}
								width={40}
								showValues={true}
							/>
						)}

						<Box marginTop={2}>
							<Text bold>Token Efficiency Metrics</Text>
							<Box marginTop={1}>
								<Text>Avg tokens/request: </Text>
								<Text color="yellow" bold>
									{formatNumber(
										stats.totalRequests > 0
											? Math.round(stats.totalTokens / stats.totalRequests)
											: 0,
									)}
								</Text>
							</Box>
							<Box>
								<Text>Cache hit rate: </Text>
								<Text color="cyan" bold>
									{formatPercentage(
										stats.tokenDetails
											? (stats.tokenDetails.cacheReadInputTokens /
													stats.tokenDetails.inputTokens) *
													100
											: 0,
									)}
								</Text>
							</Box>
						</Box>
					</Box>
				);

			case "performance":
				return (
					<Box flexDirection="column">
						{/* Account performance bar chart */}
						<BarChart
							title="Account Performance (Requests)"
							data={accountBarData}
							width={35}
							showValues={true}
						/>

						<Box marginTop={2}>
							<Text bold underline>
								Performance Metrics
							</Text>
							<Box marginTop={1}>
								<Text>Success Rate: </Text>
								<Text
									color={
										stats.successRate >= 95
											? "green"
											: stats.successRate >= 80
												? "yellow"
												: "red"
									}
									bold
								>
									{formatPercentage(stats.successRate)}
								</Text>
							</Box>
							<Box>
								<Text>Avg Response: </Text>
								<Text color="magenta" bold>
									{formatNumber(stats.avgResponseTime)}ms
								</Text>
							</Box>
						</Box>
					</Box>
				);

			case "costs":
				return (
					<Box flexDirection="column">
						<Box marginBottom={1}>
							<Text bold underline>
								Cost Analysis
							</Text>
						</Box>

						{/* Cost trend sparkline */}
						<Box marginBottom={2}>
							<SparklineChart
								data={costSparkline}
								label="Cost Trend"
								color="green"
								showMinMax={true}
								showCurrent={true}
							/>
						</Box>

						{/* Cost breakdown */}
						<Box flexDirection="column">
							<Box>
								<Text>Total Cost: </Text>
								<Text color="green" bold>
									{formatCost(stats.totalCostUsd)}
								</Text>
							</Box>
							<Box>
								<Text>Avg per request: </Text>
								<Text color="yellow">
									{formatCost(
										stats.totalRequests > 0
											? stats.totalCostUsd / stats.totalRequests
											: 0,
									)}
								</Text>
							</Box>
							<Box>
								<Text>Projected daily: </Text>
								<Text dimColor>
									{formatCost(
										stats.totalCostUsd *
											(24 /
												(timeRange === "1h"
													? 1
													: timeRange === "6h"
														? 6
														: timeRange === "24h"
															? 24
															: 168)),
									)}
								</Text>
							</Box>
						</Box>
					</Box>
				);

			case "models":
				return (
					<Box flexDirection="column">
						{/* Model distribution pie chart */}
						<PieChart
							title="Model Distribution"
							data={modelData}
							size="medium"
							showLegend={true}
						/>

						<Box marginTop={2}>
							<Text bold>Model Performance</Text>
							<Box flexDirection="column" marginTop={1}>
								{modelDistribution.slice(0, 5).map((model) => {
									const shortName = getModelShortName(model.model);
									const color = shortName.includes("opus")
										? "magenta"
										: shortName.includes("sonnet")
											? "cyan"
											: "yellow";
									return (
										<Box key={model.model}>
											<Text>{model.model}: </Text>
											<Text color={color}>
												{formatNumber(model.count)} (
												{formatPercentage(model.percentage)})
											</Text>
										</Box>
									);
								})}
							</Box>
						</Box>
					</Box>
				);

			default:
				return null;
		}
	};

	return (
		<Box flexDirection="column" padding={1}>
			{/* Header */}
			<Box marginBottom={1} justifyContent="space-between">
				<Text color="cyan" bold>
					📈 Analytics Dashboard - {TIME_RANGE_LABELS[timeRange]}
				</Text>
				<Text dimColor> View: {chartView}</Text>
			</Box>

			{/* Time range selector */}
			<Box marginBottom={1}>
				<Text dimColor>
					Time: [1] 1h [2] 6h [3] 24h [4] 7d | View: [o]verview [t]okens [p]erf
					[c]ost [d]models
				</Text>
			</Box>

			{/* Chart content */}
			{renderChart()}

			{/* Controls */}
			<Box marginTop={2}>
				<Text dimColor>[m] Menu • [r] Refresh • [q/ESC] Back</Text>
			</Box>
		</Box>
	);
}
</file>

<file path="docs/configuration.md">
# ccflare Configuration Guide

This guide covers all configuration options for ccflare, including file-based configuration, environment variables, and runtime API updates.

## Table of Contents

- [Configuration Overview](#configuration-overview)
- [Configuration Precedence](#configuration-precedence)
- [Configuration File Format](#configuration-file-format)
- [Configuration Options](#configuration-options)
- [Environment Variables](#environment-variables)
- [Runtime Configuration API](#runtime-configuration-api)
- [Example Configurations](#example-configurations)
- [Configuration Validation](#configuration-validation)
- [Migration Guide](#migration-guide)

## Configuration Overview

ccflare uses a flexible configuration system that supports:

- **File-based configuration**: JSON configuration file for persistent settings
- **Environment variables**: Override configuration for deployment flexibility
- **Runtime updates**: Modify certain settings via API without restart

Configuration is managed through the `@ccflare/config` package, which provides automatic loading, validation, and change notifications.

## Configuration Precedence

Configuration values are resolved in the following order (highest to lowest priority):

1. **Environment variables** - Always take precedence when set
2. **Configuration file** - Values from `~/.config/ccflare/ccflare.json` (or custom path)
3. **Default values** - Built-in defaults when no other value is specified

### Special Cases

- **Load balancing strategy**: Environment variable `LB_STRATEGY` overrides file configuration
- **Runtime configuration**: Some values (like strategy) can be changed at runtime via API

## Configuration File Format

The configuration file is stored at:

- **Linux/macOS**: `~/.config/ccflare/ccflare.json` (or `$XDG_CONFIG_HOME/ccflare/ccflare.json`)
- **Windows**: `%LOCALAPPDATA%\ccflare\ccflare.json` (or `%APPDATA%\ccflare\ccflare.json`)
- **Custom path**: Set via `ccflare_CONFIG_PATH` environment variable

### File Structure

```json
{
  "lb_strategy": "session",
  "client_id": "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
  "retry_attempts": 3,
  "retry_delay_ms": 1000,
  "retry_backoff": 2,
  "session_duration_ms": 18000000,
  "port": 8080
}
```

## Configuration Options

### Complete Options Table

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `lb_strategy` | string | `"session"` | Load balancing strategy. Only `"session"` is supported (using other strategies risks account bans) |
| `client_id` | string | `"9d1c250a-e61b-44d9-88ed-5944d1962f5e"` | OAuth client ID for authentication |
| `retry_attempts` | number | `3` | Maximum number of retry attempts for failed requests |
| `retry_delay_ms` | number | `1000` | Initial delay in milliseconds between retry attempts |
| `retry_backoff` | number | `2` | Exponential backoff multiplier for retry delays |
| `session_duration_ms` | number | `18000000` (5 hours) | Session persistence duration in milliseconds |
| `port` | number | `8080` | HTTP server port |

### Load Balancing Strategy

⚠️ **WARNING**: Only use the `session` strategy. Other strategies can trigger Claude's anti-abuse systems and result in account bans.

| Strategy | Description | Use Case |
|----------|-------------|----------|
| `session` | Maintains client-account affinity for session duration | Only supported strategy - mimics natural usage patterns |

### Logging Configuration (Environment Only)

| Variable | Type | Default | Description |
|----------|------|---------|-------------|
| `LOG_LEVEL` | string | `"INFO"` | Logging level: `DEBUG`, `INFO`, `WARN`, `ERROR` |
| `LOG_FORMAT` | string | `"pretty"` | Log format: `"pretty"` or `"json"` |
| `ccflare_DEBUG` | string | - | Set to `"1"` to enable debug mode with console output |

## Environment Variables

### Configuration Mapping

| Environment Variable | Config Field | Type | Example |
|---------------------|--------------|------|---------|
| `LB_STRATEGY` | `lb_strategy` | string | `LB_STRATEGY=session` |
| `CLIENT_ID` | `client_id` | string | `CLIENT_ID=your-client-id` |
| `RETRY_ATTEMPTS` | `retry_attempts` | number | `RETRY_ATTEMPTS=5` |
| `RETRY_DELAY_MS` | `retry_delay_ms` | number | `RETRY_DELAY_MS=2000` |
| `RETRY_BACKOFF` | `retry_backoff` | number | `RETRY_BACKOFF=1.5` |
| `SESSION_DURATION_MS` | `session_duration_ms` | number | `SESSION_DURATION_MS=3600000` |
| `PORT` | `port` | number | `PORT=3000` |
| `DATA_RETENTION_DAYS` | `data_retention_days` | number | `DATA_RETENTION_DAYS=7` (payloads) |
| `REQUEST_RETENTION_DAYS` | `request_retention_days` | number | `REQUEST_RETENTION_DAYS=365` (metadata) |
| `ccflare_CONFIG_PATH` | - | string | `ccflare_CONFIG_PATH=/etc/ccflare.json` |

### Additional Environment Variables

These environment variables are not stored in the configuration file and must be set via environment:

| Variable | Description | Default | Example |
|----------|-------------|---------|---------|
| `LOG_LEVEL` | Set logging verbosity (DEBUG, INFO, WARN, ERROR) | `INFO` | `LOG_LEVEL=DEBUG` |
| `LOG_FORMAT` | Set log output format (pretty, json) | `pretty` | `LOG_FORMAT=json` |
| `ccflare_DEBUG` | Enable debug mode with console output | - | `ccflare_DEBUG=1` |
| `ccflare_DB_PATH` | Custom database file path | Platform-specific | `ccflare_DB_PATH=/var/lib/ccflare/db.sqlite` |
| `CF_PRICING_REFRESH_HOURS` | Hours between pricing data refreshes | `24` | `CF_PRICING_REFRESH_HOURS=12` |
| `CF_PRICING_OFFLINE` | Disable online pricing updates | - | `CF_PRICING_OFFLINE=1` |
| `CF_STREAM_USAGE_BUFFER_KB` | Stream usage buffer size in KB | `64` | `CF_STREAM_USAGE_BUFFER_KB=128` |
| `CF_STREAM_TIMEOUT_MS` | Stream processing timeout in milliseconds | `60000` (1 minute) | `CF_STREAM_TIMEOUT_MS=120000` |

## Runtime Configuration API

Some configuration values can be updated at runtime through the HTTP API without restarting the server.

### Available Endpoints

#### Get Current Configuration
```http
GET /api/config
```

Response:
```json
{
  "lb_strategy": "session",
  "port": 8080,
  "sessionDurationMs": 18000000
}
```

Note: The API response uses camelCase (`sessionDurationMs`) while the configuration file uses snake_case (`session_duration_ms`).

#### Get Current Strategy
```http
GET /api/config/strategy
```

Response:
```json
{
  "strategy": "session"
}
```

#### Update Strategy
```http
POST /api/config/strategy
Content-Type: application/json

{
  "strategy": "session"
}
```

Response:
```json
{
  "success": true,
  "strategy": "session"
}
```

#### Get Available Strategies
```http
GET /api/strategies
```

Response:
```json
["session"]
```

⚠️ **NOTE**: Only the `"session"` strategy is available in ccflare. Other strategies (round-robin, least-requests, weighted) have been removed from the codebase as they can trigger Claude's anti-abuse systems and result in account bans.

### Runtime Update Behavior

- Strategy changes take effect immediately for new requests
- Existing sessions (for session strategy) are maintained until expiration
- Configuration file is automatically updated when changed via API
- Change events are emitted for monitoring and logging

## Example Configurations

### High Throughput Setup

Optimized for maximum request throughput with minimal overhead:

```json
{
  "lb_strategy": "session",
  "retry_attempts": 2,
  "retry_delay_ms": 500,
  "retry_backoff": 1.5,
  "session_duration_ms": 300000,
  "port": 8080
}
```

Environment variables:
```bash
export LB_STRATEGY=session
export RETRY_ATTEMPTS=2
export RETRY_DELAY_MS=500
export SESSION_DURATION_MS=300000  # 5 minutes
export LOG_LEVEL=WARN  # Reduce logging overhead
```

### Session Persistence Setup

Ideal for maintaining conversation context with Claude:

```json
{
  "lb_strategy": "session",
  "retry_attempts": 3,
  "retry_delay_ms": 1000,
  "retry_backoff": 2,
  "session_duration_ms": 21600000,
  "port": 8080
}
```

Environment variables:
```bash
export LB_STRATEGY=session
export SESSION_DURATION_MS=21600000  # 6 hours
export RETRY_ATTEMPTS=3
export LOG_LEVEL=INFO
```

### Development Setup

Configuration for local development and debugging:

```json
{
  "lb_strategy": "session",
  "retry_attempts": 5,
  "retry_delay_ms": 2000,
  "retry_backoff": 2,
  "session_duration_ms": 3600000,
  "port": 3000
}
```

Environment variables:
```bash
export PORT=3000
export LOG_LEVEL=DEBUG
export LOG_FORMAT=pretty
export ccflare_DEBUG=1
export RETRY_ATTEMPTS=5
```

### Production Setup

Recommended configuration for production deployments:

```json
{
  "lb_strategy": "session",
  "retry_attempts": 3,
  "retry_delay_ms": 1000,
  "retry_backoff": 2,
  "session_duration_ms": 7200000,
  "port": 8080
}
```

Environment variables:
```bash
export LB_STRATEGY=session
export SESSION_DURATION_MS=7200000  # 2 hours
export LOG_LEVEL=INFO
export LOG_FORMAT=json
export CF_PRICING_OFFLINE=1  # Reduce external API calls
```

## Configuration Validation

### Automatic Validation

ccflare performs validation on:

1. **Strategy names**: Must be one of the valid strategy options (validated by `isValidStrategy`)
2. **Numeric values**: Parsed and validated as integers/floats
3. **Port ranges**: Should be valid port numbers (1-65535)
4. **File permissions**: Config directory is created with appropriate permissions

### Validation Errors

Invalid configurations result in:

- **Strategy errors**: Throws error when setting via API, falls back to default strategy when loading
- **Parse errors**: Logged to console, uses default values
- **File errors**: Creates new config file with defaults
- **Invalid numeric values**: Falls back to default values

### Best Practices

1. **Test configuration changes**: Use the API to test strategy changes before updating files
2. **Monitor logs**: Check logs after configuration updates for validation errors
3. **Use environment variables**: For deployment-specific settings that shouldn't be committed
4. **Backup configurations**: Keep backups before major changes

## Migration Guide

### From Environment-Only Configuration

If migrating from environment variables to file-based configuration:

1. Create the configuration file:
   ```bash
   mkdir -p ~/.config/ccflare
   ```

2. Export current configuration:
   ```bash
   curl http://localhost:8080/api/config > ~/.config/ccflare/ccflare.json
   ```

3. Edit and format the file:
   ```bash
   jq '.' ~/.config/ccflare/ccflare.json > temp.json && mv temp.json ~/.config/ccflare/ccflare.json
   ```

### From Older Versions

#### Pre-1.0 to Current

1. **Configuration location**: Move from `~/.ccflare/config.json` to platform-specific paths
2. **Field naming**: Update any deprecated field names (none currently deprecated)
3. **Strategy names**: Only `"session"` strategy is available (must be lowercase)

### Configuration Backup

Always backup your configuration before upgrades:

```bash
cp ~/.config/ccflare/ccflare.json ~/.config/ccflare/ccflare.json.backup
```

### Rollback Procedure

If issues occur after configuration changes:

1. **Via API**: Revert strategy changes using the runtime API
2. **File restoration**: Restore from backup configuration file
3. **Environment override**: Use environment variables to override problematic settings

## Troubleshooting

### Common Issues

1. **Configuration not loading**:
   - Check file permissions: `ls -la ~/.config/ccflare/`
   - Verify JSON syntax: `jq '.' ~/.config/ccflare/ccflare.json`
   - Check logs for parse errors

2. **Environment variables not working**:
   - Ensure variables are exported: `export VAR=value`
   - Check variable names match exactly (case-sensitive)
   - Verify no typos in variable names

3. **Runtime updates not persisting**:
   - Check file write permissions
   - Ensure configuration directory exists
   - Look for save errors in logs

### Debug Mode

Enable comprehensive debugging:

```bash
export ccflare_DEBUG=1
export LOG_LEVEL=DEBUG
export LOG_FORMAT=json  # For structured logging
```

This provides detailed configuration loading information and operation logs.

#### Get Retention
```http
GET /api/config/retention
```

Response:
```json
{ "payloadDays": 7, "requestDays": 365 }
```

Note: Payload retention applies to request/response JSON payloads. Request metadata retention controls how long rows in the `requests` table are kept (affects analytics beyond the window).

#### Set Retention
```http
POST /api/config/retention
Content-Type: application/json

{ "payloadDays": 14, "requestDays": 180 }
```

Response: `204 No Content`

#### Manual Cleanup
```http
POST /api/maintenance/cleanup
```

Response:
```json
{ "removedRequests": 0, "removedPayloads": 123, "cutoffIso": "2025-08-20T12:34:56.000Z" }
```
</file>

<file path="docs/database.md">
# Database Documentation

## Overview

ccflare uses SQLite as its database engine, providing a lightweight, serverless, and efficient storage solution for managing OAuth accounts, request history, and usage statistics. The database is designed to support high-performance load balancing operations while maintaining detailed audit trails and rate limit tracking.

### Key Features
- **Zero-configuration** deployment with SQLite
- **Automatic migrations** to handle schema evolution
- **Thread-safe operations** using Bun's SQLite bindings
- **Comprehensive indexing** for fast query performance
- **Foreign key constraints** for data integrity
- **Asynchronous write operations** for improved performance
- **Singleton pattern** with dependency injection support

## Database Schema

### Entity Relationship Diagram

```mermaid
erDiagram
    accounts {
        TEXT id PK "UUID primary key"
        TEXT name "Display name for the account"
        TEXT provider "OAuth provider (default: anthropic)"
        TEXT api_key "API key (optional)"
        TEXT refresh_token "OAuth refresh token"
        TEXT access_token "OAuth access token"
        INTEGER expires_at "Token expiration timestamp"
        INTEGER created_at "Account creation timestamp"
        INTEGER last_used "Last request timestamp"
        INTEGER request_count "Total requests in current period"
        INTEGER total_requests "All-time request count"
        INTEGER rate_limited_until "Rate limit expiration timestamp"
        INTEGER session_start "Current session start timestamp"
        INTEGER session_request_count "Requests in current session"
        INTEGER account_tier "Account tier (1, 5, or 20)"
        INTEGER paused "Account pause status (0 or 1)"
        INTEGER rate_limit_reset "Next rate limit reset timestamp"
        TEXT rate_limit_status "Current rate limit status"
        INTEGER rate_limit_remaining "Remaining requests before limit"
    }
    
    requests {
        TEXT id PK "UUID primary key"
        INTEGER timestamp "Request timestamp"
        TEXT method "HTTP method"
        TEXT path "Request path"
        TEXT account_used FK "Account ID used (nullable)"
        INTEGER status_code "HTTP response status"
        BOOLEAN success "Request success flag"
        TEXT error_message "Error details if failed"
        INTEGER response_time_ms "Response latency"
        INTEGER failover_attempts "Number of retry attempts"
        TEXT model "AI model used"
        INTEGER prompt_tokens "Input token count"
        INTEGER completion_tokens "Output token count"
        INTEGER total_tokens "Total token count"
        REAL cost_usd "Estimated cost in USD"
        REAL output_tokens_per_second "Output generation speed"
        INTEGER input_tokens "Detailed input tokens"
        INTEGER cache_read_input_tokens "Cached input tokens read"
        INTEGER cache_creation_input_tokens "Cached input tokens created"
        INTEGER output_tokens "Detailed output tokens"
        TEXT agent_used "Agent ID if request used an agent"
    }
    
    request_payloads {
        TEXT id PK "Request ID (foreign key)"
        TEXT json "Full request/response JSON payload"
    }
    
    oauth_sessions {
        TEXT id PK "Session ID"
        TEXT account_name "Account name for OAuth flow"
        TEXT verifier "PKCE verifier for security"
        TEXT mode "OAuth mode (console or max)"
        INTEGER tier "Account tier (1, 5, or 20)"
        INTEGER created_at "Session creation timestamp"
        INTEGER expires_at "Session expiration timestamp"
    }
    
    agent_preferences {
        TEXT agent_id PK "Agent identifier"
        TEXT model "Preferred model for the agent"
        INTEGER updated_at "Last update timestamp"
    }
    
    accounts ||--o{ requests : "handles"
    requests ||--|| request_payloads : "has payload"
```

## Table Documentation

### accounts Table

The `accounts` table stores OAuth account information and usage statistics for load balancing.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | UUID identifier for the account |
| `name` | TEXT | NOT NULL | Human-readable name for the account |
| `provider` | TEXT | DEFAULT 'anthropic' | OAuth provider identifier |
| `api_key` | TEXT | NULL | Optional API key for non-OAuth providers |
| `refresh_token` | TEXT | NOT NULL | OAuth refresh token for token renewal |
| `access_token` | TEXT | NULL | Current OAuth access token |
| `expires_at` | INTEGER | NULL | Unix timestamp when access token expires |
| `created_at` | INTEGER | NOT NULL | Unix timestamp when account was added |
| `last_used` | INTEGER | NULL | Unix timestamp of last request |
| `request_count` | INTEGER | DEFAULT 0 | Rolling window request count |
| `total_requests` | INTEGER | DEFAULT 0 | All-time request count |
| `rate_limited_until` | INTEGER | NULL* | Unix timestamp when rate limit expires |
| `session_start` | INTEGER | NULL* | Start of current usage session |
| `session_request_count` | INTEGER | DEFAULT 0* | Requests in current session |
| `account_tier` | INTEGER | DEFAULT 1* | Account tier (1=Free, 5=Pro, 20=Team) |
| `paused` | INTEGER | DEFAULT 0* | 1 if account is paused, 0 if active |
| `rate_limit_reset` | INTEGER | NULL* | Next rate limit window reset time |
| `rate_limit_status` | TEXT | NULL* | Current rate limit status message |
| `rate_limit_remaining` | INTEGER | NULL* | Remaining requests in current window |

*Note: Columns marked with * are added via migrations and may not exist in databases created before the migration was introduced.

### requests Table

The `requests` table logs all proxied requests for analytics and debugging.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | UUID identifier for the request |
| `timestamp` | INTEGER | NOT NULL | Unix timestamp when request was made |
| `method` | TEXT | NOT NULL | HTTP method (GET, POST, etc.) |
| `path` | TEXT | NOT NULL | Request path/endpoint |
| `account_used` | TEXT | NULL | Account ID that handled the request |
| `status_code` | INTEGER | NULL | HTTP response status code |
| `success` | BOOLEAN | NULL | 1 for success, 0 for failure |
| `error_message` | TEXT | NULL | Error details if request failed |
| `response_time_ms` | INTEGER | NULL | Total response time in milliseconds |
| `failover_attempts` | INTEGER | DEFAULT 0 | Number of retry attempts |
| `model` | TEXT | NULL* | AI model used (e.g., claude-3-sonnet) |
| `prompt_tokens` | INTEGER | DEFAULT 0* | Legacy: Input token count |
| `completion_tokens` | INTEGER | DEFAULT 0* | Legacy: Output token count |
| `total_tokens` | INTEGER | DEFAULT 0* | Legacy: Total token count |
| `cost_usd` | REAL | DEFAULT 0* | Estimated cost in USD |
| `input_tokens` | INTEGER | DEFAULT 0* | Detailed input token count |
| `cache_read_input_tokens` | INTEGER | DEFAULT 0* | Tokens read from cache |
| `cache_creation_input_tokens` | INTEGER | DEFAULT 0* | Tokens written to cache |
| `output_tokens` | INTEGER | DEFAULT 0* | Detailed output token count |
| `output_tokens_per_second` | REAL | NULL* | Output generation speed (tokens/sec) |
| `agent_used` | TEXT | NULL* | Agent ID if request used an agent |

*Note: Columns marked with * are added via migrations and may not exist in databases created before the migration was introduced.

**Indexes:**
- `idx_requests_timestamp` on `timestamp DESC` for efficient time-based queries
- `idx_requests_timestamp_account` on `timestamp DESC, account_used` for time-based account queries
- `idx_requests_model_timestamp` on `model, timestamp DESC` WHERE `model IS NOT NULL` for model analytics
- `idx_requests_success_timestamp` on `success, timestamp DESC` for success rate calculations
- `idx_requests_account_timestamp` on `account_used, timestamp DESC` for per-account analytics
- `idx_requests_cost_model` on `cost_usd, model, timestamp DESC` WHERE `cost_usd > 0 AND model IS NOT NULL` for cost analysis
- `idx_requests_response_time` on `model, response_time_ms` WHERE `response_time_ms IS NOT NULL AND model IS NOT NULL` for response time analysis
- `idx_requests_tokens` on `timestamp DESC, total_tokens` WHERE `total_tokens > 0` for token usage analysis

### request_payloads Table

The `request_payloads` table stores full request and response bodies for detailed analysis.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY, FOREIGN KEY | References requests.id |
| `json` | TEXT | NOT NULL | Complete request/response JSON data |

**Foreign Key Constraints:**
- `id` references `requests(id)` with `ON DELETE CASCADE`

### oauth_sessions Table

The `oauth_sessions` table stores temporary OAuth PKCE (Proof Key for Code Exchange) data for secure authentication flows.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | Session identifier (UUID) |
| `account_name` | TEXT | NOT NULL | Name for the account being created |
| `verifier` | TEXT | NOT NULL | PKCE code verifier for security |
| `mode` | TEXT | NOT NULL | OAuth mode ('console' or 'max') |
| `tier` | INTEGER | DEFAULT 1 | Account tier (1=Free, 5=Pro, 20=Team) |
| `created_at` | INTEGER | NOT NULL | Unix timestamp when session was created |
| `expires_at` | INTEGER | NOT NULL | Unix timestamp when session expires |

**Indexes:**
- `idx_oauth_sessions_expires` on `expires_at` for efficient cleanup of expired sessions

### agent_preferences Table

The `agent_preferences` table stores user-defined model preferences for specific agents.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `agent_id` | TEXT | PRIMARY KEY | Unique identifier for the agent |
| `model` | TEXT | NOT NULL | Preferred model for this agent |
| `updated_at` | INTEGER | NOT NULL | Unix timestamp of last update |

### strategies Table (Not Yet Implemented)

**Note**: The codebase references a `strategies` table through the `StrategyRepository`, but this table is not currently created in the schema. When implemented, it would store:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `name` | TEXT | PRIMARY KEY | Strategy identifier |
| `config` | TEXT | NOT NULL | JSON configuration for the strategy |
| `updated_at` | INTEGER | NOT NULL | Unix timestamp of last update |

This table would be used for storing custom load balancing strategies and routing configurations.

## Migration System

The database uses an incremental migration system that:

1. **Ensures Base Schema**: Creates core tables if they don't exist
2. **Applies Migrations**: Checks for missing columns and adds them incrementally
3. **Preserves Data**: All migrations are additive, never destructive
4. **Logs Changes**: Outputs migration progress to console

### Migration Process

```typescript
// Migration execution order:
1. ensureSchema(db)      // Creates base tables
2. runMigrations(db)     // Applies incremental changes
```

Key migrations include:
- Rate limiting columns (`rate_limited_until`, `rate_limit_status`, etc.)
- Session tracking (`session_start`, `session_request_count`)
- Account tiers and pausing
- Token usage tracking for cost analysis
- Output tokens per second tracking
- Agent usage tracking
- Performance indexes for common query patterns

## Database Architecture

### Core Components

#### DatabaseOperations
The main database access layer that implements both `StrategyStore` and `Disposable` interfaces:
- Uses Repository Pattern for clean separation of concerns
- Manages direct SQLite connections via Bun's native SQLite bindings
- Handles all CRUD operations for accounts and requests
- Supports runtime configuration injection for session management
- Thread-safe for concurrent operations

#### DatabaseFactory
Singleton pattern implementation for global database instance management:
- Ensures a single database connection throughout the application
- Provides `initialize()` and `getInstance()` methods
- Integrates with the dependency injection container

#### AsyncDbWriter
Asynchronous write queue for non-blocking database operations:
- Batches write operations to improve performance
- Processes queue every 100ms or immediately when jobs are added
- Gracefully flushes pending operations on shutdown
- Prevents blocking the main thread during heavy write loads

#### Repository Pattern Architecture
The database uses a clean Repository Pattern with the following repositories:
- **AccountRepository**: Manages all account-related operations
- **RequestRepository**: Handles request logging and analytics queries
- **OAuthRepository**: Manages OAuth session storage and cleanup
- **StrategyRepository**: Handles strategy configuration storage (pending table implementation)
- **StatsRepository**: Provides consolidated statistics and analytics
- **AgentPreferenceRepository**: Manages agent-specific model preferences

Each repository:
- Extends a common `BaseRepository` class for shared functionality
- Encapsulates SQL queries and data transformations
- Provides type-safe interfaces for database operations
- Handles data mapping between database rows and application models

### Dependency Injection Integration
The database integrates with the DI container:
```typescript
// Registration in container
container.registerInstance(SERVICE_KEYS.Database, dbOps);

// Resolution from container
const db = container.resolve<DatabaseOperations>(SERVICE_KEYS.Database);
```

## Database Location and Configuration

### Default Location

The database file is stored in a platform-specific configuration directory:

- **macOS**: `~/Library/Application Support/ccflare/ccflare.db`
- **Linux**: `~/.config/ccflare/ccflare.db`
- **Windows**: `%APPDATA%\ccflare\ccflare.db`

### Custom Location

You can override the default location using the `ccflare_DB_PATH` environment variable:

```bash
export ccflare_DB_PATH=/custom/path/to/database.db
```

### Runtime Configuration

The database supports runtime configuration for dynamic behavior:
```typescript
interface RuntimeConfig {
  sessionDurationMs?: number; // Default: 5 hours (5 * 60 * 60 * 1000)
}
```

### Database Initialization

The database is automatically initialized with:
- Directory creation if needed
- Schema creation on first use
- Migration application on startup
- Foreign key constraint enforcement

## Query Patterns and Indexes

### Common Query Patterns

1. **Account Selection for Load Balancing**
```sql
SELECT * FROM accounts 
WHERE paused = 0 
  AND (rate_limited_until IS NULL OR rate_limited_until < ?)
ORDER BY session_request_count ASC
```

2. **Request History Analysis**
```sql
SELECT * FROM requests 
WHERE timestamp >= ? 
ORDER BY timestamp DESC
LIMIT ?
```

3. **Usage Statistics by Account**
```sql
SELECT 
  account_used,
  COUNT(*) as request_count,
  AVG(response_time_ms) as avg_response_time,
  SUM(cost_usd) as total_cost
FROM requests
WHERE timestamp >= ?
GROUP BY account_used
```

4. **Request Payloads with Account Names**
```sql
SELECT rp.id, rp.json, a.name as account_name
FROM request_payloads rp
JOIN requests r ON rp.id = r.id
LEFT JOIN accounts a ON r.account_used = a.id
ORDER BY r.timestamp DESC
LIMIT ?
```

### Index Strategy

Current indexes optimize for:
- **Time-series queries**: `idx_requests_timestamp` enables fast filtering and sorting by time
- **Primary key lookups**: Automatic indexes on all primary keys
- **Foreign key joins**: Automatic indexes for referential integrity

### Performance Indexes

The database includes comprehensive performance indexes that are automatically added during initialization:

**Account Table Indexes:**
- `idx_accounts_paused` on `paused` WHERE `paused = 0` - For quickly finding active accounts
- `idx_accounts_name` on `name` - For account name lookups in analytics joins
- `idx_accounts_rate_limited` on `rate_limited_until` WHERE `rate_limited_until IS NOT NULL` - For rate limit checks
- `idx_accounts_session` on `session_start, session_request_count` WHERE `session_start IS NOT NULL` - For session management
- `idx_accounts_request_count` on `request_count DESC, last_used` - For account ordering in load balancer

**Request Table Indexes:**
- `idx_requests_timestamp` on `timestamp DESC` - For time-based queries
- `idx_requests_timestamp_account` on `timestamp DESC, account_used` - For time-based account queries
- `idx_requests_model_timestamp` on `model, timestamp DESC` WHERE `model IS NOT NULL` - For model analytics
- `idx_requests_success_timestamp` on `success, timestamp DESC` - For success rate calculations
- `idx_requests_account_timestamp` on `account_used, timestamp DESC` - For per-account analytics
- `idx_requests_cost_model` on `cost_usd, model, timestamp DESC` WHERE `cost_usd > 0 AND model IS NOT NULL` - For cost analysis
- `idx_requests_response_time` on `model, response_time_ms` WHERE `response_time_ms IS NOT NULL AND model IS NOT NULL` - For response time analysis (p95 calculations)
- `idx_requests_tokens` on `timestamp DESC, total_tokens` WHERE `total_tokens > 0` - For token usage analysis

**OAuth Sessions Table Indexes:**
- `idx_oauth_sessions_expires` on `expires_at` - For efficient cleanup of expired sessions

## Performance Considerations

### SQLite Optimization

The database is automatically configured with the following optimizations:

1. **WAL Mode**: Write-Ahead Logging is enabled by default for better concurrency:
```sql
PRAGMA journal_mode = WAL;
```

2. **Busy Timeout**: Set to 5 seconds to handle concurrent access:
```sql
PRAGMA busy_timeout = 5000;
```

3. **Synchronous Mode**: Set to NORMAL for better performance while maintaining safety:
```sql
PRAGMA synchronous = NORMAL;
```

4. **Query Optimization**:
   - Prepared statements are used throughout via Bun's query API
   - Comprehensive indexing strategy based on actual query patterns
   - Partial indexes with WHERE clauses for efficient filtering

5. **Periodic Optimization**: The database supports an `optimize()` method that runs:
```sql
PRAGMA optimize;
PRAGMA wal_checkpoint(PASSIVE);
```

### Data Growth Management

Default data retention:
- Payloads: 7 days (configurable via `DATA_RETENTION_DAYS` / `data_retention_days`)
- Request metadata: 365 days (configurable via `REQUEST_RETENTION_DAYS` / `request_retention_days`)

The server performs automatic cleanup at startup (one-shot), removing payloads older than the payload retention window, then removing any orphaned payloads. It also deletes request rows older than the request metadata retention window.

You can change both via environment variables, the config file, or the dashboard (Overview → Data Retention). A manual “Clean up now” action is also available. There is no periodic cleanup job; use the manual action if needed between restarts.

1. **Payload Storage**: Periodic cleanup of old payloads:
```sql
DELETE FROM request_payloads WHERE id IN (
  SELECT id FROM requests WHERE timestamp < ?
);
DELETE FROM request_payloads WHERE id NOT IN (SELECT id FROM requests);
```

2. **Request Metadata**: Optional cleanup of old request records:
```sql
DELETE FROM requests WHERE timestamp < ?;
```

3. **Compaction**: After cleanup, SQLite doesn't shrink the main DB file automatically. To reclaim disk space:
```sql
PRAGMA wal_checkpoint(TRUNCATE);
VACUUM;
```
The dashboard exposes a "Compact database" button that runs these for you. Expect a brief pause during compaction.

4. **Statistics Aggregation**: Pre-aggregate statistics for common time windows to reduce query complexity.

## API Methods

### Core Database Operations

#### Account Management
- `getAllAccounts()`: Retrieve all accounts with computed fields
- `getAccount(accountId: string)`: Get a specific account by ID
- `updateAccountTokens(accountId, accessToken, expiresAt)`: Update OAuth tokens
- `updateAccountUsage(accountId)`: Increment usage counters and manage sessions
- `updateAccountTier(accountId, tier)`: Set account tier (1, 5, or 20)
- `pauseAccount(accountId)` / `resumeAccount(accountId)`: Toggle account availability

#### Rate Limiting
- `markAccountRateLimited(accountId, until)`: Set rate limit expiration
- `updateAccountRateLimitMeta(accountId, status, reset, remaining?)`: Update rate limit metadata
- `resetAccountSession(accountId, timestamp)`: Reset session counters

#### Request Tracking
- `saveRequestMeta(id, method, path, accountUsed, statusCode, timestamp?)`: Save basic request metadata
- `saveRequest(id, method, path, ...)`: Log request with full metadata including usage and agent info
- `updateRequestUsage(requestId, usage)`: Update token usage after request completion
- `saveRequestPayload(id, data)`: Store request/response JSON
- `getRequestPayload(id)`: Retrieve specific payload
- `listRequestPayloads(limit?)`: List recent payloads
- `listRequestPayloadsWithAccountNames(limit?)`: List payloads with account names

#### OAuth Session Management
- `createOAuthSession(sessionId, accountName, verifier, mode, tier, ttlMinutes?)`: Create OAuth session
- `getOAuthSession(sessionId)`: Retrieve session data
- `deleteOAuthSession(sessionId)`: Delete specific session
- `cleanupExpiredOAuthSessions()`: Remove expired sessions

#### Agent Preferences
- `getAgentPreference(agentId)`: Get model preference for an agent
- `getAllAgentPreferences()`: List all agent preferences
- `setAgentPreference(agentId, model)`: Set model preference
- `deleteAgentPreference(agentId)`: Remove agent preference

#### Analytics and Reporting
- `getRecentRequests(limit?)`: Get recent request history
- `getRequestStats(since?)`: Get aggregate request statistics
- `aggregateStats(rangeMs?)`: Get comprehensive analytics data
- `getRecentErrors(limit?)`: List recent error messages
- `getTopModels(limit?)`: Get most used models
- `getRequestsByAccount(since?)`: Get per-account request breakdown

## CLI Commands

The database can be managed through CLI commands:

### Account Management
```bash
# Add a new account
bun cli add <name> [--mode <max|console>] [--tier <1|5|20>]

# List all accounts with status
bun cli list

# Remove an account
bun cli remove <name>

# Pause/resume an account
bun cli pause <name>
bun cli resume <name>
```

### Database Maintenance
```bash
# Reset all usage statistics
bun cli reset-stats

# Clear all request history
bun cli clear-history
```

These commands directly interact with the database through the `DatabaseOperations` class.

## Backup and Maintenance

### Backup Strategies

1. **File-based Backup**: Simple copy of the SQLite file when the application is stopped:
```bash
cp ccflare.db ccflare.db.backup
```

2. **Online Backup**: Use SQLite's backup API for hot backups:
```sql
VACUUM INTO 'backup.db';
```

3. **Automated Backups**: Schedule regular backups using cron or system schedulers:
```bash
# Daily backup with rotation
0 2 * * * cp /path/to/ccflare.db /backups/ccflare-$(date +\%Y\%m\%d).db
```

### Maintenance Operations

The following maintenance operations are available through the CLI:

1. **Reset Statistics**:
```bash
# Resets request_count, session_start, and session_request_count for all accounts
bun cli reset-stats
```

2. **Clear History**:
```bash
# Removes all entries from the requests table
bun cli clear-history
```

3. **Manual Cleanup** (via SQL):
```sql
-- Clean up old requests (keep last 30 days)
DELETE FROM requests WHERE timestamp < strftime('%s', 'now') * 1000 - 30 * 24 * 60 * 60 * 1000;

-- Clean up orphaned payloads
DELETE FROM request_payloads WHERE id NOT IN (SELECT id FROM requests);
```

### Integrity Checks

Regular integrity checks should be performed:
```sql
-- Check database integrity
PRAGMA integrity_check;

-- Check foreign key constraints
PRAGMA foreign_key_check;

-- Analyze and optimize
ANALYZE;
VACUUM;
```

### Monitoring

Key metrics to monitor:
- Database file size growth
- Query performance (especially account selection)
- Request table row count
- Failed request rate
- Rate limit violations per account

## Security Considerations

1. **Token Storage**: OAuth tokens are stored in plaintext. In production environments, consider:
   - Encrypting sensitive columns
   - Using OS-level file encryption
   - Restricting file permissions

2. **Access Control**: Ensure proper file permissions:
```bash
chmod 600 ccflare.db
```

3. **SQL Injection**: The codebase uses parameterized queries throughout, providing protection against SQL injection.

## Future Enhancements

1. **Partitioning**: Consider partitioning the requests table by timestamp for better performance with large datasets.

2. **Replication**: Add read replicas for analytics queries without impacting operational performance.

3. **Migration Versioning**: Implement a formal migration version tracking system with a `migrations` table to track applied migrations.

4. **Audit Logging**: Add a separate audit table for security-sensitive operations like account modifications and token refreshes.

5. **Performance Metrics**: Store query performance metrics for optimization.

6. **Encryption**: Implement column-level encryption for sensitive data (tokens, API keys).

7. **Compression**: Enable compression for the `request_payloads` table to reduce storage requirements.

8. **Analytics Tables**: Create pre-aggregated tables for common analytics queries.

9. **Strategies Table**: Implement the `strategies` table that is referenced in the codebase but not yet created in the schema. This table would store:
   - Strategy configurations for load balancing algorithms
   - Custom routing rules
   - Performance tuning parameters

10. **Connection Pooling**: Implement connection pooling for high-concurrency scenarios.

11. **Streaming Backups**: Implement streaming backups to cloud storage providers.

12. **Request Archival**: Implement automatic archival of old request data to separate tables or external storage.
</file>

<file path="packages/cli-commands/src/commands/account.ts">
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import { createOAuthFlow } from "@ccflare/oauth-flow";
import type { AccountListItem } from "@ccflare/types";
import {
	type PromptAdapter,
	promptAccountRemovalConfirmation,
	stdPromptAdapter,
} from "../prompts/index";
import { openBrowser } from "../utils/browser";

// Re-export types with adapter extension for CLI-specific options
export interface AddAccountOptions {
	name: string;
	mode?: "max" | "console";
	tier?: 1 | 5 | 20;
	adapter?: PromptAdapter;
}

// Re-export AccountListItem from types for backward compatibility
export type { AccountListItem } from "@ccflare/types";

// Add mode property to AccountListItem for CLI display
export interface AccountListItemWithMode extends AccountListItem {
	mode: "max" | "console";
}

/**
 * Add a new account using OAuth flow
 */
export async function addAccount(
	dbOps: DatabaseOperations,
	config: Config,
	options: AddAccountOptions,
): Promise<void> {
	const {
		name,
		mode: providedMode,
		tier: providedTier,
		adapter = stdPromptAdapter,
	} = options;

	// Create OAuth flow instance
	const oauthFlow = await createOAuthFlow(dbOps, config);

	// Prompt for mode if not provided
	const mode =
		providedMode ||
		(await adapter.select("What type of account would you like to add?", [
			{ label: "Claude Max account", value: "max" },
			{ label: "Claude Console account", value: "console" },
		]));

	// Begin OAuth flow
	const flowResult = await oauthFlow.begin({
		name,
		mode: mode as "max" | "console",
	});
	const { authUrl, sessionId } = flowResult;

	// Open browser and prompt for code
	console.log(`\nOpening browser to authenticate...`);
	console.log(`URL: ${authUrl}`);
	const browserOpened = await openBrowser(authUrl);
	if (!browserOpened) {
		console.log(
			`\nFailed to open browser automatically. Please manually open the URL above.`,
		);
	}

	// Get authorization code
	const code = await adapter.input("\nEnter the authorization code: ");

	// Get tier for Max accounts
	const tier =
		mode === "max"
			? providedTier ||
				(await adapter.select(
					"Select the tier for this account (used for weighted load balancing):",
					[
						{ label: "1x tier (default free account)", value: 1 },
						{ label: "5x tier (paid account)", value: 5 },
						{ label: "20x tier (enterprise account)", value: 20 },
					],
				))
			: 1;

	// Complete OAuth flow
	console.log("\nExchanging code for tokens...");
	const _account = await oauthFlow.complete(
		{ sessionId, code, tier, name },
		flowResult,
	);

	console.log(`\nAccount '${name}' added successfully!`);
	console.log(`Type: ${mode === "max" ? "Claude Max" : "Claude Console"}`);
	console.log(`Tier: ${tier}x`);
}

/**
 * Get list of all accounts with formatted information
 */
export function getAccountsList(dbOps: DatabaseOperations): AccountListItem[] {
	const accounts = dbOps.getAllAccounts();
	const now = Date.now();

	return accounts.map((account) => {
		const tierDisplay = `${account.account_tier}x`;
		const tokenStatus =
			account.expires_at && account.expires_at > now ? "valid" : "expired";

		let rateLimitStatus = "OK";
		if (account.paused) {
			rateLimitStatus = "Paused";
		} else if (account.rate_limited_until && account.rate_limited_until > now) {
			const minutesLeft = Math.ceil((account.rate_limited_until - now) / 60000);
			rateLimitStatus = `Rate limited (${minutesLeft}m)`;
		}

		let sessionInfo = "-";
		if (account.session_start) {
			const sessionAge = Math.floor((now - account.session_start) / 60000);
			sessionInfo = `${account.session_request_count} reqs, ${sessionAge}m ago`;
		}

		return {
			id: account.id,
			name: account.name,
			provider: account.provider,
			tierDisplay,
			created: new Date(account.created_at),
			lastUsed: account.last_used ? new Date(account.last_used) : null,
			requestCount: account.request_count,
			totalRequests: account.total_requests,
			paused: account.paused,
			tokenStatus,
			rateLimitStatus,
			sessionInfo,
			tier: account.account_tier || 1,
			mode: account.account_tier > 1 ? "max" : "console",
		};
	});
}

/**
 * Remove an account by name
 */
export function removeAccount(
	dbOps: DatabaseOperations,
	name: string,
): { success: boolean; message: string } {
	const db = dbOps.getDatabase();
	const result = db.run("DELETE FROM accounts WHERE name = ?", [name]);

	if (result.changes === 0) {
		return {
			success: false,
			message: `Account '${name}' not found`,
		};
	}

	return {
		success: true,
		message: `Account '${name}' removed successfully`,
	};
}

/**
 * Remove an account by name with confirmation prompt (for CLI)
 */
export async function removeAccountWithConfirmation(
	dbOps: DatabaseOperations,
	name: string,
	force?: boolean,
): Promise<{ success: boolean; message: string }> {
	// Check if account exists first
	const accounts = dbOps.getAllAccounts();
	const exists = accounts.some((a) => a.name === name);

	if (!exists) {
		return {
			success: false,
			message: `Account '${name}' not found`,
		};
	}

	// Skip confirmation if force flag is set
	if (!force) {
		const confirmed = await promptAccountRemovalConfirmation(name);
		if (!confirmed) {
			return {
				success: false,
				message: "Account removal cancelled",
			};
		}
	}

	return removeAccount(dbOps, name);
}

/**
 * Toggle account pause state (shared logic for pause/resume)
 */
function toggleAccountPause(
	dbOps: DatabaseOperations,
	name: string,
	shouldPause: boolean,
): { success: boolean; message: string } {
	const db = dbOps.getDatabase();

	// Get account ID by name
	const account = db
		.query<{ id: string; paused: 0 | 1 }, [string]>(
			"SELECT id, COALESCE(paused, 0) as paused FROM accounts WHERE name = ?",
		)
		.get(name);

	if (!account) {
		return {
			success: false,
			message: `Account '${name}' not found`,
		};
	}

	const isPaused = account.paused === 1;
	const _action = shouldPause ? "pause" : "resume";
	const actionPast = shouldPause ? "paused" : "resumed";

	if (isPaused === shouldPause) {
		return {
			success: false,
			message: `Account '${name}' is already ${actionPast}`,
		};
	}

	if (shouldPause) {
		dbOps.pauseAccount(account.id);
	} else {
		dbOps.resumeAccount(account.id);
	}

	return {
		success: true,
		message: `Account '${name}' ${actionPast} successfully`,
	};
}

/**
 * Pause an account by name
 */
export function pauseAccount(
	dbOps: DatabaseOperations,
	name: string,
): { success: boolean; message: string } {
	return toggleAccountPause(dbOps, name, true);
}

/**
 * Resume a paused account by name
 */
export function resumeAccount(
	dbOps: DatabaseOperations,
	name: string,
): { success: boolean; message: string } {
	return toggleAccountPause(dbOps, name, false);
}
</file>

<file path="packages/core/src/index.ts">
// Re-export only used items from each module
export {
	BUFFER_SIZES,
	CACHE,
	HTTP_STATUS,
	LIMITS,
	NETWORK,
	TIME_CONSTANTS,
} from "./constants";

export {
	logError,
	OAuthError,
	ProviderError,
	RateLimitError,
	ServiceUnavailableError,
	TokenRefreshError,
	ValidationError,
} from "./errors";

export * from "./lifecycle";
export {
	CLAUDE_MODEL_IDS,
	type ClaudeModelId,
	DEFAULT_AGENT_MODEL,
	DEFAULT_MODEL,
	getModelDisplayName,
	getModelShortName,
	isValidModelId,
	MODEL_DISPLAY_NAMES,
	MODEL_SHORT_NAMES,
} from "./models";
export {
	estimateCostUSD,
	setPricingLogger,
	type TokenBreakdown,
} from "./pricing";
export * from "./request-events";
export * from "./strategy";
export {
	patterns,
	sanitizers,
	validateNumber,
	validateString,
} from "./validation";
</file>

<file path="packages/core/src/models.ts">
/**
 * Centralized model definitions and constants
 * All Claude model IDs and metadata should be defined here
 */

// Full model IDs as used by the Anthropic API
export const CLAUDE_MODEL_IDS = {
	// Claude 3.5 models
	HAIKU_3_5: "claude-3-5-haiku-20241022",
	SONNET_3_5: "claude-3-5-sonnet-20241022",

	// Claude 4 models
	SONNET_4: "claude-sonnet-4-20250514",
	OPUS_4: "claude-opus-4-20250514",
	OPUS_4_1: "claude-opus-4-1-20250805",

	// Legacy Claude 3 models (for documentation/API examples)
	OPUS_3: "claude-3-opus-20240229",
	SONNET_3: "claude-3-sonnet-20240229",
} as const;

// Model display names
export const MODEL_DISPLAY_NAMES: Record<string, string> = {
	[CLAUDE_MODEL_IDS.HAIKU_3_5]: "Claude Haiku 3.5",
	[CLAUDE_MODEL_IDS.SONNET_3_5]: "Claude Sonnet 3.5 v2",
	[CLAUDE_MODEL_IDS.SONNET_4]: "Claude Sonnet 4",
	[CLAUDE_MODEL_IDS.OPUS_4]: "Claude Opus 4",
	[CLAUDE_MODEL_IDS.OPUS_4_1]: "Claude Opus 4.1",
	[CLAUDE_MODEL_IDS.OPUS_3]: "Claude Opus 3",
	[CLAUDE_MODEL_IDS.SONNET_3]: "Claude Sonnet 3",
};

// Short model names used in UI (for color mapping, etc.)
export const MODEL_SHORT_NAMES: Record<string, string> = {
	[CLAUDE_MODEL_IDS.HAIKU_3_5]: "claude-3.5-haiku",
	[CLAUDE_MODEL_IDS.SONNET_3_5]: "claude-3.5-sonnet",
	[CLAUDE_MODEL_IDS.SONNET_4]: "claude-sonnet-4",
	[CLAUDE_MODEL_IDS.OPUS_4]: "claude-opus-4",
	[CLAUDE_MODEL_IDS.OPUS_4_1]: "claude-opus-4.1",
	[CLAUDE_MODEL_IDS.OPUS_3]: "claude-3-opus",
	[CLAUDE_MODEL_IDS.SONNET_3]: "claude-3-sonnet",
};

// Default model for various contexts
export const DEFAULT_MODEL = CLAUDE_MODEL_IDS.SONNET_4;
export const DEFAULT_AGENT_MODEL = CLAUDE_MODEL_IDS.SONNET_4;

// Type for all valid model IDs
export type ClaudeModelId =
	(typeof CLAUDE_MODEL_IDS)[keyof typeof CLAUDE_MODEL_IDS];

// Helper function to get short name from full model ID
export function getModelShortName(modelId: string): string {
	return MODEL_SHORT_NAMES[modelId] || modelId;
}

// Helper function to get display name from model ID
export function getModelDisplayName(modelId: string): string {
	return MODEL_DISPLAY_NAMES[modelId] || modelId;
}

// Helper function to validate if a string is a valid model ID
export function isValidModelId(modelId: string): modelId is ClaudeModelId {
	return Object.values(CLAUDE_MODEL_IDS).includes(modelId as ClaudeModelId);
}
</file>

<file path="packages/dashboard-web/src/components/accounts/AccountList.tsx">
import type { Account } from "../../api";
import { AccountListItem } from "./AccountListItem";

interface AccountListProps {
	accounts: Account[] | undefined;
	onPauseToggle: (account: Account) => void;
	onRemove: (name: string) => void;
	onRename: (account: Account) => void;
}

export function AccountList({
	accounts,
	onPauseToggle,
	onRemove,
	onRename,
}: AccountListProps) {
	if (!accounts || accounts.length === 0) {
		return <p className="text-muted-foreground">No accounts configured</p>;
	}

	// Find the most recently used account
	const mostRecentAccountId = accounts.reduce(
		(mostRecent, account) => {
			if (!account.lastUsed) return mostRecent;
			if (!mostRecent) return account.id;

			const mostRecentAccount = accounts.find((a) => a.id === mostRecent);
			if (!mostRecentAccount?.lastUsed) return account.id;

			const mostRecentLastUsed = new Date(mostRecentAccount.lastUsed).getTime();
			const currentLastUsed = new Date(account.lastUsed).getTime();

			return currentLastUsed > mostRecentLastUsed ? account.id : mostRecent;
		},
		null as string | null,
	);

	return (
		<div className="space-y-2">
			{accounts.map((account) => (
				<AccountListItem
					key={account.name}
					account={account}
					isActive={account.id === mostRecentAccountId}
					onPauseToggle={onPauseToggle}
					onRemove={onRemove}
					onRename={onRename}
				/>
			))}
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/accounts/index.ts">
export { AccountAddForm } from "./AccountAddForm";
export { AccountList } from "./AccountList";
export { AccountListItem } from "./AccountListItem";
export { DeleteConfirmationDialog } from "./DeleteConfirmationDialog";
export { RateLimitProgress } from "./RateLimitProgress";
export { RenameAccountDialog } from "./RenameAccountDialog";
</file>

<file path="packages/dashboard-web/src/components/analytics/AnalyticsCharts.tsx">
import type { TimePoint } from "@ccflare/types";
import { formatCost, formatNumber, formatTokens } from "@ccflare/ui-common";
import { useState } from "react";
import {
	Area,
	AreaChart,
	CartesianGrid,
	Legend,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import {
	CHART_HEIGHTS,
	CHART_PROPS,
	COLORS,
	type TimeRange,
} from "../../constants";
import {
	formatCompactCurrency,
	formatCompactNumber,
} from "../../lib/chart-utils";
import {
	BaseAreaChart,
	BaseBarChart,
	BaseLineChart,
	CostChart,
	ModelPerformanceChart,
	MultiModelChart,
	RequestVolumeChart,
	ResponseTimeChart,
	TokenSpeedChart,
	TokenUsageChart,
} from "../charts";
import { Badge } from "../ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Switch } from "../ui/switch";

interface ChartData {
	time: string;
	requests: number;
	tokens: number;
	cost: number;
	responseTime: number;
	errorRate: number;
	cacheHitRate: number;
	avgTokensPerSecond: number;
	[key: string]: string | number;
}

interface MainMetricsChartProps {
	data: ChartData[];
	rawTimeSeries?: TimePoint[];
	loading: boolean;
	viewMode: "normal" | "cumulative";
	timeRange: TimeRange;
	selectedMetric: string;
	setSelectedMetric: (metric: string) => void;
	modelBreakdown?: boolean;
	onModelBreakdownChange?: (enabled: boolean) => void;
}

export function MainMetricsChart({
	data,
	rawTimeSeries,
	loading,
	viewMode,
	timeRange,
	selectedMetric,
	setSelectedMetric,
	modelBreakdown = false,
	onModelBreakdownChange,
}: MainMetricsChartProps) {
	// Process data for multi-model chart if model breakdown is enabled (not in cumulative mode)
	const processedMultiModelData =
		rawTimeSeries && modelBreakdown && viewMode !== "cumulative"
			? (() => {
					// Group by timestamp and pivot models
					const grouped: Record<
						string,
						{ time: string; [model: string]: string | number }
					> = {};
					const models = new Set<string>();

					// First pass: collect all time points and models
					const timePoints = new Set<string>();
					const timeToTimestamp = new Map<string, number>();

					rawTimeSeries.forEach((point) => {
						if (point.model) {
							models.add(point.model);
							const time =
								timeRange === "30d"
									? new Date(point.ts).toLocaleDateString()
									: new Date(point.ts).toLocaleTimeString([], {
											hour: "2-digit",
											minute: "2-digit",
										});
							timePoints.add(time);
							timeToTimestamp.set(time, point.ts);
						}
					});

					// Sort time points chronologically using the original timestamps
					const sortedTimes = Array.from(timePoints).sort((a, b) => {
						const tsA = timeToTimestamp.get(a) || 0;
						const tsB = timeToTimestamp.get(b) || 0;
						return tsA - tsB;
					});

					// Initialize data structure
					const modelArrays = Array.from(models).sort();

					// Process time points in order
					sortedTimes.forEach((time) => {
						grouped[time] = { time };

						// Initialize all models for this time point
						modelArrays.forEach((model) => {
							// Default to 0 for missing data points
							grouped[time][model] = 0;
						});
					});

					// Fill in actual values
					rawTimeSeries.forEach((point) => {
						if (point.model) {
							const time =
								timeRange === "30d"
									? new Date(point.ts).toLocaleDateString()
									: new Date(point.ts).toLocaleTimeString([], {
											hour: "2-digit",
											minute: "2-digit",
										});

							// Map the metric value
							let value = 0;
							switch (selectedMetric) {
								case "requests":
									value = point.requests;
									break;
								case "tokens":
									value = point.tokens;
									break;
								case "cost":
									value = point.costUsd;
									break;
								case "responseTime":
									value = point.avgResponseTime;
									break;
								case "tokensPerSecond":
									value = point.avgTokensPerSecond || 0;
									break;
							}

							grouped[time][point.model] = value;
						}
					});

					// Sort and return the data
					const finalData = sortedTimes.map((time) => grouped[time]);

					return {
						data: finalData,
						models: modelArrays,
					};
				})()
			: null;

	return (
		<Card>
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle>Traffic Analytics</CardTitle>
						<CardDescription>
							{viewMode === "cumulative"
								? "Cumulative totals showing growth over time"
								: modelBreakdown
									? "Per-model breakdown over time"
									: "Request volume and performance metrics over time"}
						</CardDescription>
					</div>
					<div className="flex items-center gap-4">
						{viewMode !== "cumulative" && (
							<div className="flex items-center gap-2">
								<Switch
									id="model-breakdown"
									checked={modelBreakdown}
									onCheckedChange={onModelBreakdownChange}
								/>
								<Label htmlFor="model-breakdown" className="text-sm">
									Per Model
								</Label>
							</div>
						)}
						<Select value={selectedMetric} onValueChange={setSelectedMetric}>
							<SelectTrigger className="w-40">
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="requests">Requests</SelectItem>
								<SelectItem value="tokens">Token Usage</SelectItem>
								<SelectItem value="cost">Cost ($)</SelectItem>
								<SelectItem value="responseTime">Response Time</SelectItem>
								<SelectItem value="tokensPerSecond">Output Speed</SelectItem>
							</SelectContent>
						</Select>
					</div>
				</div>
			</CardHeader>
			<CardContent>
				{(() => {
					// Show multi-model chart if breakdown is enabled
					if (modelBreakdown && processedMultiModelData) {
						return (
							<MultiModelChart
								data={processedMultiModelData.data}
								models={processedMultiModelData.models}
								metric={
									selectedMetric as
										| "requests"
										| "tokens"
										| "cost"
										| "responseTime"
										| "tokensPerSecond"
								}
								loading={loading}
								height={CHART_HEIGHTS.large}
								viewMode={viewMode}
							/>
						);
					}

					// Otherwise show normal charts
					const commonProps = {
						data,
						loading,
						height: CHART_HEIGHTS.large,
						viewMode,
						timeRange,
					};

					switch (selectedMetric) {
						case "tokens":
							return <TokenUsageChart {...commonProps} />;
						case "cost":
							return <CostChart {...commonProps} />;
						case "requests":
							return <RequestVolumeChart {...commonProps} />;
						case "responseTime":
							return <ResponseTimeChart {...commonProps} />;
						case "tokensPerSecond":
							return <TokenSpeedChart {...commonProps} />;
						default:
							return (
								<BaseAreaChart
									data={data}
									dataKey={selectedMetric}
									loading={loading}
									height="large"
									color={
										viewMode === "cumulative" ? COLORS.purple : COLORS.primary
									}
									strokeWidth={viewMode === "cumulative" ? 3 : 2}
									xAxisAngle={
										timeRange === "7d" || timeRange === "30d" ? -45 : 0
									}
									xAxisTextAnchor={
										timeRange === "7d" || timeRange === "30d" ? "end" : "middle"
									}
									xAxisHeight={
										timeRange === "7d" || timeRange === "30d" ? 60 : 30
									}
									tooltipLabelFormatter={(label) =>
										viewMode === "cumulative" ? `Cumulative at ${label}` : label
									}
								/>
							);
					}
				})()}
			</CardContent>
		</Card>
	);
}

interface PerformanceIndicatorsChartProps {
	data: ChartData[];
	loading: boolean;
	modelBreakdown?: boolean;
	rawTimeSeries?: TimePoint[];
	selectedMetric?: "errorRate" | "cacheHitRate";
	timeRange?: TimeRange;
}

export function PerformanceIndicatorsChart({
	data,
	loading,
	modelBreakdown = false,
	rawTimeSeries,
	selectedMetric = "cacheHitRate",
	timeRange = "24h",
}: PerformanceIndicatorsChartProps) {
	const [currentMetric, setCurrentMetric] = useState(selectedMetric);

	// Process data for multi-model chart if model breakdown is enabled
	const processedMultiModelData =
		rawTimeSeries && modelBreakdown
			? (() => {
					// Group by timestamp and pivot models
					const grouped: Record<
						string,
						{ time: string; [model: string]: string | number }
					> = {};
					const models = new Set<string>();
					const timeToTimestamp = new Map<string, number>();

					rawTimeSeries.forEach((point) => {
						if (point.model) {
							models.add(point.model);
							const time =
								timeRange === "30d"
									? new Date(point.ts).toLocaleDateString()
									: new Date(point.ts).toLocaleTimeString([], {
											hour: "2-digit",
											minute: "2-digit",
										});
							timeToTimestamp.set(time, point.ts);
						}
					});

					// Sort time points chronologically
					const sortedTimes = Array.from(new Set(timeToTimestamp.keys())).sort(
						(a, b) => {
							const tsA = timeToTimestamp.get(a) || 0;
							const tsB = timeToTimestamp.get(b) || 0;
							return tsA - tsB;
						},
					);

					const modelArrays = Array.from(models).sort();

					// Initialize all time points with all models
					sortedTimes.forEach((time) => {
						grouped[time] = { time };
						modelArrays.forEach((model) => {
							grouped[time][model] = 0;
						});
					});

					// Fill in actual values
					rawTimeSeries.forEach((point) => {
						if (point.model) {
							const time =
								timeRange === "30d"
									? new Date(point.ts).toLocaleDateString()
									: new Date(point.ts).toLocaleTimeString([], {
											hour: "2-digit",
											minute: "2-digit",
										});

							// Map the metric value
							const value =
								currentMetric === "errorRate"
									? point.errorRate
									: point.cacheHitRate;

							grouped[time][point.model] = value;
						}
					});

					const finalData = sortedTimes.map((time) => grouped[time]);

					return {
						data: finalData,
						models: modelArrays,
					};
				})()
			: null;

	return (
		<Card>
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle>Performance Indicators</CardTitle>
						<CardDescription>
							{modelBreakdown
								? "Per-model error rate and cache hit rate trends"
								: "Error rate and cache hit rate trends"}
						</CardDescription>
					</div>
					{modelBreakdown && (
						<Select
							value={currentMetric}
							onValueChange={(value) =>
								setCurrentMetric(value as "errorRate" | "cacheHitRate")
							}
						>
							<SelectTrigger className="w-36">
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="cacheHitRate">Cache Hit Rate</SelectItem>
								<SelectItem value="errorRate">Error Rate</SelectItem>
							</SelectContent>
						</Select>
					)}
				</div>
			</CardHeader>
			<CardContent>
				{modelBreakdown && processedMultiModelData ? (
					<MultiModelChart
						data={processedMultiModelData.data}
						models={processedMultiModelData.models}
						metric={currentMetric}
						loading={loading}
						height={CHART_HEIGHTS.medium}
					/>
				) : (
					<BaseLineChart
						data={data}
						lines={[
							{
								dataKey: "errorRate",
								stroke: COLORS.error,
								name: "Error Rate %",
							},
							{
								dataKey: "cacheHitRate",
								stroke: COLORS.success,
								name: "Cache Hit %",
							},
						]}
						loading={loading}
						height="medium"
						showLegend={true}
						referenceLines={[
							{ y: 90, stroke: COLORS.success },
							{ y: 5, stroke: COLORS.error },
						]}
					/>
				)}
			</CardContent>
		</Card>
	);
}

interface TokenBreakdownItem {
	type: string;
	value: number;
	percentage: number;
}

interface TokenUsageBreakdownProps {
	tokenBreakdown: TokenBreakdownItem[];
	timeRange: TimeRange;
}

export function TokenUsageBreakdown({
	tokenBreakdown,
	timeRange,
}: TokenUsageBreakdownProps) {
	return (
		<Card>
			<CardHeader>
				<CardTitle>Token Usage Breakdown</CardTitle>
				<CardDescription>
					Distribution of token types in the last {timeRange}
				</CardDescription>
			</CardHeader>
			<CardContent>
				<div className="space-y-4">
					{tokenBreakdown.map((item, index) => (
						<div key={item.type}>
							<div className="flex items-center justify-between mb-2">
								<span className="text-sm font-medium">{item.type}</span>
								<div className="flex items-center gap-2">
									<span className="text-sm text-muted-foreground">
										{formatTokens(item.value)} tokens
									</span>
									<Badge variant="outline">{item.percentage}%</Badge>
								</div>
							</div>
							<div className="w-full bg-muted rounded-full h-2">
								<div
									className="h-2 rounded-full transition-all"
									style={{
										width: `${item.percentage}%`,
										backgroundColor:
											index === 0
												? COLORS.blue
												: index === 1
													? COLORS.success
													: index === 2
														? COLORS.warning
														: COLORS.purple,
									}}
								/>
							</div>
						</div>
					))}
					<div className="pt-4 border-t">
						<div className="flex items-center justify-between">
							<span className="text-sm font-medium">Total Tokens</span>
							<span className="text-lg font-bold">
								{tokenBreakdown.reduce((acc, item) => acc + item.value, 0)}
							</span>
						</div>
					</div>
				</div>
			</CardContent>
		</Card>
	);
}

interface ModelComparisonChartsProps {
	modelPerformance: Array<{
		model: string;
		avgTime: number;
		p95Time: number;
		errorRate: number;
	}>;
	costByModel: Array<{ model: string; cost: number; requests: number }>;
	loading: boolean;
	timeRange: TimeRange;
}

export function ModelComparisonCharts({
	modelPerformance,
	costByModel,
	loading,
	timeRange,
}: ModelComparisonChartsProps) {
	return (
		<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
			{/* Model Performance */}
			<Card>
				<CardHeader>
					<CardTitle>Model Performance Comparison</CardTitle>
					<CardDescription>
						Response times and error rates by model
					</CardDescription>
				</CardHeader>
				<CardContent>
					<ModelPerformanceChart
						data={modelPerformance}
						loading={loading}
						height={CHART_HEIGHTS.medium}
					/>
				</CardContent>
			</Card>

			{/* Cost by Model */}
			<Card>
				<CardHeader>
					<CardTitle>Cost Analysis by Model</CardTitle>
					<CardDescription>
						Top models by cost in the last {timeRange}
					</CardDescription>
				</CardHeader>
				<CardContent>
					<BaseBarChart
						data={costByModel}
						bars={{ dataKey: "cost", radius: [0, 4, 4, 0] }}
						xAxisKey="model"
						loading={loading}
						height="medium"
						layout="vertical"
						yAxisWidth={120}
						tooltipFormatter={(value, name) => {
							if (name === "cost") return [formatCost(Number(value)), "Cost"];
							return [formatNumber(value as number), "Requests"];
						}}
					/>
				</CardContent>
			</Card>
		</div>
	);
}

interface CumulativeGrowthChartProps {
	data: ChartData[];
}

export function CumulativeGrowthChart({ data }: CumulativeGrowthChartProps) {
	return (
		<Card className="bg-gradient-to-br from-background to-muted/10 border-muted">
			<CardHeader>
				<CardTitle className="text-2xl font-bold">
					Cumulative Growth Analysis
				</CardTitle>
				<CardDescription>
					Token usage vs. cost accumulation over time
				</CardDescription>
			</CardHeader>
			<CardContent>
				<ResponsiveContainer width="100%" height={CHART_HEIGHTS.large}>
					<AreaChart
						data={data}
						margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
					>
						<defs>
							<linearGradient id="colorTokens" x1="0" y1="0" x2="0" y2="1">
								<stop offset="0%" stopColor={COLORS.blue} stopOpacity={0.9} />
								<stop offset="100%" stopColor={COLORS.blue} stopOpacity={0.1} />
							</linearGradient>
							<linearGradient id="colorCost" x1="0" y1="0" x2="0" y2="1">
								<stop
									offset="0%"
									stopColor={COLORS.warning}
									stopOpacity={0.9}
								/>
								<stop
									offset="100%"
									stopColor={COLORS.warning}
									stopOpacity={0.1}
								/>
							</linearGradient>
							<filter id="glow">
								<feGaussianBlur stdDeviation="4" result="coloredBlur" />
								<feMerge>
									<feMergeNode in="coloredBlur" />
									<feMergeNode in="SourceGraphic" />
								</feMerge>
							</filter>
						</defs>
						<CartesianGrid
							strokeDasharray={CHART_PROPS.strokeDasharray}
							stroke="rgba(255,255,255,0.1)"
						/>
						<XAxis
							dataKey="time"
							className="text-xs"
							stroke="rgba(255,255,255,0.5)"
						/>
						<YAxis
							yAxisId="tokens"
							className="text-xs"
							stroke={COLORS.blue}
							tickFormatter={formatCompactNumber}
						/>
						<YAxis
							yAxisId="cost"
							orientation="right"
							className="text-xs"
							stroke={COLORS.warning}
							tickFormatter={formatCompactCurrency}
						/>
						<Tooltip
							labelClassName="font-bold"
							contentStyle={{
								backgroundColor: "rgba(0,0,0,0.8)",
								border: "1px solid rgba(255,255,255,0.2)",
								borderRadius: "8px",
								backdropFilter: "blur(8px)",
							}}
							formatter={(value: number | string, name: string) => {
								if (name === "Total Cost")
									return [formatCost(Number(value)), "Total Cost"];
								return [formatTokens(value as number), "Total Tokens"];
							}}
						/>
						<Legend
							verticalAlign="top"
							height={36}
							iconType="rect"
							wrapperStyle={{
								paddingBottom: "20px",
							}}
						/>
						<Area
							yAxisId="tokens"
							type="monotone"
							dataKey="tokens"
							stroke={COLORS.blue}
							strokeWidth={3}
							fillOpacity={1}
							fill="url(#colorTokens)"
							filter="url(#glow)"
							name="Total Tokens"
						/>
						<Area
							yAxisId="cost"
							type="monotone"
							dataKey="cost"
							stroke={COLORS.warning}
							strokeWidth={3}
							fillOpacity={1}
							fill="url(#colorCost)"
							filter="url(#glow)"
							name="Total Cost"
						/>
					</AreaChart>
				</ResponsiveContainer>
			</CardContent>
		</Card>
	);
}

interface CumulativeTokenCompositionProps {
	tokenBreakdown: TokenBreakdownItem[];
}

export function CumulativeTokenComposition({
	tokenBreakdown,
}: CumulativeTokenCompositionProps) {
	return (
		<Card>
			<CardHeader>
				<CardTitle>Cumulative Token Composition</CardTitle>
				<CardDescription>Token type distribution over time</CardDescription>
			</CardHeader>
			<CardContent>
				<div className="space-y-6">
					<div className="relative h-24 bg-muted rounded-lg overflow-hidden">
						{(() => {
							let offset = 0;
							return tokenBreakdown.map((item, index) => {
								const width = item.percentage;
								const currentOffset = offset;
								offset += width;
								return (
									<div
										key={item.type}
										className="absolute h-full transition-all duration-1000 hover:opacity-80"
										style={{
											left: `${currentOffset}%`,
											width: `${width}%`,
											background: `linear-gradient(135deg, ${
												index === 0
													? COLORS.blue
													: index === 1
														? COLORS.success
														: index === 2
															? COLORS.warning
															: COLORS.purple
											} 0%, ${
												index === 0
													? COLORS.purple
													: index === 1
														? COLORS.blue
														: index === 2
															? COLORS.primary
															: COLORS.warning
											} 100%)`,
										}}
									>
										<div className="flex items-center justify-center h-full">
											{width > 10 && (
												<span className="text-white font-medium text-xs">
													{item.percentage}%
												</span>
											)}
										</div>
									</div>
								);
							});
						})()}
					</div>
					<div className="grid grid-cols-2 md:grid-cols-4 gap-4">
						{tokenBreakdown.map((item, index) => (
							<div key={item.type} className="flex items-center gap-2">
								<div
									className="w-3 h-3 rounded-full"
									style={{
										background:
											index === 0
												? COLORS.blue
												: index === 1
													? COLORS.success
													: index === 2
														? COLORS.warning
														: COLORS.purple,
									}}
								/>
								<div>
									<p className="text-xs text-muted-foreground">{item.type}</p>
									<p className="text-sm font-medium">
										{formatTokens(item.value)}
									</p>
								</div>
							</div>
						))}
					</div>
				</div>
			</CardContent>
		</Card>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/ModelTokenSpeedChart.tsx">
import { getModelShortName } from "@ccflare/core";
import { formatTokensPerSecond } from "@ccflare/ui-common";
import {
	Bar,
	BarChart,
	CartesianGrid,
	Cell,
	ErrorBar,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { getTooltipStyles } from "./chart-utils";

interface ModelTokenSpeedData {
	model: string;
	avgTokensPerSecond: number | null;
	minTokensPerSecond: number | null;
	maxTokensPerSecond: number | null;
}

interface ModelTokenSpeedChartProps {
	data: ModelTokenSpeedData[];
	loading?: boolean;
	height?: number;
}

// Model-based color palette
const MODEL_COLORS: Record<string, string> = {
	"claude-3.5-sonnet": COLORS.purple,
	"claude-3.5-haiku": COLORS.success,
	"claude-3-opus": COLORS.blue,
	"claude-opus-4": COLORS.pink,
	// Add more models as needed
};

function getModelColor(model: string): string {
	// Try to find color by short name first
	const shortName = getModelShortName(model);
	if (MODEL_COLORS[shortName]) return MODEL_COLORS[shortName];

	// Check for exact match
	if (MODEL_COLORS[model]) return MODEL_COLORS[model];

	// Check for partial matches
	for (const [key, color] of Object.entries(MODEL_COLORS)) {
		if (model.includes(key) || key.includes(model)) {
			return color;
		}
	}

	// Default color
	return COLORS.primary;
}

export function ModelTokenSpeedChart({
	data,
	loading = false,
	height = 300,
}: ModelTokenSpeedChartProps) {
	if (loading) {
		return (
			<div className="flex items-center justify-center" style={{ height }}>
				<div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" />
			</div>
		);
	}

	// Filter out models without token speed data and prepare chart data
	const chartData = data
		.filter((d) => d.avgTokensPerSecond !== null && d.avgTokensPerSecond > 0)
		.map((d) => ({
			model: d.model,
			avgSpeed: d.avgTokensPerSecond || 0,
			minSpeed: d.minTokensPerSecond || 0,
			maxSpeed: d.maxTokensPerSecond || 0,
			// Calculate error bars (distance from avg to min/max)
			errorLower: (d.avgTokensPerSecond || 0) - (d.minTokensPerSecond || 0),
			errorUpper: (d.maxTokensPerSecond || 0) - (d.avgTokensPerSecond || 0),
		}))
		.sort((a, b) => b.avgSpeed - a.avgSpeed); // Sort by average speed

	if (chartData.length === 0) {
		return (
			<div
				className="flex items-center justify-center text-muted-foreground"
				style={{ height }}
			>
				No token speed data available
			</div>
		);
	}

	return (
		<ResponsiveContainer width="100%" height={height}>
			<BarChart
				data={chartData}
				margin={{ top: 20, right: 30, left: 60, bottom: 80 }}
			>
				<CartesianGrid
					strokeDasharray={CHART_PROPS.strokeDasharray}
					className={CHART_PROPS.gridClassName}
				/>
				<XAxis
					dataKey="model"
					fontSize={12}
					angle={-45}
					textAnchor="end"
					height={80}
					interval={0}
				/>
				<YAxis
					fontSize={12}
					tickFormatter={formatCompactNumber}
					label={{
						value: "Tokens/Second",
						angle: -90,
						position: "insideLeft",
						style: {
							textAnchor: "middle",
							fontSize: 12,
						},
					}}
				/>
				<Tooltip
					contentStyle={getTooltipStyles("default")}
					formatter={(value: number, name: string) => {
						if (name === "avgSpeed") {
							return [formatTokensPerSecond(value), "Avg Speed"];
						}
						return [value, name];
					}}
					labelFormatter={(label) => `Model: ${label}`}
				/>
				<Bar dataKey="avgSpeed" name="Average Speed">
					{chartData.map((entry) => (
						<Cell
							key={`cell-${entry.model}`}
							fill={getModelColor(entry.model)}
						/>
					))}
					<ErrorBar
						dataKey="errorLower"
						width={4}
						strokeOpacity={0.5}
						direction="y"
					/>
				</Bar>
			</BarChart>
		</ResponsiveContainer>
	);
}
</file>

<file path="packages/dashboard-web/src/components/charts/MultiModelChart.tsx">
import { getModelShortName } from "@ccflare/core";
import {
	formatCost,
	formatNumber,
	formatTokens,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import {
	CartesianGrid,
	Legend,
	Line,
	LineChart,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import {
	CHART_COLORS,
	CHART_HEIGHTS,
	CHART_PROPS,
	COLORS,
} from "../../constants";
import {
	formatCompactCurrency,
	formatCompactNumber,
} from "../../lib/chart-utils";
import { ChartContainer } from "./ChartContainer";
import { getTooltipStyles } from "./chart-utils";

interface MultiModelChartProps {
	data: Array<{
		time: string;
		[model: string]: string | number;
	}>;
	models: string[];
	metric:
		| "requests"
		| "tokens"
		| "cost"
		| "responseTime"
		| "tokensPerSecond"
		| "errorRate"
		| "cacheHitRate";
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
}

// Model-based color palette
const MODEL_COLORS: Record<string, string> = {
	"claude-3.5-sonnet": COLORS.purple,
	"claude-3.5-haiku": COLORS.success,
	"claude-3-opus": COLORS.blue,
	"claude-opus-4": COLORS.pink,
};

function getModelColor(model: string, index: number): string {
	// Try to find color by short name first
	const shortName = getModelShortName(model);
	if (MODEL_COLORS[shortName]) return MODEL_COLORS[shortName];

	// Check for exact match
	if (MODEL_COLORS[model]) return MODEL_COLORS[model];

	// Check for partial matches
	for (const [key, color] of Object.entries(MODEL_COLORS)) {
		if (model.includes(key) || key.includes(model)) {
			return color;
		}
	}

	// Use chart colors array as fallback
	return CHART_COLORS[index % CHART_COLORS.length];
}

function getMetricLabel(metric: string): string {
	switch (metric) {
		case "requests":
			return "Requests";
		case "tokens":
			return "Tokens";
		case "cost":
			return "Cost ($)";
		case "responseTime":
			return "Response Time (ms)";
		case "tokensPerSecond":
			return "Tokens/Second";
		case "errorRate":
			return "Error Rate (%)";
		case "cacheHitRate":
			return "Cache Hit Rate (%)";
		default:
			return metric;
	}
}

function formatValue(value: number, metric: string): string {
	switch (metric) {
		case "cost":
			return formatCost(value);
		case "tokens":
			return formatTokens(value);
		case "tokensPerSecond":
			return formatTokensPerSecond(value);
		case "responseTime":
			return `${value.toFixed(0)}ms`;
		case "errorRate":
		case "cacheHitRate":
			return `${value.toFixed(1)}%`;
		default:
			return formatNumber(value);
	}
}

function formatAxisValue(value: number, metric: string): string {
	switch (metric) {
		case "cost":
			return formatCompactCurrency(value);
		case "tokens":
		case "requests":
			return formatCompactNumber(value);
		case "tokensPerSecond":
			return formatCompactNumber(value);
		case "responseTime":
			return formatCompactNumber(value);
		case "errorRate":
		case "cacheHitRate":
			return `${value.toFixed(0)}%`;
		default:
			return formatCompactNumber(value);
	}
}

export function MultiModelChart({
	data,
	models,
	metric,
	loading = false,
	height = CHART_HEIGHTS.large,
	viewMode = "normal",
}: MultiModelChartProps) {
	if (loading || !data || data.length === 0) {
		return (
			<ChartContainer
				loading={loading}
				height={height}
				isEmpty={!loading && (!data || data.length === 0)}
				emptyState={
					<div className="text-muted-foreground">No data available</div>
				}
			>
				<div />
			</ChartContainer>
		);
	}

	return (
		<ResponsiveContainer width="100%" height={height}>
			<LineChart
				data={data}
				margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
			>
				<defs>
					{models.map((model, index) => (
						<linearGradient
							key={model}
							id={`gradient-${model}`}
							x1="0"
							y1="0"
							x2="0"
							y2="1"
						>
							<stop
								offset="0%"
								stopColor={getModelColor(model, index)}
								stopOpacity={0.9}
							/>
							<stop
								offset="100%"
								stopColor={getModelColor(model, index)}
								stopOpacity={0.3}
							/>
						</linearGradient>
					))}
					<filter id="glow">
						<feGaussianBlur stdDeviation="2" result="coloredBlur" />
						<feMerge>
							<feMergeNode in="coloredBlur" />
							<feMergeNode in="SourceGraphic" />
						</feMerge>
					</filter>
				</defs>
				<CartesianGrid
					strokeDasharray={CHART_PROPS.strokeDasharray}
					className={CHART_PROPS.gridClassName}
				/>
				<XAxis
					dataKey="time"
					fontSize={12}
					angle={data.length > 10 ? -45 : 0}
					textAnchor={data.length > 10 ? "end" : "middle"}
					height={data.length > 10 ? 60 : 30}
				/>
				<YAxis
					fontSize={12}
					tickFormatter={(value) => formatAxisValue(value, metric)}
					label={{
						value: getMetricLabel(metric),
						angle: -90,
						position: "insideLeft",
						style: { textAnchor: "middle", fontSize: 12 },
					}}
				/>
				<Tooltip
					contentStyle={getTooltipStyles("dark")}
					formatter={(value: number) => formatValue(value, metric)}
					labelFormatter={(label) =>
						viewMode === "cumulative" ? `Cumulative at ${label}` : label
					}
				/>
				<Legend
					verticalAlign="top"
					height={36}
					wrapperStyle={{ paddingTop: "10px" }}
				/>
				{models.map((model, index) => (
					<Line
						key={model}
						type="monotone"
						dataKey={model}
						name={model}
						stroke={getModelColor(model, index)}
						strokeWidth={viewMode === "cumulative" ? 3 : 2}
						dot={false}
						activeDot={{ r: 6 }}
						filter={viewMode === "cumulative" ? "url(#glow)" : undefined}
						connectNulls={true}
					/>
				))}
			</LineChart>
		</ResponsiveContainer>
	);
}
</file>

<file path="packages/dashboard-web/src/components/conversation/MessageBubble.tsx">
import type { Role } from "@ccflare/types";
import React from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";

interface MessageBubbleProps {
	role: Role;
	content: string;
}

const MAX_CHARS_COLLAPSE = 300;

const ROLE_BG_COLORS: Record<Role, string> = {
	user: "bg-primary text-primary-foreground",
	assistant: "bg-muted",
	system: "bg-orange-100 dark:bg-orange-900",
};

function MessageBubbleComponent({ role, content }: MessageBubbleProps) {
	const { display, isLong, isExpanded, toggle } = useCollapsible(
		content,
		MAX_CHARS_COLLAPSE,
	);
	const bgColor = ROLE_BG_COLORS[role];

	return (
		<div>
			<div className={`rounded-lg px-4 py-2 ${bgColor}`}>
				<div
					className={`whitespace-pre text-sm overflow-x-auto text-left ${
						isExpanded && isLong ? "max-h-96 overflow-y-auto pr-2" : ""
					}`}
				>
					{display}
				</div>
			</div>
			{isLong && (
				<Button
					variant="ghost"
					size="sm"
					className="mt-1 h-6 px-2 text-xs"
					onClick={toggle}
				>
					{isExpanded ? "Show less" : "Show more"}
				</Button>
			)}
		</div>
	);
}

export const MessageBubble = React.memo(MessageBubbleComponent);
</file>

<file path="packages/dashboard-web/src/components/navigation.tsx">
import {
	Activity,
	BarChart3,
	Bot,
	FileText,
	GitBranch,
	LayoutDashboard,
	Menu,
	Shield,
	Users,
	Wrench,
	X,
	Zap,
} from "lucide-react";
import { useState } from "react";
import { Link, useLocation } from "react-router-dom";
import { cn } from "../lib/utils";
import { ThemeToggle } from "./theme-toggle";
import { Button } from "./ui/button";
import { Separator } from "./ui/separator";

interface NavItem {
	label: string;
	icon: React.ComponentType<{ className?: string }>;
	path: string;
	badge?: string;
}

const navItems: NavItem[] = [
	{ label: "Overview", icon: LayoutDashboard, path: "/" },
	{ label: "Analytics", icon: BarChart3, path: "/analytics" },
	{ label: "Requests", icon: Activity, path: "/requests" },
	{ label: "Accounts", icon: Users, path: "/accounts" },
	{ label: "Agents", icon: Bot, path: "/agents" },
	{ label: "Tools", icon: Wrench, path: "/tools" },
	{ label: "Logs", icon: FileText, path: "/logs" },
];

export function Navigation() {
	const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
	const location = useLocation();

	return (
		<>
			{/* Mobile header */}
			<div className="lg:hidden fixed top-0 left-0 right-0 z-50 h-16 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b px-4 flex items-center justify-between">
				<div className="flex items-center gap-3">
					<Shield className="h-6 w-6 text-primary" />
					<span className="font-semibold text-lg">ccflare</span>
				</div>
				<div className="flex items-center gap-2">
					<ThemeToggle />
					<Button
						variant="ghost"
						size="sm"
						onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
					>
						{isMobileMenuOpen ? (
							<X className="h-5 w-5" />
						) : (
							<Menu className="h-5 w-5" />
						)}
					</Button>
				</div>
			</div>

			{/* Mobile menu overlay */}
			{isMobileMenuOpen && (
				<button
					type="button"
					className="lg:hidden fixed inset-0 z-40 bg-background/80 backdrop-blur-sm cursor-default"
					onClick={() => setIsMobileMenuOpen(false)}
					aria-label="Close menu"
				/>
			)}

			{/* Sidebar */}
			<aside
				className={cn(
					"fixed left-0 top-0 z-40 h-screen w-64 bg-card border-r transition-transform duration-300 lg:translate-x-0",
					isMobileMenuOpen
						? "translate-x-0"
						: "-translate-x-full lg:translate-x-0",
				)}
			>
				<div className="flex h-full flex-col">
					{/* Logo */}
					<div className="p-6 pb-4">
						<div className="flex items-center gap-3">
							<div className="flex h-10 w-10 items-center justify-center rounded-lg bg-primary/10">
								<Shield className="h-6 w-6 text-primary" />
							</div>
							<div>
								<h1 className="font-semibold text-lg">ccflare</h1>
								<p className="text-xs text-muted-foreground">
									Powerful proxy for Claude Code
								</p>
							</div>
						</div>
					</div>

					<Separator />

					{/* Navigation */}
					<nav className="flex-1 space-y-1 p-4">
						{navItems.map((item) => {
							const Icon = item.icon;
							const isActive = location.pathname === item.path;
							return (
								<Link
									key={item.path}
									to={item.path}
									onClick={() => setIsMobileMenuOpen(false)}
								>
									<Button
										variant={isActive ? "secondary" : "ghost"}
										className={cn(
											"w-full justify-start gap-3 transition-all",
											isActive &&
												"bg-primary/10 text-primary hover:bg-primary/20",
										)}
									>
										<Icon className="h-4 w-4" />
										{item.label}
										{item.badge && (
											<span className="ml-auto rounded-full bg-primary/20 px-2 py-0.5 text-xs font-medium">
												{item.badge}
											</span>
										)}
									</Button>
								</Link>
							);
						})}
					</nav>

					<Separator />

					{/* Footer */}
					<div className="p-4 space-y-4">
						<div className="rounded-lg bg-muted/50 p-3">
							<div className="flex items-center gap-2 text-sm">
								<Zap className="h-4 w-4 text-primary" />
								<span className="font-medium">Status</span>
							</div>
							<p className="mt-1 text-xs text-muted-foreground">
								All systems operational
							</p>
						</div>

						<div className="hidden lg:flex items-center justify-between">
							<div className="flex items-center gap-2 text-xs text-muted-foreground">
								<GitBranch className="h-3 w-3" />
								<span>v1.0.0</span>
							</div>
							<ThemeToggle />
						</div>
					</div>
				</div>
			</aside>
		</>
	);
}
</file>

<file path="packages/dashboard-web/src/components/ToolsTab.tsx">
import { SystemPromptInterceptorCard } from "./tools/SystemPromptInterceptorCard";

export function ToolsTab() {
	return (
		<div className="container mx-auto p-6">
			<SystemPromptInterceptorCard />
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/constants/index.ts">
// Re-export all shared constants from ui-constants

// Re-export agent constants from types
export { TOOL_PRESETS } from "@ccflare/types";
export {
	API_LIMITS,
	API_TIMEOUT,
	CHART_COLORS,
	CHART_HEIGHTS,
	CHART_PROPS,
	CHART_TOOLTIP_STYLE,
	COLORS,
	QUERY_CONFIG,
	REFRESH_INTERVALS,
	TIME_RANGES,
	type TimeRange,
} from "@ccflare/ui-constants";
</file>

<file path="packages/dashboard-web/src/App.tsx">
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Navigate, Route, Routes, useLocation } from "react-router-dom";
import { AccountsTab } from "./components/AccountsTab";
import { AgentsTab } from "./components/AgentsTab";
import { AnalyticsTab } from "./components/AnalyticsTab";
import { LogsTab } from "./components/LogsTab";
import { Navigation } from "./components/navigation";
import { OverviewTab } from "./components/OverviewTab";
import { RequestsTab } from "./components/RequestsTab";
import { ToolsTab } from "./components/ToolsTab";
import { QUERY_CONFIG, REFRESH_INTERVALS } from "./constants";
import { ThemeProvider } from "./contexts/theme-context";
import "./index.css";

const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			refetchInterval: REFRESH_INTERVALS.default, // Refetch every 30 seconds
			staleTime: QUERY_CONFIG.staleTime, // Consider data stale after 10 seconds
		},
	},
});

const routes = [
	{
		path: "/",
		element: <OverviewTab />,
		title: "Dashboard Overview",
		subtitle: "Monitor your ccflare performance and usage",
	},
	{
		path: "/analytics",
		element: <AnalyticsTab />,
		title: "Analytics",
		subtitle: "Deep dive into your usage patterns and trends",
	},
	{
		path: "/requests",
		element: <RequestsTab />,
		title: "Request History",
		subtitle: "View detailed request and response data",
	},
	{
		path: "/accounts",
		element: <AccountsTab />,
		title: "Account Management",
		subtitle: "Manage your OAuth accounts and settings",
	},
	{
		path: "/agents",
		element: <AgentsTab />,
		title: "Agent Management",
		subtitle: "Discover and manage Claude Code agents",
	},
	{
		path: "/tools",
		element: <ToolsTab />,
		title: "Tools",
		subtitle: "Configure and manage system tools and interceptors",
	},
	{
		path: "/logs",
		element: <LogsTab />,
		title: "System Logs",
		subtitle: "Real-time system logs and debugging information",
	},
];

export function App() {
	const location = useLocation();
	const currentRoute =
		routes.find((route) => route.path === location.pathname) || routes[0];

	return (
		<QueryClientProvider client={queryClient}>
			<ThemeProvider>
				<div className="min-h-screen bg-background">
					<Navigation />

					{/* Main Content */}
					<main className="lg:pl-64">
						{/* Mobile spacer */}
						<div className="h-16 lg:hidden" />

						{/* Page Content */}
						<div className="p-4 md:p-6 lg:p-8 max-w-[1600px] mx-auto">
							{/* Page Header */}
							<div className="mb-8">
								<h1 className="text-3xl font-bold gradient-text">
									{currentRoute.title}
								</h1>
								<p className="text-muted-foreground mt-2">
									{currentRoute.subtitle}
								</p>
							</div>

							{/* Tab Content */}
							<div className="animate-in fade-in-0 duration-200">
								<Routes>
									{routes.map((route) => (
										<Route
											key={route.path}
											path={route.path}
											element={route.element}
										/>
									))}
									<Route path="*" element={<Navigate to="/" replace />} />
								</Routes>
							</div>
						</div>
					</main>
				</div>
			</ThemeProvider>
		</QueryClientProvider>
	);
}
</file>

<file path="packages/dashboard-web/package.json">
{
	"name": "@ccflare/dashboard-web",
	"version": "1.0.0",
	"private": true,
	"type": "module",
	"scripts": {
		"dev": "bun --hot src/index.tsx",
		"build": "bun run build.ts",
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/errors": "workspace:*",
		"@ccflare/ui-common": "workspace:*",
		"@ccflare/ui-constants": "workspace:*",
		"@radix-ui/react-dialog": "^1.1.14",
		"@radix-ui/react-dropdown-menu": "^2.1.15",
		"@radix-ui/react-label": "^2.1.0",
		"@radix-ui/react-popover": "^1.1.14",
		"@radix-ui/react-progress": "^1.1.7",
		"@radix-ui/react-select": "^2.1.2",
		"@radix-ui/react-separator": "^1.1.7",
		"@radix-ui/react-slot": "^1.1.0",
		"@radix-ui/react-switch": "^1.2.5",
		"@radix-ui/react-tabs": "^1.1.1",
		"@radix-ui/react-tooltip": "^1.2.7",
		"@tanstack/react-query": "^5.83.0",
		"@types/react-router-dom": "^5.3.3",
		"bun-plugin-tailwind": "^0.0.15",
		"class-variance-authority": "^0.7.1",
		"clsx": "^2.1.1",
		"cmdk": "^1.1.1",
		"date-fns": "^4.1.0",
		"framer-motion": "^12.23.9",
		"lucide-react": "^0.525.0",
		"react": "^19.0.0",
		"react-dom": "^19.0.0",
		"react-router-dom": "^7.8.1",
		"recharts": "^3.1.0",
		"tailwind-merge": "^2.6.0",
		"tailwindcss": "^4.0.0",
		"tailwindcss-animate": "^1.0.7"
	},
	"devDependencies": {
		"@types/react": "^19.0.0",
		"@types/react-dom": "^19.0.0",
		"@types/bun": "latest"
	}
}
</file>

<file path="packages/database/src/migrations.ts">
import type { Database } from "bun:sqlite";
import { Logger } from "@ccflare/logger";
import { addPerformanceIndexes } from "./performance-indexes";

const log = new Logger("DatabaseMigrations");

export function ensureSchema(db: Database): void {
	// Create accounts table
	db.run(`
		CREATE TABLE IF NOT EXISTS accounts (
			id TEXT PRIMARY KEY,
			name TEXT NOT NULL,
			provider TEXT DEFAULT 'anthropic',
			api_key TEXT,
			refresh_token TEXT NOT NULL,
			access_token TEXT,
			expires_at INTEGER,
			created_at INTEGER NOT NULL,
			last_used INTEGER,
			request_count INTEGER DEFAULT 0,
			total_requests INTEGER DEFAULT 0,
			account_tier INTEGER DEFAULT 1
		)
	`);

	// Create requests table
	db.run(`
		CREATE TABLE IF NOT EXISTS requests (
			id TEXT PRIMARY KEY,
			timestamp INTEGER NOT NULL,
			method TEXT NOT NULL,
			path TEXT NOT NULL,
			account_used TEXT,
			status_code INTEGER,
			success BOOLEAN,
			error_message TEXT,
			response_time_ms INTEGER,
			failover_attempts INTEGER DEFAULT 0,
			model TEXT,
			prompt_tokens INTEGER DEFAULT 0,
			completion_tokens INTEGER DEFAULT 0,
			total_tokens INTEGER DEFAULT 0,
			cost_usd REAL DEFAULT 0,
			output_tokens_per_second REAL,
			input_tokens INTEGER DEFAULT 0,
			cache_read_input_tokens INTEGER DEFAULT 0,
			cache_creation_input_tokens INTEGER DEFAULT 0,
			output_tokens INTEGER DEFAULT 0,
			agent_used TEXT
		)
	`);

	// Create index for faster queries
	db.run(
		`CREATE INDEX IF NOT EXISTS idx_requests_timestamp ON requests(timestamp DESC)`,
	);

	// Create request_payloads table for storing full request/response data
	db.run(`
		CREATE TABLE IF NOT EXISTS request_payloads (
			id TEXT PRIMARY KEY,
			json TEXT NOT NULL,
			FOREIGN KEY (id) REFERENCES requests(id) ON DELETE CASCADE
		)
	`);

	// Create oauth_sessions table for secure PKCE verifier storage
	db.run(`
		CREATE TABLE IF NOT EXISTS oauth_sessions (
			id TEXT PRIMARY KEY,
			account_name TEXT NOT NULL,
			verifier TEXT NOT NULL,
			mode TEXT NOT NULL,
			tier INTEGER DEFAULT 1,
			created_at INTEGER NOT NULL,
			expires_at INTEGER NOT NULL
		)
	`);

	// Create index for faster cleanup of expired sessions
	db.run(
		`CREATE INDEX IF NOT EXISTS idx_oauth_sessions_expires ON oauth_sessions(expires_at)`,
	);

	// Create agent_preferences table for storing user-defined agent settings
	db.run(`
		CREATE TABLE IF NOT EXISTS agent_preferences (
			agent_id TEXT PRIMARY KEY,
			model TEXT NOT NULL,
			updated_at INTEGER NOT NULL
		)
	`);

	// Create interceptors table for storing tool configurations
	db.run(`
		CREATE TABLE IF NOT EXISTS interceptors (
			id TEXT PRIMARY KEY,
			is_enabled INTEGER NOT NULL DEFAULT 0,
			config TEXT NOT NULL
		)
	`);

	// Create system_kv_store table for storing system-wide key-value pairs
	db.run(`
		CREATE TABLE IF NOT EXISTS system_kv_store (
			key TEXT PRIMARY KEY,
			value TEXT
		)
	`);
}

export function runMigrations(db: Database): void {
	// Ensure base schema exists first
	ensureSchema(db);
	// Check if columns exist before adding them
	const accountsInfo = db
		.prepare("PRAGMA table_info(accounts)")
		.all() as Array<{
		cid: number;
		name: string;
		type: string;
		notnull: number;
		// biome-ignore lint/suspicious/noExplicitAny: SQLite pragma can return various default value types
		dflt_value: any;
		pk: number;
	}>;

	const accountsColumnNames = accountsInfo.map((col) => col.name);

	// Add rate_limited_until column if it doesn't exist
	if (!accountsColumnNames.includes("rate_limited_until")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN rate_limited_until INTEGER",
		).run();
		log.info("Added rate_limited_until column to accounts table");
	}

	// Add session_start column if it doesn't exist
	if (!accountsColumnNames.includes("session_start")) {
		db.prepare("ALTER TABLE accounts ADD COLUMN session_start INTEGER").run();
		log.info("Added session_start column to accounts table");
	}

	// Add session_request_count column if it doesn't exist
	if (!accountsColumnNames.includes("session_request_count")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN session_request_count INTEGER DEFAULT 0",
		).run();
		log.info("Added session_request_count column to accounts table");
	}

	// Add account_tier column if it doesn't exist
	if (!accountsColumnNames.includes("account_tier")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN account_tier INTEGER DEFAULT 1",
		).run();
		log.info("Added account_tier column to accounts table");
	}

	// Add paused column if it doesn't exist
	if (!accountsColumnNames.includes("paused")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN paused INTEGER DEFAULT 0",
		).run();
		log.info("Added paused column to accounts table");
	}

	// Add rate_limit_reset column if it doesn't exist
	if (!accountsColumnNames.includes("rate_limit_reset")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN rate_limit_reset INTEGER",
		).run();
		log.info("Added rate_limit_reset column to accounts table");
	}

	// Add rate_limit_status column if it doesn't exist
	if (!accountsColumnNames.includes("rate_limit_status")) {
		db.prepare("ALTER TABLE accounts ADD COLUMN rate_limit_status TEXT").run();
		log.info("Added rate_limit_status column to accounts table");
	}

	// Add rate_limit_remaining column if it doesn't exist
	if (!accountsColumnNames.includes("rate_limit_remaining")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN rate_limit_remaining INTEGER",
		).run();
		log.info("Added rate_limit_remaining column to accounts table");
	}

	// Check columns in requests table
	const requestsInfo = db
		.prepare("PRAGMA table_info(requests)")
		.all() as Array<{
		cid: number;
		name: string;
		type: string;
		notnull: number;
		// biome-ignore lint/suspicious/noExplicitAny: SQLite pragma can return various default value types
		dflt_value: any;
		pk: number;
	}>;

	const requestsColumnNames = requestsInfo.map((col) => col.name);

	// Add model column if it doesn't exist
	if (!requestsColumnNames.includes("model")) {
		db.prepare("ALTER TABLE requests ADD COLUMN model TEXT").run();
		log.info("Added model column to requests table");
	}

	// Add prompt_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("prompt_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN prompt_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added prompt_tokens column to requests table");
	}

	// Add completion_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("completion_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN completion_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added completion_tokens column to requests table");
	}

	// Add total_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("total_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN total_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added total_tokens column to requests table");
	}

	// Add cost_usd column if it doesn't exist
	if (!requestsColumnNames.includes("cost_usd")) {
		db.prepare("ALTER TABLE requests ADD COLUMN cost_usd REAL DEFAULT 0").run();
		log.info("Added cost_usd column to requests table");
	}

	// Add input_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("input_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN input_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added input_tokens column to requests table");
	}

	// Add cache_read_input_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("cache_read_input_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN cache_read_input_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added cache_read_input_tokens column to requests table");
	}

	// Add cache_creation_input_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("cache_creation_input_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN cache_creation_input_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added cache_creation_input_tokens column to requests table");
	}

	// Add output_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("output_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN output_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added output_tokens column to requests table");
	}

	// Add agent_used column if it doesn't exist
	if (!requestsColumnNames.includes("agent_used")) {
		db.prepare("ALTER TABLE requests ADD COLUMN agent_used TEXT").run();
		log.info("Added agent_used column to requests table");
	}

	// Add output_tokens_per_second column if it doesn't exist
	if (!requestsColumnNames.includes("output_tokens_per_second")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN output_tokens_per_second REAL",
		).run();
		log.info("Added output_tokens_per_second column to requests table");
	}

	// Add performance indexes
	addPerformanceIndexes(db);
}
</file>

<file path="packages/http-api/src/handlers/accounts.ts">
import type { Database } from "bun:sqlite";
import * as cliCommands from "@ccflare/cli-commands";
import type { Config } from "@ccflare/config";
import {
	patterns,
	sanitizers,
	validateNumber,
	validateString,
} from "@ccflare/core";
import type { DatabaseOperations } from "@ccflare/database";
import {
	BadRequest,
	errorResponse,
	InternalServerError,
	jsonResponse,
	NotFound,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import type { AccountResponse } from "../types";

const log = new Logger("AccountsHandler");

/**
 * Create an accounts list handler
 */
export function createAccountsListHandler(db: Database) {
	return (): Response => {
		const now = Date.now();
		const sessionDuration = 5 * 60 * 60 * 1000; // 5 hours

		const accounts = db
			.query(
				`
				SELECT 
					id,
					name,
					provider,
					request_count,
					total_requests,
					last_used,
					created_at,
					expires_at,
					rate_limited_until,
					rate_limit_reset,
					rate_limit_status,
					rate_limit_remaining,
					session_start,
					session_request_count,
					COALESCE(account_tier, 1) as account_tier,
					COALESCE(paused, 0) as paused,
					CASE 
						WHEN expires_at > ?1 THEN 1 
						ELSE 0 
					END as token_valid,
					CASE 
						WHEN rate_limited_until > ?2 THEN 1
						ELSE 0
					END as rate_limited,
					CASE
						WHEN session_start IS NOT NULL AND ?3 - session_start < ?4 THEN
							'Active: ' || session_request_count || ' reqs'
						ELSE '-'
					END as session_info
				FROM accounts
				ORDER BY request_count DESC
			`,
			)
			.all(now, now, now, sessionDuration) as Array<{
			id: string;
			name: string;
			provider: string | null;
			request_count: number;
			total_requests: number;
			last_used: number | null;
			created_at: number;
			expires_at: number | null;
			rate_limited_until: number | null;
			rate_limit_reset: number | null;
			rate_limit_status: string | null;
			rate_limit_remaining: number | null;
			session_start: number | null;
			session_request_count: number;
			account_tier: number;
			paused: 0 | 1;
			token_valid: 0 | 1;
			rate_limited: 0 | 1;
			session_info: string | null;
		}>;

		const response: AccountResponse[] = accounts.map((account) => {
			let rateLimitStatus = "OK";

			// Use unified rate limit status if available
			if (account.rate_limit_status) {
				rateLimitStatus = account.rate_limit_status;
				if (account.rate_limit_reset && account.rate_limit_reset > now) {
					const minutesLeft = Math.ceil(
						(account.rate_limit_reset - now) / 60000,
					);
					rateLimitStatus = `${account.rate_limit_status} (${minutesLeft}m)`;
				}
			} else if (
				account.rate_limited &&
				account.rate_limited_until &&
				account.rate_limited_until > now
			) {
				// Fall back to legacy rate limit check
				const minutesLeft = Math.ceil(
					(account.rate_limited_until - now) / 60000,
				);
				rateLimitStatus = `Rate limited (${minutesLeft}m)`;
			}

			return {
				id: account.id,
				name: account.name,
				provider: account.provider || "anthropic",
				requestCount: account.request_count,
				totalRequests: account.total_requests,
				lastUsed: account.last_used
					? new Date(account.last_used).toISOString()
					: null,
				created: new Date(account.created_at).toISOString(),
				tier: account.account_tier,
				paused: account.paused === 1,
				tokenStatus: account.token_valid ? "valid" : "expired",
				tokenExpiresAt: account.expires_at
					? new Date(account.expires_at).toISOString()
					: null,
				rateLimitStatus,
				rateLimitReset: account.rate_limit_reset
					? new Date(account.rate_limit_reset).toISOString()
					: null,
				rateLimitRemaining: account.rate_limit_remaining,
				sessionInfo: account.session_info || "",
			};
		});

		return jsonResponse(response);
	};
}

/**
 * Create an account tier update handler
 */
export function createAccountTierUpdateHandler(dbOps: DatabaseOperations) {
	return async (req: Request, accountId: string): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate tier input
			const tier = validateNumber(body.tier, "tier", {
				required: true,
				allowedValues: [1, 5, 20] as const,
			});

			if (tier === undefined) {
				return errorResponse(BadRequest("Tier is required"));
			}

			dbOps.updateAccountTier(accountId, tier);

			return jsonResponse({ success: true, tier });
		} catch (_error) {
			return errorResponse(
				InternalServerError("Failed to update account tier"),
			);
		}
	};
}

/**
 * Create an account add handler (manual token addition)
 * This is primarily used for adding accounts with existing tokens
 * For OAuth flow, use the OAuth handlers
 */
export function createAccountAddHandler(
	dbOps: DatabaseOperations,
	_config: Config,
) {
	return async (req: Request): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate account name
			const name = validateString(body.name, "name", {
				required: true,
				minLength: 1,
				maxLength: 100,
				pattern: patterns.accountName,
				transform: sanitizers.trim,
			});

			if (!name) {
				return errorResponse(BadRequest("Account name is required"));
			}

			// Validate tokens
			const accessToken = validateString(body.accessToken, "accessToken", {
				required: true,
				minLength: 1,
			});

			const refreshToken = validateString(body.refreshToken, "refreshToken", {
				required: true,
				minLength: 1,
			});

			if (!accessToken || !refreshToken) {
				return errorResponse(
					BadRequest("Access token and refresh token are required"),
				);
			}

			// Validate provider
			const provider =
				validateString(body.provider, "provider", {
					allowedValues: ["anthropic"] as const,
				}) || "anthropic";

			// Validate tier
			const tier = (validateNumber(body.tier, "tier", {
				allowedValues: [1, 5, 20] as const,
			}) || 1) as 1 | 5 | 20;

			try {
				// Add account directly to database
				const accountId = crypto.randomUUID();
				const now = Date.now();

				dbOps.getDatabase().run(
					`INSERT INTO accounts (
						id, name, provider, refresh_token, access_token,
						created_at, request_count, total_requests, account_tier
					) VALUES (?, ?, ?, ?, ?, ?, 0, 0, ?)`,
					[accountId, name, provider, refreshToken, accessToken, now, tier],
				);

				return jsonResponse({
					success: true,
					message: `Account ${name} added successfully`,
					tier,
					accountId,
				});
			} catch (error) {
				if (
					error instanceof Error &&
					error.message.includes("already exists")
				) {
					return errorResponse(BadRequest(error.message));
				}
				return errorResponse(InternalServerError((error as Error).message));
			}
		} catch (error) {
			log.error("Account add error:", error);
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to add account"),
			);
		}
	};
}

/**
 * Create an account remove handler
 */
export function createAccountRemoveHandler(dbOps: DatabaseOperations) {
	return async (req: Request, accountName: string): Promise<Response> => {
		try {
			// Parse and validate confirmation
			const body = await req.json();

			// Validate confirmation string
			const confirm = validateString(body.confirm, "confirm", {
				required: true,
			});

			if (confirm !== accountName) {
				return errorResponse(
					BadRequest("Confirmation string does not match account name", {
						confirmationRequired: true,
					}),
				);
			}

			const result = cliCommands.removeAccount(dbOps, accountName);

			if (!result.success) {
				return errorResponse(NotFound(result.message));
			}

			return jsonResponse({
				success: true,
				message: result.message,
			});
		} catch (error) {
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to remove account"),
			);
		}
	};
}

/**
 * Create an account pause handler
 */
export function createAccountPauseHandler(dbOps: DatabaseOperations) {
	return async (_req: Request, accountId: string): Promise<Response> => {
		try {
			// Get account name by ID
			const db = dbOps.getDatabase();
			const account = db
				.query<{ name: string }, [string]>(
					"SELECT name FROM accounts WHERE id = ?",
				)
				.get(accountId);

			if (!account) {
				return errorResponse(NotFound("Account not found"));
			}

			const result = cliCommands.pauseAccount(dbOps, account.name);

			if (!result.success) {
				return errorResponse(BadRequest(result.message));
			}

			return jsonResponse({
				success: true,
				message: result.message,
			});
		} catch (error) {
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to pause account"),
			);
		}
	};
}

/**
 * Create an account resume handler
 */
export function createAccountResumeHandler(dbOps: DatabaseOperations) {
	return async (_req: Request, accountId: string): Promise<Response> => {
		try {
			// Get account name by ID
			const db = dbOps.getDatabase();
			const account = db
				.query<{ name: string }, [string]>(
					"SELECT name FROM accounts WHERE id = ?",
				)
				.get(accountId);

			if (!account) {
				return errorResponse(NotFound("Account not found"));
			}

			const result = cliCommands.resumeAccount(dbOps, account.name);

			if (!result.success) {
				return errorResponse(BadRequest(result.message));
			}

			return jsonResponse({
				success: true,
				message: result.message,
			});
		} catch (error) {
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to resume account"),
			);
		}
	};
}

/**
 * Create an account rename handler
 */
export function createAccountRenameHandler(dbOps: DatabaseOperations) {
	return async (req: Request, accountId: string): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate new name
			const newName = validateString(body.name, "name", {
				required: true,
				minLength: 1,
				maxLength: 100,
				pattern: patterns.accountName,
				transform: sanitizers.trim,
			});

			if (!newName) {
				return errorResponse(BadRequest("New account name is required"));
			}

			// Check if account exists
			const db = dbOps.getDatabase();
			const account = db
				.query<{ name: string }, [string]>(
					"SELECT name FROM accounts WHERE id = ?",
				)
				.get(accountId);

			if (!account) {
				return errorResponse(NotFound("Account not found"));
			}

			// Check if new name is already taken
			const existingAccount = db
				.query<{ id: string }, [string, string]>(
					"SELECT id FROM accounts WHERE name = ? AND id != ?",
				)
				.get(newName, accountId);

			if (existingAccount) {
				return errorResponse(
					BadRequest(`Account name '${newName}' is already taken`),
				);
			}

			// Rename the account
			dbOps.renameAccount(accountId, newName);

			return jsonResponse({
				success: true,
				message: `Account renamed from '${account.name}' to '${newName}'`,
				newName,
			});
		} catch (error) {
			log.error("Account rename error:", error);
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to rename account"),
			);
		}
	};
}
</file>

<file path="packages/http-api/src/handlers/requests-stream.ts">
import { type RequestEvt, requestEvents } from "@ccflare/core";

export function createRequestsStreamHandler() {
	return (): Response => {
		// Store the write handler outside to access it in cancel
		let writeHandler: ((data: RequestEvt) => void) | null = null;

		const stream = new ReadableStream({
			start(controller) {
				const encoder = new TextEncoder();

				// Helper to send SSE formatted data
				writeHandler = (data: RequestEvt) => {
					const message = `data: ${JSON.stringify(data)}\n\n`;
					controller.enqueue(encoder.encode(message));
				};

				// Send initial connection message
				const connectMsg = `event: connected\ndata: ok\n\n`;
				controller.enqueue(encoder.encode(connectMsg));

				// Listen for events
				requestEvents.on("event", writeHandler);
			},
			cancel() {
				// Cleanup only this specific listener
				if (writeHandler) {
					requestEvents.off("event", writeHandler);
					writeHandler = null;
				}
			},
		});

		return new Response(stream, {
			headers: {
				"Content-Type": "text/event-stream",
				Connection: "keep-alive",
				"Cache-Control": "no-cache",
			},
		});
	};
}
</file>

<file path="packages/http-common/src/headers.ts">
/**
 * Sanitizes proxy headers by removing hop-by-hop headers that should not be forwarded
 * after Bun has automatically decompressed the response body.
 *
 * Removes: content-encoding, content-length, transfer-encoding
 */
export function sanitizeProxyHeaders(original: Headers): Headers {
	const sanitized = new Headers(original);

	// Remove headers that are invalidated by automatic decompression
	sanitized.delete("content-encoding");
	sanitized.delete("content-length");
	sanitized.delete("transfer-encoding");

	return sanitized;
}

/**
 * Removes hop-by-hop + compression negotiation headers from the ORIGINAL
 * client request before it is persisted for analytics. Does **not** add /
 * remove auth headers.
 *
 * Removes: accept-encoding, content-encoding, transfer-encoding, content-length
 */
export function sanitizeRequestHeaders(original: Headers): Headers {
	const h = new Headers(original);
	h.delete("accept-encoding");
	h.delete("content-encoding");
	h.delete("content-length");
	h.delete("transfer-encoding");
	return h;
}

/**
 * Return a new Response with hop-by-hop / compression headers stripped.
 * Body & status are preserved.
 */
export function withSanitizedProxyHeaders(res: Response): Response {
	return new Response(res.body, {
		status: res.status,
		statusText: res.statusText,
		headers: sanitizeProxyHeaders(res.headers),
	});
}
</file>

<file path="packages/oauth-flow/src/index.ts">
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import {
	generatePKCE,
	getOAuthProvider,
	type OAuthProviderConfig,
	type OAuthTokens,
	type PKCEChallenge,
} from "@ccflare/providers";
import type { AccountTier } from "@ccflare/types";

export interface BeginOptions {
	name: string;
	mode: "max" | "console";
}

export interface BeginResult {
	sessionId: string;
	authUrl: string;
	pkce: PKCEChallenge;
	oauthConfig: OAuthProviderConfig;
	mode: "max" | "console"; // Track mode to handle differently in complete()
}

export interface CompleteOptions {
	sessionId: string;
	code: string;
	tier?: AccountTier;
	name: string; // Required to properly create the account
}

export interface AccountCreated {
	id: string;
	name: string;
	tier: number;
	provider: "anthropic";
	authType: "oauth" | "api_key"; // Track authentication type
}

export interface OAuthFlowResult {
	success: boolean;
	message: string;
	data?: AccountCreated;
}

/**
 * Handles the Anthropic OAuth flow for both "max" and "console" authentication modes.
 *
 * - "max" mode: Standard OAuth with refresh tokens for Claude Max accounts
 * - "console" mode: OAuth flow that creates a static API key
 *
 * This class does not persist session data. The caller must handle storage
 * between {@link begin} and {@link complete} calls.
 */
export class OAuthFlow {
	constructor(
		private dbOps: DatabaseOperations,
		private config: Config,
	) {}

	/**
	 * Starts an Anthropic OAuth flow.
	 *
	 * The caller MUST persist the returned `sessionId`, `pkce.verifier`,
	 * `mode`, and `tier` so that {@link complete} can validate the callback.
	 *
	 * @param opts - OAuth flow options
	 * @param opts.name - Unique account name
	 * @param opts.mode - Authentication mode ("max" for Claude Max, "console" for API key)
	 * @returns OAuth flow data including auth URL and session info
	 * @throws {Error} If account name already exists
	 */
	async begin(opts: BeginOptions): Promise<BeginResult> {
		const { name, mode } = opts;

		// Check if account already exists
		const existingAccounts = this.dbOps.getAllAccounts();
		if (existingAccounts.some((a) => a.name === name)) {
			throw new Error(`Account with name '${name}' already exists`);
		}

		// Get OAuth provider
		const oauthProvider = getOAuthProvider("anthropic");
		if (!oauthProvider) {
			throw new Error("Anthropic OAuth provider not found");
		}

		// Generate PKCE challenge
		const pkce = await generatePKCE();

		// Get OAuth config with runtime client ID
		const runtime = this.config.getRuntime();
		const oauthConfig = oauthProvider.getOAuthConfig(mode);
		oauthConfig.clientId = runtime.clientId;

		// Generate auth URL
		const authUrl = oauthProvider.generateAuthUrl(oauthConfig, pkce);

		// Create session ID for this OAuth flow
		const sessionId = crypto.randomUUID();

		// NOTE: OAuthFlow itself does not persist the session.
		//       The caller (HTTP-API oauth-init handler) must
		//       store {sessionId, verifier, mode, tier} – typically
		//       via DatabaseOperations.createOAuthSession().

		return {
			sessionId,
			authUrl,
			pkce,
			oauthConfig,
			mode,
		};
	}

	/**
	 * Completes the Anthropic OAuth flow after user authorization.
	 *
	 * Exchanges the authorization code for tokens and creates the account.
	 * For "console" mode, creates an API key instead of storing OAuth tokens.
	 *
	 * @param opts - Completion options
	 * @param opts.sessionId - Session ID from {@link begin}
	 * @param opts.code - Authorization code from OAuth callback
	 * @param opts.tier - Account tier (1, 5, or 20)
	 * @param opts.name - Account name (must match the one from begin)
	 * @param flowData - Flow data returned from {@link begin}
	 * @returns Created account information
	 * @throws {Error} If OAuth provider not found or token exchange fails
	 */
	async complete(
		opts: CompleteOptions,
		flowData: BeginResult,
	): Promise<AccountCreated> {
		const { code, tier = 1, name } = opts;

		// Get OAuth provider
		const oauthProvider = getOAuthProvider("anthropic");
		if (!oauthProvider) {
			throw new Error("Anthropic OAuth provider not found");
		}

		// Exchange authorization code for tokens
		const tokens = await oauthProvider.exchangeCode(
			code,
			flowData.pkce.verifier,
			flowData.oauthConfig,
		);

		const accountId = crypto.randomUUID();

		// Handle console mode - create API key
		if (flowData.mode === "console" || !tokens.refreshToken) {
			const apiKey = await this.createAnthropicApiKey(tokens.accessToken);
			return this.createAccountWithApiKey(accountId, name, apiKey, tier);
		}

		// Handle max mode - standard OAuth flow
		return this.createAccountWithOAuth(accountId, name, tokens, tier);
	}

	/**
	 * Creates an API key using the Anthropic console endpoint.
	 *
	 * This is used for "console" mode accounts where users want a static API key
	 * instead of OAuth tokens that need refreshing.
	 *
	 * @param accessToken - Temporary access token from OAuth flow
	 * @returns The newly created API key
	 * @throws {Error} If API key creation fails
	 */
	private async createAnthropicApiKey(accessToken: string): Promise<string> {
		const response = await fetch(
			"https://api.anthropic.com/api/oauth/claude_cli/create_api_key",
			{
				method: "POST",
				headers: {
					Authorization: `Bearer ${accessToken}`,
					"Content-Type": "application/x-www-form-urlencoded",
					Accept: "application/json, text/plain, */*",
				},
			},
		);

		if (!response.ok) {
			throw new Error(`Failed to create API key: ${response.statusText}`);
		}

		const json = (await response.json()) as { raw_key: string };
		return json.raw_key;
	}

	/**
	 * Creates an account with OAuth tokens (max mode).
	 *
	 * Stores refresh token, access token, and expiration for automatic token refresh.
	 *
	 * @param id - Unique account ID
	 * @param name - Account name
	 * @param tokens - OAuth tokens from token exchange
	 * @param tier - Account tier (1, 5, or 20)
	 * @returns Created account information
	 */
	private createAccountWithOAuth(
		id: string,
		name: string,
		tokens: OAuthTokens,
		tier: AccountTier,
	): AccountCreated {
		const db = this.dbOps.getDatabase();

		db.run(
			`
			INSERT INTO accounts (
				id, name, provider, api_key, refresh_token, access_token, expires_at, 
				created_at, request_count, total_requests, account_tier
			) VALUES (?, ?, ?, NULL, ?, ?, ?, ?, 0, 0, ?)
			`,
			[
				id,
				name,
				"anthropic",
				tokens.refreshToken || "",
				tokens.accessToken,
				tokens.expiresAt,
				Date.now(),
				tier,
			],
		);

		return {
			id,
			name,
			tier,
			provider: "anthropic",
			authType: "oauth",
		};
	}

	/**
	 * Creates an account with API key (console mode).
	 *
	 * Stores only the API key, no OAuth tokens. These accounts don't require
	 * token refresh but cannot be refreshed if the API key is revoked.
	 *
	 * @param id - Unique account ID
	 * @param name - Account name
	 * @param apiKey - API key from Anthropic console
	 * @param tier - Account tier (1, 5, or 20)
	 * @returns Created account information
	 */
	private createAccountWithApiKey(
		id: string,
		name: string,
		apiKey: string,
		tier: AccountTier,
	): AccountCreated {
		const db = this.dbOps.getDatabase();

		db.run(
			`
			INSERT INTO accounts (
				id, name, provider, api_key, refresh_token, access_token, expires_at, 
				created_at, request_count, total_requests, account_tier
			) VALUES (?, ?, ?, ?, NULL, NULL, NULL, ?, 0, 0, ?)
			`,
			[id, name, "anthropic", apiKey, Date.now(), tier],
		);

		return {
			id,
			name,
			tier,
			provider: "anthropic",
			authType: "api_key",
		};
	}
}

// Helper function for simpler usage
export async function createOAuthFlow(
	dbOps: DatabaseOperations,
	config: Config,
): Promise<OAuthFlow> {
	return new OAuthFlow(dbOps, config);
}
</file>

<file path="packages/providers/src/providers/anthropic/provider.ts">
import { BUFFER_SIZES } from "@ccflare/core";
import { sanitizeProxyHeaders } from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import type { Account } from "@ccflare/types";
import { BaseProvider } from "../../base";
import type { RateLimitInfo, TokenRefreshResult } from "../../types";

// Hard rate limit statuses that should block account usage
const HARD_LIMIT_STATUSES = new Set([
	"rate_limited",
	"blocked",
	"queueing_hard",
	"payment_required",
]);

// Soft warning statuses that should not block account usage
const _SOFT_WARNING_STATUSES = new Set(["allowed_warning", "queueing_soft"]);

const log = new Logger("AnthropicProvider");

export class AnthropicProvider extends BaseProvider {
	name = "anthropic";

	canHandle(_path: string): boolean {
		// Handle all paths for now since this is Anthropic-specific
		return true;
	}

	async refreshToken(
		account: Account,
		clientId: string,
	): Promise<TokenRefreshResult> {
		if (!account.refresh_token) {
			throw new Error(`No refresh token available for account ${account.name}`);
		}

		log.info(
			`Refreshing token for account ${account.name} with client ID: ${clientId}`,
		);

		const response = await fetch(
			"https://console.anthropic.com/v1/oauth/token",
			{
				method: "POST",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					grant_type: "refresh_token",
					refresh_token: account.refresh_token,
					client_id: clientId,
				}),
			},
		);

		if (!response.ok) {
			let errorMessage = response.statusText;
			let errorData: unknown = null;
			try {
				errorData = await response.json();
				const errorObj = errorData as { error?: string; message?: string };
				errorMessage = errorObj.error || errorObj.message || errorMessage;
			} catch {
				// If we can't parse the error response, use the status text
			}
			log.error(
				`Token refresh failed for ${account.name}: Status ${response.status}, Error: ${errorMessage}`,
				errorData,
			);
			throw new Error(
				`Failed to refresh token for account ${account.name}: ${errorMessage}`,
			);
		}

		const json = (await response.json()) as {
			access_token: string;
			expires_in: number;
			refresh_token?: string;
		};

		// Ensure we always return a refresh token
		const refreshToken = json.refresh_token || account.refresh_token;

		if (!json.refresh_token) {
			log.warn(
				`Anthropic refresh endpoint did not return a refresh_token for ${account.name} - continuing with previous one`,
			);
		} else {
			log.info(
				`Token refresh successful for ${account.name}, new refresh token provided`,
			);
		}

		return {
			accessToken: json.access_token,
			expiresAt: Date.now() + json.expires_in * 1000,
			refreshToken: refreshToken,
		};
	}

	buildUrl(path: string, query: string): string {
		return `https://api.anthropic.com${path}${query}`;
	}

	prepareHeaders(
		headers: Headers,
		accessToken?: string,
		apiKey?: string,
	): Headers {
		const newHeaders = new Headers(headers);

		// Set authentication header
		if (accessToken) {
			newHeaders.set("Authorization", `Bearer ${accessToken}`);
		} else if (apiKey) {
			newHeaders.set("x-api-key", apiKey);
		}

		// Remove host header
		newHeaders.delete("host");

		// Remove compression headers to avoid decompression issues
		newHeaders.delete("accept-encoding");
		newHeaders.delete("content-encoding");

		return newHeaders;
	}

	parseRateLimit(response: Response): RateLimitInfo {
		// Check for unified rate limit headers
		const statusHeader = response.headers.get(
			"anthropic-ratelimit-unified-status",
		);
		const resetHeader = response.headers.get(
			"anthropic-ratelimit-unified-reset",
		);
		const remainingHeader = response.headers.get(
			"anthropic-ratelimit-unified-remaining",
		);

		if (statusHeader || resetHeader) {
			const resetTime = resetHeader ? Number(resetHeader) * 1000 : undefined; // Convert to ms
			const remaining = remainingHeader ? Number(remainingHeader) : undefined;

			// Only mark as rate limited for hard limit statuses or 429
			const isRateLimited =
				HARD_LIMIT_STATUSES.has(statusHeader || "") || response.status === 429;

			return {
				isRateLimited,
				resetTime,
				statusHeader: statusHeader || undefined,
				remaining,
			};
		}

		// Fall back to 429 status with x-ratelimit-reset header
		if (response.status !== 429) {
			return { isRateLimited: false };
		}

		const rateLimitReset = response.headers.get("x-ratelimit-reset");
		const resetTime = rateLimitReset
			? parseInt(rateLimitReset) * 1000
			: Date.now() + 60000; // Default to 1 minute

		return {
			isRateLimited: true,
			resetTime,
		};
	}

	async processResponse(
		response: Response,
		_account: Account | null,
	): Promise<Response> {
		// Sanitize headers by removing hop-by-hop headers
		const headers = sanitizeProxyHeaders(response.headers);

		return new Response(response.body, {
			status: response.status,
			statusText: response.statusText,
			headers,
		});
	}

	async extractTierInfo(response: Response): Promise<number | null> {
		try {
			const clone = response.clone();
			const json = (await clone.json()) as {
				type?: string;
				usage?: {
					rate_limit_tokens?: number;
				};
			};

			// Check for tier information in response
			if (json.type === "message" && json.usage?.rate_limit_tokens) {
				const rateLimit = json.usage.rate_limit_tokens;
				if (rateLimit >= 800000) return 20;
				if (rateLimit >= 200000) return 5;
				return 1;
			}
		} catch {
			// Ignore JSON parsing errors
		}

		return null;
	}

	async extractUsageInfo(response: Response): Promise<{
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
	} | null> {
		try {
			const clone = response.clone();
			const contentType = response.headers.get("content-type");

			// Handle streaming responses (SSE)
			if (contentType?.includes("text/event-stream")) {
				// Use bounded reader to avoid consuming entire stream
				const reader = clone.body?.getReader();
				if (!reader) return null;

				let buffered = "";
				const maxBytes = BUFFER_SIZES.ANTHROPIC_STREAM_CAP_BYTES;
				const decoder = new TextDecoder();
				let foundMessageStart = false;

				try {
					while (buffered.length < maxBytes) {
						const { value, done } = await reader.read();
						if (done) break;

						buffered += decoder.decode(value, { stream: true });

						// Check if we have the message_start event
						if (buffered.includes("event: message_start")) {
							foundMessageStart = true;
							// Read a bit more to ensure we get the data line
							const { value: nextValue, done: nextDone } = await reader.read();
							if (!nextDone && nextValue) {
								buffered += decoder.decode(nextValue, { stream: true });
							}
							break;
						}
					}
				} finally {
					// Cancel the reader to prevent hanging
					reader.cancel().catch(() => {});
				}

				if (!foundMessageStart) return null;

				// Parse the buffered content
				const lines = buffered.split("\n");

				// Parse SSE events
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i];
					if (line.startsWith("event: message_start")) {
						// Next line should be the data
						const dataLine = lines[i + 1];
						if (dataLine?.startsWith("data: ")) {
							try {
								const jsonStr = dataLine.slice(6); // Remove "data: " prefix
								const data = JSON.parse(jsonStr) as {
									message?: {
										model?: string;
										usage?: {
											input_tokens?: number;
											output_tokens?: number;
											cache_creation_input_tokens?: number;
											cache_read_input_tokens?: number;
										};
									};
								};

								if (data.message?.usage) {
									const usage = data.message.usage;
									const inputTokens = usage.input_tokens || 0;
									const cacheCreationInputTokens =
										usage.cache_creation_input_tokens || 0;
									const cacheReadInputTokens =
										usage.cache_read_input_tokens || 0;
									const outputTokens = usage.output_tokens || 0;
									const promptTokens =
										inputTokens +
										cacheCreationInputTokens +
										cacheReadInputTokens;
									const completionTokens = outputTokens;
									const totalTokens = promptTokens + completionTokens;

									// Extract cost from header if available
									const costHeader = response.headers.get(
										"anthropic-billing-cost",
									);
									const costUsd = costHeader
										? parseFloat(costHeader)
										: undefined;

									return {
										model: data.message.model,
										promptTokens,
										completionTokens,
										totalTokens,
										costUsd,
										inputTokens,
										cacheReadInputTokens,
										cacheCreationInputTokens,
										outputTokens,
									};
								}
							} catch {
								// Ignore parse errors
							}
						}
					}
				}

				// For streaming responses, we only extract initial usage
				// Output tokens will be accumulated during streaming but we can't capture that here
				return null;
			} else {
				// Handle non-streaming JSON responses
				const json = (await clone.json()) as {
					model?: string;
					usage?: {
						input_tokens?: number;
						output_tokens?: number;
						cache_creation_input_tokens?: number;
						cache_read_input_tokens?: number;
					};
				};

				if (!json.usage) return null;

				const inputTokens = json.usage.input_tokens || 0;
				const cacheCreationInputTokens =
					json.usage.cache_creation_input_tokens || 0;
				const cacheReadInputTokens = json.usage.cache_read_input_tokens || 0;
				const outputTokens = json.usage.output_tokens || 0;
				const promptTokens =
					inputTokens + cacheCreationInputTokens + cacheReadInputTokens;
				const completionTokens = outputTokens;
				const totalTokens = promptTokens + completionTokens;

				// Extract cost from header if available
				const costHeader = response.headers.get("anthropic-billing-cost");
				const costUsd = costHeader ? parseFloat(costHeader) : undefined;

				return {
					model: json.model,
					promptTokens,
					completionTokens,
					totalTokens,
					costUsd,
					inputTokens,
					cacheReadInputTokens,
					cacheCreationInputTokens,
					outputTokens,
				};
			}
		} catch {
			// Ignore parsing errors
			return null;
		}
	}

	/**
	 * Check if this provider supports OAuth
	 */
	supportsOAuth(): boolean {
		return true;
	}

	/**
	 * Get the OAuth provider for this provider
	 */
	getOAuthProvider() {
		// Lazy load to avoid circular dependencies
		const { AnthropicOAuthProvider } = require("./oauth.js");
		return new AnthropicOAuthProvider();
	}
}
</file>

<file path="packages/proxy/src/handlers/system-prompt-interceptor.ts">
import type { DatabaseOperations } from "@ccflare/database";
import { Logger } from "@ccflare/logger";

const interceptLog = new Logger("SystemPromptInterceptor");
const updateLog = new Logger("UpdateLastSeenPrompt");

// Type definitions
interface SystemMessage {
	type: string;
	text: string;
	cache_control?: {
		type: string;
	};
}

// Tool definition based on Anthropic API specification
interface Tool {
	type: string;
	name: string;
	description?: string;
	input_schema?: {
		type: string;
		properties?: Record<string, unknown>;
		required?: string[];
	};
}

interface RequestBody {
	messages?: unknown[];
	model?: string;
	system?: string | SystemMessage[];
	tools?: Tool[];
}

/**
 * Type guard to check if a system array element is a SystemMessage with text
 */
function isSystemMessageWithText(
	item: unknown,
): item is SystemMessage & { text: string } {
	return (
		typeof item === "object" &&
		item !== null &&
		"type" in item &&
		"text" in item &&
		typeof (item as SystemMessage).text === "string"
	);
}

/**
 * Applies system prompt interception if configured.
 *
 * This function provides template-based system prompt replacement for the main
 * Claude Code agent. It allows users to customize the instructional portion of
 * the system prompt while preserving dynamic environment data.
 *
 * @param requestBodyBuffer - The buffered request body
 * @param dbOps - Database operations instance
 * @returns Modified request body buffer if changes were made, null otherwise
 */
export async function applySystemPromptInterception(
	requestBodyBuffer: ArrayBuffer | null,
	dbOps: DatabaseOperations,
): Promise<ArrayBuffer | null> {
	// If no body, nothing to intercept
	if (!requestBodyBuffer) {
		return null;
	}

	try {
		// Parse the request body
		const bodyText = new TextDecoder().decode(requestBodyBuffer);
		const requestBody = JSON.parse(bodyText) as RequestBody;

		// Early check: Fetch interceptor configuration before any processing
		const interceptorConfig = dbOps.getInterceptorConfig("system_prompt");

		// If not enabled or config missing, return unchanged
		if (!interceptorConfig || !interceptorConfig.isEnabled) {
			interceptLog.info("System prompt interceptor is not enabled");
			return null;
		}

		interceptLog.info("System prompt interceptor is enabled");

		// Check if this is a main agent request
		if (!Array.isArray(requestBody.system)) {
			interceptLog.info("System field is not an array, skipping interception");
			return null;
		}

		// Check first system message for main agent identification with type guard
		const firstSystemMessage = requestBody.system[0];
		if (!isSystemMessageWithText(firstSystemMessage)) {
			interceptLog.info(
				"First system message is not in expected format, skipping interception",
			);
			return null;
		}
		const firstSystemText = firstSystemMessage.text;

		// Check if it's the main Claude Code agent (not a subagent)
		const isMainAgent = firstSystemText.includes(
			"You are Claude Code, Anthropic's official CLI for Claude.",
		);
		const isSubAgent = firstSystemText.includes(
			"You are an agent for Claude Code",
		);

		if (!isMainAgent || isSubAgent) {
			interceptLog.info(
				`Not a main agent request (isMainAgent: ${isMainAgent}, isSubAgent: ${isSubAgent}), skipping interception`,
			);
			return null;
		}

		interceptLog.info(
			"Detected main agent request, applying system prompt interception",
		);

		// Extract the second system message (contains env block and other dynamic content)
		const secondSystemMessage = requestBody.system[1];
		if (!isSystemMessageWithText(secondSystemMessage)) {
			interceptLog.info(
				"Second system message is not in expected format, skipping interception",
			);
			return null;
		}

		// Capture the original system prompt before any modifications
		const originalPrompt = secondSystemMessage.text;

		// Update last-seen prompt in next tick (truly non-blocking)
		setImmediate(() => {
			_updateLastSeenPrompt(originalPrompt, dbOps);
		});

		// Extract the <env> block(s) from the original system prompt
		// Using global regex to find all env blocks
		const envBlockRegex = /<env>([\s\S]*?)<\/env>/g;
		const envBlocks = secondSystemMessage.text.match(envBlockRegex) || [];

		let envBlock = "";
		if (envBlocks.length === 0) {
			interceptLog.warn(
				"No env block found in system prompt, using empty string",
			);
		} else if (envBlocks.length === 1) {
			envBlock = envBlocks[0];
			interceptLog.info(`Extracted env block (${envBlock.length} chars)`);
		} else {
			// Multiple env blocks found - concatenate them
			envBlock = envBlocks.join("\n");
			interceptLog.warn(
				`Found ${envBlocks.length} env blocks, concatenating them (${envBlock.length} chars total)`,
			);
		}

		// Extract the git status block from the original system prompt
		// The git status block starts with "gitStatus:" and continues to the end
		const gitStatusIndex = secondSystemMessage.text.indexOf("gitStatus:");
		let gitStatusBlock = "";
		if (gitStatusIndex !== -1) {
			gitStatusBlock = secondSystemMessage.text.substring(gitStatusIndex);
			interceptLog.info(
				`Extracted git status block (${gitStatusBlock.length} chars)`,
			);
		} else {
			interceptLog.info("No git status block found in system prompt");
		}

		// Validate and apply the template
		const { replacementPrompt, toolsEnabled } = interceptorConfig.config;

		// Validate replacementPrompt is a non-empty string
		if (!replacementPrompt || typeof replacementPrompt !== "string") {
			interceptLog.error(
				"Invalid replacementPrompt in config, skipping interception",
			);
			return null;
		}

		// Check if the current prompt matches the target (simplified check - could be enhanced)
		// For now, we'll always apply the replacement if the interceptor is enabled
		// Future enhancement: actually compare originalPrompt with targetPrompt

		// Validate template has the placeholder
		if (!replacementPrompt.includes("{{env_block}}")) {
			interceptLog.warn(
				"Replacement prompt missing {{env_block}} placeholder, env data may be lost",
			);
		}

		// Apply template with all occurrences replaced
		let newPrompt = replacementPrompt.replace(/\{\{env_block\}\}/g, envBlock);
		newPrompt = newPrompt.replace(/\{\{git_status_block\}\}/g, gitStatusBlock);

		// Verify replacement actually happened
		if (newPrompt === replacementPrompt && envBlock) {
			interceptLog.warn(
				"Template replacement may have failed - prompt unchanged despite env block present",
			);
		}

		// Update the second system message
		secondSystemMessage.text = newPrompt;

		interceptLog.info(
			`Applied replacement prompt, new prompt length: ${newPrompt.length} chars`,
		);

		// Handle tools toggle
		let _toolsRemoved = false;
		if (!toolsEnabled && requestBody.tools !== undefined) {
			const toolCount = requestBody.tools.length;
			delete requestBody.tools;
			_toolsRemoved = true;
			interceptLog.info(
				`Removed ${toolCount} tools from request as per configuration`,
			);
		}

		// Convert back to buffer if modifications were made
		const modifiedBodyText = JSON.stringify(requestBody);
		const encodedData = new TextEncoder().encode(modifiedBodyText);
		const modifiedBody = new ArrayBuffer(encodedData.byteLength);
		new Uint8Array(modifiedBody).set(encodedData);

		return modifiedBody;
	} catch (error) {
		interceptLog.error("Failed to apply system prompt interception:", error);
		return null;
	}
}

/**
 * Updates the last-seen system prompt in the database if it has changed.
 * This is a non-critical synchronous operation that logs errors but doesn't throw.
 * Should be called via setImmediate to avoid blocking the request.
 *
 * @param prompt - The original system prompt to store
 * @param dbOps - Database operations instance
 */
function _updateLastSeenPrompt(
	prompt: string,
	dbOps: DatabaseOperations,
): void {
	try {
		const lastSeen = dbOps.getSystemKV("last_seen_system_prompt");

		// Only update if the prompt has changed
		if (prompt !== lastSeen) {
			dbOps.setSystemKV("last_seen_system_prompt", prompt);
			updateLog.info("Updated last-seen system prompt in database");
		} else {
			updateLog.info("System prompt unchanged, skipping database update");
		}
	} catch (error) {
		// Log error but don't throw - this is a non-critical background operation
		updateLog.error("Failed to update last-seen system prompt:", error);
	}
}
</file>

<file path="packages/proxy/src/worker-messages.ts">
/**
 * Unified message protocol for main thread <-> worker communication
 * Handles both streaming and non-streaming responses
 */

export interface StartMessage {
	type: "start";
	requestId: string;
	accountId: string | null;
	method: string;
	path: string;
	timestamp: number;

	// Request details
	requestHeaders: Record<string, string>;
	requestBody: string | null; // base64 encoded

	// Response details
	responseStatus: number;
	responseHeaders: Record<string, string>;
	isStream: boolean;

	// Provider info for rate limit parsing
	providerName: string;

	// Agent info
	agentUsed: string | null;

	// Retry info
	retryAttempt: number;
	failoverAttempts: number;
}

export interface ChunkMessage {
	type: "chunk";
	requestId: string;
	data: Uint8Array;
}

export interface EndMessage {
	type: "end";
	requestId: string;
	responseBody?: string | null; // base64 encoded, for non-streaming
	success: boolean;
	error?: string;
}

export interface ControlMessage {
	type: "shutdown";
}

export type WorkerMessage =
	| StartMessage
	| ChunkMessage
	| EndMessage
	| ControlMessage
	| SummaryMessage
	| PayloadMessage;

// Response from worker (if needed in future)
export interface WorkerResponse {
	type: "ack" | "error";
	requestId?: string;
	message?: string;
}

// Worker to main thread messages
export interface SummaryMessage {
	type: "summary";
	summary: import("@ccflare/types").RequestResponse;
}

export interface PayloadMessage {
	type: "payload";
	payload: import("@ccflare/types").RequestPayload;
}

export type OutgoingWorkerMessage = SummaryMessage | PayloadMessage;
</file>

<file path="packages/types/src/index.ts">
// Re-export all types organized by domain
export * from "./account";
export * from "./agent";
export * from "./agent-constants";
// Keep existing exports for backward compatibility
export * from "./api";
export * from "./context";
export * from "./conversation";
export * from "./logging";
export * from "./request";
export * from "./stats";
export * from "./strategy";
</file>

<file path="packages/types/src/request.ts">
// Database row type
export interface RequestRow {
	id: string;
	timestamp: number;
	method: string;
	path: string;
	account_used: string | null;
	status_code: number | null;
	success: 0 | 1;
	error_message: string | null;
	response_time_ms: number | null;
	failover_attempts: number;
	model: string | null;
	prompt_tokens: number | null;
	completion_tokens: number | null;
	total_tokens: number | null;
	cost_usd: number | null;
	input_tokens: number | null;
	cache_read_input_tokens: number | null;
	cache_creation_input_tokens: number | null;
	output_tokens: number | null;
	agent_used: string | null;
	output_tokens_per_second: number | null;
}

// Domain model
export interface Request {
	id: string;
	timestamp: number;
	method: string;
	path: string;
	accountUsed: string | null;
	statusCode: number | null;
	success: boolean;
	errorMessage: string | null;
	responseTimeMs: number | null;
	failoverAttempts: number;
	model?: string;
	promptTokens?: number;
	completionTokens?: number;
	totalTokens?: number;
	costUsd?: number;
	inputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	outputTokens?: number;
	agentUsed?: string;
	tokensPerSecond?: number;
}

// API response type
export interface RequestResponse {
	id: string;
	timestamp: string;
	method: string;
	path: string;
	accountUsed: string | null;
	statusCode: number | null;
	success: boolean;
	errorMessage: string | null;
	responseTimeMs: number | null;
	failoverAttempts: number;
	model?: string;
	promptTokens?: number;
	completionTokens?: number;
	totalTokens?: number;
	inputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	outputTokens?: number;
	costUsd?: number;
	agentUsed?: string;
	tokensPerSecond?: number;
}

// Detailed request with payload
export interface RequestPayload {
	id: string;
	request: {
		headers: Record<string, string>;
		body: string | null;
	};
	response: {
		status: number;
		headers: Record<string, string>;
		body: string | null;
	} | null;
	error?: string;
	meta: {
		accountId?: string;
		accountName?: string;
		retry?: number;
		timestamp: number;
		success?: boolean;
		rateLimited?: boolean;
		accountsAttempted?: number;
		pending?: boolean;
		path?: string;
		method?: string;
		agentUsed?: string;
	};
}

// Type mappers
export function toRequest(row: RequestRow): Request {
	return {
		id: row.id,
		timestamp: row.timestamp,
		method: row.method,
		path: row.path,
		accountUsed: row.account_used,
		statusCode: row.status_code,
		success: row.success === 1,
		errorMessage: row.error_message,
		responseTimeMs: row.response_time_ms,
		failoverAttempts: row.failover_attempts,
		model: row.model || undefined,
		promptTokens: row.prompt_tokens || undefined,
		completionTokens: row.completion_tokens || undefined,
		totalTokens: row.total_tokens || undefined,
		costUsd: row.cost_usd || undefined,
		inputTokens: row.input_tokens || undefined,
		cacheReadInputTokens: row.cache_read_input_tokens || undefined,
		cacheCreationInputTokens: row.cache_creation_input_tokens || undefined,
		outputTokens: row.output_tokens || undefined,
		agentUsed: row.agent_used || undefined,
		tokensPerSecond: row.output_tokens_per_second || undefined,
	};
}

export function toRequestResponse(request: Request): RequestResponse {
	return {
		id: request.id,
		timestamp: new Date(request.timestamp).toISOString(),
		method: request.method,
		path: request.path,
		accountUsed: request.accountUsed,
		statusCode: request.statusCode,
		success: request.success,
		errorMessage: request.errorMessage,
		responseTimeMs: request.responseTimeMs,
		failoverAttempts: request.failoverAttempts,
		model: request.model,
		promptTokens: request.promptTokens,
		completionTokens: request.completionTokens,
		totalTokens: request.totalTokens,
		inputTokens: request.inputTokens,
		cacheReadInputTokens: request.cacheReadInputTokens,
		cacheCreationInputTokens: request.cacheCreationInputTokens,
		outputTokens: request.outputTokens,
		costUsd: request.costUsd,
		agentUsed: request.agentUsed,
		tokensPerSecond: request.tokensPerSecond,
	};
}

// Special account ID for requests without an account
export const NO_ACCOUNT_ID = "no_account";
</file>

<file path="packages/ui-common/src/utils/clean-line-numbers.ts">
/**
 * Replace leading numeric line markers such as "123→" or "123â" by "123: ".
 */
export const cleanLineNumbers = (str: string): string => {
	// Be defensive at runtime: only operate on real strings
	if (typeof str !== "string") return "";
	return str.replace(/^(\s*)(\d+)[→â]\s*/gm, "$1$2: ");
};
</file>

<file path="packages/ui-common/src/utils/normalize-text.ts">
/**
 * Normalize tool/text content that may arrive with mojibake (UTF-8 seen as Latin-1),
 * and optionally strip a single pair of wrapping quotes.
 */
export function normalizeText(input: unknown): string {
	let s = typeof input === "string" ? input : "";
	if (!s) return "";

	// 1) If it's a JSON-encoded string (e.g., "...\n..."), try to parse directly
	if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
		try {
			s = JSON.parse(s);
		} catch {
			// If JSON.parse fails, fall back to manual unquoting
			s = s.slice(1, -1);
		}
	} else if (/\\[nrt"\\]/.test(s)) {
		// 2) If it contains escaped sequences, decode them via JSON.parse wrapper
		try {
			const literal =
				'"' +
				s
					.replace(/\\/g, "\\\\")
					.replace(/\n/g, "\\n")
					.replace(/\r/g, "\\r")
					.replace(/\t/g, "\\t")
					.replace(/"/g, '\\"') +
				'"';
			s = JSON.parse(literal);
		} catch {
			// Ignore if decoding fails
		}
	}

	// 3) Heuristic: repair mojibake (UTF-8 mis-decoded as Latin-1)
	if (/[ÃÂâ]/.test(s)) {
		try {
			const bytes = new Uint8Array(
				Array.from(s, (ch) => ch.charCodeAt(0) & 0xff),
			);
			const recoded = new TextDecoder("utf-8", { fatal: false }).decode(bytes);
			if (recoded && recoded !== s) {
				s = recoded;
			}
		} catch {
			// Ignore decoding errors
		}
	}

	return s;
}
</file>

<file path="packages/ui-common/src/index.ts">
// Export all formatters

// Export all components
export * from "./components/TokenUsageDisplay";
export * from "./formatters";
// Export parsers
export * from "./parsers/parse-conversation";
// Export all presenters
export * from "./presenters";
// Export utilities
export * from "./utils/clean-line-numbers";
export * from "./utils/generate-message-key";
export * from "./utils/normalize-text";
</file>

<file path="apps/tui/src/main.ts">
#!/usr/bin/env bun
import { Config } from "@ccflare/config";
import { CLAUDE_MODEL_IDS, NETWORK, shutdown } from "@ccflare/core";
import { container, SERVICE_KEYS } from "@ccflare/core-di";
import { DatabaseFactory } from "@ccflare/database";
import { Logger } from "@ccflare/logger";
// Import server
import startServer from "@ccflare/server";
import * as tuiCore from "@ccflare/tui-core";
import { parseArgs } from "@ccflare/tui-core";
import { render } from "ink";
import React from "react";
import { App } from "./App";

// Global singleton for auto-started server
let runningServer: ReturnType<typeof startServer> | null = null;

async function ensureServer(port: number) {
	if (!runningServer) {
		runningServer = startServer({ port, withDashboard: true });
	}
	return runningServer;
}

async function main() {
	// Initialize DI container and services
	container.registerInstance(SERVICE_KEYS.Config, new Config());
	container.registerInstance(SERVICE_KEYS.Logger, new Logger("TUI"));

	// Initialize database factory
	DatabaseFactory.initialize();
	const dbOps = DatabaseFactory.getInstance();
	container.registerInstance(SERVICE_KEYS.Database, dbOps);

	const args = process.argv.slice(2);
	const parsed = parseArgs(args);

	// Handle help
	if (parsed.help) {
		console.log(`
🎯 ccflare - Load Balancer for Claude

Usage: ccflare [options]

Options:
  --serve              Start API server with dashboard
  --port <number>      Server port (default: 8080, or PORT env var)
  --logs [N]           Stream latest N lines then follow
  --stats              Show statistics (JSON output)
  --add-account <name> Add a new account
    --mode <max|console>  Account mode (default: max)
    --tier <1|5|20>       Account tier (default: 1)
  --list               List all accounts
  --remove <name>      Remove an account
  --pause <name>       Pause an account
  --resume <name>      Resume an account
  --analyze            Analyze database performance
  --reset-stats        Reset usage statistics
  --clear-history      Clear request history
  --get-model          Show current default agent model
  --set-model <model>  Set default agent model (opus-4 or sonnet-4)
  --help, -h           Show this help message

Interactive Mode:
  ccflare          Launch interactive TUI (default)

Examples:
  ccflare                        # Interactive mode
  ccflare --serve                # Start server
  ccflare --add-account work     # Add account
  ccflare --pause work           # Pause account
  ccflare --analyze              # Run performance analysis
  ccflare --stats                # View stats
`);
		process.exit(0);
	}

	// Handle non-interactive commands
	if (parsed.serve) {
		const config = new Config();
		const port =
			parsed.port || config.getRuntime().port || NETWORK.DEFAULT_PORT;
		startServer({ port, withDashboard: true });
		// Keep process alive
		await new Promise(() => {});
		return;
	}

	if (parsed.logs !== undefined) {
		const limit = typeof parsed.logs === "number" ? parsed.logs : 100;

		// First print historical logs if limit was specified
		if (typeof parsed.logs === "number") {
			const history = await tuiCore.getLogHistory(limit);
			for (const log of history) {
				console.log(`[${log.level}] ${log.msg}`);
			}
			console.log("--- Live logs ---");
		}

		// Then stream live logs
		await tuiCore.streamLogs((log) => {
			console.log(`[${log.level}] ${log.msg}`);
		});
		return;
	}

	if (parsed.stats) {
		const stats = await tuiCore.getStats();
		console.log(JSON.stringify(stats, null, 2));
		return;
	}

	if (parsed.addAccount) {
		await tuiCore.addAccount({
			name: parsed.addAccount,
			mode: parsed.mode || "max",
			tier: parsed.tier || 1,
		});
		console.log(`✅ Account "${parsed.addAccount}" added successfully`);
		return;
	}

	if (parsed.list) {
		const accounts = await tuiCore.getAccounts();
		if (accounts.length === 0) {
			console.log("No accounts configured");
		} else {
			console.log("\nAccounts:");
			accounts.forEach((acc) => {
				console.log(`  - ${acc.name} (${acc.mode} mode, tier ${acc.tier})`);
			});
		}
		return;
	}

	if (parsed.remove) {
		await tuiCore.removeAccount(parsed.remove);
		console.log(`✅ Account "${parsed.remove}" removed successfully`);
		return;
	}

	if (parsed.resetStats) {
		await tuiCore.resetStats();
		console.log("✅ Statistics reset successfully");
		return;
	}

	if (parsed.clearHistory) {
		await tuiCore.clearHistory();
		console.log("✅ Request history cleared successfully");
		return;
	}

	if (parsed.pause) {
		const result = await tuiCore.pauseAccount(parsed.pause);
		console.log(result.message);
		if (!result.success) {
			process.exit(1);
		}
		return;
	}

	if (parsed.resume) {
		const result = await tuiCore.resumeAccount(parsed.resume);
		console.log(result.message);
		if (!result.success) {
			process.exit(1);
		}
		return;
	}

	if (parsed.analyze) {
		await tuiCore.analyzePerformance();
		return;
	}

	if (parsed.getModel) {
		const config = new Config();
		const model = config.getDefaultAgentModel();
		console.log(`Current default agent model: ${model}`);
		return;
	}

	if (parsed.setModel) {
		const config = new Config();
		// Validate the model
		const modelMap: Record<string, string> = {
			"opus-4": CLAUDE_MODEL_IDS.OPUS_4,
			"sonnet-4": CLAUDE_MODEL_IDS.SONNET_4,
			"opus-4.1": CLAUDE_MODEL_IDS.OPUS_4_1,
		};

		const fullModel = modelMap[parsed.setModel];
		if (!fullModel) {
			console.error(`❌ Invalid model: ${parsed.setModel}`);
			console.error("Valid models: opus-4, sonnet-4");
			process.exit(1);
		}

		config.setDefaultAgentModel(fullModel);
		console.log(`✅ Default agent model set to: ${fullModel}`);
		return;
	}

	// Default: Launch interactive TUI with auto-started server
	const config = new Config();
	const port = parsed.port || config.getRuntime().port || NETWORK.DEFAULT_PORT;
	await ensureServer(port);
	const { waitUntilExit } = render(React.createElement(App));
	await waitUntilExit();

	// Cleanup server when TUI exits
	if (runningServer) {
		runningServer.stop();
	}

	// Shutdown all resources
	await shutdown();
}

// Run main and handle errors
main().catch(async (error) => {
	console.error("Error:", error.message);
	try {
		await shutdown();
	} catch (shutdownError) {
		console.error("Error during shutdown:", shutdownError);
	}
	process.exit(1);
});

// Handle process termination
process.on("SIGINT", async () => {
	try {
		await shutdown();
	} catch (error) {
		console.error("Error during shutdown:", error);
	}
	process.exit(0);
});

process.on("SIGTERM", async () => {
	try {
		await shutdown();
	} catch (error) {
		console.error("Error during shutdown:", error);
	}
	process.exit(0);
});
</file>

<file path="docs/architecture.md">
# ccflare Architecture Documentation

## Overview

ccflare is a sophisticated load balancer proxy system designed to distribute requests across multiple OAuth accounts for AI services (currently focused on Anthropic's Claude API). It prevents rate limiting by intelligently routing requests through different authenticated accounts using a session-based load balancing strategy.

The system is built with a modular, microservices-inspired architecture using TypeScript and Bun runtime, emphasizing separation of concerns, extensibility, and real-time monitoring capabilities. Recent enhancements include asynchronous database operations, streaming response capture for analytics, advanced request filtering, and agent detection with model preference management.

## System Overview

```mermaid
graph LR
    subgraph "User Interfaces"
        UI1[Web Dashboard]
        UI2[TUI/CLI]
        UI3[API Clients]
    end
    
    subgraph "ccflare Core"
        LB[Load Balancer]
        PROXY[Proxy Engine]
        AUTH[OAuth Manager]
        MON[Monitoring]
        AGENT[Agent Detector]
    end
    
    subgraph "Data Storage"
        DB[(SQLite DB)]
        LOGS[Log Files]
        CFG[Config]
        WS[Workspaces]
    end
    
    subgraph "External Services"
        CLAUDE[Claude API]
        OAUTH[OAuth Provider]
    end
    
    UI1 --> LB
    UI2 --> LB
    UI3 --> LB
    
    LB --> PROXY
    PROXY --> AUTH
    PROXY --> AGENT
    AUTH --> OAUTH
    PROXY --> CLAUDE
    
    LB --> DB
    PROXY --> DB
    MON --> DB
    AGENT --> WS
    MON --> LOGS
    LB --> CFG
```

## High-Level Architecture Diagram

```mermaid
graph TB
    %% Client Layer
    subgraph "Client Applications"
        CA[Client Apps]
        TUI[TUI/CLI Tool<br/>apps/tui]
        WEB[Web Dashboard<br/>packages/dashboard-web]
    end

    %% API Gateway Layer
    subgraph "ccflare Server"
        SERVER[HTTP Server<br/>apps/server]
        
        subgraph "Request Processing"
            ROUTER[API Router<br/>packages/http-api]
            PROXY[Proxy Handler<br/>packages/proxy]
            INTERCEPT[Agent Interceptor]
        end
        
        subgraph "Core Services"
            LB[Load Balancer<br/>packages/load-balancer]
            PROV[Provider Registry<br/>packages/providers]
            AUTH[OAuth Manager<br/>packages/oauth-flow]
            AGENTS[Agent Registry<br/>packages/agents]
            DI[DI Container<br/>packages/core-di]
            CFG[Config<br/>packages/config]
        end
        
        subgraph "Data Layer"
            DB[Database Operations<br/>packages/database]
            REPOS[Repositories]
            LOGGER[Logger<br/>packages/logger]
        end
        
        subgraph "Utilities"
            ERRORS[Error Handling<br/>packages/errors]
            HTTP[HTTP Utilities<br/>packages/http-common]
            UI_COMMON[UI Common<br/>packages/ui-common]
            UI_CONST[UI Constants<br/>packages/ui-constants]
        end
    end

    %% External Services
    subgraph "External"
        CLAUDE[Claude API]
        OAUTH[OAuth Provider]
    end

    %% Storage
    SQLITE[(SQLite Database)]
    LOGS[Log Files]
    CONFIG[Config Files]
    WORKSPACES[Agent Workspaces]

    %% Connections
    CA -->|HTTP/HTTPS| SERVER
    TUI -->|Commands/API| SERVER
    WEB -->|Embedded in| SERVER
    
    SERVER --> ROUTER
    SERVER --> DI
    DI --> CFG
    CFG --> CONFIG
    ROUTER --> PROXY
    ROUTER -->|Health/Stats/Config| DB
    
    PROXY --> INTERCEPT
    INTERCEPT --> AGENTS
    AGENTS --> WORKSPACES
    PROXY --> LB
    LB -->|Select Account| DB
    PROXY --> PROV
    PROV --> AUTH
    
    PROXY -->|Forward Request| CLAUDE
    AUTH -->|Token Refresh| OAUTH
    
    DB --> REPOS
    REPOS --> SQLITE
    LOGGER --> LOGS
    LOGGER --> DB
```

## Component Architecture

### Project Structure

The project is organized as a Bun monorepo with clear separation of concerns:

```
ccflare/
├── apps/                    # Deployable applications
│   ├── lander/            # Static landing page
│   ├── server/            # Main HTTP server
│   └── tui/               # Terminal UI with integrated CLI
├── packages/              # Shared libraries
│   ├── agents/            # Agent discovery and workspace management
│   ├── cli-commands/      # CLI command implementations
│   ├── config/            # Configuration management
│   ├── core/              # Core utilities and types
│   ├── core-di/           # Dependency injection
│   ├── dashboard-web/     # React dashboard
│   ├── database/          # SQLite operations with repository pattern
│   ├── errors/            # Error handling utilities
│   ├── http-api/          # REST API handlers
│   ├── http-common/       # Common HTTP utilities
│   ├── load-balancer/     # Load balancing strategies
│   ├── logger/            # Logging utilities
│   ├── oauth-flow/        # OAuth authentication flow
│   ├── providers/         # AI provider integrations
│   ├── proxy/             # Request proxy logic with agent interceptor
│   ├── tui-core/          # TUI screen components
│   ├── types/             # Shared TypeScript types
│   ├── ui-common/         # Shared UI components and formatters
│   └── ui-constants/      # UI constants and configuration
```

### 1. Server Application (`apps/server`)

The main HTTP server that orchestrates all components:

```mermaid
graph LR
    subgraph "Server Initialization"
        START[Server Start]
        DI[DI Container Setup]
        DB_INIT[Database Init]
        AGENT_INIT[Agent Registry Init]
        STRAT[Strategy Init]
        ROUTES[Route Setup]
    end
    
    START --> DI
    DI --> DB_INIT
    DB_INIT --> AGENT_INIT
    AGENT_INIT --> STRAT
    STRAT --> ROUTES
    
    subgraph "Request Flow"
        REQ[Incoming Request]
        API_CHECK{API Route?}
        DASH_CHECK{Dashboard?}
        PROXY_CHECK{Proxy Route?}
        
        API_RESP[API Response]
        DASH_RESP[Dashboard HTML]
        PROXY_RESP[Proxy Response]
        NOT_FOUND[404 Response]
    end
    
    REQ --> API_CHECK
    API_CHECK -->|Yes| API_RESP
    API_CHECK -->|No| DASH_CHECK
    DASH_CHECK -->|Yes| DASH_RESP
    DASH_CHECK -->|No| PROXY_CHECK
    PROXY_CHECK -->|Yes| PROXY_RESP
    PROXY_CHECK -->|No| NOT_FOUND
```

**Key Responsibilities:**
- HTTP server setup using Bun's native server
- Dependency injection container management
- Route handling delegation
- Static asset serving for dashboard
- Graceful shutdown coordination
- Strategy hot-reloading based on configuration changes
- Agent registry initialization

### 2. TUI Application with Integrated CLI (`apps/tui`)

The Terminal User Interface application that also serves as the CLI:

```mermaid
graph TB
    %% Entry Point
    subgraph "TUI/CLI Entry Point"
        MAIN[main.ts]
        ARGS[Parse Arguments]

        %% CLI Commands group
        subgraph "CLI Commands"
            CLI_CMDS[CLI Commands]
            SERVE[--serve]
            ADD[--add-account]
            LIST[--list]
            REMOVE[--remove]
            STATS[--stats]
            LOGS[--logs]
            ANALYZE[--analyze]
            CLI_CMDS --> SERVE
            CLI_CMDS --> ADD
            CLI_CMDS --> LIST
            CLI_CMDS --> REMOVE
            CLI_CMDS --> STATS
            CLI_CMDS --> LOGS
            CLI_CMDS --> ANALYZE
        end

        %% Interactive Mode group
        subgraph "Interactive Mode"
            INT_MODE[Interactive Mode]
            TUI[TUI Interface]
            AUTO_SERVER[Auto-start Server]
            INT_MODE --> TUI
            TUI --> AUTO_SERVER
        end
    end

    MAIN --> ARGS
    ARGS -->|CLI Command| CLI_CMDS
    ARGS -->|No Command| INT_MODE
```

**Features:**
- Unified binary for both CLI and TUI functionality
- Auto-starts server when launching interactive TUI
- Account management commands
- Statistics viewing
- Log streaming
- Performance analysis
- Configuration updates

### 3. Agents Package (`packages/agents`)

Manages agent discovery and workspace registration:

```mermaid
classDiagram
    class AgentRegistry {
        -cache: AgentCache
        -workspaces: Map<string, AgentWorkspace>
        +initialize(): Promise<void>
        +getAgents(): Promise<Agent[]>
        +findAgentByPrompt(prompt: string): Agent
        +registerWorkspace(path: string): Promise<void>
        +loadAgents(): Promise<void>
    }
    
    class Agent {
        +id: string
        +name: string
        +description: string
        +color: string
        +model: AllowedModel
        +systemPrompt: string
        +source: "global" | "workspace"
        +workspace?: string
    }
    
    class AgentWorkspace {
        +path: string
        +name: string
        +lastSeen: number
    }
    
    class WorkspacePersistence {
        +loadWorkspaces(): Promise<AgentWorkspace[]>
        +saveWorkspaces(workspaces: AgentWorkspace[]): Promise<void>
    }
    
    AgentRegistry --> Agent
    AgentRegistry --> AgentWorkspace
    AgentRegistry --> WorkspacePersistence
```

**Agent Discovery Process:**
1. **Global Agents**: Loaded from `~/.config/ccflare/agents/` directory
2. **Workspace Agents**: Dynamically discovered from `<workspace>/.claude/agents/` directories
3. **Agent Format**: Markdown files with frontmatter containing metadata
4. **Workspace Detection**: Automatically registers workspaces from system prompts containing CLAUDE.md references
5. **Model Preferences**: Per-agent model preferences stored in database

### 4. Load Balancer Package (`packages/load-balancer`)

Implements the session-based load balancing strategy:

```mermaid
classDiagram
    class LoadBalancingStrategy {
        <<interface>>
        +select(accounts: Account[], meta: RequestMeta): Account[]
        +initialize?(store: StrategyStore): void
    }
    
    class SessionStrategy {
        -sessionDurationMs: number
        -store: StrategyStore
        -log: Logger
        +constructor(sessionDurationMs?: number)
        +select(accounts, meta): Account[]
        +initialize(store): void
        -resetSessionIfExpired(account): void
    }
    
    class StrategyStore {
        <<interface>>
        +resetAccountSession(accountId: string, timestamp: number): void
        +getAllAccounts?(): Account[]
        +updateAccountRequestCount?(accountId: string, count: number): void
        +getAccount?(accountId: string): Account | null
    }
    
    LoadBalancingStrategy <|.. SessionStrategy
    SessionStrategy ..> StrategyStore : uses
```

**Session Strategy:**
- **Session**: The only available strategy, maintains sticky sessions for a configured duration (default 5 hours)
- Minimizes account switching to avoid triggering Claude's anti-abuse systems
- Automatically handles failover when the active session account becomes unavailable
- Tracks session start time and request count per session

**Note:** Other strategies (round-robin, least-requests, weighted) were removed from the codebase as they could trigger account bans.

### 5. Provider Package (`packages/providers`)

Manages AI service providers with extensible architecture:

```mermaid
graph TB
    REG["Provider Registry"]
    BASE["Base Provider"]

    subgraph "Provider Implementations"
        ANTH["Anthropic Provider"]
        OAUTH_PROV["OAuth Provider"]
    end

    subgraph "Provider Interface"
        HANDLE["canHandle()"]
        BUILD["buildUrl()"]
        PREP["prepareHeaders()"]
        PARSE["parseRateLimit()"]
        PROC["processResponse()"]
        USAGE["extractUsageInfo()"]
        TIER["extractTierInfo()"]
    end

    REG -->|Manages| BASE
    BASE -->|Implements| ANTH
    ANTH -->|Uses| OAUTH_PROV
    ANTH --> HANDLE
    ANTH --> BUILD
    ANTH --> PREP
    ANTH --> PARSE
    ANTH --> PROC
    ANTH --> USAGE
    ANTH --> TIER
```

**Provider Features:**
- Provider registration and discovery
- OAuth token management with PKCE flow
- Rate limit parsing and tracking
- Usage metrics extraction
- Account tier detection
- Extensible for additional AI providers

### 6. Database Package (`packages/database`)

SQLite-based persistence layer with repository pattern and asynchronous writes:

```mermaid
erDiagram
    accounts {
        text id PK
        text name
        text provider
        text api_key
        text refresh_token
        text access_token
        integer expires_at
        integer created_at
        integer last_used
        integer request_count
        integer total_requests
        integer account_tier
        integer rate_limited_until
        integer session_start
        integer session_request_count
        integer paused
        text rate_limit_status
        integer rate_limit_reset
        integer rate_limit_remaining
    }
    
    requests {
        text id PK
        integer timestamp
        text method
        text path
        text account_used FK
        integer status_code
        boolean success
        text error_message
        integer response_time_ms
        integer failover_attempts
        text model
        integer input_tokens
        integer output_tokens
        integer cache_read_input_tokens
        integer cache_creation_input_tokens
        real cost_usd
        text agent_used
    }
    
    request_payloads {
        text id PK
        text json
    }
    
    agent_preferences {
        text agent_id PK
        text model
        integer updated_at
    }
    
    accounts ||--o{ requests : "handles"
    requests ||--|| request_payloads : "has payload"
    agent_preferences ||--o{ requests : "configures"
```

**Repository Pattern:**
```mermaid
classDiagram
    class BaseRepository~T~ {
        #db: Database
        #query(sql, params): R[]
        #get(sql, params): R
        #run(sql, params): void
        #runWithChanges(sql, params): number
    }
    
    class AccountRepository {
        +getAllAccounts(): Account[]
        +getAccount(id): Account
        +createAccount(account): void
        +updateAccount(id, data): void
        +deleteAccount(id): void
    }
    
    class RequestRepository {
        +logRequest(request): void
        +getRequests(filters): Request[]
        +getRequestStats(): Stats
    }
    
    class AgentPreferenceRepository {
        +getPreference(agentId): Preference
        +setPreference(agentId, model): void
    }
    
    BaseRepository <|-- AccountRepository
    BaseRepository <|-- RequestRepository
    BaseRepository <|-- AgentPreferenceRepository
```

**Database Operations:**
- Account CRUD operations
- Request logging and analytics
- Rate limit tracking
- Session management
- Usage statistics
- Agent preference storage
- Migration system for schema evolution
- **AsyncDbWriter**: Queue-based asynchronous writes to prevent blocking
  - Processes database writes in batches every 100ms
  - Ensures graceful shutdown with queue flushing
  - Prevents database write bottlenecks during high load

### 7. Proxy Package (`packages/proxy`)

Core request forwarding logic with agent detection and streaming support:

```mermaid
stateDiagram-v2
    [*] --> ValidateRequest
    ValidateRequest --> CheckProvider: Valid
    ValidateRequest --> Error400: Invalid
    
    CheckProvider --> AgentDetection
    AgentDetection --> ModifyModel: Agent Found
    AgentDetection --> GetAccounts: No Agent
    
    ModifyModel --> GetAccounts
    GetAccounts --> NoAccounts: Empty
    GetAccounts --> TryAccount: Has Accounts
    
    NoAccounts --> ForwardUnauthenticated
    
    TryAccount --> CheckToken
    CheckToken --> RefreshToken: Expired
    CheckToken --> ForwardRequest: Valid
    RefreshToken --> ForwardRequest: Success
    RefreshToken --> NextAccount: Failed
    
    ForwardRequest --> CheckRateLimit
    CheckRateLimit --> MarkRateLimited: Limited
    CheckRateLimit --> ExtractUsage: OK
    MarkRateLimited --> NextAccount
    
    ExtractUsage --> UpdateStats
    UpdateStats --> ReturnResponse
    
    NextAccount --> TryAccount: More Accounts
    NextAccount --> AllFailed: No More
    
    ForwardUnauthenticated --> ReturnResponse
    AllFailed --> Error503
    Error400 --> [*]
    Error503 --> [*]
    ReturnResponse --> [*]
```

**Agent Interceptor:**
```mermaid
sequenceDiagram
    participant Client
    participant Proxy
    participant AgentInterceptor
    participant AgentRegistry
    participant Database
    
    Client->>Proxy: Request with System Prompt
    Proxy->>AgentInterceptor: Intercept Request
    AgentInterceptor->>AgentInterceptor: Extract System Prompt
    AgentInterceptor->>AgentInterceptor: Detect Workspace Paths
    AgentInterceptor->>AgentRegistry: Register Workspaces
    AgentRegistry->>AgentRegistry: Load Workspace Agents
    AgentInterceptor->>AgentRegistry: Find Agent by Prompt
    AgentRegistry-->>AgentInterceptor: Agent Match
    AgentInterceptor->>Database: Get Model Preference
    Database-->>AgentInterceptor: Preferred Model
    AgentInterceptor->>AgentInterceptor: Modify Request Body
    AgentInterceptor-->>Proxy: Modified Request
    Proxy->>Client: Response
```

**Proxy Features:**
- Request validation and routing
- Token refresh with stampede prevention
- Retry logic with exponential backoff
- Rate limit detection and account marking
- Usage tracking and cost calculation
- Request/response payload logging
- **Agent Detection**: Automatically detects agent usage from system prompts
- **Model Override**: Applies agent-specific model preferences
- **Streaming Response Capture**: 
  - Tees streaming responses for analytics without blocking
  - Configurable buffer size (default 256KB)
  - Captures partial response bodies for debugging
- **Request Body Buffering**:
  - Buffers small request bodies (up to 256KB) for retry scenarios
  - Enables request replay on failover without client resend

### 8. OAuth Flow Package (`packages/oauth-flow`)

Manages the OAuth authentication flow:

```mermaid
sequenceDiagram
    participant User
    participant OAuthFlow
    participant OAuthProvider
    participant Database
    participant External OAuth
    
    User->>OAuthFlow: begin(name, mode)
    OAuthFlow->>OAuthFlow: Check existing accounts
    OAuthFlow->>OAuthProvider: Get OAuth config
    OAuthFlow->>OAuthFlow: Generate PKCE
    OAuthFlow->>OAuthProvider: Generate auth URL
    OAuthFlow-->>User: Auth URL + session data
    
    User->>External OAuth: Authorize
    External OAuth-->>User: Authorization code
    
    User->>OAuthFlow: complete(code, session)
    OAuthFlow->>OAuthProvider: Exchange code
    OAuthProvider->>External OAuth: Token request
    External OAuth-->>OAuthProvider: Tokens
    OAuthProvider-->>OAuthFlow: OAuth tokens
    OAuthFlow->>Database: Create account
    OAuthFlow-->>User: Account created
```

**Features:**
- PKCE (Proof Key for Code Exchange) support
- Session management
- Token exchange
- Account creation with tier support

### 9. HTTP API Package (`packages/http-api`)

RESTful API endpoints:

```mermaid
graph LR
    subgraph "API Endpoints"
        subgraph "Health & Status"
            HEALTH[GET /health]
            STATS[GET /api/stats]
            ANALYTICS[GET /api/analytics]
        end
        
        subgraph "Account Management"
            LIST_ACC[GET /api/accounts]
            ADD_ACC[POST /api/accounts]
            DEL_ACC[DELETE /api/accounts/:id]
            PAUSE_ACC[POST /api/accounts/:id/pause]
            RESUME_ACC[POST /api/accounts/:id/resume]
            TIER_ACC[POST /api/accounts/:id/tier]
        end
        
        subgraph "Agent Management"
            LIST_AGENTS[GET /api/agents]
            GET_PREF[GET /api/agents/:id/preference]
            SET_PREF[POST /api/agents/:id/preference]
        end
        
        subgraph "Configuration"
            GET_CFG[GET /api/config]
            GET_STRAT[GET /api/config/strategy]
            SET_STRAT[POST /api/config/strategy]
            LIST_STRAT[GET /api/strategies]
        end
        
        subgraph "Monitoring"
            REQ_SUM[GET /api/requests]
            REQ_DET[GET /api/requests/detail]
            LOG_STREAM[GET /api/logs/stream]
            LOG_HIST[GET /api/logs/history]
        end
    end
```

**Analytics Endpoint Enhancements:**
- **GET /api/analytics**: Advanced analytics with filtering support
  - Filter by time range (1h, 6h, 24h, 7d, 30d)
  - Filter by accounts (comma-separated list)
  - Filter by models (comma-separated list)
  - Filter by status (all, success, error)
  - Returns comprehensive metrics including:
    - Time series data with configurable bucketing
    - Token breakdown (input, cache, output)
    - Model distribution and performance metrics
    - Cost analysis by model
    - Account performance statistics
    - Agent usage statistics

### 10. Error Handling Package (`packages/errors`)

Centralized error handling utilities:

```mermaid
classDiagram
    class HttpError {
        +status: number
        +message: string
        +details?: unknown
    }
    
    class ErrorType {
        <<enumeration>>
        NETWORK
        AUTH
        RATE_LIMIT
        VALIDATION
        SERVER
        UNKNOWN
    }
    
    class ErrorUtils {
        +getErrorType(error): ErrorType
        +formatError(error, options): string
        +parseHttpError(response): HttpError
        +isNetworkError(error): boolean
        +isAuthError(error): boolean
        +isRateLimitError(error): boolean
    }
    
    HttpError --> ErrorType
    ErrorUtils --> ErrorType
    ErrorUtils --> HttpError
```

**Features:**
- Common HTTP error factories
- Error type detection
- User-friendly error formatting
- Response error parsing
- Type guards for specific error types

### 11. HTTP Common Package (`packages/http-common`)

Common HTTP utilities:

```mermaid
graph TB
    subgraph "HTTP Common Utilities"
        HEADERS["Header Utilities"]
        CLIENT["HTTP Client"]
        RESPONSES["Response Helpers"]
        ERRORS["Error Handlers"]
    end

    subgraph "Header Functions"
        SANITIZE["sanitizeProxyHeaders()"]
    end

    HEADERS --> SANITIZE
```

**Key Utilities:**
- **sanitizeProxyHeaders**: Removes hop-by-hop headers after automatic decompression
  - Removes: content-encoding, content-length, transfer-encoding
  - Ensures proper header forwarding through proxy
- HTTP client wrapper
- Response helpers
- Error handling utilities

### 12. UI Common Package (`packages/ui-common`)

Shared UI components and formatting utilities:

```mermaid
graph LR
    subgraph "Components"
        TOKEN_DISPLAY["TokenUsageDisplay"]
    end

    subgraph "Formatters"
        DURATION["formatDuration()"]
        TOKENS["formatTokens()"]
        COST["formatCost()"]
        PERCENT["formatPercentage()"]
        TIMESTAMP["formatTimestamp()"]
        SPEED["formatTokensPerSecond()"]
    end

    subgraph "Presenters"
        DATA_PRESENT["Data Presenters"]
    end
```

**Features:**
- Reusable React components
- Consistent data formatting across UI
- Token usage visualization
- Cost and performance metrics display

### 13. UI Constants Package (`packages/ui-constants`)

UI configuration and constants:

```typescript
// Color palette
export const COLORS = {
    primary: "#f38020",
    success: "#10b981",
    warning: "#f59e0b",
    error: "#ef4444",
    blue: "#3b82f6",
    purple: "#8b5cf6",
    pink: "#ec4899",
}

// Time ranges for analytics
export type TimeRange = "1h" | "6h" | "24h" | "7d" | "30d"

// Chart configurations
export const CHART_HEIGHTS = {
    small: 250,
    medium: 300,
    large: 400,
}

// Refresh intervals
export const REFRESH_INTERVALS = {
    default: 30000, // 30 seconds
    fast: 10000,    // 10 seconds
    slow: 60000,    // 1 minute
}
```

### 14. Core Packages

#### Core DI (`packages/core-di`)

Dependency injection container for managing service instances:

```mermaid
graph TB
    subgraph "DI Container"
        CONT[Container]
        KEYS[Service Keys]
        
        subgraph "Registered Services"
            CFG[Config Service]
            LOG[Logger Service]
            DB[Database Service]
            PRICE[Pricing Logger]
            ASYNC[AsyncWriter Service]
            AGENTS[Agent Registry]
        end
    end
    
    CONT -->|Register| CFG
    CONT -->|Register| LOG
    CONT -->|Register| DB
    CONT -->|Register| PRICE
    CONT -->|Register| ASYNC
    CONT -->|Register| AGENTS
    KEYS -->|Identify| CONT
```

**Features:**
- Service registration and resolution
- Singleton pattern for shared instances
- Type-safe service keys
- Lifecycle management
- AsyncWriter integration for non-blocking database operations

#### Core (`packages/core`)

Shared utilities and types:
- Strategy interfaces and base implementations
- Account availability checks
- Pricing calculations
- Lifecycle management (graceful shutdown)
- Strategy store interface
- Common error types

#### Config (`packages/config`)

Configuration management:
- Runtime configuration
- Strategy selection
- Port and session duration settings
- File-based persistence
- Change event notifications
- **New Configuration Options**:
  - `streamBodyMaxBytes`: Controls streaming response buffer size (default: 256KB)
  - Environment variable support for all settings
  - Dynamic configuration reloading

#### Types (`packages/types`)

Shared TypeScript type definitions:
- API response types
- Strategy enums
- Logging interfaces
- Common data structures
- Agent types and interfaces

### 15. Dashboard Package (`packages/dashboard-web`)

React-based monitoring dashboard:

```mermaid
graph TB
    subgraph "Dashboard Architecture"
        APP[App Component]
        
        subgraph "Tabs"
            OVER[Overview Tab]
            ACC[Accounts Tab]
            REQ[Requests Tab]
            LOGS[Logs Tab]
            ANAL[Analytics Tab]
            STATS[Stats Tab]
            AGENTS[Agents Tab]
        end
        
        subgraph "Components"
            NAV[Navigation]
            THEME[Theme Toggle]
            CARDS[Metric Cards]
            TABLES[Data Tables]
            CHARTS[Charts]
            AGENT_CARDS[Agent Cards]
        end
        
        subgraph "State Management"
            CTX[Theme Context]
            HOOKS[Custom Hooks]
            API_CLIENT[API Client]
        end
    end
    
    APP --> NAV
    APP --> TABS
    TABS --> OVER
    TABS --> ACC
    TABS --> REQ
    TABS --> LOGS
    TABS --> ANAL
    TABS --> STATS
    TABS --> AGENTS
    
    OVER --> CARDS
    ACC --> TABLES
    REQ --> TABLES
    ANAL --> CHARTS
    AGENTS --> AGENT_CARDS
    
    TABS --> API_CLIENT
    APP --> CTX
```

**New Features:**
- Agent management tab
- Model preference configuration
- Agent usage analytics
- Workspace visualization

## Agent System Architecture

The agent system allows ccflare to automatically detect and apply model preferences based on the agent being used:

```mermaid
graph TB
    subgraph "Agent Discovery"
        GLOBAL[Global Agents<br/>~/.config/ccflare/agents/]
        WORKSPACE[Workspace Agents<br/><workspace>/.claude/agents/]
        REGISTRY[Agent Registry]
    end
    
    subgraph "Request Processing"
        REQUEST[Incoming Request]
        DETECT[System Prompt Detection]
        WORKSPACE_DISC[Workspace Discovery]
        AGENT_MATCH[Agent Matching]
        MODEL_PREF[Model Preference Lookup]
        MODIFY[Request Modification]
    end
    
    subgraph "Agent Format"
        MD[Markdown File]
        FRONT[Frontmatter Metadata]
        PROMPT[System Prompt]
    end
    
    GLOBAL --> REGISTRY
    WORKSPACE --> REGISTRY
    REQUEST --> DETECT
    DETECT --> WORKSPACE_DISC
    WORKSPACE_DISC --> REGISTRY
    DETECT --> AGENT_MATCH
    AGENT_MATCH --> MODEL_PREF
    MODEL_PREF --> MODIFY
    
    MD --> FRONT
    MD --> PROMPT
```

**Agent File Format:**
```markdown
---
name: "Agent Name"
description: "Agent description"
color: "blue"
model: "claude-opus-4-20250514"  # Optional, UI preference takes precedence
---

Your system prompt goes here...
```

**Workspace Discovery Process:**
1. System prompt analysis for CLAUDE.md references
2. Extraction of repository paths
3. Automatic workspace registration
4. Agent loading from `.claude/agents/` directories

## Applications

### 1. Server App (`apps/server`)

The main HTTP server application that:
- Hosts the proxy endpoints
- Serves the web dashboard
- Provides REST API endpoints
- Manages WebSocket connections for real-time updates
- Initializes agent registry

### 2. TUI App with Integrated CLI (`apps/tui`)

Unified terminal application built with Ink (React for CLI):
- **Interactive Mode**: 
  - Real-time monitoring dashboard in the terminal
  - Auto-starts server if not running
  - Interactive account management
  - Log streaming
  - Request monitoring
- **CLI Mode**: 
  - Account management (add, remove, list, pause, resume)
  - Statistics viewing
  - Log streaming with tail functionality
  - Performance analysis
  - Server startup with `--serve`
  - Configuration updates

**Note**: There is no separate CLI app - all CLI functionality is integrated into the TUI binary.

### 3. Landing Page (`apps/lander`)

Static landing page for the project:
- Project overview
- Screenshots
- Getting started guide
- Built with vanilla HTML/CSS

## Component Interaction Patterns

### Request Flow with Agent Detection

```mermaid
sequenceDiagram
    participant Client
    participant Server
    participant Router
    participant Proxy
    participant AgentInterceptor
    participant LoadBalancer
    participant AsyncWriter
    participant Database
    participant Provider
    participant Claude API
    
    Client->>Server: HTTP Request
    Server->>Router: Route Request
    
    alt API Route
        Router->>Database: Query Data
        Database-->>Router: Return Data
        Router-->>Client: JSON Response
    else Proxy Route
        Router->>Proxy: Forward to Proxy
        Proxy->>AgentInterceptor: Check for Agent
        
        alt Agent Detected
            AgentInterceptor->>Database: Get Model Preference
            Database-->>AgentInterceptor: Preferred Model
            AgentInterceptor->>Proxy: Modified Request
        end
        
        Proxy->>LoadBalancer: Get Account
        LoadBalancer->>Database: Get Available Accounts
        Database-->>LoadBalancer: Account List
        LoadBalancer-->>Proxy: Selected Account
        
        alt Token Expired
            Proxy->>Provider: Refresh Token
            Provider-->>Proxy: New Token
            Proxy->>AsyncWriter: Queue Token Update
            AsyncWriter->>Database: Update Token (Async)
        end
        
        Proxy->>Claude API: Forward Request
        Claude API-->>Proxy: Response
        
        alt Streaming Response
            Proxy->>Proxy: Tee Stream
            Proxy-->>Client: Stream Response
            Proxy->>AsyncWriter: Queue Response Capture
            AsyncWriter->>Database: Save Payload (Async)
        else Regular Response
            Proxy->>AsyncWriter: Queue Request Log
            AsyncWriter->>Database: Log Request (Async)
            Proxy->>AsyncWriter: Queue Stats Update
            AsyncWriter->>Database: Update Stats (Async)
            Proxy-->>Client: Proxy Response
        end
    end
```

### Account Lifecycle

```mermaid
stateDiagram-v2
    [*] --> Created: Add Account
    Created --> Active: OAuth Success
    
    Active --> RateLimited: Hit Rate Limit
    Active --> Paused: Manual Pause
    Active --> Expired: Token Expired
    
    RateLimited --> Active: Reset Time Reached
    Paused --> Active: Manual Resume
    Expired --> Active: Token Refresh
    
    Active --> Removed: Delete Account
    Paused --> Removed: Delete Account
    Removed --> [*]
```

### Agent Lifecycle

```mermaid
stateDiagram-v2
    [*] --> GlobalAgent: Place in global directory
    [*] --> WorkspaceAgent: Place in workspace
    
    GlobalAgent --> Discovered: Registry scan
    WorkspaceAgent --> Discovered: Workspace registration
    
    Discovered --> Available: Loaded successfully
    Discovered --> Invalid: Parse failure
    
    Available --> InUse: System prompt match
    InUse --> ModelOverride: Preference exists
    InUse --> DefaultModel: No preference
    
    Available --> Updated: File modified
    Updated --> Available: Reload
    
    Available --> Removed: File deleted
    Removed --> [*]
```

### Streaming Architecture

ccflare implements sophisticated streaming support for handling large language model responses:

```mermaid
graph TB
    subgraph "Streaming Pipeline"
        REQ[Incoming Request]
        PROXY[Proxy Handler]
        
        subgraph "Stream Processing"
            TEE[Stream Tee]
            CLIENT[Client Stream]
            CAPTURE[Analytics Capture]
        end
        
        subgraph "Storage"
            BUFFER[Memory Buffer]
            ASYNC[AsyncWriter Queue]
            DB[(Database)]
        end
    end
    
    REQ --> PROXY
    PROXY --> TEE
    TEE --> CLIENT
    TEE --> CAPTURE
    CAPTURE --> BUFFER
    BUFFER --> ASYNC
    ASYNC --> DB
    
    style TEE fill:#f9f,stroke:#333,stroke-width:2px
    style ASYNC fill:#9f9,stroke:#333,stroke-width:2px
```

**Stream Tee Features:**
- Non-blocking stream duplication
- Configurable buffer limits (default 256KB)
- Graceful truncation for large responses
- Error handling without stream interruption
- Metadata preservation (truncation flags)

## Key Architectural Decisions

### 1. Modular Package Structure
- **Decision**: Organize code into focused packages with clear boundaries
- **Rationale**: Enables independent development, testing, and potential microservice migration
- **Trade-offs**: Some code duplication vs. tight coupling

### 2. SQLite for Persistence
- **Decision**: Use SQLite as the primary database
- **Rationale**: Zero-configuration, file-based, sufficient for expected load
- **Trade-offs**: Limited concurrent writes vs. operational simplicity

### 3. Bun Runtime
- **Decision**: Use Bun instead of Node.js
- **Rationale**: Better performance, built-in TypeScript, native SQLite support
- **Trade-offs**: Smaller ecosystem vs. performance gains

### 4. Strategy Pattern for Load Balancing
- **Decision**: Implement load balancing as pluggable strategies
- **Rationale**: Easy to add new algorithms, runtime switching
- **Trade-offs**: Additional abstraction vs. flexibility

### 5. Provider Abstraction
- **Decision**: Abstract AI providers behind a common interface
- **Rationale**: Future-proof for multiple AI services
- **Trade-offs**: Over-engineering for single provider vs. extensibility

### 6. Asynchronous Database Writes
- **Decision**: Implement AsyncDbWriter for non-blocking database operations
- **Rationale**: Prevent database writes from blocking request processing
- **Trade-offs**: Eventual consistency vs. immediate durability

### 7. Streaming Response Capture
- **Decision**: Tee streaming responses for analytics without blocking
- **Rationale**: Enable debugging and analytics for streaming LLM responses
- **Trade-offs**: Memory usage vs. complete observability

### 8. Real-time Monitoring
- **Decision**: Include comprehensive logging and real-time dashboards
- **Rationale**: Critical for debugging rate limits and performance
- **Trade-offs**: Storage overhead vs. observability

### 9. Repository Pattern for Database
- **Decision**: Implement repository pattern for database operations
- **Rationale**: Clean separation of data access logic, easier testing
- **Trade-offs**: Additional abstraction layer vs. maintainability

### 10. Agent System Integration
- **Decision**: Build agent detection and model preference into proxy layer
- **Rationale**: Transparent model switching without client changes
- **Trade-offs**: Request inspection overhead vs. flexibility

### 11. Unified TUI/CLI Binary
- **Decision**: Combine TUI and CLI into single binary
- **Rationale**: Simpler distribution, shared codebase, consistent behavior
- **Trade-offs**: Larger binary size vs. deployment simplicity

## Technology Stack

### Runtime & Language
- **Bun**: High-performance JavaScript runtime
- **TypeScript**: Type-safe development
- **React**: Dashboard UI framework
- **Ink**: Terminal UI framework
- **Tailwind CSS**: Utility-first styling

### Data Storage
- **SQLite**: Primary database
- **File System**: Log storage, configuration, agent definitions

### Key Libraries
- **@tanstack/react-query**: Dashboard data fetching
- **@nivo/charts**: Analytics visualization
- **Commander**: CLI argument parsing
- **PKCE**: OAuth security

### Development Tools
- **Biome**: Linting and formatting
- **Bun**: Monorepo management and build system
- **TypeScript**: Build system

## Security Considerations

1. **Token Storage**: OAuth tokens encrypted at rest
2. **API Authentication**: Currently relies on network security (localhost)
3. **Rate Limit Protection**: Automatic account rotation prevents service disruption
4. **Request Logging**: 
   - Sensitive data can be logged (configurable)
   - Request bodies buffered only for small payloads
   - Streaming responses captured with size limits
5. **Data Retention**: Automatic cleanup of old request payloads (configurable)
6. **Agent Security**: 
   - System prompts validated before agent matching
   - Model preferences require explicit configuration
   - Workspace registration limited to existing directories

## Performance Characteristics

1. **Request Overhead**: ~5-10ms for load balancing decision + agent detection
2. **Token Refresh**: Cached to prevent stampedes
3. **Database Operations**: 
   - Read operations: Direct synchronous access
   - Write operations: Queued through AsyncDbWriter (sub-millisecond enqueue)
   - Batch processing: Every 100ms for optimal throughput
4. **Memory Usage**: 
   - Base: Scales with active connections
   - Streaming: Up to 256KB per active stream (configurable)
   - AsyncWriter queue: Minimal, processes continuously
   - Agent cache: 5-minute TTL, lazy loading
5. **Streaming Performance**:
   - Zero-copy stream forwarding to clients
   - Parallel capture for analytics
   - Graceful degradation on memory pressure
6. **Agent Detection**:
   - System prompt analysis: <1ms for typical prompts
   - Workspace discovery: Cached after first detection
   - Model preference lookup: O(1) database query

## Future Extensibility

The architecture supports:
1. Additional AI providers (OpenAI, Cohere, etc.)
2. Distributed deployment with external database
3. Webhook notifications for events
4. Advanced analytics and ML-based load prediction
5. Multi-region deployment for global distribution
6. Real-time metrics export (Prometheus, DataDog)
7. Request replay and debugging tools
8. A/B testing for load balancing strategies
9. Plugin system for custom agents
10. GraphQL API layer
11. Multi-tenant support
12. Advanced agent capabilities (tool use, memory)

## Deployment Architecture

### Current Single-Instance Deployment

```mermaid
graph TB
    subgraph "Local Machine"
        SERVER[ccflare Server<br/>Port 8080]
        DB[(SQLite DB)]
        LOGS[Log Files]
        CONFIG[Config Files]
        AGENTS[Agent Definitions]
    end
    
    subgraph "Clients"
        LOCAL[Local Apps]
        REMOTE[Remote Clients]
        CLAUDE_CODE[Claude Code]
    end
    
    LOCAL -->|localhost:8080| SERVER
    REMOTE -->|http://host:8080| SERVER
    CLAUDE_CODE -->|Proxy Requests| SERVER
    SERVER --> DB
    SERVER --> LOGS
    SERVER --> CONFIG
    SERVER --> AGENTS
```

### Potential Distributed Architecture

```mermaid
graph TB
    subgraph "Load Balancer Tier"
        LB1[HAProxy/Nginx]
    end
    
    subgraph "Application Tier"
        APP1[ccflare Instance 1]
        APP2[ccflare Instance 2]
        APP3[ccflare Instance N]
    end
    
    subgraph "Data Tier"
        REDIS[(Redis Cache)]
        PG[(PostgreSQL)]
        S3[S3-Compatible<br/>Log Storage]
        CONSUL[Consul<br/>Agent Registry]
    end
    
    subgraph "Monitoring"
        PROM[Prometheus]
        GRAF[Grafana]
        SENTRY[Sentry]
    end
    
    LB1 --> APP1
    LB1 --> APP2
    LB1 --> APP3
    
    APP1 --> REDIS
    APP2 --> REDIS
    APP3 --> REDIS
    
    APP1 --> PG
    APP2 --> PG
    APP3 --> PG
    
    APP1 --> S3
    APP2 --> S3
    APP3 --> S3
    
    APP1 --> CONSUL
    APP2 --> CONSUL
    APP3 --> CONSUL
    
    APP1 --> PROM
    APP2 --> PROM
    APP3 --> PROM
    
    PROM --> GRAF
    APP1 --> SENTRY
    APP2 --> SENTRY
    APP3 --> SENTRY
```

## Monorepo Benefits

1. **Code Sharing**: Packages can be easily shared between applications
2. **Atomic Changes**: Related changes across packages can be committed together
3. **Consistent Tooling**: Single set of build tools and configurations
4. **Simplified Dependencies**: Internal packages are linked, not published
5. **Better Refactoring**: Easy to move code between packages

## Development Workflow

1. **Local Development**: `bun dev` starts all necessary services
2. **Testing**: Per-package tests with shared test utilities
3. **Building**: Bun handles build orchestration
4. **Type Safety**: TypeScript project references ensure type consistency
5. **Linting/Formatting**: Biome provides consistent code style
6. **Agent Development**: Drop markdown files in agent directories

## Recent Architectural Changes

### Version 2.0 Enhancements (Current)

1. **Asynchronous Database Operations**
   - Added AsyncDbWriter for non-blocking database writes
   - Improved request throughput by preventing database bottlenecks
   - Graceful shutdown with queue flushing

2. **Streaming Response Analytics**
   - Implemented stream teeing for response capture
   - Configurable buffer sizes for memory management
   - Partial response logging for debugging

3. **Enhanced Analytics API**
   - Advanced filtering by accounts, models, and status
   - Time-based bucketing for different time ranges
   - Comprehensive performance metrics per model
   - Cost analysis and token breakdown

4. **Request Handling Improvements**
   - Small request body buffering for retry scenarios
   - Better error handling and payload capture
   - Streaming response support with minimal overhead

5. **Configuration Enhancements**
   - New `streamBodyMaxBytes` setting
   - Environment variable support for all settings
   - Dynamic configuration updates without restart

6. **Agent System**
   - Automatic agent discovery from workspaces
   - System prompt-based agent detection
   - Per-agent model preferences
   - Workspace persistence and management

7. **Unified TUI/CLI**
   - Single binary for all terminal interactions
   - Auto-server startup in interactive mode
   - Comprehensive CLI commands
   - Performance analysis tools

8. **Enhanced Error Handling**
   - Centralized error utilities
   - Type-safe error detection
   - User-friendly error formatting

9. **UI Improvements**
   - Agent management interface
   - Model preference configuration
   - Enhanced analytics visualizations
   - Consistent formatting utilities
</file>

<file path="packages/agents/src/discovery.ts">
import { existsSync } from "node:fs";
import { readdir, readFile, writeFile } from "node:fs/promises";
import { basename, join, resolve } from "node:path";
import { Config } from "@ccflare/config";
import { Logger } from "@ccflare/logger";
import {
	type Agent,
	type AgentTool,
	type AgentWorkspace,
	ALLOWED_MODELS,
	type AllowedModel,
} from "@ccflare/types";
import { getAgentsDirectory } from "./paths";
import { workspacePersistence } from "./workspace-persistence";

interface AgentCache {
	agents: Agent[];
	timestamp: number;
}

const CACHE_TTL_MS = 30 * 1000; // 30 seconds
const DEFAULT_COLOR = "gray";

const log = new Logger("AgentRegistry");

export class AgentRegistry {
	private cache: AgentCache | null = null;
	private workspaces: Map<string, AgentWorkspace> = new Map();
	private initialized = false;
	private config: Config;

	constructor() {
		this.config = new Config();
	}

	// Initialize the registry (load persisted workspaces)
	async initialize(): Promise<void> {
		if (this.initialized) return;

		try {
			const savedWorkspaces = await workspacePersistence.loadWorkspaces();
			for (const workspace of savedWorkspaces) {
				this.workspaces.set(workspace.path, workspace);
			}
			log.info(
				`Initialized with ${savedWorkspaces.length} persisted workspaces`,
			);
			this.initialized = true;

			// Load agents from all workspaces
			if (savedWorkspaces.length > 0) {
				await this.loadAgents();
			}
		} catch (error) {
			log.error("Failed to initialize agent registry:", error);
			this.initialized = true; // Mark as initialized even on error
		}
	}

	private isValidModel(model: string): model is AllowedModel {
		return ALLOWED_MODELS.includes(model as AllowedModel);
	}

	private async loadAgentFromFile(
		filePath: string,
		source: "global" | "workspace",
		workspace?: string,
	): Promise<Agent | null> {
		try {
			const content = await readFile(filePath, "utf-8");

			// Extract frontmatter manually
			const frontmatterMatch = content.match(
				/^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/,
			);
			if (!frontmatterMatch) {
				log.error(`No valid frontmatter found in ${filePath}`);
				return null;
			}

			const frontmatterContent = frontmatterMatch[1];
			const systemPrompt = frontmatterMatch[2];

			// Parse frontmatter into a data object
			const data: Record<string, string> = {};
			const lines = frontmatterContent.split("\n");
			let currentKey = "";
			let currentValue = "";

			for (const line of lines) {
				// Check if this line starts a new key-value pair
				const keyMatch = line.match(/^(\w+):\s*(.*)$/);
				if (keyMatch) {
					// Save previous key-value pair if exists
					if (currentKey) {
						data[currentKey] = currentValue.trim();
					}
					// Start new key-value pair
					currentKey = keyMatch[1];
					currentValue = keyMatch[2];
				} else if (currentKey && line.trim()) {
					// This is a continuation of the previous value
					currentValue += ` ${line.trim()}`;
				}
			}
			// Save the last key-value pair
			if (currentKey) {
				data[currentKey] = currentValue.trim();
			}

			// Validate required fields
			if (!data.name || !data.description) {
				log.warn(
					`Agent file ${filePath} missing required fields (name, description)`,
				);
				return null;
			}

			// Parse and validate model
			const defaultModel = this.config.getDefaultAgentModel();
			let model: AllowedModel = defaultModel as AllowedModel;

			// Handle shorthand model names
			if (data.model) {
				const modelLower = data.model.toLowerCase();
				if (modelLower === "opus") {
					model = ALLOWED_MODELS[0]; // claude-opus-4-20250514
				} else if (modelLower === "sonnet") {
					model = ALLOWED_MODELS[1]; // claude-sonnet-4-20250514
				} else if (this.isValidModel(data.model)) {
					model = data.model as AllowedModel;
				} else {
					log.warn(
						`Agent file ${filePath} has invalid model: ${data.model}. Using default.`,
					);
				}
			}

			// Parse tools from frontmatter
			let tools: AgentTool[] | undefined;
			if (data.tools) {
				tools = data.tools
					.split(",")
					.map((t: string) => t.trim() as AgentTool)
					.filter(Boolean);
			}

			const id = basename(filePath, ".md");

			return {
				id,
				name: data.name,
				description: data.description,
				color: data.color || DEFAULT_COLOR,
				model,
				systemPrompt: systemPrompt.trim(),
				source,
				workspace,
				tools,
				filePath,
			};
		} catch (error) {
			log.error(`Error loading agent from ${filePath}:`, error);
			return null;
		}
	}

	async loadAgents(): Promise<void> {
		const agents: Agent[] = [];
		const seenIds = new Set<string>();

		// Load global agents
		const globalDir = getAgentsDirectory();
		if (existsSync(globalDir)) {
			try {
				const files = await readdir(globalDir);
				const mdFiles = files.filter((file) => file.endsWith(".md"));

				for (const file of mdFiles) {
					const filePath = join(globalDir, file);
					const agent = await this.loadAgentFromFile(filePath, "global");

					if (agent) {
						if (seenIds.has(agent.id)) {
							log.warn(
								`Duplicate agent id ${agent.id} found in ${filePath} - keeping first occurrence`,
							);
							continue;
						}

						seenIds.add(agent.id);
						agents.push(agent);
					}
				}

				log.info(`Loaded ${mdFiles.length} global agents from ${globalDir}`);
			} catch (error) {
				log.error(`Error loading global agents from ${globalDir}:`, error);
			}
		}

		// Load workspace agents
		for (const [workspacePath, workspace] of this.workspaces) {
			const workspaceAgentsDir = join(workspacePath, ".claude", "agents");

			if (!existsSync(workspaceAgentsDir)) {
				log.debug(
					`Workspace agents directory does not exist: ${workspaceAgentsDir}`,
				);
				continue;
			}

			try {
				const files = await readdir(workspaceAgentsDir);
				const mdFiles = files.filter((file) => file.endsWith(".md"));

				for (const file of mdFiles) {
					const filePath = join(workspaceAgentsDir, file);
					const agent = await this.loadAgentFromFile(
						filePath,
						"workspace",
						workspacePath,
					);

					if (agent) {
						// For workspace agents, prefix the ID with workspace path to ensure uniqueness
						const workspaceAgentId = `${workspace.name}:${agent.id}`;

						if (seenIds.has(workspaceAgentId)) {
							log.warn(
								`Duplicate agent id ${workspaceAgentId} found in ${filePath} - keeping first occurrence`,
							);
							continue;
						}

						// Update the agent ID to include workspace prefix
						agent.id = workspaceAgentId;
						seenIds.add(workspaceAgentId);
						agents.push(agent);
					}
				}

				log.info(
					`Loaded ${mdFiles.length} agents from workspace ${workspace.name} (${workspacePath})`,
				);
			} catch (error) {
				log.error(
					`Error loading agents from workspace ${workspacePath}:`,
					error,
				);
			}
		}

		this.cache = { agents, timestamp: Date.now() };
		log.info(
			`Total agents loaded: ${agents.length} (${agents.filter((a) => a.source === "global").length} global, ${agents.filter((a) => a.source === "workspace").length} workspace)`,
		);
	}

	async getAgents(): Promise<Agent[]> {
		// Ensure we're initialized
		await this.initialize();

		// Check if cache is valid
		if (this.cache && Date.now() - this.cache.timestamp < CACHE_TTL_MS) {
			return this.cache.agents;
		}

		// Reload agents
		await this.loadAgents();
		return this.cache?.agents || [];
	}

	async findAgentByPrompt(systemPrompt: string): Promise<Agent | undefined> {
		const agents = await this.getAgents();

		// Normalize the prompt for comparison
		const normalizedPrompt = systemPrompt.trim();

		return agents.find((agent) => {
			// Check if the agent's system prompt is contained within the provided prompt
			// This handles cases where the agent prompt is part of a larger system prompt
			return normalizedPrompt.includes(agent.systemPrompt);
		});
	}

	// Force reload agents (useful for testing or manual refresh)
	async refresh(): Promise<void> {
		this.cache = null;
		await this.loadAgents();
	}

	// Register a workspace
	async registerWorkspace(workspacePath: string): Promise<void> {
		const normalizedPath = resolve(workspacePath);

		// Check if this workspace is already registered
		if (this.workspaces.has(normalizedPath)) {
			// Update last seen time
			const workspace = this.workspaces.get(normalizedPath);
			if (workspace) {
				workspace.lastSeen = Date.now();
			}
			return;
		}

		// Extract workspace name from path
		const pathParts = normalizedPath.split("/");
		const workspaceName = pathParts[pathParts.length - 1] || "workspace";

		// Create new workspace entry
		const workspace: AgentWorkspace = {
			path: normalizedPath,
			name: workspaceName,
			lastSeen: Date.now(),
		};

		this.workspaces.set(normalizedPath, workspace);
		log.info(`Registered workspace: ${workspaceName} at ${normalizedPath}`);

		// Save workspaces to disk
		await this.saveWorkspaces();

		// Refresh to load agents from the new workspace
		await this.refresh();
	}

	// Get current workspaces
	getWorkspaces(): AgentWorkspace[] {
		return Array.from(this.workspaces.values());
	}

	// Save workspaces to disk
	private async saveWorkspaces(): Promise<void> {
		try {
			await workspacePersistence.saveWorkspaces(this.getWorkspaces());
		} catch (error) {
			log.error("Failed to save workspaces:", error);
		}
	}

	// Clear all workspaces (useful for testing)
	async clearWorkspaces(): Promise<void> {
		this.workspaces.clear();
		this.cache = null;
		await this.saveWorkspaces();
		log.info("Cleared all workspaces");
	}

	// Remove old workspaces that haven't been seen recently (e.g., 7 days)
	async pruneOldWorkspaces(
		maxAgeMs: number = 7 * 24 * 60 * 60 * 1000,
	): Promise<void> {
		const now = Date.now();
		const toRemove: string[] = [];

		for (const [path, workspace] of this.workspaces) {
			if (now - workspace.lastSeen > maxAgeMs) {
				toRemove.push(path);
			}
		}

		for (const path of toRemove) {
			this.workspaces.delete(path);
			log.info(`Removed stale workspace: ${path}`);
		}

		if (toRemove.length > 0) {
			this.cache = null; // Clear cache to force reload
			await this.saveWorkspaces();
		}
	}

	// Update an agent in the filesystem
	async updateAgent(
		agentId: string,
		updates: Partial<
			Pick<Agent, "description" | "model" | "tools" | "color" | "systemPrompt">
		>,
		dbOps?: { deleteAgentPreference: (agentId: string) => boolean },
	): Promise<Agent> {
		// Ensure we're initialized
		await this.initialize();

		// Find the agent
		const agents = await this.getAgents();
		const agent = agents.find((a) => a.id === agentId);
		if (!agent) {
			throw new Error(`Agent with id ${agentId} not found`);
		}

		// Prepare front-matter updates
		const frontMatterUpdates: Record<string, unknown> = {};

		if (updates.description !== undefined) {
			frontMatterUpdates.description = updates.description;
		}
		if (updates.model !== undefined) {
			frontMatterUpdates.model = updates.model;
		}
		if (updates.tools !== undefined) {
			if (updates.tools.length === 0) {
				// Remove tools property entirely for "all" mode
				frontMatterUpdates.tools = undefined;
			} else {
				frontMatterUpdates.tools = updates.tools.join(", ");
			}
		}
		if (updates.color !== undefined) {
			frontMatterUpdates.color = updates.color;
		}

		// Reconstruct the agent file
		const currentContent = await readFile(agent.filePath, "utf-8");
		const frontmatterMatch = currentContent.match(
			/^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/,
		);

		if (!frontmatterMatch) {
			throw new Error(`Invalid agent file format: ${agent.filePath}`);
		}

		// Parse existing frontmatter
		const existingFrontmatter = frontmatterMatch[1];
		const existingData: Record<string, string> = {};
		const lines = existingFrontmatter.split("\n");
		let currentKey = "";
		let currentValue = "";

		for (const line of lines) {
			const keyMatch = line.match(/^(\w+):\s*(.*)$/);
			if (keyMatch) {
				if (currentKey) {
					existingData[currentKey] = currentValue.trim();
				}
				currentKey = keyMatch[1];
				currentValue = keyMatch[2];
			} else if (currentKey && line.trim()) {
				currentValue += ` ${line.trim()}`;
			}
		}
		if (currentKey) {
			existingData[currentKey] = currentValue.trim();
		}

		// Apply updates to frontmatter
		if (updates.description !== undefined) {
			existingData.description = updates.description;
		}
		if (updates.model !== undefined) {
			existingData.model = updates.model;
		}
		if (updates.tools !== undefined) {
			if (updates.tools.length === 0) {
				delete existingData.tools;
			} else {
				existingData.tools = updates.tools.join(", ");
			}
		}
		if (updates.color !== undefined) {
			existingData.color = updates.color;
		}

		// Reconstruct frontmatter with proper formatting
		const newFrontmatter = Object.entries(existingData)
			.map(([key, value]) => `${key}: ${value}`)
			.join("\n");

		// Use updated system prompt or existing one
		const newSystemPrompt =
			updates.systemPrompt !== undefined
				? updates.systemPrompt
				: frontmatterMatch[2].trim();

		// Write the updated file
		const newContent = `---\n${newFrontmatter}\n---\n\n${newSystemPrompt}`;
		await writeFile(agent.filePath, newContent, "utf-8");

		// If model was updated, clear any database preference to avoid conflicts
		if (updates.model && dbOps?.deleteAgentPreference) {
			try {
				dbOps.deleteAgentPreference(agentId);
			} catch (error) {
				log.warn(`Failed to clear agent preference for ${agentId}:`, error);
			}
		}

		// Force cache refresh
		await this.refresh();

		// Return updated agent
		const updatedAgents = await this.getAgents();
		const updatedAgent = updatedAgents.find((a) => a.id === agentId);
		if (!updatedAgent) {
			throw new Error(`Failed to reload updated agent ${agentId}`);
		}

		return updatedAgent;
	}
}

// Create singleton instance
export const agentRegistry = new AgentRegistry();
</file>

<file path="packages/config/src/index.ts">
import { EventEmitter } from "node:events";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname } from "node:path";
import {
	DEFAULT_AGENT_MODEL,
	DEFAULT_STRATEGY,
	isValidStrategy,
	NETWORK,
	type StrategyName,
	TIME_CONSTANTS,
} from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import { resolveConfigPath } from "./paths";

const log = new Logger("Config");

export interface RuntimeConfig {
	clientId: string;
	retry: { attempts: number; delayMs: number; backoff: number };
	sessionDurationMs: number;
	port: number;
}

export interface ConfigData {
	lb_strategy?: StrategyName;
	client_id?: string;
	retry_attempts?: number;
	retry_delay_ms?: number;
	retry_backoff?: number;
	session_duration_ms?: number;
	port?: number;
	default_agent_model?: string;
	data_retention_days?: number;
	request_retention_days?: number;
	[key: string]: string | number | boolean | undefined;
}

export class Config extends EventEmitter {
	private configPath: string;
	private data: ConfigData = {};

	constructor(configPath?: string) {
		super();
		this.configPath = configPath ?? resolveConfigPath();
		this.loadConfig();
	}

	private loadConfig(): void {
		if (existsSync(this.configPath)) {
			try {
				const content = readFileSync(this.configPath, "utf8");
				this.data = JSON.parse(content) as ConfigData;
			} catch (error) {
				log.error(`Failed to parse config file: ${error}`);
				this.data = {};
			}
		} else {
			// Create config directory if it doesn't exist
			const dir = dirname(this.configPath);
			mkdirSync(dir, { recursive: true });

			// Initialize with default config
			this.data = {
				lb_strategy: DEFAULT_STRATEGY,
			};
			this.saveConfig();
		}
	}

	private saveConfig(): void {
		try {
			const content = JSON.stringify(this.data, null, 2);
			writeFileSync(this.configPath, content, "utf8");
		} catch (error) {
			log.error(`Failed to save config file: ${error}`);
		}
	}

	get(
		key: string,
		defaultValue?: string | number | boolean,
	): string | number | boolean | undefined {
		if (key in this.data) {
			return this.data[key];
		}

		if (defaultValue !== undefined) {
			this.set(key, defaultValue);
			return defaultValue;
		}

		return undefined;
	}

	set(key: string, value: string | number | boolean): void {
		const oldValue = this.data[key];
		this.data[key] = value;
		this.saveConfig();

		// Emit change event
		this.emit("change", { key, oldValue, newValue: value });
	}

	getStrategy(): StrategyName {
		// First check environment variable
		const envStrategy = process.env.LB_STRATEGY;
		if (envStrategy && isValidStrategy(envStrategy)) {
			return envStrategy;
		}

		// Then check config file
		const configStrategy = this.data.lb_strategy;
		if (configStrategy && isValidStrategy(configStrategy)) {
			return configStrategy;
		}

		return DEFAULT_STRATEGY;
	}

	setStrategy(strategy: StrategyName): void {
		if (!isValidStrategy(strategy)) {
			throw new Error(`Invalid strategy: ${strategy}`);
		}
		this.set("lb_strategy", strategy);
	}

	getDefaultAgentModel(): string {
		// First check environment variable
		const envModel = process.env.DEFAULT_AGENT_MODEL;
		if (envModel) {
			return envModel;
		}

		// Then check config file
		const configModel = this.data.default_agent_model;
		if (configModel) {
			return configModel;
		}

		// Default to the centralized default agent model
		return DEFAULT_AGENT_MODEL;
	}

	setDefaultAgentModel(model: string): void {
		this.set("default_agent_model", model);
	}

	private clamp(n: number, min: number, max: number): number {
		return Math.max(min, Math.min(max, n));
	}

	getDataRetentionDays(): number {
		const fromEnv = process.env.DATA_RETENTION_DAYS;
		if (fromEnv) {
			const n = parseInt(fromEnv, 10);
			if (!Number.isNaN(n)) return this.clamp(n, 1, 365);
		}
		const fromFile = this.data.data_retention_days;
		if (typeof fromFile === "number") return this.clamp(fromFile, 1, 365);
		return 7;
	}

	setDataRetentionDays(days: number): void {
		const clamped = this.clamp(days, 1, 365);
		this.set("data_retention_days", clamped);
	}

	getRequestRetentionDays(): number {
		const fromEnv = process.env.REQUEST_RETENTION_DAYS;
		if (fromEnv) {
			const n = parseInt(fromEnv, 10);
			if (!Number.isNaN(n)) return this.clamp(n, 1, 3650);
		}
		const fromFile = this.data.request_retention_days;
		if (typeof fromFile === "number") return this.clamp(fromFile, 1, 3650);
		return 365; // default metadata retention
	}

	setRequestRetentionDays(days: number): void {
		const clamped = this.clamp(days, 1, 3650);
		this.set("request_retention_days", clamped);
	}

	getAllSettings(): Record<string, string | number | boolean | undefined> {
		// Include current strategy (which might come from env)
		return {
			...this.data,
			lb_strategy: this.getStrategy(),
			default_agent_model: this.getDefaultAgentModel(),
			data_retention_days: this.getDataRetentionDays(),
			request_retention_days: this.getRequestRetentionDays(),
		};
	}

	getRuntime(): RuntimeConfig {
		// Default values
		const defaults: RuntimeConfig = {
			clientId: "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
			retry: {
				attempts: 3,
				delayMs: TIME_CONSTANTS.RETRY_DELAY_DEFAULT,
				backoff: 2,
			},
			sessionDurationMs: TIME_CONSTANTS.SESSION_DURATION_DEFAULT,
			port: NETWORK.DEFAULT_PORT,
		};

		// Override with environment variables if present
		if (process.env.CLIENT_ID) {
			defaults.clientId = process.env.CLIENT_ID;
		}
		if (process.env.RETRY_ATTEMPTS) {
			defaults.retry.attempts = parseInt(process.env.RETRY_ATTEMPTS);
		}
		if (process.env.RETRY_DELAY_MS) {
			defaults.retry.delayMs = parseInt(process.env.RETRY_DELAY_MS);
		}
		if (process.env.RETRY_BACKOFF) {
			defaults.retry.backoff = parseFloat(process.env.RETRY_BACKOFF);
		}
		if (process.env.SESSION_DURATION_MS) {
			defaults.sessionDurationMs = parseInt(process.env.SESSION_DURATION_MS);
		}
		if (process.env.PORT) {
			defaults.port = parseInt(process.env.PORT);
		}

		// Override with config file settings if present
		if (this.data.client_id) {
			defaults.clientId = this.data.client_id;
		}
		if (typeof this.data.retry_attempts === "number") {
			defaults.retry.attempts = this.data.retry_attempts;
		}
		if (typeof this.data.retry_delay_ms === "number") {
			defaults.retry.delayMs = this.data.retry_delay_ms;
		}
		if (typeof this.data.retry_backoff === "number") {
			defaults.retry.backoff = this.data.retry_backoff;
		}
		if (typeof this.data.session_duration_ms === "number") {
			defaults.sessionDurationMs = this.data.session_duration_ms;
		}
		if (typeof this.data.port === "number") {
			defaults.port = this.data.port;
		}

		return defaults;
	}
}

// Re-export types
export type { StrategyName } from "@ccflare/core";
export { resolveConfigPath } from "./paths";
export { getPlatformConfigDir } from "./paths-common";
</file>

<file path="packages/core/src/pricing.ts">
import { promises as fs } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { TIME_CONSTANTS } from "./constants";
import { CLAUDE_MODEL_IDS, MODEL_DISPLAY_NAMES } from "./models";

export interface TokenBreakdown {
	inputTokens?: number;
	outputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
}

interface ModelCost {
	input: number;
	output: number;
	cache_read?: number;
	cache_write?: number;
}

interface ModelDef {
	id: string;
	name: string;
	cost?: ModelCost;
}

interface ApiResponse {
	[provider: string]: {
		models?: {
			[modelId: string]: ModelDef;
		};
	};
}

// Bundled fallback pricing for Anthropic models (dollars per 1M tokens)
const BUNDLED_PRICING: ApiResponse = {
	anthropic: {
		models: {
			[CLAUDE_MODEL_IDS.HAIKU_3_5]: {
				id: CLAUDE_MODEL_IDS.HAIKU_3_5,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.HAIKU_3_5],
				cost: {
					input: 0.8,
					output: 4,
					cache_read: 0.08,
					cache_write: 1,
				},
			},
			[CLAUDE_MODEL_IDS.SONNET_3_5]: {
				id: CLAUDE_MODEL_IDS.SONNET_3_5,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.SONNET_3_5],
				cost: {
					input: 3,
					output: 15,
					cache_read: 0.3,
					cache_write: 3.75,
				},
			},
			[CLAUDE_MODEL_IDS.SONNET_4]: {
				id: CLAUDE_MODEL_IDS.SONNET_4,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.SONNET_4],
				cost: {
					input: 3,
					output: 15,
					cache_read: 0.3,
					cache_write: 3.75,
				},
			},
			[CLAUDE_MODEL_IDS.OPUS_4]: {
				id: CLAUDE_MODEL_IDS.OPUS_4,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.OPUS_4],
				cost: {
					input: 15,
					output: 75,
					cache_read: 1.5,
					cache_write: 18.75,
				},
			},
			[CLAUDE_MODEL_IDS.OPUS_4_1]: {
				id: CLAUDE_MODEL_IDS.OPUS_4_1,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.OPUS_4_1],
				cost: {
					input: 15,
					output: 75,
					cache_read: 1.5,
					cache_write: 18.75,
				},
			},
		},
	},
};

interface Logger {
	warn(message: string, ...args: unknown[]): void;
}

class PriceCatalogue {
	private static instance: PriceCatalogue;
	private priceData: ApiResponse | null = null;
	private lastFetch = 0;
	private warnedModels = new Set<string>();
	private logger: Logger | null = null;

	private constructor() {}

	setLogger(logger: Logger): void {
		this.logger = logger;
	}

	static get(): PriceCatalogue {
		if (!PriceCatalogue.instance) {
			PriceCatalogue.instance = new PriceCatalogue();
		}
		return PriceCatalogue.instance;
	}

	private getCacheDir(): string {
		return join(tmpdir(), "ccflare");
	}

	private getCachePath(): string {
		return join(this.getCacheDir(), "models.dev.json");
	}

	private getCacheDurationMs(): number {
		const hours = Number(process.env.CF_PRICING_REFRESH_HOURS) || 24;
		return hours * TIME_CONSTANTS.HOUR;
	}

	private async ensureCacheDir(): Promise<void> {
		try {
			await fs.mkdir(this.getCacheDir(), { recursive: true });
		} catch (error) {
			this.logger?.warn("Failed to create cache directory: %s", error);
		}
	}

	private async loadFromCache(): Promise<ApiResponse | null> {
		try {
			const cachePath = this.getCachePath();
			const stats = await fs.stat(cachePath);
			const age = Date.now() - stats.mtime.getTime();

			if (age < this.getCacheDurationMs()) {
				const content = await fs.readFile(cachePath, "utf-8");
				return JSON.parse(content);
			}
		} catch {
			// Cache miss or error - that's ok
		}
		return null;
	}

	private async saveToCache(data: ApiResponse): Promise<void> {
		try {
			await this.ensureCacheDir();
			const cachePath = this.getCachePath();
			await fs.writeFile(cachePath, JSON.stringify(data, null, 2));
		} catch (error) {
			this.logger?.warn("Failed to save pricing cache: %s", error);
		}
	}

	private async fetchRemote(): Promise<ApiResponse | null> {
		if (process.env.CF_PRICING_OFFLINE === "1") {
			return null;
		}

		try {
			const response = await fetch("https://models.dev/api.json");
			if (!response.ok) {
				throw new Error(`HTTP ${response.status}: ${response.statusText}`);
			}
			const data = await response.json();
			await this.saveToCache(data);
			return data;
		} catch (error) {
			this.logger?.warn("Failed to fetch pricing data: %s", error);
			return null;
		}
	}

	async getPricing(): Promise<ApiResponse> {
		// Return cached data if available
		if (
			this.priceData &&
			Date.now() - this.lastFetch < this.getCacheDurationMs()
		) {
			return this.priceData;
		}

		// Always attempt to fetch fresh pricing first (once per process start)
		let data = await this.fetchRemote();

		// If remote fetch failed (offline or error), fall back to disk cache
		if (!data) {
			data = await this.loadFromCache();
		}

		// Fall back to bundled pricing
		if (!data) {
			data = BUNDLED_PRICING;
		}

		this.priceData = data;
		this.lastFetch = Date.now();
		return data;
	}

	warnOnce(modelId: string): void {
		if (!this.warnedModels.has(modelId)) {
			this.warnedModels.add(modelId);
			this.logger?.warn(
				"Price for model %s not found - cost set to 0",
				modelId,
			);
		}
	}
}

/**
 * Set the logger for pricing warnings
 */
export function setPricingLogger(logger: Logger): void {
	PriceCatalogue.get().setLogger(logger);
}

/**
 * Get the cost rate for a specific model and token type
 * @returns Cost in dollars per token (NOT per million)
 * @throws If model or cost type is unknown
 */
async function getCostRate(
	modelId: string,
	kind: "input" | "output" | "cache_read" | "cache_write",
): Promise<number> {
	const catalogue = PriceCatalogue.get();
	const pricing = await catalogue.getPricing();

	// Search all providers for the model
	for (const provider of Object.values(pricing)) {
		if (provider.models?.[modelId]) {
			const model = provider.models[modelId];
			if (!model.cost) {
				throw new Error(`Model ${modelId} has no cost information`);
			}

			const costKey =
				kind === "cache_read" || kind === "cache_write"
					? kind
					: kind === "input"
						? "input"
						: "output";
			const costPerMillion = model.cost[costKey];

			if (costPerMillion === undefined) {
				throw new Error(`Model ${modelId} has no ${kind} cost`);
			}

			// Convert from per-million to per-token
			return costPerMillion / 1_000_000;
		}
	}

	throw new Error(`Model ${modelId} not found in pricing catalogue`);
}

/**
 * Estimate the total cost in USD for a request based on token counts
 * @returns Cost in dollars (NOT per million)
 */
export async function estimateCostUSD(
	modelId: string,
	tokens: TokenBreakdown,
): Promise<number> {
	const catalogue = PriceCatalogue.get();

	try {
		let totalCost = 0;

		if (tokens.inputTokens) {
			const rate = await getCostRate(modelId, "input");
			totalCost += tokens.inputTokens * rate;
		}

		if (tokens.outputTokens) {
			const rate = await getCostRate(modelId, "output");
			totalCost += tokens.outputTokens * rate;
		}

		if (tokens.cacheReadInputTokens) {
			const rate = await getCostRate(modelId, "cache_read");
			totalCost += tokens.cacheReadInputTokens * rate;
		}

		if (tokens.cacheCreationInputTokens) {
			const rate = await getCostRate(modelId, "cache_write");
			totalCost += tokens.cacheCreationInputTokens * rate;
		}

		return totalCost;
	} catch (_error) {
		catalogue.warnOnce(modelId);
		return 0;
	}
}
</file>

<file path="packages/core/src/request-events.ts">
import { EventEmitter } from "node:events";

export type RequestStartEvt = {
	type: "start";
	id: string;
	timestamp: number;
	method: string;
	path: string;
	accountId: string | null;
	statusCode: number;
	agentUsed: string | null;
};

export type RequestSummaryEvt = {
	type: "summary";
	payload: import("@ccflare/types").RequestResponse;
};

export type RequestPayloadEvt = {
	type: "payload";
	payload: import("@ccflare/types").RequestPayload;
};

export type RequestEvt =
	| RequestStartEvt
	| RequestSummaryEvt
	| RequestPayloadEvt;

class RequestEventBus extends EventEmitter {}
export const requestEvents = new RequestEventBus();
</file>

<file path="packages/dashboard-web/src/components/accounts/AccountListItem.tsx">
import { AccountPresenter } from "@ccflare/ui-common";
import {
	AlertCircle,
	CheckCircle,
	Edit2,
	Pause,
	Play,
	Trash2,
} from "lucide-react";
import type { Account } from "../../api";
import { Button } from "../ui/button";
import { RateLimitProgress } from "./RateLimitProgress";

interface AccountListItemProps {
	account: Account;
	isActive?: boolean;
	onPauseToggle: (account: Account) => void;
	onRemove: (name: string) => void;
	onRename: (account: Account) => void;
}

export function AccountListItem({
	account,
	isActive = false,
	onPauseToggle,
	onRemove,
	onRename,
}: AccountListItemProps) {
	const presenter = new AccountPresenter(account);

	return (
		<div
			key={account.name}
			className={`p-4 border rounded-lg transition-colors space-y-4 ${
				isActive
					? "border-primary bg-primary/5 shadow-sm"
					: "border-border hover:border-muted-foreground/50"
			}`}
		>
			<div className="flex items-center justify-between">
				<div className="flex items-center gap-4">
					<div>
						<div className="flex items-center gap-2">
							<p className="font-medium">{account.name}</p>
							{isActive && (
								<span className="px-2 py-0.5 text-xs font-medium bg-primary text-primary-foreground rounded-full">
									Active
								</span>
							)}
						</div>
						<p className="text-sm text-muted-foreground">
							{account.provider} • {presenter.tierDisplay}
						</p>
					</div>
					<div className="flex items-center gap-2">
						{presenter.isRateLimited ? (
							<AlertCircle className="h-4 w-4 text-yellow-600" />
						) : (
							<CheckCircle className="h-4 w-4 text-green-600" />
						)}
						<span className="text-sm">{presenter.requestCount} requests</span>
						{presenter.isPaused && (
							<span className="text-sm text-muted-foreground">Paused</span>
						)}
						{!presenter.isPaused && presenter.rateLimitStatus !== "OK" && (
							<span className="text-sm text-destructive">
								{presenter.rateLimitStatus}
							</span>
						)}
					</div>
				</div>
				<div className="flex items-center gap-2">
					<Button
						variant="ghost"
						size="sm"
						onClick={() => onRename(account)}
						title="Rename account"
					>
						<Edit2 className="h-4 w-4" />
					</Button>
					<Button
						variant="ghost"
						size="sm"
						onClick={() => onPauseToggle(account)}
						title={account.paused ? "Resume account" : "Pause account"}
					>
						{account.paused ? (
							<Play className="h-4 w-4" />
						) : (
							<Pause className="h-4 w-4" />
						)}
					</Button>
					<Button
						variant="ghost"
						size="sm"
						onClick={() => onRemove(account.name)}
					>
						<Trash2 className="h-4 w-4" />
					</Button>
				</div>
			</div>
			{account.rateLimitReset && (
				<RateLimitProgress resetIso={account.rateLimitReset} />
			)}
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/conversation/Message.tsx">
import {
	type ContentBlock,
	ContentBlockType,
	type Role,
	type ToolResult,
	type ToolUse,
} from "@ccflare/types";
import type { LucideIcon } from "lucide-react";
import { Bot, FileText, Terminal, User } from "lucide-react";
import React from "react";
import { Badge } from "../ui/badge";
import { MessageBubble } from "./MessageBubble";
import { ThinkingBlock } from "./ThinkingBlock";
import { ToolResultBlock } from "./ToolResultBlock";
import { ToolUsageBlock } from "./ToolUsageBlock";

interface MessageProps {
	role: Role;
	content: string;
	contentBlocks?: ContentBlock[];
	tools?: ToolUse[];
	toolResults?: ToolResult[];
	cleanLineNumbers: (content: string) => string;
}

const ROLE_STYLES: Record<Role, { bg: string; Icon: LucideIcon }> = {
	user: { bg: "bg-primary text-primary-foreground", Icon: User },
	assistant: { bg: "bg-muted", Icon: Bot },
	system: { bg: "bg-orange-100 dark:bg-orange-900", Icon: Bot },
};

function MessageComponent({
	role,
	content,
	contentBlocks,
	tools,
	toolResults,
	cleanLineNumbers,
}: MessageProps) {
	const isRightAligned = role === "user";
	const thinkingBlock = contentBlocks?.find(
		(b) => b.type === ContentBlockType.Thinking,
	);
	const thinkingText =
		typeof thinkingBlock?.thinking === "string" ? thinkingBlock.thinking : "";
	const hasThinking =
		thinkingText && cleanLineNumbers(thinkingText).trim().length > 0;
	const cleanedContent =
		typeof content === "string" ? cleanLineNumbers(content).trim() : "";
	const hasTools = tools?.length || 0;
	const hasToolResults = toolResults?.length || 0;

	const roleStyle = ROLE_STYLES[role];
	const Icon = roleStyle.Icon;

	return (
		<div
			className={`flex gap-3 w-full ${isRightAligned ? "flex-row-reverse" : "flex-row"}`}
		>
			<div
				className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center ${roleStyle.bg}`}
			>
				<Icon className="w-4 h-4" />
			</div>

			<div
				className={`flex-1 min-w-0 ${isRightAligned ? "text-right" : "text-left"}`}
			>
				<div
					className={`inline-block max-w-[85%] ${isRightAligned ? "ml-auto" : "mr-auto"}`}
				>
					<div className="flex items-center gap-2 mb-1">
						<span className="text-xs font-medium text-muted-foreground">
							{role.charAt(0).toUpperCase() + role.slice(1)}
						</span>
						{hasThinking && (
							<Badge variant="secondary" className="text-xs">
								Thinking
							</Badge>
						)}
						{hasTools > 0 && (
							<Badge variant="outline" className="text-xs">
								<Terminal className="w-3 h-3 mr-1" />
								{hasTools} tool{hasTools > 1 ? "s" : ""} used
							</Badge>
						)}
						{hasToolResults > 0 && (
							<Badge variant="secondary" className="text-xs">
								<FileText className="w-3 h-3 mr-1" />
								{hasToolResults} result{hasToolResults > 1 ? "s" : ""}
							</Badge>
						)}
					</div>

					{/* Thinking block */}
					{hasThinking && thinkingBlock && (
						<div className="mb-2">
							<ThinkingBlock content={cleanLineNumbers(thinkingText)} />
						</div>
					)}

					{/* Main content */}
					{cleanedContent.length > 0 && (
						<MessageBubble role={role} content={cleanedContent} />
					)}

					{/* Tool usage */}
					{hasTools > 0 && (
						<div className="mt-2 space-y-2">
							{tools?.map((tool, index) => (
								<ToolUsageBlock
									key={`tool-${tool.id || tool.name}-${index}`}
									toolName={tool.name}
									input={tool.input}
								/>
							))}
						</div>
					)}

					{/* Tool results */}
					{hasToolResults > 0 && (
						<div className="mt-2 space-y-2">
							{toolResults?.map((result, index) => (
								<ToolResultBlock
									key={`result-${result.tool_use_id || index}`}
									content={
										typeof result.content === "string"
											? cleanLineNumbers(result.content)
											: ""
									}
								/>
							))}
						</div>
					)}
				</div>
			</div>
		</div>
	);
}

export const Message = React.memo(MessageComponent);
</file>

<file path="packages/dashboard-web/src/components/OverviewTab.tsx">
import {
	formatCost,
	formatNumber,
	formatPercentage,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import { format } from "date-fns";
import { Activity, CheckCircle, Clock, DollarSign, Zap } from "lucide-react";
import { useMemo, useState } from "react";
import { REFRESH_INTERVALS } from "../constants";
import { useAccounts, useAnalytics, useStats } from "../hooks/queries";
import { ChartsSection } from "./overview/ChartsSection";
import { DataRetentionCard } from "./overview/DataRetentionCard";
import { LoadingSkeleton } from "./overview/LoadingSkeleton";
import { MetricCard } from "./overview/MetricCard";
import { RateLimitInfo } from "./overview/RateLimitInfo";
import { SystemStatus } from "./overview/SystemStatus";
import { TimeRangeSelector } from "./overview/TimeRangeSelector";
import { StrategyCard } from "./StrategyCard";

export function OverviewTab() {
	// Fetch all data using React Query hooks
	const { data: stats, isLoading: statsLoading } = useStats(
		REFRESH_INTERVALS.default,
	);
	const [timeRange, setTimeRange] = useState("24h");
	const { data: analytics, isLoading: analyticsLoading } = useAnalytics(
		timeRange,
		{ accounts: [], models: [], status: "all" },
		"normal",
	);
	const { data: accounts, isLoading: accountsLoading } = useAccounts();

	const loading = statsLoading || analyticsLoading || accountsLoading;
	const combinedData =
		stats && analytics && accounts ? { stats, analytics, accounts } : null;

	// Transform time series data
	const timeSeriesData = useMemo(() => {
		if (!analytics) return [];
		return analytics.timeSeries.map((point) => ({
			time: format(new Date(point.ts), "HH:mm"),
			requests: point.requests,
			successRate: point.successRate,
			responseTime: Math.round(point.avgResponseTime),
			cost: point.costUsd.toFixed(2),
			tokensPerSecond: point.avgTokensPerSecond || 0,
		}));
	}, [analytics]);

	if (loading && !combinedData) {
		return <LoadingSkeleton />;
	}

	// Helper function to calculate percentage change
	function pctChange(current: number, previous: number): number | null {
		if (previous === 0) return null; // avoid division by zero
		return ((current - previous) / previous) * 100;
	}

	// Get trend period description based on time range
	function getTrendPeriod(range: string): string {
		switch (range) {
			case "1h":
				return "previous minute";
			case "6h":
				return "previous 5 minutes";
			case "24h":
				return "previous hour";
			case "7d":
				return "previous hour";
			case "30d":
				return "previous day";
			default:
				return "previous period";
		}
	}

	const trendPeriod = getTrendPeriod(timeRange);

	// Calculate percentage changes from time series data
	let deltaRequests: number | null = null;
	let deltaSuccessRate: number | null = null;
	let deltaResponseTime: number | null = null;
	let deltaCost: number | null = null;
	let deltaOutputSpeed: number | null = null;
	let trendRequests: "up" | "down" | "flat" = "flat";
	let trendSuccessRate: "up" | "down" | "flat" = "flat";
	let trendResponseTime: "up" | "down" | "flat" = "flat";
	let trendCost: "up" | "down" | "flat" = "flat";
	let trendOutputSpeed: "up" | "down" | "flat" = "flat";

	if (timeSeriesData.length >= 2) {
		const lastBucket = timeSeriesData[timeSeriesData.length - 1];
		const prevBucket = timeSeriesData[timeSeriesData.length - 2];

		// Calculate deltas
		deltaRequests = pctChange(lastBucket.requests, prevBucket.requests);
		deltaSuccessRate = pctChange(
			lastBucket.successRate,
			prevBucket.successRate,
		);
		// For response time, calculate normal percentage change
		deltaResponseTime = pctChange(
			lastBucket.responseTime,
			prevBucket.responseTime,
		);
		deltaCost = pctChange(
			Number.parseFloat(lastBucket.cost),
			Number.parseFloat(prevBucket.cost),
		);
		deltaOutputSpeed = pctChange(
			lastBucket.tokensPerSecond,
			prevBucket.tokensPerSecond,
		);

		// Determine trends
		trendRequests =
			deltaRequests !== null ? (deltaRequests >= 0 ? "up" : "down") : "flat";
		trendSuccessRate =
			deltaSuccessRate !== null
				? deltaSuccessRate >= 0
					? "up"
					: "down"
				: "flat";
		// For response time, higher is worse (positive change is bad)
		trendResponseTime =
			deltaResponseTime !== null
				? deltaResponseTime >= 0
					? "down"
					: "up"
				: "flat";
		// For cost, higher is bad (positive change is bad)
		trendCost = deltaCost !== null ? (deltaCost >= 0 ? "down" : "up") : "flat";
		// For output speed, higher is better
		trendOutputSpeed =
			deltaOutputSpeed !== null
				? deltaOutputSpeed >= 0
					? "up"
					: "down"
				: "flat";
	}

	// Use analytics data for model distribution
	const modelData =
		analytics?.modelDistribution?.map((model) => ({
			name: model.model || "Unknown",
			value: model.count,
		})) || [];

	// Use analytics data for account health
	const accountHealthData = analytics?.accountPerformance || [];

	return (
		<div className="space-y-6">
			{/* Header with Time Range Selector */}
			<div className="flex justify-between items-center">
				<h2 className="text-2xl font-semibold">Overview</h2>
				<TimeRangeSelector value={timeRange} onChange={setTimeRange} />
			</div>

			{/* Metrics Grid */}
			<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
				<MetricCard
					title="Total Requests"
					value={formatNumber(analytics?.totals.requests || 0)}
					change={deltaRequests !== null ? deltaRequests : undefined}
					trend={trendRequests}
					trendPeriod={trendPeriod}
					icon={Activity}
				/>
				<MetricCard
					title="Success Rate"
					value={formatPercentage(analytics?.totals.successRate || 0, 0)}
					change={deltaSuccessRate !== null ? deltaSuccessRate : undefined}
					trend={trendSuccessRate}
					trendPeriod={trendPeriod}
					icon={CheckCircle}
				/>
				<MetricCard
					title="Avg Response Time"
					value={`${Math.round(analytics?.totals.avgResponseTime || 0)}ms`}
					change={deltaResponseTime !== null ? deltaResponseTime : undefined}
					trend={trendResponseTime}
					trendPeriod={trendPeriod}
					icon={Clock}
				/>
				<MetricCard
					title="Total Cost"
					value={
						analytics?.totals.totalCostUsd
							? formatCost(analytics.totals.totalCostUsd)
							: "$0.0000"
					}
					change={deltaCost !== null ? deltaCost : undefined}
					trend={trendCost}
					trendPeriod={trendPeriod}
					icon={DollarSign}
				/>
				<MetricCard
					title="Output Speed"
					value={formatTokensPerSecond(analytics?.totals.avgTokensPerSecond)}
					change={deltaOutputSpeed !== null ? deltaOutputSpeed : undefined}
					trend={trendOutputSpeed}
					trendPeriod={trendPeriod}
					icon={Zap}
				/>
			</div>

			<ChartsSection
				timeSeriesData={timeSeriesData}
				modelData={modelData}
				accountHealthData={accountHealthData}
				loading={loading}
			/>

			<SystemStatus recentErrors={stats?.recentErrors} />

			{accounts && <RateLimitInfo accounts={accounts} />}

			{/* Configuration Row */}
			<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
				<StrategyCard />
				<DataRetentionCard />
			</div>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/lib/query-keys.ts">
export const queryKeys = {
	all: ["ccflare"] as const,
	accounts: () => [...queryKeys.all, "accounts"] as const,
	agents: () => [...queryKeys.all, "agents"] as const,
	stats: () => [...queryKeys.all, "stats"] as const,
	analytics: (
		timeRange?: string,
		filters?: unknown,
		viewMode?: string,
		modelBreakdown?: boolean,
	) =>
		[
			...queryKeys.all,
			"analytics",
			{ timeRange, filters, viewMode, modelBreakdown },
		] as const,
	requests: (limit?: number) =>
		[...queryKeys.all, "requests", { limit }] as const,
	requestDetails: (id: string) =>
		[...queryKeys.all, "requests", "detail", id] as const,
	logs: () => [...queryKeys.all, "logs"] as const,
	logHistory: () => [...queryKeys.all, "logs", "history"] as const,
	defaultAgentModel: () =>
		[...queryKeys.all, "config", "defaultAgentModel"] as const,
	systemPromptOverride: () =>
		[...queryKeys.all, "tools", "systemPromptOverride"] as const,
} as const;
</file>

<file path="packages/database/src/repositories/interceptor.repository.ts">
import { BaseRepository } from "./base.repository";

export interface InterceptorConfig {
	targetPrompt: string;
	replacementPrompt: string;
	toolsEnabled: boolean;
}

interface InterceptorRow {
	id: string;
	is_enabled: number;
	config: string;
}

export class InterceptorRepository extends BaseRepository<InterceptorRow> {
	getConfig(
		id: string,
	): { isEnabled: boolean; config: InterceptorConfig } | null {
		const row = super.get<InterceptorRow>(
			"SELECT id, is_enabled, config FROM interceptors WHERE id = ?",
			[id],
		);

		if (!row) {
			return null;
		}

		return {
			isEnabled: row.is_enabled === 1,
			config: JSON.parse(row.config) as InterceptorConfig,
		};
	}

	setConfig(id: string, isEnabled: boolean, config: InterceptorConfig): void {
		const configJson = JSON.stringify(config);
		const isEnabledInt = isEnabled ? 1 : 0;

		this.run(
			"INSERT OR REPLACE INTO interceptors (id, is_enabled, config) VALUES (?, ?, ?)",
			[id, isEnabledInt, configJson],
		);
	}

	/**
	 * Delete an interceptor configuration
	 */
	delete(id: string): boolean {
		const changes = this.runWithChanges(
			"DELETE FROM interceptors WHERE id = ?",
			[id],
		);
		return changes > 0;
	}
}
</file>

<file path="packages/http-api/src/handlers/agents-update.ts">
import { agentRegistry } from "@ccflare/agents";
import type { DatabaseOperations } from "@ccflare/database";
import { errorResponse, jsonResponse } from "@ccflare/http-common";
import type { AgentTool, AllowedModel } from "@ccflare/types";
import { ALLOWED_MODELS, TOOL_PRESETS } from "@ccflare/types";

type ToolMode = keyof typeof TOOL_PRESETS | "custom";

interface AgentUpdateRequest {
	description?: string;
	model?: AllowedModel;
	tools?: AgentTool[];
	color?: string;
	systemPrompt?: string;
	mode?: ToolMode;
}

export function createAgentUpdateHandler(dbOps: DatabaseOperations) {
	return async (req: Request, agentId: string): Promise<Response> => {
		try {
			const body = (await req.json()) as AgentUpdateRequest;

			// Validate individual pieces
			const updates: Partial<{
				description: string;
				model: AllowedModel;
				tools: AgentTool[];
				color: string;
				systemPrompt: string;
			}> = {};

			if (body.description !== undefined) {
				if (typeof body.description !== "string") {
					return errorResponse("Description must be a string");
				}
				updates.description = body.description;
			}

			if (body.model !== undefined) {
				if (!ALLOWED_MODELS.includes(body.model)) {
					return errorResponse(
						`Model must be one of: ${ALLOWED_MODELS.join(", ")}`,
					);
				}
				updates.model = body.model;
			}

			if (body.color !== undefined) {
				if (typeof body.color !== "string") {
					return errorResponse("Color must be a string");
				}
				updates.color = body.color;
			}

			if (body.systemPrompt !== undefined) {
				if (typeof body.systemPrompt !== "string") {
					return errorResponse("System prompt must be a string");
				}
				updates.systemPrompt = body.systemPrompt;
			}

			// Handle tools - either from mode or explicit tools array
			if (body.mode !== undefined) {
				if (body.mode === "custom") {
					if (!body.tools || !Array.isArray(body.tools)) {
						return errorResponse(
							"Tools array is required when mode is 'custom'",
						);
					}
					updates.tools = body.tools;
				} else if (body.mode in TOOL_PRESETS) {
					updates.tools = TOOL_PRESETS[body.mode];
				} else {
					return errorResponse(
						`Invalid mode. Must be one of: ${Object.keys(TOOL_PRESETS).join(", ")}, custom`,
					);
				}
			} else if (body.tools !== undefined) {
				if (!Array.isArray(body.tools)) {
					return errorResponse("Tools must be an array");
				}
				updates.tools = body.tools;
			}

			// Update agent using the registry
			const updated = await agentRegistry.updateAgent(agentId, updates, {
				deleteAgentPreference: (id: string) => dbOps.deleteAgentPreference(id),
			});

			return jsonResponse({ success: true, agent: updated });
		} catch (error) {
			if (error instanceof Error && error.message.includes("not found")) {
				return errorResponse(`Agent with id ${agentId} not found`);
			}
			console.error("Error updating agent:", error);
			return errorResponse("Failed to update agent");
		}
	};
}
</file>

<file path="packages/http-api/src/handlers/config.ts">
import type { Config } from "@ccflare/config";
import {
	DEFAULT_AGENT_MODEL,
	NETWORK,
	STRATEGIES,
	type StrategyName,
	TIME_CONSTANTS,
	validateNumber,
	validateString,
} from "@ccflare/core";
import { BadRequest, errorResponse, jsonResponse } from "@ccflare/http-common";
import type { ConfigResponse, RetentionSetRequest } from "../types";

/**
 * Create config handlers
 */
export function createConfigHandlers(config: Config) {
	return {
		/**
		 * Get all configuration settings
		 */
		getConfig: (): Response => {
			const settings = config.getAllSettings();
			const response: ConfigResponse = {
				lb_strategy: (settings.lb_strategy as string) || "round_robin",
				port: (settings.port as number) || NETWORK.DEFAULT_PORT,
				sessionDurationMs:
					(settings.sessionDurationMs as number) ||
					TIME_CONSTANTS.SESSION_DURATION_FALLBACK,
				default_agent_model:
					(settings.default_agent_model as string) || DEFAULT_AGENT_MODEL,
			};
			return jsonResponse(response);
		},

		/**
		 * Get current strategy
		 */
		getStrategy: (): Response => {
			const strategy = config.getStrategy();
			return jsonResponse({ strategy });
		},

		/**
		 * Update strategy
		 */
		setStrategy: async (req: Request): Promise<Response> => {
			const body = await req.json();

			// Validate strategy input
			const strategyValidation = validateString(body.strategy, "strategy", {
				required: true,
				allowedValues: STRATEGIES,
			});

			if (!strategyValidation) {
				return errorResponse(BadRequest("Strategy is required"));
			}

			const strategy = strategyValidation as StrategyName;
			config.setStrategy(strategy);

			return jsonResponse({ success: true, strategy });
		},

		/**
		 * Get available strategies
		 */
		getStrategies: (): Response => {
			return jsonResponse(STRATEGIES);
		},

		/**
		 * Get default agent model
		 */
		getDefaultAgentModel: (): Response => {
			const model = config.getDefaultAgentModel();
			return jsonResponse({ model });
		},

		/**
		 * Set default agent model
		 */
		setDefaultAgentModel: async (req: Request): Promise<Response> => {
			const body = await req.json();

			// Validate model input
			const modelValidation = validateString(body.model, "model", {
				required: true,
			});

			if (!modelValidation) {
				return errorResponse(BadRequest("Model is required"));
			}

			config.setDefaultAgentModel(modelValidation);

			return jsonResponse({ success: true, model: modelValidation });
		},

		/**
		 * Get current data retention in days
		 */
		getRetention: (): Response => {
			return jsonResponse({
				payloadDays: config.getDataRetentionDays(),
				requestDays: config.getRequestRetentionDays(),
			});
		},

		/**
		 * Set data retention in days
		 */
		setRetention: async (req: Request): Promise<Response> => {
			const body = (await req.json()) as RetentionSetRequest;
			let updated = false;
			if (body.payloadDays !== undefined) {
				const payloadDays = validateNumber(body.payloadDays, "payloadDays", {
					min: 1,
					max: 365,
					integer: true,
				});
				if (typeof payloadDays !== "number") {
					return errorResponse(BadRequest("Invalid 'payloadDays'"));
				}
				config.setDataRetentionDays(payloadDays);
				updated = true;
			}
			if (body.requestDays !== undefined) {
				const requestDays = validateNumber(body.requestDays, "requestDays", {
					min: 1,
					max: 3650,
					integer: true,
				});
				if (typeof requestDays !== "number") {
					return errorResponse(BadRequest("Invalid 'requestDays'"));
				}
				config.setRequestRetentionDays(requestDays);
				updated = true;
			}
			if (!updated) {
				return errorResponse(BadRequest("No retention fields provided"));
			}
			return new Response(null, { status: 204 });
		},
	};
}
</file>

<file path="packages/proxy/src/post-processor.worker.ts">
declare var self: Worker;

import { BUFFER_SIZES, estimateCostUSD, TIME_CONSTANTS } from "@ccflare/core";
import { AsyncDbWriter, DatabaseOperations } from "@ccflare/database";
import { Logger } from "@ccflare/logger";
import {
	NO_ACCOUNT_ID,
	type RequestPayload,
	type RequestResponse,
} from "@ccflare/types";
import { formatCost } from "@ccflare/ui-common";
import { get_encoding } from "@dqbd/tiktoken";
import { combineChunks } from "./stream-tee";
import type {
	ChunkMessage,
	EndMessage,
	PayloadMessage,
	StartMessage,
	SummaryMessage,
	WorkerMessage,
} from "./worker-messages";

interface RequestState {
	startMessage: StartMessage;
	buffer: string;
	chunks: Uint8Array[];
	usage: {
		model?: string;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
		outputTokensComputed?: number;
		totalTokens?: number;
		costUsd?: number;
		tokensPerSecond?: number;
	};
	lastActivity: number;
	agentUsed?: string;
	firstTokenTimestamp?: number;
	lastTokenTimestamp?: number;
	providerFinalOutputTokens?: number;
	shouldSkipLogging?: boolean;
}

const log = new Logger("PostProcessor");
const requests = new Map<string, RequestState>();

// Initialize tiktoken encoder (cl100k_base is used for Claude models)
const tokenEncoder = get_encoding("cl100k_base");

// Initialize database connection for worker
const dbOps = new DatabaseOperations();
const asyncWriter = new AsyncDbWriter();

// Environment variables
const MAX_BUFFER_SIZE =
	Number(
		process.env.CF_STREAM_USAGE_BUFFER_KB ||
			BUFFER_SIZES.STREAM_USAGE_BUFFER_KB,
	) * 1024;
const TIMEOUT_MS = Number(
	process.env.CF_STREAM_TIMEOUT_MS || TIME_CONSTANTS.STREAM_TIMEOUT_DEFAULT,
);

// Check if a request should be logged
function shouldLogRequest(path: string, status: number): boolean {
	// Skip logging .well-known 404s
	if (path.startsWith("/.well-known/") && status === 404) {
		return false;
	}
	return true;
}

// Extract system prompt from request body
function _extractSystemPrompt(requestBody: string | null): string | null {
	if (!requestBody) return null;

	try {
		// Decode base64 request body
		const decodedBody = Buffer.from(requestBody, "base64").toString("utf-8");
		const parsed = JSON.parse(decodedBody);

		// Check if there's a system property in the request
		if (parsed.system) {
			// Handle both string and array formats
			if (typeof parsed.system === "string") {
				return parsed.system;
			} else if (Array.isArray(parsed.system)) {
				// Concatenate all text from system messages
				return parsed.system
					.filter(
						(item: { type?: string; text?: string }) =>
							item.type === "text" && item.text,
					)
					.map((item: { type?: string; text?: string }) => item.text)
					.join("\n");
			}
		}
	} catch (error) {
		log.debug("Failed to extract system prompt:", error);
	}

	return null;
}

// Parse SSE lines to extract usage (reuse existing logic)
function parseSSELine(line: string): { event?: string; data?: string } {
	if (line.startsWith("event: ")) {
		return { event: line.slice(7).trim() };
	}
	if (line.startsWith("data: ")) {
		return { data: line.slice(6).trim() };
	}
	return {};
}

// Extract usage data from non-stream JSON response bodies
function extractUsageFromJson(
	json: {
		model?: string;
		usage?: {
			input_tokens?: number;
			cache_read_input_tokens?: number;
			cache_creation_input_tokens?: number;
			output_tokens?: number;
		};
	},
	state: RequestState,
): void {
	if (!json) return;

	const usageObj = json.usage;
	if (!usageObj) return;

	state.usage.model = json.model ?? state.usage.model;

	state.usage.inputTokens = usageObj.input_tokens ?? 0;
	state.usage.cacheReadInputTokens = usageObj.cache_read_input_tokens ?? 0;
	state.usage.cacheCreationInputTokens =
		usageObj.cache_creation_input_tokens ?? 0;
	state.usage.outputTokens = usageObj.output_tokens ?? 0;

	// Calculate total tokens
	const prompt =
		(state.usage.inputTokens ?? 0) +
		(state.usage.cacheReadInputTokens ?? 0) +
		(state.usage.cacheCreationInputTokens ?? 0);
	const completion = state.usage.outputTokens ?? 0;
	state.usage.totalTokens = prompt + completion;
}

function extractUsageFromData(data: string, state: RequestState): void {
	try {
		const parsed = JSON.parse(data);

		// Handle message_start
		if (parsed.type === "message_start" && parsed.message?.usage) {
			const usage = parsed.message.usage;
			state.usage.inputTokens = usage.input_tokens || 0;
			state.usage.cacheReadInputTokens = usage.cache_read_input_tokens || 0;
			state.usage.cacheCreationInputTokens =
				usage.cache_creation_input_tokens || 0;
			state.usage.outputTokens = usage.output_tokens || 0;
			if (parsed.message?.model) {
				state.usage.model = parsed.message.model;
			}
		}

		// Track streaming start time on first content block
		if (parsed.type === "content_block_start" && !state.firstTokenTimestamp) {
			state.firstTokenTimestamp = Date.now();
		}

		// Handle message_delta - provider's authoritative output token count AND end time
		if (parsed.type === "message_delta") {
			state.lastTokenTimestamp = Date.now();

			if (parsed.usage?.output_tokens !== undefined) {
				state.providerFinalOutputTokens = parsed.usage.output_tokens;
				state.usage.outputTokens = parsed.usage.output_tokens;
				return; // No further processing needed
			}
		}

		// Count tokens locally as fallback (but provider's count takes precedence)
		if (
			parsed.type === "content_block_delta" &&
			parsed.delta &&
			state.providerFinalOutputTokens === undefined // Avoid double counting
		) {
			let textToCount: string | undefined;

			// Extract text from different delta types
			if (parsed.delta.type === "text_delta" && parsed.delta.text) {
				textToCount = parsed.delta.text;
			} else if (
				parsed.delta.type === "thinking_delta" &&
				parsed.delta.thinking
			) {
				textToCount = parsed.delta.thinking;
			}

			if (textToCount) {
				// Count tokens using tiktoken
				try {
					const tokens = tokenEncoder.encode(textToCount);
					state.usage.outputTokensComputed =
						(state.usage.outputTokensComputed || 0) + tokens.length;
				} catch (err) {
					log.debug("Failed to count tokens:", err);
				}
			}
		}

		// Handle any usage field in the data
		if (parsed.usage) {
			if (parsed.usage.input_tokens !== undefined) {
				state.usage.inputTokens = parsed.usage.input_tokens;
			}
			if (parsed.usage.output_tokens !== undefined) {
				state.usage.outputTokens = parsed.usage.output_tokens;
			}
			if (parsed.usage.cache_read_input_tokens !== undefined) {
				state.usage.cacheReadInputTokens = parsed.usage.cache_read_input_tokens;
			}
			if (parsed.usage.cache_creation_input_tokens !== undefined) {
				state.usage.cacheCreationInputTokens =
					parsed.usage.cache_creation_input_tokens;
			}
		}
	} catch {
		// Silent fail for non-JSON lines
	}
}

function processStreamChunk(chunk: Uint8Array, state: RequestState): void {
	const text = new TextDecoder().decode(chunk);
	state.buffer += text;
	state.lastActivity = Date.now();

	// Limit buffer size
	if (state.buffer.length > MAX_BUFFER_SIZE) {
		state.buffer = state.buffer.slice(-MAX_BUFFER_SIZE);
	}

	// Process complete lines
	const lines = state.buffer.split("\n");
	state.buffer = lines.pop() || "";

	let currentEvent = "";
	for (const line of lines) {
		const trimmed = line.trim();
		if (!trimmed) continue;

		const parsed = parseSSELine(trimmed);
		if (parsed.event) {
			currentEvent = parsed.event;
		} else if (parsed.data && currentEvent) {
			extractUsageFromData(parsed.data, state);
		}
	}
}

async function handleStart(msg: StartMessage): Promise<void> {
	// Check if we should skip logging this request
	const shouldSkip = !shouldLogRequest(msg.path, msg.responseStatus);

	// Create request state
	const state: RequestState = {
		startMessage: msg,
		buffer: "",
		chunks: [],
		usage: {},
		lastActivity: Date.now(),
		shouldSkipLogging: shouldSkip,
	};

	// Use agent from message if provided
	if (msg.agentUsed) {
		state.agentUsed = msg.agentUsed;
		log.debug(`Agent '${msg.agentUsed}' used for request ${msg.requestId}`);
	}

	requests.set(msg.requestId, state);

	// Skip all database operations for ignored requests
	if (shouldSkip) {
		log.debug(`Skipping logging for ${msg.path} (${msg.responseStatus})`);
		return;
	}

	// Save minimal request info immediately
	asyncWriter.enqueue(() =>
		dbOps.saveRequestMeta(
			msg.requestId,
			msg.method,
			msg.path,
			msg.accountId,
			msg.responseStatus,
			msg.timestamp,
		),
	);

	// Update account usage if authenticated
	if (msg.accountId && msg.accountId !== NO_ACCOUNT_ID) {
		const accountId = msg.accountId; // Capture for closure
		asyncWriter.enqueue(() => dbOps.updateAccountUsage(accountId));
	}
}

function handleChunk(msg: ChunkMessage): void {
	const state = requests.get(msg.requestId);
	if (!state) {
		log.warn(`No state found for request ${msg.requestId}`);
		return;
	}

	// Store chunk for later payload saving
	state.chunks.push(msg.data);

	// Process for usage extraction
	processStreamChunk(msg.data, state);
}

async function handleEnd(msg: EndMessage): Promise<void> {
	const state = requests.get(msg.requestId);
	if (!state) {
		log.warn(`No state found for request ${msg.requestId}`);
		return;
	}

	const { startMessage } = state;
	const responseTime = Date.now() - startMessage.timestamp;

	// Skip all database operations for ignored requests
	if (state.shouldSkipLogging) {
		// Clean up state without logging
		requests.delete(msg.requestId);
		return;
	}

	// For non-stream responses, extract usage data from response body
	if (!state.usage.model && msg.responseBody) {
		try {
			const decoded = Buffer.from(msg.responseBody, "base64").toString("utf-8");
			const json = JSON.parse(decoded);
			extractUsageFromJson(json, state);
		} catch {
			// Ignore parse errors
		}
	}

	// Calculate total tokens and cost
	if (state.usage.model) {
		// Use provider's authoritative count if available, fallback to computed
		const finalOutputTokens =
			state.providerFinalOutputTokens ??
			state.usage.outputTokens ??
			state.usage.outputTokensComputed ??
			0;

		// Update usage with final values
		state.usage.outputTokens = finalOutputTokens;
		state.usage.outputTokensComputed = undefined; // Clear to avoid confusion

		state.usage.totalTokens =
			(state.usage.inputTokens || 0) +
			finalOutputTokens +
			(state.usage.cacheReadInputTokens || 0) +
			(state.usage.cacheCreationInputTokens || 0);

		state.usage.costUsd = await estimateCostUSD(state.usage.model, {
			inputTokens: state.usage.inputTokens,
			outputTokens: finalOutputTokens,
			cacheReadInputTokens: state.usage.cacheReadInputTokens,
			cacheCreationInputTokens: state.usage.cacheCreationInputTokens,
		});

		// Calculate tokens per second using actual streaming duration
		if (
			state.firstTokenTimestamp &&
			state.lastTokenTimestamp &&
			finalOutputTokens > 0
		) {
			const durationSec =
				(state.lastTokenTimestamp - state.firstTokenTimestamp) / 1000;
			if (durationSec > 0) {
				state.usage.tokensPerSecond = finalOutputTokens / durationSec;
			} else if (finalOutputTokens > 0) {
				// If tokens were generated instantly, use a very small duration
				state.usage.tokensPerSecond = finalOutputTokens / 0.001;
			}
		}
	}

	// Update request with final data
	asyncWriter.enqueue(() =>
		dbOps.saveRequest(
			startMessage.requestId,
			startMessage.method,
			startMessage.path,
			startMessage.accountId,
			startMessage.responseStatus,
			msg.success,
			msg.error || null,
			responseTime,
			startMessage.failoverAttempts,
			state.usage.model
				? {
						model: state.usage.model,
						promptTokens:
							(state.usage.inputTokens || 0) +
							(state.usage.cacheReadInputTokens || 0) +
							(state.usage.cacheCreationInputTokens || 0),
						completionTokens: state.usage.outputTokens,
						totalTokens: state.usage.totalTokens,
						costUsd: state.usage.costUsd,
						// Keep original breakdown for payload
						inputTokens: state.usage.inputTokens,
						outputTokens: state.usage.outputTokens,
						cacheReadInputTokens: state.usage.cacheReadInputTokens,
						cacheCreationInputTokens: state.usage.cacheCreationInputTokens,
						tokensPerSecond: state.usage.tokensPerSecond,
					}
				: undefined,
			state.agentUsed,
		),
	);

	// Save payload
	let responseBody: string | null = null;

	if (msg.responseBody) {
		// Non-streaming response
		responseBody = msg.responseBody;
	} else if (state.chunks.length > 0) {
		// Streaming response - combine chunks
		const combined = combineChunks(state.chunks);
		if (combined.length > 0) {
			responseBody = combined.toString("base64");
		}
	}

	const payload = {
		request: {
			headers: startMessage.requestHeaders,
			body: startMessage.requestBody,
		},
		response: {
			status: startMessage.responseStatus,
			headers: startMessage.responseHeaders,
			body: responseBody,
		},
		meta: {
			accountId: startMessage.accountId || NO_ACCOUNT_ID,
			timestamp: startMessage.timestamp,
			success: msg.success,
			isStream: startMessage.isStream,
			retry: startMessage.retryAttempt,
		},
	};

	asyncWriter.enqueue(() =>
		dbOps.saveRequestPayload(startMessage.requestId, payload),
	);

	// Log if we have usage
	if (state.usage.model && startMessage.accountId !== NO_ACCOUNT_ID) {
		log.info(
			`Usage for request ${startMessage.requestId}: Model: ${state.usage.model}, ` +
				`Tokens: ${state.usage.totalTokens || 0}, Cost: ${formatCost(state.usage.costUsd)}`,
		);
	}

	// Post summary to main thread for real-time updates
	const summary: RequestResponse = {
		id: startMessage.requestId,
		timestamp: new Date(startMessage.timestamp).toISOString(),
		method: startMessage.method,
		path: startMessage.path,
		accountUsed: startMessage.accountId,
		statusCode: startMessage.responseStatus,
		success: msg.success,
		errorMessage: msg.error || null,
		responseTimeMs: responseTime,
		failoverAttempts: startMessage.failoverAttempts,
		model: state.usage.model,
		promptTokens: state.usage.inputTokens,
		completionTokens: state.usage.outputTokens,
		totalTokens: state.usage.totalTokens,
		inputTokens: state.usage.inputTokens,
		cacheReadInputTokens: state.usage.cacheReadInputTokens,
		cacheCreationInputTokens: state.usage.cacheCreationInputTokens,
		outputTokens: state.usage.outputTokens,
		costUsd: state.usage.costUsd,
		agentUsed: state.agentUsed,
		tokensPerSecond: state.usage.tokensPerSecond,
	};

	self.postMessage({
		type: "summary",
		summary,
	} satisfies SummaryMessage);

	// Post full payload to main thread
	const fullPayload: RequestPayload = {
		id: startMessage.requestId,
		request: {
			headers: startMessage.requestHeaders,
			body: startMessage.requestBody,
		},
		response: {
			status: startMessage.responseStatus,
			headers: startMessage.responseHeaders,
			body: responseBody,
		},
		error: msg.error,
		meta: {
			accountId: startMessage.accountId || NO_ACCOUNT_ID,
			timestamp: startMessage.timestamp,
			success: msg.success,
			retry: startMessage.retryAttempt,
			path: startMessage.path,
			method: startMessage.method,
			agentUsed: state.agentUsed,
		},
	};

	self.postMessage({
		type: "payload",
		payload: fullPayload,
	} satisfies PayloadMessage);

	// Clean up
	requests.delete(msg.requestId);
}

async function handleShutdown(): Promise<void> {
	log.info("Worker shutting down, flushing async writer...");
	await asyncWriter.dispose();
	dbOps.close();
	// Worker will be terminated by main thread
}

// Periodic cleanup of stale requests (safety net for orphaned requests)
// This should rarely trigger as the main app handles timeouts
setInterval(() => {
	const now = Date.now();
	for (const [id, state] of requests) {
		if (now - state.lastActivity > TIMEOUT_MS) {
			log.warn(
				`Request ${id} appears orphaned (no activity for ${TIMEOUT_MS}ms), cleaning up...`,
			);
			handleEnd({
				type: "end",
				requestId: id,
				success: false,
				error: "Request orphaned - no activity",
			});
		}
	}
}, TIMEOUT_MS); // Check every TIMEOUT_MS

// Message handler
self.onmessage = async (event: MessageEvent<WorkerMessage>) => {
	const msg = event.data;

	switch (msg.type) {
		case "start":
			await handleStart(msg);
			break;
		case "chunk":
			handleChunk(msg);
			break;
		case "end":
			await handleEnd(msg);
			break;
		case "shutdown":
			await handleShutdown();
			break;
		default:
			log.warn(`Unknown message type: ${(msg as { type: string }).type}`);
	}
};
</file>

<file path="packages/proxy/src/response-handler.ts">
import { requestEvents } from "@ccflare/core";
import {
	sanitizeRequestHeaders,
	withSanitizedProxyHeaders,
} from "@ccflare/http-common";
import type { Account } from "@ccflare/types";
import type { ProxyContext } from "./handlers";
import type { ChunkMessage, EndMessage, StartMessage } from "./worker-messages";

/**
 * Check if a response should be considered successful/expected
 * Treats certain well-known paths that return 404 as expected
 */
function isExpectedResponse(path: string, response: Response): boolean {
	// Any .well-known path returning 404 is expected
	if (path.startsWith("/.well-known/") && response.status === 404) {
		return true;
	}

	// Otherwise use standard HTTP success logic
	return response.ok;
}

export interface ResponseHandlerOptions {
	requestId: string;
	method: string;
	path: string;
	account: Account | null;
	requestHeaders: Headers;
	requestBody: ArrayBuffer | null;
	response: Response;
	timestamp: number;
	retryAttempt: number;
	failoverAttempts: number;
	agentUsed?: string | null;
}

/**
 * Unified response handler that immediately streams responses
 * while forwarding data to worker for async processing
 */
// Forward response to client while streaming analytics to worker
export async function forwardToClient(
	options: ResponseHandlerOptions,
	ctx: ProxyContext,
): Promise<Response> {
	const {
		requestId,
		method,
		path,
		account,
		requestHeaders,
		requestBody,
		response: responseRaw,
		timestamp,
		retryAttempt, // Always 0 in new flow, but kept for message compatibility
		failoverAttempts,
		agentUsed,
	} = options;

	// Always strip compression headers *before* we do anything else
	const response = withSanitizedProxyHeaders(responseRaw);

	// Prepare objects once for serialisation - sanitize headers before storing
	const sanitizedReq = sanitizeRequestHeaders(requestHeaders);
	const requestHeadersObj = Object.fromEntries(sanitizedReq.entries());

	const responseHeadersObj = Object.fromEntries(response.headers.entries());

	const isStream = ctx.provider.isStreamingResponse?.(response) ?? false;

	// Send START message immediately
	const startMessage: StartMessage = {
		type: "start",
		requestId,
		accountId: account?.id || null,
		method,
		path,
		timestamp,
		requestHeaders: requestHeadersObj,
		requestBody: requestBody
			? Buffer.from(requestBody).toString("base64")
			: null,
		responseStatus: response.status,
		responseHeaders: responseHeadersObj,
		isStream,
		providerName: ctx.provider.name,
		agentUsed: agentUsed || null,
		retryAttempt,
		failoverAttempts,
	};
	ctx.usageWorker.postMessage(startMessage);

	// Emit request start event for real-time dashboard
	requestEvents.emit("event", {
		type: "start",
		id: requestId,
		timestamp,
		method,
		path,
		accountId: account?.id || null,
		statusCode: response.status,
		agentUsed: agentUsed || null,
	});

	/*********************************************************************
	 *  STREAMING RESPONSES — tee with Response.clone() and send chunks
	 *********************************************************************/
	if (isStream && response.body) {
		// Clone response once for background consumption.
		const analyticsClone = response.clone();

		(async () => {
			try {
				const reader = analyticsClone.body?.getReader();
				if (!reader) return; // Safety check
				// eslint-disable-next-line no-constant-condition
				while (true) {
					const { value, done } = await reader.read();
					if (done) break;
					if (value) {
						const chunkMsg: ChunkMessage = {
							type: "chunk",
							requestId,
							data: value,
						};
						ctx.usageWorker.postMessage(chunkMsg);
					}
				}
				// Finished without errors
				const endMsg: EndMessage = {
					type: "end",
					requestId,
					success: isExpectedResponse(path, analyticsClone),
				};
				ctx.usageWorker.postMessage(endMsg);
			} catch (err) {
				const endMsg: EndMessage = {
					type: "end",
					requestId,
					success: false,
					error: (err as Error).message,
				};
				ctx.usageWorker.postMessage(endMsg);
			}
		})();

		// Return the sanitized response
		return response;
	}

	/*********************************************************************
	 *  NON-STREAMING RESPONSES — read body in background, send END once
	 *********************************************************************/
	(async () => {
		try {
			const clone = response.clone();
			const bodyBuf = await clone.arrayBuffer();
			const endMsg: EndMessage = {
				type: "end",
				requestId,
				responseBody:
					bodyBuf.byteLength > 0
						? Buffer.from(bodyBuf).toString("base64")
						: null,
				success: isExpectedResponse(path, clone),
			};
			ctx.usageWorker.postMessage(endMsg);
		} catch (err) {
			const endMsg: EndMessage = {
				type: "end",
				requestId,
				success: false,
				error: (err as Error).message,
			};
			ctx.usageWorker.postMessage(endMsg);
		}
	})();

	// Return the sanitized response
	return response;
}
</file>

<file path="packages/types/src/agent.ts">
import { CLAUDE_MODEL_IDS } from "@ccflare/core";

export type AgentSource = "global" | "workspace";

export type AgentTool =
	| "Bash"
	| "Glob"
	| "Grep"
	| "LS"
	| "Read"
	| "Edit"
	| "MultiEdit"
	| "Write"
	| "NotebookRead"
	| "NotebookEdit"
	| "WebFetch"
	| "TodoWrite"
	| "WebSearch";

export interface AgentWorkspace {
	path: string;
	name: string;
	lastSeen: number; // timestamp
}

export interface Agent {
	id: string;
	name: string;
	description: string;
	color: string;
	model: AllowedModel;
	systemPrompt: string;
	source: AgentSource;
	workspace?: string; // workspace path if source is "workspace"
	tools?: AgentTool[]; // parsed from tools: front-matter
	filePath: string; // absolute path of the markdown file
}

export type AgentResponse = Agent[];

export const ALLOWED_MODELS = [
	CLAUDE_MODEL_IDS.OPUS_4,
	CLAUDE_MODEL_IDS.OPUS_4_1,
	CLAUDE_MODEL_IDS.SONNET_4,
] as const;

export type AllowedModel = (typeof ALLOWED_MODELS)[number];
</file>

<file path="packages/types/src/api.ts">
export interface RequestMeta {
	id: string;
	method: string;
	path: string;
	timestamp: number;
	agentUsed?: string | null;
}

export interface AgentUpdatePayload {
	description?: string;
	model?: string;
	tools?: string[];
	color?: string;
	systemPrompt?: string;
	mode?: "all" | "edit" | "read-only" | "execution" | "custom";
}

// Retention and maintenance API shapes
export interface RetentionGetResponse {
	payloadDays: number;
	requestDays: number;
}

export interface RetentionSetRequest {
	payloadDays?: number;
	requestDays?: number;
}

export interface CleanupResponse {
	removedRequests: number;
	removedPayloads: number;
	cutoffIso: string;
}

export interface CompactResponse {
	ok: boolean;
}
</file>

<file path="packages/ui-common/src/parsers/parse-conversation.ts">
import {
	ContentBlockType,
	type MessageData,
	type ToolUse,
} from "@ccflare/types";
import { normalizeText } from "../utils/normalize-text";

export function parseRequestMessages(body: string | null): MessageData[] {
	if (!body) return [];

	try {
		const parsed = JSON.parse(body);
		if (!parsed.messages || !Array.isArray(parsed.messages)) return [];

		return parsed.messages
			.map(
				(msg: {
					role: "user" | "assistant" | "system";
					content:
						| string
						| Array<{
								type: string;
								text?: string;
								thinking?: string;
								id?: string;
								name?: string;
								input?: Record<string, unknown>;
								tool_use_id?: string;
								content?: string | Array<{ type: string; text?: string }>;
						  }>;
				}): MessageData | null => {
					const message: MessageData = {
						role: msg.role,
						content: "",
						contentBlocks: [],
						tools: [],
						toolResults: [],
					};

					if (typeof msg.content === "string") {
						message.content = msg.content;
					} else if (Array.isArray(msg.content)) {
						// Process content blocks
						const textContents: string[] = [];

						for (const item of msg.content) {
							if (item.type === "text") {
								// Filter out system reminders
								let text = normalizeText(item.text || "");
								if (text.includes("<system-reminder>")) {
									text = text
										.split(/<system-reminder>[\s\S]*?<\/system-reminder>/g)
										.join("")
										.trim();
								}
								if (text) {
									textContents.push(text);
									message.contentBlocks?.push({
										type: ContentBlockType.Text,
										text,
									});
								}
							} else if (item.type === "tool_use") {
								message.tools?.push({
									id: item.id,
									name: item.name || "unknown",
									input: item.input,
								});
								message.contentBlocks?.push({
									type: ContentBlockType.ToolUse,
									id: item.id,
									name: item.name,
									input: item.input,
								});
							} else if (item.type === "tool_result") {
								const resultContent = Array.isArray((item as any).content)
									? (
											(item as any).content as Array<{
												type: string;
												text?: string;
											}>
										)
											.map((c) =>
												normalizeText(typeof c.text === "string" ? c.text : ""),
											)
											.join("")
									: typeof (item as any).content === "string"
										? normalizeText((item as any).content as string)
										: "";
								message.toolResults?.push({
									tool_use_id: (item as any).tool_use_id || "",
									content: resultContent,
								});
								message.contentBlocks?.push({
									type: ContentBlockType.ToolResult,
									tool_use_id: (item as any).tool_use_id,
									content: resultContent,
								});
							} else if (item.type === "thinking") {
								const thinking = normalizeText((item as any).thinking || "");
								if (thinking) {
									message.contentBlocks?.push({
										type: ContentBlockType.Thinking,
										thinking,
									});
								}
							}
						}

						message.content = textContents.join("\n\n").trim();
						if (
							!message.content &&
							message.tools?.length === 0 &&
							message.toolResults?.length === 0
						) {
							return null;
						}
					}

					return message;
				},
			)
			.filter((msg: MessageData | null): msg is MessageData => msg !== null);
	} catch (error) {
		console.error("Failed to parse request body:", error);
		return [];
	}
}

export function parseAssistantMessage(body: string | null): MessageData | null {
	if (!body) return null;

	try {
		const lines = body.split("\n");
		const message: MessageData = {
			role: "assistant",
			content: "",
			contentBlocks: [],
			tools: [],
			toolResults: [],
		};

		let currentContent = "";
		let currentThinking = "";
		let isStreaming = false;

		for (const line of lines) {
			if (line.startsWith("event:")) {
				isStreaming = true;
				continue;
			}

			if (line.startsWith("data:")) {
				const dataStr = line.substring(5).trim();
				if (!dataStr || dataStr === "[DONE]") continue;

				try {
					const data = JSON.parse(dataStr);

					// Handle different event types
					if (data.type === "content_block_start") {
						if (data.content_block?.type === "tool_use") {
							const tool: ToolUse = {
								id: data.content_block.id,
								name: data.content_block.name,
								input: {},
							};
							message.tools?.push(tool);
							message.contentBlocks?.push({
								type: ContentBlockType.ToolUse,
								id: data.content_block.id,
								name: data.content_block.name,
								input: {},
							});
						} else if (data.content_block?.type === "thinking") {
							// Thinking block will be added when content is received
						}
					} else if (data.type === "content_block_delta") {
						if (data.delta?.type === "text_delta") {
							currentContent += data.delta.text || "";
						} else if (data.delta?.type === "thinking_delta") {
							currentThinking += data.delta.thinking || "";
						} else if (
							data.delta?.type === "input_json_delta" &&
							data.index !== undefined
						) {
							// Update tool input
							const hasThinking = message.contentBlocks?.some(
								(b) => b.type === ContentBlockType.Thinking,
							);
							const toolIndex = data.index - (hasThinking ? 1 : 0);
							if (message.tools?.[toolIndex]) {
								try {
									const partialJson = data.delta.partial_json || "";
									// This is a simplified approach - in production you'd want proper JSON streaming
									if (partialJson && message.contentBlocks) {
										const blockIndex = message.contentBlocks.findIndex(
											(b) =>
												b.type === ContentBlockType.ToolUse &&
												b.id === message.tools?.[toolIndex].id,
										);
										if (blockIndex !== -1) {
											// Try to parse the partial JSON, fallback to empty object
											try {
												message.contentBlocks[blockIndex].input =
													JSON.parse(partialJson);
											} catch {
												// If parsing fails, store raw string in a temporary field
												message.contentBlocks[blockIndex].input = {
													_partial: partialJson,
												};
											}
										}
									}
								} catch (_e) {
									// Ignore JSON parsing errors for partial data
								}
							}
						}
					}
				} catch (_e) {
					// Skip invalid JSON
				}
			}
		}

		// If no streaming data found, try parsing as direct response
		if (!isStreaming) {
			try {
				const parsed = JSON.parse(body);
				if (parsed.content) {
					if (typeof parsed.content === "string") {
						currentContent = normalizeText(parsed.content);
					} else if (Array.isArray(parsed.content)) {
						for (const item of parsed.content) {
							if (item.type === "text" && item.text) {
								const norm = normalizeText(item.text);
								currentContent += norm;
								message.contentBlocks?.push({
									type: ContentBlockType.Text,
									text: norm,
								});
							} else if (item.type === "tool_use") {
								message.tools?.push({
									id: item.id,
									name: item.name || "unknown",
									input: item.input,
								});
								message.contentBlocks?.push({
									type: ContentBlockType.ToolUse,
									...item,
								});
							} else if (item.type === "thinking") {
								const thinking = normalizeText((item as any).thinking || "");
								if (thinking) {
									message.contentBlocks?.push({
										type: ContentBlockType.Thinking,
										thinking,
									});
								}
							} else if (item.type === "tool_result") {
								const resultContent = Array.isArray((item as any).content)
									? (
											(item as any).content as Array<{
												type: string;
												text?: string;
											}>
										)
											.map((c) =>
												normalizeText(typeof c.text === "string" ? c.text : ""),
											)
											.join("")
									: typeof (item as any).content === "string"
										? normalizeText((item as any).content as string)
										: "";
								message.toolResults?.push({
									tool_use_id: (item as any).tool_use_id || "",
									content: resultContent,
								});
								message.contentBlocks?.push({
									type: ContentBlockType.ToolResult,
									tool_use_id: (item as any).tool_use_id,
									content: resultContent,
								});
							}
						}
					}
				}
			} catch (_e) {
				// Not JSON, might be plain text
				currentContent = body;
			}
		}

		message.content = currentContent.trim();

		if (currentThinking) {
			message.contentBlocks?.unshift({
				type: ContentBlockType.Thinking,
				thinking: currentThinking,
			});
		}

		if (
			!message.content &&
			!currentThinking &&
			(!message.tools || message.tools.length === 0) &&
			(!message.toolResults || message.toolResults.length === 0)
		) {
			return null;
		}

		return message;
	} catch (error) {
		console.error("Failed to parse response body:", error);
		return null;
	}
}
</file>

<file path="README.md">
# ccflare 🛡️

**Track Every Request. Go Low-Level. Never Hit Rate Limits Again.**

The ultimate Claude API proxy with intelligent load balancing across multiple accounts. Full visibility into every request, response, and rate limit.


https://github.com/user-attachments/assets/c859872f-ca5e-4f8b-b6a0-7cc7461fe62a


![ccflare Dashboard](apps/lander/src/screenshot-dashboard.png)

## Why ccflare?

- **🚀 Zero Rate Limit Errors** - Automatically distribute requests across multiple accounts
- **📊 Request-Level Analytics** - Track latency, token usage, and costs in real-time  
- **🔍 Deep Debugging** - Full request/response logging and error traces
- **⚡ <10ms Overhead** - Minimal performance impact on your API calls
- **💸 Free & Open Source** - Run it yourself, modify it, own your infrastructure

## Quick Start

```bash
# Clone and install
git clone https://github.com/snipeship/ccflare
cd ccflare
bun install

# Start ccflare (TUI + Server)
bun run ccflare

# Configure Claude SDK
export ANTHROPIC_BASE_URL=http://localhost:8080
```

## Features

### 🎯 Intelligent Load Balancing
- **Session-based** - Maintain conversation context (5hr sessions)

### 📈 Real-Time Analytics
- Token usage tracking per request
- Response time monitoring
- Rate limit detection and warnings
- Cost estimation and budgeting

### 🛠️ Developer Tools
- Interactive TUI (`bun run ccflare`)
- Web dashboard (`http://localhost:8080/dashboard`)
- CLI for account management
- REST API for automation

### 🔒 Production Ready
- Automatic failover between accounts
- OAuth token refresh handling
- SQLite database for persistence
- Configurable retry logic

## Documentation

Full documentation available in [`docs/`](docs/):
- [Getting Started](docs/index.md)
- [Architecture](docs/architecture.md) 
- [API Reference](docs/api-http.md)
- [Configuration](docs/configuration.md)
- [Load Balancing Strategies](docs/load-balancing.md)

## Screenshots

<table>
  <tr>
    <td><img src="apps/lander/src/screenshot-dashboard.png" alt="Dashboard"/></td>
    <td><img src="apps/lander/src/screenshot-logs.png" alt="Logs"/></td>
  </tr>
  <tr>
    <td align="center"><b>Real-time Dashboard</b></td>
    <td align="center"><b>Request Logs</b></td>
  </tr>
  <tr>
    <td colspan="2"><img src="apps/lander/src/screenshot-analytics.png" alt="Analytics"/></td>
  </tr>
  <tr>
    <td colspan="2" align="center"><b>Analytics & Usage Tracking</b></td>
  </tr>
</table>

## Requirements

- [Bun](https://bun.sh) >= 1.2.8
- Claude API accounts (Free, Pro, or Team)

## Contributing

We welcome contributions! See [CONTRIBUTING.md](docs/contributing.md) for guidelines.

## License

MIT - See [LICENSE](LICENSE) for details

---

<p align="center">
  Built with ❤️ for developers who ship
</p>

[![Mentioned in Awesome Claude Code](https://awesome.re/mentioned-badge-flat.svg)](https://github.com/hesreallyhim/awesome-claude-code)

[![Mentioned in Awesome Claude Code](https://awesome.re/mentioned-badge.svg)](https://github.com/hesreallyhim/awesome-claude-code)
</file>

<file path="packages/dashboard-web/src/components/AgentsTab.tsx">
import { DEFAULT_AGENT_MODEL, getModelDisplayName } from "@ccflare/core";
import { ALLOWED_MODELS } from "@ccflare/types";
import {
	AlertCircle,
	Bot,
	Folder,
	FolderOpen,
	Globe,
	Info,
	Package,
	RefreshCw,
	Settings,
} from "lucide-react";
import { useState } from "react";
import {
	useAgents,
	useBulkUpdateAgentPreferences,
	useDefaultAgentModel,
	useSetDefaultAgentModel,
	useUpdateAgentPreference,
} from "../hooks/queries";
import { AgentCard, WorkspaceCard } from "./agents";
import { Badge } from "./ui/badge";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
	DialogTrigger,
} from "./ui/dialog";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "./ui/select";
import { Separator } from "./ui/separator";
import { Skeleton } from "./ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/tabs";

export function AgentsTab() {
	const { data: response, isLoading, error, refetch } = useAgents();
	const updatePreference = useUpdateAgentPreference();
	const { data: defaultModel, isLoading: isLoadingDefaultModel } =
		useDefaultAgentModel();
	const setDefaultModel = useSetDefaultAgentModel();
	const bulkUpdatePreferences = useBulkUpdateAgentPreferences();
	const [selectedWorkspace, setSelectedWorkspace] = useState<string | null>(
		null,
	);
	const [bulkUpdateDialogOpen, setBulkUpdateDialogOpen] = useState(false);
	const [bulkUpdateModel, setBulkUpdateModel] =
		useState<string>(DEFAULT_AGENT_MODEL);

	const handleModelChange = (agentId: string, model: string) => {
		updatePreference.mutate({ agentId, model });
	};

	const handleDefaultModelChange = (model: string) => {
		setDefaultModel.mutate(model);
	};

	const handleBulkUpdate = () => {
		bulkUpdatePreferences.mutate(bulkUpdateModel, {
			onSuccess: (_data) => {
				setBulkUpdateDialogOpen(false);
				// You could add a toast notification here
			},
		});
	};

	if (isLoading) {
		return (
			<div className="space-y-8">
				<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
					{[...Array(6)].map((_, i) => (
						// biome-ignore lint/suspicious/noArrayIndexKey: Static skeleton elements
						<Card key={i}>
							<CardHeader>
								<Skeleton className="h-6 w-32" />
								<Skeleton className="h-4 w-full mt-2" />
								<Skeleton className="h-4 w-3/4" />
							</CardHeader>
							<CardContent>
								<Skeleton className="h-4 w-24" />
							</CardContent>
						</Card>
					))}
				</div>
			</div>
		);
	}

	if (error) {
		return (
			<Card>
				<CardHeader>
					<CardTitle className="flex items-center gap-2 text-destructive">
						<AlertCircle className="h-5 w-5" />
						Error Loading Agents
					</CardTitle>
					<CardDescription>
						{error instanceof Error ? error.message : "Failed to load agents"}
					</CardDescription>
				</CardHeader>
				<CardContent>
					<Button onClick={() => refetch()} variant="outline" size="sm">
						<RefreshCw className="mr-2 h-4 w-4" />
						Retry
					</Button>
				</CardContent>
			</Card>
		);
	}

	if (!response || response.agents.length === 0) {
		return (
			<Card>
				<CardHeader>
					<CardTitle className="flex items-center gap-2">
						<Bot className="h-5 w-5" />
						No Agents Found
					</CardTitle>
					<CardDescription>
						No agent definition files found in ~/.claude/agents/ or workspace
						directories
					</CardDescription>
				</CardHeader>
				<CardContent className="space-y-4">
					<div>
						<h4 className="font-medium mb-2">Global Agents</h4>
						<p className="text-sm text-muted-foreground">
							To add global agents, create markdown files in the
							~/.claude/agents/ directory.
						</p>
					</div>
					<Separator />
					<div>
						<h4 className="font-medium mb-2">Workspace Agents</h4>
						<p className="text-sm text-muted-foreground">
							To add workspace-specific agents, create markdown files in your
							project's .claude/agents/ directory. They should be able to
							discover local project agents after you send a message from within
							that directory.
						</p>
					</div>
					<Separator />
					<div>
						<h4 className="font-medium mb-2">Agent Format</h4>
						<pre className="mt-2 p-4 bg-muted rounded-lg text-xs overflow-x-auto">
							{`---
name: My Agent
description: Description of what this agent does
color: blue
model: ${DEFAULT_AGENT_MODEL}
---

Your system prompt content here...`}
						</pre>
					</div>
				</CardContent>
			</Card>
		);
	}

	const { globalAgents, workspaceAgents, workspaces } = response;
	const filteredWorkspaceAgents = selectedWorkspace
		? workspaceAgents.filter((agent) => agent.workspace === selectedWorkspace)
		: workspaceAgents;

	// Add agent counts to workspaces
	const workspacesWithCounts = workspaces.map((workspace) => ({
		...workspace,
		agentCount: workspaceAgents.filter((a) => a.workspace === workspace.path)
			.length,
	}));

	return (
		<div className="space-y-6">
			{/* Header */}
			<div className="space-y-4">
				<div className="flex items-center justify-between">
					<div>
						<h2 className="text-2xl font-bold flex items-center gap-3">
							<div className="p-2 bg-primary/10 rounded-lg">
								<Bot className="h-6 w-6 text-primary" />
							</div>
							AI Agents
						</h2>
						<p className="text-muted-foreground mt-1">
							Manage your AI agents and their model preferences
						</p>
					</div>
					<div className="flex items-center gap-4">
						<div className="flex items-center gap-2">
							<Badge variant="secondary" className="gap-1.5">
								<Globe className="h-3.5 w-3.5" />
								{globalAgents.length} Global
							</Badge>
							<Badge variant="secondary" className="gap-1.5">
								<Folder className="h-3.5 w-3.5" />
								{workspaceAgents.length} Workspace
							</Badge>
						</div>
					</div>
				</div>

				{/* Default Model Settings */}
				<Card>
					<CardHeader>
						<CardTitle className="text-base flex items-center gap-2">
							<Settings className="h-4 w-4" />
							Default Agent Model
						</CardTitle>
						<CardDescription>
							Set the default model for all agents. Individual agent preferences
							will override this setting.
						</CardDescription>
					</CardHeader>
					<CardContent>
						<div className="space-y-4">
							<div className="flex items-center gap-4">
								<div className="flex-1">
									<Select
										value={defaultModel || DEFAULT_AGENT_MODEL}
										onValueChange={handleDefaultModelChange}
										disabled={
											isLoadingDefaultModel || setDefaultModel.isPending
										}
									>
										<SelectTrigger className="w-full max-w-xs">
											<SelectValue placeholder="Select a model" />
										</SelectTrigger>
										<SelectContent>
											{ALLOWED_MODELS.map((model) => (
												<SelectItem key={model} value={model}>
													{getModelDisplayName(model)}
												</SelectItem>
											))}
										</SelectContent>
									</Select>
								</div>
								{setDefaultModel.isPending && (
									<span className="text-sm text-muted-foreground">
										Updating...
									</span>
								)}
							</div>

							<Separator />

							<div className="space-y-2">
								<p className="text-sm font-medium">Force Update All Agents</p>
								<p className="text-sm text-muted-foreground">
									Override all individual agent preferences with a specific
									model.
								</p>
								<Dialog
									open={bulkUpdateDialogOpen}
									onOpenChange={setBulkUpdateDialogOpen}
								>
									<DialogTrigger asChild>
										<Button variant="outline" size="sm">
											Force Update All
										</Button>
									</DialogTrigger>
									<DialogContent>
										<DialogHeader>
											<DialogTitle>Update All Agent Models</DialogTitle>
											<DialogDescription>
												This will override all individual agent preferences and
												set them to the selected model. This action cannot be
												undone.
											</DialogDescription>
										</DialogHeader>
										<div className="py-4">
											<Select
												value={bulkUpdateModel}
												onValueChange={setBulkUpdateModel}
											>
												<SelectTrigger>
													<SelectValue />
												</SelectTrigger>
												<SelectContent>
													{ALLOWED_MODELS.map((model) => (
														<SelectItem key={model} value={model}>
															{getModelDisplayName(model)}
														</SelectItem>
													))}
												</SelectContent>
											</Select>
										</div>
										<DialogFooter>
											<Button
												variant="outline"
												onClick={() => setBulkUpdateDialogOpen(false)}
											>
												Cancel
											</Button>
											<Button
												onClick={handleBulkUpdate}
												disabled={bulkUpdatePreferences.isPending}
											>
												{bulkUpdatePreferences.isPending
													? "Updating..."
													: `Update ${response?.agents.length || 0} Agents`}
											</Button>
										</DialogFooter>
									</DialogContent>
								</Dialog>
							</div>
						</div>
					</CardContent>
				</Card>

				{/* Workspaces Section */}
				{workspacesWithCounts.length > 0 && (
					<Card className="border-dashed">
						<CardHeader>
							<CardTitle className="text-base flex items-center gap-2">
								<FolderOpen className="h-4 w-4" />
								Active Workspaces
							</CardTitle>
						</CardHeader>
						<CardContent>
							<div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
								{workspacesWithCounts.map((workspace) => (
									<button
										type="button"
										key={workspace.path}
										onClick={() =>
											setSelectedWorkspace(
												selectedWorkspace === workspace.path
													? null
													: workspace.path,
											)
										}
										className="text-left w-full"
									>
										<WorkspaceCard
											workspace={workspace}
											isActive={selectedWorkspace === workspace.path}
										/>
									</button>
								))}
							</div>
						</CardContent>
					</Card>
				)}
			</div>

			{/* Agents Tabs */}
			<Tabs defaultValue="all" className="space-y-4">
				<TabsList className="grid w-full max-w-md grid-cols-3">
					<TabsTrigger value="all" className="gap-1.5">
						<Package className="h-4 w-4" />
						All Agents
					</TabsTrigger>
					<TabsTrigger value="global" className="gap-1.5">
						<Globe className="h-4 w-4" />
						Global
					</TabsTrigger>
					<TabsTrigger value="workspace" className="gap-1.5">
						<Folder className="h-4 w-4" />
						Workspace
					</TabsTrigger>
				</TabsList>

				<TabsContent value="all" className="space-y-6">
					{globalAgents.length > 0 && (
						<div className="space-y-4">
							<div className="flex items-center gap-2">
								<h3 className="text-lg font-semibold">Global Agents</h3>
								<Badge variant="outline">{globalAgents.length}</Badge>
							</div>
							<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
								{globalAgents.map((agent) => (
									<AgentCard
										key={agent.id}
										agent={agent}
										onModelChange={handleModelChange}
										isUpdating={updatePreference.isPending}
									/>
								))}
							</div>
						</div>
					)}

					{workspaceAgents.length > 0 && (
						<div className="space-y-4">
							<div className="flex items-center gap-2">
								<h3 className="text-lg font-semibold">Workspace Agents</h3>
								<Badge variant="outline">
									{filteredWorkspaceAgents.length}
								</Badge>
								{selectedWorkspace && (
									<Button
										variant="ghost"
										size="sm"
										onClick={() => setSelectedWorkspace(null)}
									>
										Clear filter
									</Button>
								)}
							</div>
							<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
								{filteredWorkspaceAgents.map((agent) => (
									<AgentCard
										key={agent.id}
										agent={agent}
										onModelChange={handleModelChange}
										isUpdating={updatePreference.isPending}
									/>
								))}
							</div>
						</div>
					)}
				</TabsContent>

				<TabsContent value="global" className="space-y-4">
					{globalAgents.length === 0 ? (
						<Card>
							<CardHeader>
								<CardTitle className="flex items-center gap-2">
									<Info className="h-5 w-5" />
									No Global Agents
								</CardTitle>
								<CardDescription>
									Create agent files in ~/.claude/agents/ to add global agents
								</CardDescription>
							</CardHeader>
						</Card>
					) : (
						<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
							{globalAgents.map((agent) => (
								<AgentCard
									key={agent.id}
									agent={agent}
									onModelChange={handleModelChange}
									isUpdating={updatePreference.isPending}
								/>
							))}
						</div>
					)}
				</TabsContent>

				<TabsContent value="workspace" className="space-y-4">
					{workspaceAgents.length === 0 ? (
						<Card>
							<CardHeader>
								<CardTitle className="flex items-center gap-2">
									<Info className="h-5 w-5" />
									No Workspace Agents
								</CardTitle>
								<CardDescription>
									Workspace agents are automatically discovered from your
									project directories. They should be able to discover local
									project agents after you send a message from within that
									directory.
								</CardDescription>
							</CardHeader>
						</Card>
					) : (
						<>
							{selectedWorkspace && (
								<div className="flex items-center gap-2 p-3 bg-muted rounded-lg">
									<Folder className="h-4 w-4" />
									<span className="text-sm">
										Showing agents from:{" "}
										<strong>{selectedWorkspace.split("/").pop()}</strong>
									</span>
									<Button
										variant="ghost"
										size="sm"
										className="ml-auto"
										onClick={() => setSelectedWorkspace(null)}
									>
										Clear filter
									</Button>
								</div>
							)}
							<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
								{filteredWorkspaceAgents.map((agent) => (
									<AgentCard
										key={agent.id}
										agent={agent}
										onModelChange={handleModelChange}
										isUpdating={updatePreference.isPending}
									/>
								))}
							</div>
						</>
					)}
				</TabsContent>
			</Tabs>
		</div>
	);
}
</file>

<file path="packages/dashboard-web/src/components/ConversationView.tsx">
import type { MessageData } from "@ccflare/types";
import {
	cleanLineNumbers,
	genMessageKey,
	parseAssistantMessage,
	parseRequestMessages,
} from "@ccflare/ui-common";
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { Message } from "./conversation";

interface ConversationViewProps {
	requestBody: string | null;
	responseBody: string | null;
}

function ConversationViewComponent({
	requestBody,
	responseBody,
}: ConversationViewProps) {
	const [messages, setMessages] = useState<MessageData[]>([]);

	// Create stable cleanLineNumbers function
	const cleanLineNumbersCallback = useCallback(cleanLineNumbers, []);

	// Parse request body to extract conversation messages
	const requestMessages = useMemo(
		() => parseRequestMessages(requestBody),
		[requestBody],
	);

	// Parse streaming response to extract assistant message
	const assistantMessage = useMemo(
		() => parseAssistantMessage(responseBody),
		[responseBody],
	);

	// Combine messages
	useEffect(() => {
		const allMessages: MessageData[] = [...requestMessages];
		if (assistantMessage) {
			allMessages.push(assistantMessage);
		}
		setMessages(allMessages);
	}, [requestMessages, assistantMessage]);

	if (messages.length === 0) {
		return (
			<div className="flex items-center justify-center h-32">
				<p className="text-muted-foreground">No conversation data available</p>
			</div>
		);
	}

	return (
		<div className="h-[calc(65vh-10rem)] w-full overflow-hidden">
			<div className="h-full w-full overflow-y-auto overflow-x-hidden px-4 py-3 space-y-3">
				{messages.map((message, index) => (
					<Message
						key={genMessageKey(message, index)}
						role={message.role}
						content={message.content}
						contentBlocks={message.contentBlocks}
						tools={message.tools}
						toolResults={message.toolResults}
						cleanLineNumbers={cleanLineNumbersCallback}
					/>
				))}
			</div>
		</div>
	);
}

export const ConversationView = React.memo(ConversationViewComponent);
</file>

<file path="packages/dashboard-web/src/hooks/useRequestStream.ts">
import { useQueryClient } from "@tanstack/react-query";
import { useEffect } from "react";
import type { Account, RequestPayload, RequestResponse } from "../api";
import { queryKeys } from "../lib/query-keys";

export function useRequestStream(limit = 200) {
	const queryClient = useQueryClient();

	useEffect(() => {
		let es: EventSource | null = null;
		let retries = 0;
		let reconnectTimeout: NodeJS.Timeout | null = null;

		const connect = () => {
			// Clear any existing timeout
			if (reconnectTimeout) {
				clearTimeout(reconnectTimeout);
				reconnectTimeout = null;
			}

			es = new EventSource("/api/requests/stream");

			es.addEventListener("open", () => {
				// Reset retry count on successful connection
				retries = 0;
				console.log("SSE connection established");
			});

			es.addEventListener("message", (ev) => {
				const evt = JSON.parse(ev.data) as
					| {
							type: "start";
							id: string;
							method: string;
							path: string;
							timestamp: number;
							accountId: string | null;
							statusCode: number;
							agentUsed: string | null;
					  }
					| { type: "summary"; payload: RequestResponse }
					| { type: "payload"; payload: RequestPayload };

				queryClient.setQueryData(
					queryKeys.requests(limit),
					(
						current:
							| {
									requests: RequestPayload[];
									detailsMap: Map<string, RequestResponse> | RequestResponse[];
							  }
							| undefined,
					) => {
						if (!current) return current;

						// Ensure detailsMap is a Map
						const currentDetailsMap =
							current.detailsMap instanceof Map
								? current.detailsMap
								: new Map(
										(current.detailsMap as RequestResponse[]).map((s) => [
											s.id,
											s,
										]),
									);

						if (evt.type === "start") {
							// Look up account name from cache
							const accounts = queryClient.getQueryData<Account[]>(
								queryKeys.accounts(),
							);
							const account = accounts?.find((a) => a.id === evt.accountId);

							// Create a lightweight placeholder payload
							const placeholder: RequestPayload = {
								id: evt.id,
								request: { headers: {}, body: null },
								response: {
									status: evt.statusCode,
									headers: {},
									body: null,
								},
								meta: {
									timestamp: evt.timestamp,
									path: evt.path,
									method: evt.method,
									accountId: evt.accountId || undefined,
									accountName: account?.name,
									success: false,
									pending: true,
									agentUsed: evt.agentUsed || undefined,
								},
							};

							// Check if this request already exists
							const existingIndex = current.requests.findIndex(
								(r) => r.id === evt.id,
							);
							if (existingIndex >= 0) {
								// Update existing placeholder
								const newRequests = [...current.requests];
								newRequests[existingIndex] = placeholder;
								return {
									...current,
									requests: newRequests,
									detailsMap: currentDetailsMap,
								};
							}

							// Add new placeholder at the beginning
							return {
								...current,
								requests: [placeholder, ...current.requests].slice(0, limit),
								detailsMap: currentDetailsMap,
							};
						} else if (evt.type === "payload") {
							// Replace placeholder or insert if missing
							const newRequests = [...current.requests];
							const idx = newRequests.findIndex((r) => r.id === evt.payload.id);
							if (idx >= 0) {
								newRequests[idx] = evt.payload;
							} else {
								newRequests.unshift(evt.payload);
							}
							return {
								...current,
								requests: newRequests.slice(0, limit),
								detailsMap: currentDetailsMap,
							};
						} else {
							// Update details map with summary
							const map = new Map(currentDetailsMap);
							map.set(evt.payload.id, evt.payload);

							// Update the request if it exists
							const requestIndex = current.requests.findIndex(
								(r) => r.id === evt.payload.id,
							);
							if (requestIndex >= 0) {
								const newRequests = [...current.requests];
								// Update meta to remove pending status
								if (newRequests[requestIndex].meta) {
									newRequests[requestIndex] = {
										...newRequests[requestIndex],
										meta: {
											...newRequests[requestIndex].meta,
											pending: false,
											success: evt.payload.success,
										},
									};
								}
								return { ...current, requests: newRequests, detailsMap: map };
							}

							return { ...current, detailsMap: map };
						}
					},
				);
			});

			es.addEventListener("error", (error) => {
				console.error("SSE connection error:", error);

				if (es) {
					es.close();
					es = null;
				}

				// Calculate exponential backoff delay (max 30 seconds)
				const delay = Math.min(1000 * 2 ** retries, 30000);
				retries++;

				console.log(`Reconnecting in ${delay}ms (attempt ${retries})`);
				reconnectTimeout = setTimeout(connect, delay);
			});
		};

		// Initial connection
		connect();

		// Cleanup function
		return () => {
			if (reconnectTimeout) {
				clearTimeout(reconnectTimeout);
			}
			if (es) {
				es.close();
			}
		};
	}, [limit, queryClient]);
}
</file>

<file path="packages/proxy/src/proxy.ts">
import { requestEvents, ServiceUnavailableError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import {
	applySystemPromptInterception,
	createRequestMetadata,
	ERROR_MESSAGES,
	interceptAndModifyRequest,
	type ProxyContext,
	prepareRequestBody,
	proxyUnauthenticated,
	proxyWithAccount,
	selectAccountsForRequest,
	TIMING,
	validateProviderPath,
} from "./handlers";
import type { ControlMessage, OutgoingWorkerMessage } from "./worker-messages";

export type { ProxyContext } from "./handlers";

const log = new Logger("Proxy");

// ===== WORKER MANAGEMENT =====

// Create usage worker instance
let usageWorkerInstance: Worker | null = null;

/**
 * Gets or creates the usage worker instance
 * @returns The usage worker instance
 */
export function getUsageWorker(): Worker {
	if (!usageWorkerInstance) {
		usageWorkerInstance = new Worker(
			new URL("./post-processor.worker.ts", import.meta.url).href,
			{ smol: true },
		);
		// Bun extends Worker with unref method
		if (
			"unref" in usageWorkerInstance &&
			typeof usageWorkerInstance.unref === "function"
		) {
			usageWorkerInstance.unref(); // Don't keep process alive
		}

		// Listen for summary messages from worker
		usageWorkerInstance.onmessage = (ev) => {
			const data = ev.data as OutgoingWorkerMessage;
			if (data.type === "summary") {
				requestEvents.emit("event", { type: "summary", payload: data.summary });
			} else if (data.type === "payload") {
				requestEvents.emit("event", { type: "payload", payload: data.payload });
			}
		};
	}
	return usageWorkerInstance;
}

/**
 * Gracefully terminates the usage worker
 */
export function terminateUsageWorker(): void {
	if (usageWorkerInstance) {
		// Send shutdown message to allow worker to flush
		const shutdownMsg: ControlMessage = { type: "shutdown" };
		usageWorkerInstance.postMessage(shutdownMsg);
		// Give worker time to flush before terminating
		setTimeout(() => {
			if (usageWorkerInstance) {
				usageWorkerInstance.terminate();
				usageWorkerInstance = null;
			}
		}, TIMING.WORKER_SHUTDOWN_DELAY);
	}
}

// ===== MAIN HANDLER =====

/**
 * Main proxy handler - orchestrates the entire proxy flow
 *
 * This function coordinates the proxy process by:
 * 1. Creating request metadata for tracking
 * 2. Validating the provider can handle the path
 * 3. Preparing the request body for reuse
 * 4. Selecting accounts based on load balancing strategy
 * 5. Attempting to proxy with each account in order
 * 6. Falling back to unauthenticated proxy if no accounts available
 *
 * @param req - The incoming request
 * @param url - The parsed URL
 * @param ctx - The proxy context containing strategy, database, and provider
 * @returns Promise resolving to the proxied response
 * @throws {ValidationError} If the provider cannot handle the path
 * @throws {ServiceUnavailableError} If all accounts fail to proxy the request
 * @throws {ProviderError} If unauthenticated proxy fails
 */
export async function handleProxy(
	req: Request,
	url: URL,
	ctx: ProxyContext,
): Promise<Response> {
	// 1. Validate provider can handle path
	validateProviderPath(ctx.provider, url.pathname);

	// 2. Prepare request body
	const { buffer: requestBodyBuffer } = await prepareRequestBody(req);

	// 3. Apply system prompt interception first
	const promptInterceptedBody = await applySystemPromptInterception(
		requestBodyBuffer,
		ctx.dbOps,
	);

	// 4. Then perform agent interception on the potentially modified body
	const { modifiedBody, agentUsed, originalModel, appliedModel } =
		await interceptAndModifyRequest(
			promptInterceptedBody || requestBodyBuffer,
			ctx.dbOps,
		);

	// Use the final modified body (from agent interceptor) or fall back to earlier versions
	const finalBodyBuffer =
		modifiedBody || promptInterceptedBody || requestBodyBuffer;
	const finalCreateBodyStream = () => {
		if (!finalBodyBuffer) return undefined;
		return new Response(finalBodyBuffer).body ?? undefined;
	};

	if (agentUsed && originalModel !== appliedModel) {
		log.info(
			`Agent ${agentUsed} detected, model changed from ${originalModel} to ${appliedModel}`,
		);
	}

	// 5. Create request metadata with agent info
	const requestMeta = createRequestMetadata(req, url);
	requestMeta.agentUsed = agentUsed;

	// 6. Select accounts
	const accounts = selectAccountsForRequest(requestMeta, ctx);

	// 7. Handle no accounts case
	if (accounts.length === 0) {
		return proxyUnauthenticated(
			req,
			url,
			requestMeta,
			finalBodyBuffer,
			finalCreateBodyStream,
			ctx,
		);
	}

	// 8. Log selected accounts
	log.info(
		`Selected ${accounts.length} accounts: ${accounts.map((a) => a.name).join(", ")}`,
	);
	log.info(`Request: ${req.method} ${url.pathname}`);

	// 9. Try each account
	for (let i = 0; i < accounts.length; i++) {
		const response = await proxyWithAccount(
			req,
			url,
			accounts[i],
			requestMeta,
			finalBodyBuffer,
			finalCreateBodyStream,
			i,
			ctx,
		);

		if (response) {
			return response;
		}
	}

	// 10. All accounts failed
	throw new ServiceUnavailableError(
		`${ERROR_MESSAGES.ALL_ACCOUNTS_FAILED} (${accounts.length} attempted)`,
		ctx.provider.name,
	);
}
</file>

<file path="packages/dashboard-web/src/components/agents/AgentCard.tsx">
import { getModelDisplayName } from "@ccflare/core";
import type { Agent } from "@ccflare/types";
import { ALLOWED_MODELS } from "@ccflare/types";
import { Bot, Cpu, Edit3, Folder, Globe, Sparkles } from "lucide-react";
import { useState } from "react";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { AgentEditDialog } from "./AgentEditDialog";

interface AgentCardProps {
	agent: Agent;
	onModelChange?: (agentId: string, model: string) => void;
	isUpdating?: boolean;
}

export function AgentCard({
	agent,
	onModelChange,
	isUpdating,
}: AgentCardProps) {
	const [editDialogOpen, setEditDialogOpen] = useState(false);

	// Map color names to more sophisticated gradient classes
	const colorMap: Record<string, { border: string; bg: string; icon: string }> =
		{
			gray: {
				border: "border-gray-300 dark:border-gray-700",
				bg: "bg-gray-50 dark:bg-gray-900/50",
				icon: "text-gray-600 dark:text-gray-400",
			},
			blue: {
				border: "border-blue-300 dark:border-blue-700",
				bg: "bg-blue-50 dark:bg-blue-900/20",
				icon: "text-blue-600 dark:text-blue-400",
			},
			green: {
				border: "border-green-300 dark:border-green-700",
				bg: "bg-green-50 dark:bg-green-900/20",
				icon: "text-green-600 dark:text-green-400",
			},
			yellow: {
				border: "border-yellow-300 dark:border-yellow-700",
				bg: "bg-yellow-50 dark:bg-yellow-900/20",
				icon: "text-yellow-600 dark:text-yellow-400",
			},
			orange: {
				border: "border-orange-300 dark:border-orange-700",
				bg: "bg-orange-50 dark:bg-orange-900/20",
				icon: "text-orange-600 dark:text-orange-400",
			},
			red: {
				border: "border-red-300 dark:border-red-700",
				bg: "bg-red-50 dark:bg-red-900/20",
				icon: "text-red-600 dark:text-red-400",
			},
			purple: {
				border: "border-purple-300 dark:border-purple-700",
				bg: "bg-purple-50 dark:bg-purple-900/20",
				icon: "text-purple-600 dark:text-purple-400",
			},
			pink: {
				border: "border-pink-300 dark:border-pink-700",
				bg: "bg-pink-50 dark:bg-pink-900/20",
				icon: "text-pink-600 dark:text-pink-400",
			},
			indigo: {
				border: "border-indigo-300 dark:border-indigo-700",
				bg: "bg-indigo-50 dark:bg-indigo-900/20",
				icon: "text-indigo-600 dark:text-indigo-400",
			},
			cyan: {
				border: "border-cyan-300 dark:border-cyan-700",
				bg: "bg-cyan-50 dark:bg-cyan-900/20",
				icon: "text-cyan-600 dark:text-cyan-400",
			},
		};

	const colors = colorMap[agent.color] || colorMap.gray;
	const isWorkspaceAgent = agent.source === "workspace";
	const SourceIcon = isWorkspaceAgent ? Folder : Globe;

	// Get clean agent name (remove workspace prefix for workspace agents)
	const displayName =
		isWorkspaceAgent && agent.id.includes(":") ? agent.name : agent.name;

	// Get workspace name from ID if it's a workspace agent
	const workspaceName =
		isWorkspaceAgent && agent.id.includes(":") ? agent.id.split(":")[0] : null;

	return (
		<Card
			className={`group relative overflow-hidden transition-all hover:shadow-lg ${colors.border} border-2`}
		>
			{/* Gradient background overlay */}
			<div className={`absolute inset-0 ${colors.bg} opacity-50`} />

			<CardHeader className="relative">
				<div className="space-y-3">
					<div className="flex items-start justify-between">
						<div className="flex items-center gap-3">
							<div
								className={`p-2.5 rounded-xl ${colors.bg} ${colors.border} border backdrop-blur-sm`}
							>
								<Bot className={`h-5 w-5 ${colors.icon}`} />
							</div>
							<div className="flex-1">
								<CardTitle className="text-lg font-semibold flex items-center gap-2">
									{displayName}
									{agent.model.includes("opus") && (
										<Sparkles className="h-4 w-4 text-yellow-500" />
									)}
								</CardTitle>
								<div className="flex items-center gap-2 mt-1">
									<Badge variant="outline" className="text-xs gap-1">
										<SourceIcon className="h-3 w-3" />
										{isWorkspaceAgent ? workspaceName : "Global"}
									</Badge>
									{agent.model.includes("opus") && (
										<Badge variant="secondary" className="text-xs gap-1">
											<Cpu className="h-3 w-3" />
											Advanced
										</Badge>
									)}
								</div>
							</div>
						</div>
						<Button
							variant="ghost"
							size="sm"
							onClick={() => setEditDialogOpen(true)}
							className="opacity-0 group-hover:opacity-100 transition-opacity"
						>
							<Edit3 className="h-4 w-4" />
						</Button>
					</div>
					<CardDescription className="text-sm leading-relaxed line-clamp-3 whitespace-pre-wrap">
						{agent.description.replace(/\\n/g, "\n")}
					</CardDescription>
				</div>
			</CardHeader>

			<CardContent className="relative space-y-4">
				<div className="space-y-2">
					<Label className="text-muted-foreground">Model Preference</Label>
					<Select
						value={agent.model}
						onValueChange={(value) => onModelChange?.(agent.id, value)}
						disabled={isUpdating}
					>
						<SelectTrigger className="w-full bg-background/60 backdrop-blur-sm">
							<SelectValue />
						</SelectTrigger>
						<SelectContent>
							{ALLOWED_MODELS.map((model) => (
								<SelectItem
									key={model}
									value={model}
									className="flex items-center"
								>
									<span className="flex items-center gap-2">
										{getModelDisplayName(model)}
										{model.includes("opus") && (
											<Badge variant="secondary" className="text-xs">
												Premium
											</Badge>
										)}
									</span>
								</SelectItem>
							))}
						</SelectContent>
					</Select>
				</div>

				<div className="pt-2 border-t">
					<p className="text-xs text-muted-foreground font-mono">{agent.id}</p>
				</div>
			</CardContent>

			<AgentEditDialog
				agent={agent}
				open={editDialogOpen}
				onOpenChange={setEditDialogOpen}
			/>
		</Card>
	);
}
</file>

<file path="packages/dashboard-web/src/components/tools/SystemPromptInterceptorCard.tsx">
import { useEffect, useState } from "react";
import {
	useResetSystemPromptOverride,
	useSetSystemPromptOverride,
	useSystemPromptOverride,
} from "../../hooks/queries";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardFooter,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Label } from "../ui/label";
import { Switch } from "../ui/switch";
import { Textarea } from "../ui/textarea";

export function SystemPromptInterceptorCard() {
	const { data, isLoading } = useSystemPromptOverride();
	const { mutate, isPending, isSuccess } = useSetSystemPromptOverride();
	const { mutate: resetMutate } = useResetSystemPromptOverride();

	// Local form state
	const [isEnabled, setIsEnabled] = useState(false);
	const [targetPrompt, setTargetPrompt] = useState("");
	const [replacementPrompt, setReplacementPrompt] = useState("");
	const [toolsEnabled, setToolsEnabled] = useState(true);

	// Sync server data to local state
	useEffect(() => {
		if (data) {
			setIsEnabled(data.isEnabled);
			setTargetPrompt(data.targetPrompt);
			setReplacementPrompt(data.replacementPrompt);
			setToolsEnabled(data.toolsEnabled);
		}
	}, [data]);

	const handleSave = () => {
		mutate({
			isEnabled,
			targetPrompt,
			replacementPrompt,
			toolsEnabled,
		});
	};

	if (isLoading) {
		return (
			<Card>
				<CardHeader>
					<CardTitle>System Prompt Interceptor</CardTitle>
					<CardDescription>Loading configuration...</CardDescription>
				</CardHeader>
			</Card>
		);
	}

	return (
		<Card>
			<CardHeader>
				<CardTitle>System Prompt Interceptor</CardTitle>
				<CardDescription>
					Configure a custom system prompt to override the default Claude
					behavior
				</CardDescription>
			</CardHeader>
			<CardContent className="space-y-6">
				<div className="flex items-center justify-between">
					<div className="space-y-0.5">
						<Label htmlFor="enable-interceptor">Enable Interceptor</Label>
						<p className="text-sm text-muted-foreground">
							When enabled, your custom prompt will be used
						</p>
					</div>
					<Switch
						id="enable-interceptor"
						checked={isEnabled}
						onCheckedChange={setIsEnabled}
					/>
				</div>

				<div className="space-y-2">
					<Label htmlFor="target-prompt">Target Prompt</Label>
					<Textarea
						id="target-prompt"
						placeholder="The prompt to look for and replace..."
						value={targetPrompt}
						onChange={(e) => setTargetPrompt(e.target.value)}
						className="min-h-[150px]"
						readOnly
					/>
					<p className="text-sm text-muted-foreground">
						This is the prompt that will be detected and replaced. After reset,
						this shows the last-seen system prompt.
					</p>
				</div>

				<div className="space-y-2">
					<Label htmlFor="replacement-prompt">Custom Prompt Template</Label>
					<Textarea
						id="replacement-prompt"
						placeholder="Your custom replacement prompt here..."
						value={replacementPrompt}
						onChange={(e) => setReplacementPrompt(e.target.value)}
						className="min-h-[200px]"
					/>
					<p className="text-sm text-muted-foreground">
						Use{" "}
						<code className="bg-muted px-1 py-0.5 rounded">
							{"{{env_block}}"}
						</code>{" "}
						and{" "}
						<code className="bg-muted px-1 py-0.5 rounded">
							{"{{git_status_block}}"}
						</code>{" "}
						to preserve dynamic content (e.g., environment, git status) from the
						original prompt.
					</p>
				</div>

				<div className="flex items-center justify-between">
					<div className="space-y-0.5">
						<Label htmlFor="enable-tools">Enable Tools</Label>
						<p className="text-sm text-muted-foreground">
							Allow Claude to use tools when this interceptor is active
						</p>
					</div>
					<Switch
						id="enable-tools"
						checked={toolsEnabled}
						onCheckedChange={setToolsEnabled}
					/>
				</div>
			</CardContent>
			<CardFooter className="flex gap-2">
				<Button onClick={handleSave} disabled={isPending}>
					{isPending ? "Saving..." : isSuccess ? "Saved!" : "Save"}
				</Button>
				<Button variant="outline" onClick={() => resetMutate()}>
					Reset to Default
				</Button>
			</CardFooter>
		</Card>
	);
}
</file>

<file path="packages/database/src/database-operations.ts">
import { Database } from "bun:sqlite";
import { mkdirSync } from "node:fs";
import { dirname } from "node:path";
import type { Disposable } from "@ccflare/core";
import type { Account, StrategyStore } from "@ccflare/types";
import { ensureSchema, runMigrations } from "./migrations";
import { resolveDbPath } from "./paths";
import { AccountRepository } from "./repositories/account.repository";
import { AgentPreferenceRepository } from "./repositories/agent-preference.repository";
import {
	type InterceptorConfig,
	InterceptorRepository,
} from "./repositories/interceptor.repository";
import { OAuthRepository } from "./repositories/oauth.repository";
import {
	type RequestData,
	RequestRepository,
} from "./repositories/request.repository";
import { StatsRepository } from "./repositories/stats.repository";
import { StrategyRepository } from "./repositories/strategy.repository";
import { SystemKVRepository } from "./repositories/system-kv.repository";

export interface RuntimeConfig {
	sessionDurationMs?: number;
}

/**
 * DatabaseOperations using Repository Pattern
 * Provides a clean, organized interface for database operations
 */
export class DatabaseOperations implements StrategyStore, Disposable {
	private db: Database;
	private runtime?: RuntimeConfig;

	// Repositories
	private accounts: AccountRepository;
	private requests: RequestRepository;
	private oauth: OAuthRepository;
	private strategy: StrategyRepository;
	private stats: StatsRepository;
	private agentPreferences: AgentPreferenceRepository;
	private interceptor: InterceptorRepository;
	private systemKV: SystemKVRepository;

	constructor(dbPath?: string) {
		const resolvedPath = dbPath ?? resolveDbPath();

		// Ensure the directory exists
		const dir = dirname(resolvedPath);
		mkdirSync(dir, { recursive: true });

		this.db = new Database(resolvedPath, { create: true });

		// Configure SQLite for better concurrency
		this.db.exec("PRAGMA journal_mode = WAL"); // Enable Write-Ahead Logging
		this.db.exec("PRAGMA busy_timeout = 5000"); // Wait up to 5 seconds before throwing "database is locked"
		this.db.exec("PRAGMA synchronous = NORMAL"); // Better performance while maintaining safety

		ensureSchema(this.db);
		runMigrations(this.db);

		// Initialize repositories
		this.accounts = new AccountRepository(this.db);
		this.requests = new RequestRepository(this.db);
		this.oauth = new OAuthRepository(this.db);
		this.strategy = new StrategyRepository(this.db);
		this.stats = new StatsRepository(this.db);
		this.agentPreferences = new AgentPreferenceRepository(this.db);
		this.interceptor = new InterceptorRepository(this.db);
		this.systemKV = new SystemKVRepository(this.db);
	}

	setRuntimeConfig(runtime: RuntimeConfig): void {
		this.runtime = runtime;
	}

	getDatabase(): Database {
		return this.db;
	}

	// Account operations delegated to repository
	getAllAccounts(): Account[] {
		return this.accounts.findAll();
	}

	getAccount(accountId: string): Account | null {
		return this.accounts.findById(accountId);
	}

	updateAccountTokens(
		accountId: string,
		accessToken: string,
		expiresAt: number,
		refreshToken?: string,
	): void {
		this.accounts.updateTokens(accountId, accessToken, expiresAt, refreshToken);
	}

	updateAccountUsage(accountId: string): void {
		const sessionDuration =
			this.runtime?.sessionDurationMs || 5 * 60 * 60 * 1000;
		this.accounts.incrementUsage(accountId, sessionDuration);
	}

	markAccountRateLimited(accountId: string, until: number): void {
		this.accounts.setRateLimited(accountId, until);
	}

	updateAccountRateLimitMeta(
		accountId: string,
		status: string,
		reset: number | null,
		remaining?: number | null,
	): void {
		this.accounts.updateRateLimitMeta(accountId, status, reset, remaining);
	}

	updateAccountTier(accountId: string, tier: number): void {
		this.accounts.updateTier(accountId, tier);
	}

	pauseAccount(accountId: string): void {
		this.accounts.pause(accountId);
	}

	resumeAccount(accountId: string): void {
		this.accounts.resume(accountId);
	}

	renameAccount(accountId: string, newName: string): void {
		this.accounts.rename(accountId, newName);
	}

	resetAccountSession(accountId: string, timestamp: number): void {
		this.accounts.resetSession(accountId, timestamp);
	}

	updateAccountRequestCount(accountId: string, count: number): void {
		this.accounts.updateRequestCount(accountId, count);
	}

	// Request operations delegated to repository
	saveRequestMeta(
		id: string,
		method: string,
		path: string,
		accountUsed: string | null,
		statusCode: number | null,
		timestamp?: number,
	): void {
		this.requests.saveMeta(
			id,
			method,
			path,
			accountUsed,
			statusCode,
			timestamp,
		);
	}

	saveRequest(
		id: string,
		method: string,
		path: string,
		accountUsed: string | null,
		statusCode: number | null,
		success: boolean,
		errorMessage: string | null,
		responseTime: number,
		failoverAttempts: number,
		usage?: RequestData["usage"],
		agentUsed?: string,
	): void {
		this.requests.save({
			id,
			method,
			path,
			accountUsed,
			statusCode,
			success,
			errorMessage,
			responseTime,
			failoverAttempts,
			usage,
			agentUsed,
		});
	}

	updateRequestUsage(requestId: string, usage: RequestData["usage"]): void {
		this.requests.updateUsage(requestId, usage);
	}

	saveRequestPayload(id: string, data: unknown): void {
		this.requests.savePayload(id, data);
	}

	getRequestPayload(id: string): unknown | null {
		return this.requests.getPayload(id);
	}

	listRequestPayloads(limit = 50): Array<{ id: string; json: string }> {
		return this.requests.listPayloads(limit);
	}

	listRequestPayloadsWithAccountNames(
		limit = 50,
	): Array<{ id: string; json: string; account_name: string | null }> {
		return this.requests.listPayloadsWithAccountNames(limit);
	}

	// OAuth operations delegated to repository
	createOAuthSession(
		sessionId: string,
		accountName: string,
		verifier: string,
		mode: "console" | "max",
		tier: number,
		ttlMinutes = 10,
	): void {
		this.oauth.createSession(
			sessionId,
			accountName,
			verifier,
			mode,
			tier,
			ttlMinutes,
		);
	}

	getOAuthSession(sessionId: string): {
		accountName: string;
		verifier: string;
		mode: "console" | "max";
		tier: number;
	} | null {
		return this.oauth.getSession(sessionId);
	}

	deleteOAuthSession(sessionId: string): void {
		this.oauth.deleteSession(sessionId);
	}

	cleanupExpiredOAuthSessions(): number {
		return this.oauth.cleanupExpiredSessions();
	}

	// Strategy operations delegated to repository
	getStrategy(name: string): {
		name: string;
		config: Record<string, unknown>;
		updatedAt: number;
	} | null {
		return this.strategy.getStrategy(name);
	}

	setStrategy(name: string, config: Record<string, unknown>): void {
		this.strategy.set(name, config);
	}

	listStrategies(): Array<{
		name: string;
		config: Record<string, unknown>;
		updatedAt: number;
	}> {
		return this.strategy.list();
	}

	deleteStrategy(name: string): boolean {
		return this.strategy.delete(name);
	}

	// Analytics methods delegated to request repository
	getRecentRequests(limit = 100): Array<{
		id: string;
		timestamp: number;
		method: string;
		path: string;
		account_used: string | null;
		status_code: number | null;
		success: boolean;
		response_time_ms: number | null;
	}> {
		return this.requests.getRecentRequests(limit);
	}

	getRequestStats(since?: number): {
		totalRequests: number;
		successfulRequests: number;
		failedRequests: number;
		avgResponseTime: number | null;
	} {
		return this.requests.getRequestStats(since);
	}

	aggregateStats(rangeMs?: number) {
		return this.requests.aggregateStats(rangeMs);
	}

	getRecentErrors(limit?: number): string[] {
		return this.requests.getRecentErrors(limit);
	}

	getTopModels(limit?: number): Array<{ model: string; count: number }> {
		return this.requests.getTopModels(limit);
	}

	getRequestsByAccount(since?: number): Array<{
		accountId: string;
		accountName: string | null;
		requestCount: number;
		successRate: number;
	}> {
		return this.requests.getRequestsByAccount(since);
	}

	// Cleanup operations (payload by age; request metadata by age; plus orphan sweep)
	cleanupOldRequests(
		payloadRetentionMs: number,
		requestRetentionMs?: number,
	): {
		removedRequests: number;
		removedPayloads: number;
	} {
		const now = Date.now();
		const payloadCutoff = now - payloadRetentionMs;
		let removedRequests = 0;
		if (
			typeof requestRetentionMs === "number" &&
			Number.isFinite(requestRetentionMs)
		) {
			const requestCutoff = now - requestRetentionMs;
			removedRequests = this.requests.deleteOlderThan(requestCutoff);
		}
		const removedPayloadsByAge =
			this.requests.deletePayloadsOlderThan(payloadCutoff);
		const removedOrphans = this.requests.deleteOrphanedPayloads();
		const removedPayloads = removedPayloadsByAge + removedOrphans;
		return { removedRequests, removedPayloads };
	}

	// Agent preference operations delegated to repository
	getAgentPreference(agentId: string): { model: string } | null {
		return this.agentPreferences.getPreference(agentId);
	}

	getAllAgentPreferences(): Array<{ agent_id: string; model: string }> {
		return this.agentPreferences.getAllPreferences();
	}

	setAgentPreference(agentId: string, model: string): void {
		this.agentPreferences.setPreference(agentId, model);
	}

	deleteAgentPreference(agentId: string): boolean {
		return this.agentPreferences.deletePreference(agentId);
	}

	setBulkAgentPreferences(agentIds: string[], model: string): void {
		this.agentPreferences.setBulkPreferences(agentIds, model);
	}

	// Interceptor operations delegated to repository
	getInterceptorConfig(
		id: string,
	): { isEnabled: boolean; config: InterceptorConfig } | null {
		return this.interceptor.getConfig(id);
	}

	setInterceptorConfig(
		id: string,
		isEnabled: boolean,
		config: InterceptorConfig,
	): void {
		this.interceptor.setConfig(id, isEnabled, config);
	}

	deleteInterceptorConfig(id: string): boolean {
		return this.interceptor.delete(id);
	}

	// System KV operations delegated to repository
	getSystemKV(key: string): string | null {
		return this.systemKV.getValue(key);
	}

	setSystemKV(key: string, value: string): void {
		this.systemKV.setValue(key, value);
	}

	close(): void {
		// Ensure all write operations are flushed before closing
		this.db.exec("PRAGMA wal_checkpoint(TRUNCATE)");
		this.db.close();
	}

	dispose(): void {
		this.close();
	}

	// Optimize database periodically to maintain performance
	optimize(): void {
		this.db.exec("PRAGMA optimize");
		this.db.exec("PRAGMA wal_checkpoint(PASSIVE)");
	}

	/** Compact and reclaim disk space (blocks DB during operation) */
	compact(): void {
		// Ensure WAL is checkpointed and truncated, then VACUUM to rebuild file
		this.db.exec("PRAGMA wal_checkpoint(TRUNCATE)");
		this.db.exec("VACUUM");
	}

	/**
	 * Get the stats repository for consolidated stats access
	 */
	getStatsRepository(): StatsRepository {
		return this.stats;
	}
}
</file>

<file path="packages/proxy/src/handlers/agent-interceptor.ts">
import { existsSync } from "node:fs";
import { join, resolve } from "node:path";
import { agentRegistry } from "@ccflare/agents";
import type { DatabaseOperations } from "@ccflare/database";
import { Logger } from "@ccflare/logger";
import type { Agent } from "@ccflare/types";

const log = new Logger("AgentInterceptor");

export interface AgentInterceptResult {
	modifiedBody: ArrayBuffer | null;
	agentUsed: string | null;
	originalModel: string | null;
	appliedModel: string | null;
}

/**
 * Detects agent usage and modifies the request body to use the preferred model
 * @param requestBodyBuffer - The buffered request body
 * @param dbOps - Database operations instance
 * @returns Modified request body and agent information
 */
export async function interceptAndModifyRequest(
	requestBodyBuffer: ArrayBuffer | null,
	dbOps: DatabaseOperations,
): Promise<AgentInterceptResult> {
	// If no body, nothing to intercept
	if (!requestBodyBuffer) {
		return {
			modifiedBody: null,
			agentUsed: null,
			originalModel: null,
			appliedModel: null,
		};
	}

	try {
		// Parse the request body
		const bodyText = new TextDecoder().decode(requestBodyBuffer);
		const requestBody = JSON.parse(bodyText);

		// Extract original model
		const originalModel = requestBody.model || null;

		// Extract system prompt to detect agent usage
		const systemPrompt = extractSystemPrompt(requestBody);
		if (!systemPrompt) {
			// No system prompt, no agent detection possible
			log.info("No system prompt found in request");
			return {
				modifiedBody: requestBodyBuffer,
				agentUsed: null,
				originalModel,
				appliedModel: originalModel,
			};
		}

		// Register additional agent directories from system prompt
		log.info(`System prompt length: ${systemPrompt.length} chars`);
		if (systemPrompt.includes("CLAUDE.md")) {
			log.info("System prompt contains CLAUDE.md reference");

			// Look specifically for the Contents pattern
			if (systemPrompt.includes("Contents of")) {
				const contentsIndex = systemPrompt.indexOf("Contents of");
				const start = contentsIndex;
				const end = Math.min(systemPrompt.length, contentsIndex + 200);
				const sample = systemPrompt.substring(start, end);
				log.info(`Found 'Contents of' pattern: ${sample}`);
			} else {
				log.info("System prompt does NOT contain 'Contents of' pattern");
				// Show a sample of what we do have
				const claudeIndex = systemPrompt.indexOf("CLAUDE.md");
				const start = Math.max(0, claudeIndex - 50);
				const end = Math.min(systemPrompt.length, claudeIndex + 50);
				const sample = systemPrompt.substring(start, end);
				log.info(`Sample around CLAUDE.md: ...${sample}...`);
			}

			// Count all CLAUDE.md occurrences
			const matches = systemPrompt.match(/CLAUDE\.md/g);
			log.info(`Total CLAUDE.md occurrences: ${matches ? matches.length : 0}`);
		}

		const extraDirs = extractAgentDirectories(systemPrompt);
		log.info(
			`Found ${extraDirs.length} potential agent directories in system prompt`,
		);

		for (const dir of extraDirs) {
			log.info(`Checking potential workspace from agents directory: ${dir}`);
			// Extract workspace path from agents directory
			// Convert /path/to/project/.claude/agents to /path/to/project
			const workspacePath = dir.replace(/\/.claude\/agents$/, "");

			// Only register if the workspace exists
			if (existsSync(workspacePath)) {
				await agentRegistry.registerWorkspace(workspacePath);
				log.info(`Registered workspace: ${workspacePath}`);
			} else {
				log.info(`Workspace path does not exist: ${workspacePath}`);
			}
		}

		// Detect agent usage
		const agents = await agentRegistry.getAgents();
		const detectedAgent = agents.find((agent: Agent) =>
			systemPrompt.includes(agent.systemPrompt.trim()),
		);

		if (!detectedAgent) {
			// No agent detected, return original buffer unmodified
			return {
				modifiedBody: requestBodyBuffer,
				agentUsed: null,
				originalModel,
				appliedModel: originalModel,
			};
		}

		log.info(
			`Detected agent usage: ${detectedAgent.name} (${detectedAgent.id})`,
		);

		// Look up model preference
		const preference = dbOps.getAgentPreference(detectedAgent.id);
		const preferredModel = preference?.model || detectedAgent.model;

		// If the preferred model is the same as original, no modification needed
		if (preferredModel === originalModel) {
			return {
				modifiedBody: requestBodyBuffer,
				agentUsed: detectedAgent.id,
				originalModel,
				appliedModel: originalModel,
			};
		}

		// Modify the request body with the preferred model
		log.info(`Modifying model from ${originalModel} to ${preferredModel}`);
		requestBody.model = preferredModel;

		// Convert back to buffer
		const modifiedBodyText = JSON.stringify(requestBody);
		const encodedData = new TextEncoder().encode(modifiedBodyText);
		// Create a new ArrayBuffer to ensure compatibility
		const modifiedBody = new ArrayBuffer(encodedData.byteLength);
		new Uint8Array(modifiedBody).set(encodedData);

		return {
			modifiedBody,
			agentUsed: detectedAgent.id,
			originalModel,
			appliedModel: preferredModel,
		};
	} catch (error) {
		log.error("Failed to intercept/modify request:", error);
		// On error, return original body unmodified
		return {
			modifiedBody: requestBodyBuffer,
			agentUsed: null,
			originalModel: null,
			appliedModel: null,
		};
	}
}

interface MessageContent {
	type?: string;
	text?: string;
}

interface Message {
	role?: string;
	content?: string | MessageContent[];
}

interface SystemMessage {
	type: string;
	text: string;
	cache_control?: {
		type: string;
	};
}

interface RequestBody {
	messages?: Message[];
	model?: string;
	system?: string | SystemMessage[];
}

/**
 * Extracts system prompt from request body
 * This will extract system messages and user messages that contain system-like content
 * @param requestBody - Parsed request body
 * @returns System prompt string or null
 */
function extractSystemPrompt(requestBody: RequestBody): string | null {
	const extractLog = new Logger("ExtractSystemPrompt");
	const allSystemContent: string[] = [];

	// First check for system field at root level (Claude Code pattern)
	if (requestBody.system) {
		extractLog.info("Found system field at root level");
		if (typeof requestBody.system === "string") {
			extractLog.info(
				`System field is string, length: ${requestBody.system.length}`,
			);
			allSystemContent.push(requestBody.system);
		}
		if (Array.isArray(requestBody.system)) {
			extractLog.info(
				`System field is array with ${requestBody.system.length} items`,
			);
			// Concatenate all text from system messages
			const systemText = requestBody.system
				.filter(
					(item): item is SystemMessage => item.type === "text" && !!item.text,
				)
				.map((item) => item.text)
				.join("\n");
			extractLog.info(`Extracted system text length: ${systemText.length}`);
			if (systemText) {
				allSystemContent.push(systemText);
			}
		}
	}

	// Then check messages array
	if (requestBody.messages && Array.isArray(requestBody.messages)) {
		extractLog.info(
			`Checking messages array with ${requestBody.messages.length} messages`,
		);

		// Look for system messages
		const systemMessage = requestBody.messages.find(
			(msg) => msg.role === "system",
		);

		if (systemMessage) {
			extractLog.info("Found system role message");
			if (typeof systemMessage.content === "string") {
				extractLog.info(
					`System message content is string, length: ${systemMessage.content.length}`,
				);
				allSystemContent.push(systemMessage.content);
			}
			if (Array.isArray(systemMessage.content)) {
				extractLog.info(
					`System message content is array with ${systemMessage.content.length} items`,
				);
				const systemText = systemMessage.content
					.filter(
						(item): item is MessageContent & { text: string } =>
							item.type === "text" && !!item.text,
					)
					.map((item) => item.text)
					.join("\n");
				extractLog.info(
					`Extracted system message text length: ${systemText.length}`,
				);
				if (systemText) {
					allSystemContent.push(systemText);
				}
			}
		} else {
			extractLog.info("No system role message found, checking user messages");
		}

		// Also check for system prompt in user messages
		const userMessage = requestBody.messages.find((msg) => msg.role === "user");

		if (userMessage && Array.isArray(userMessage.content)) {
			// Concatenate all text content from the user message
			const textContents = userMessage.content.filter(
				(item): item is MessageContent & { text: string } =>
					item.type === "text" && !!item.text,
			);

			extractLog.info(
				`Found ${textContents.length} text content items in user message`,
			);

			const allUserText = textContents.map((item) => item.text).join("\n");

			if (
				allUserText.includes("Contents of") &&
				allUserText.includes("CLAUDE.md")
			) {
				extractLog.info(
					"User message contains 'Contents of' and 'CLAUDE.md' - including in system prompt",
				);
				allSystemContent.push(allUserText);
			}
		} else if (userMessage && typeof userMessage.content === "string") {
			if (
				userMessage.content.includes("Contents of") &&
				userMessage.content.includes("CLAUDE.md")
			) {
				extractLog.info(
					"User message string contains 'Contents of' and 'CLAUDE.md' - including in system prompt",
				);
				allSystemContent.push(userMessage.content);
			}
		}
	}

	// Combine all system content
	if (allSystemContent.length > 0) {
		const combined = allSystemContent.join("\n\n");
		extractLog.info(
			`Combined system prompt length: ${combined.length} from ${allSystemContent.length} sources`,
		);
		return combined;
	}

	return null;
}

/**
 * Extracts agent directories from system prompt
 * @param systemPrompt - The system prompt text
 * @returns Array of agent directory paths
 */
function extractAgentDirectories(systemPrompt: string): string[] {
	const extractDirLog = new Logger("ExtractAgentDirs");
	const directories = new Set<string>();

	// Regex #1: Look for explicit /.claude/agents paths
	const agentPathRegex = /([\\/][\w\-. ]*?\/.claude\/agents)(?=[\s"'\]])/g;
	let match: RegExpExecArray | null;

	match = agentPathRegex.exec(systemPrompt);
	while (match !== null) {
		const dir = resolve(match[1]);
		directories.add(dir);
		match = agentPathRegex.exec(systemPrompt);
	}

	// Regex #2: Look for repo root pattern "Contents of (.*?)/CLAUDE.md"
	const repoRootRegex = /Contents of ([^\n]+?)\/CLAUDE\.md/g;

	let matchCount = 0;
	match = repoRootRegex.exec(systemPrompt);
	while (match !== null) {
		matchCount++;
		const repoRoot = match[1];
		extractDirLog.info(
			`Found CLAUDE.md path match ${matchCount}: "${match[0]}"`,
		);
		extractDirLog.info(`Extracted repo root: "${repoRoot}"`);

		// Clean up any escaped slashes
		const cleanedRoot = repoRoot.replace(/\\\//g, "/");
		const agentsDir = join(cleanedRoot, ".claude", "agents");
		const resolvedDir = resolve(agentsDir);

		extractDirLog.info(`Resolved agents dir: "${resolvedDir}"`);
		directories.add(resolvedDir);
		match = repoRootRegex.exec(systemPrompt);
	}

	if (matchCount === 0 && systemPrompt.includes("CLAUDE.md")) {
		extractDirLog.info(
			"No CLAUDE.md path matches found despite CLAUDE.md being in prompt",
		);
	}

	return Array.from(directories);
}
</file>

<file path="packages/dashboard-web/src/components/RequestsTab.tsx">
import {
	formatCost,
	formatDuration,
	formatTokens,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import {
	Bot,
	Calendar,
	ChevronDown,
	ChevronRight,
	Clock,
	Eye,
	Filter,
	Hash,
	RefreshCw,
	User,
	X,
} from "lucide-react";
import { useState } from "react";
import type { RequestPayload, RequestSummary } from "../api";
import { useRequests } from "../hooks/queries";
import { useRequestStream } from "../hooks/useRequestStream";
import { CopyButton } from "./CopyButton";
import { RequestDetailsModal } from "./RequestDetailsModal";
import { TokenUsageDisplay } from "./TokenUsageDisplay";
import { Badge } from "./ui/badge";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuTrigger,
} from "./ui/dropdown-menu";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "./ui/select";

export function RequestsTab() {
	const [expandedRequests, setExpandedRequests] = useState<Set<string>>(
		new Set(),
	);
	const [modalRequest, setModalRequest] = useState<RequestPayload | null>(null);
	const [accountFilter, setAccountFilter] = useState<string>("all");
	const [agentFilter, setAgentFilter] = useState<string>("all");
	const [dateFrom, setDateFrom] = useState<string>("");
	const [dateTo, setDateTo] = useState<string>("");
	const [showFilters, setShowFilters] = useState(false);
	const [statusCodeFilters, setStatusCodeFilters] = useState<Set<string>>(
		new Set(),
	);

	const {
		data: requestsData,
		isLoading: loading,
		error,
		refetch: loadRequests,
	} = useRequests(200);

	// Enable real-time updates
	useRequestStream(200);

	// Transform the data to match the expected structure
	const data = requestsData
		? {
				requests: requestsData.requests,
				summaries: new Map(
					requestsData.detailsMap instanceof Map
						? requestsData.detailsMap
						: requestsData.detailsMap.map(
								(s: RequestSummary) => [s.id, s] as [string, RequestSummary],
							),
				),
			}
		: null;

	// Extract unique accounts for filter dropdown
	const uniqueAccounts = data
		? Array.from(
				new Set(
					data.requests
						.map((r) => r.meta.accountName || r.meta.accountId)
						.filter(Boolean),
				),
			).sort()
		: [];

	// Extract unique status codes for filter
	const uniqueStatusCodes = data
		? Array.from(
				new Set(
					data.requests
						.map((r) => r.response?.status)
						.filter((status): status is number => status !== undefined),
				),
			).sort((a, b) => a - b)
		: [];

	// Extract unique agents for filter
	const uniqueAgents = data
		? Array.from(
				new Set(
					data.requests
						.map((r) => {
							const summary = data.summaries.get(r.id);
							return summary?.agentUsed || r.meta.agentUsed;
						})
						.filter(Boolean),
				),
			).sort()
		: [];

	// Filter requests based on selected filters
	const filteredRequests = data
		? data.requests.filter((request) => {
				// Account filter
				if (accountFilter !== "all") {
					const requestAccount =
						request.meta.accountName || request.meta.accountId;
					if (requestAccount !== accountFilter) return false;
				}

				// Agent filter
				if (agentFilter !== "all") {
					const summary = data.summaries.get(request.id);
					const requestAgent = summary?.agentUsed || request.meta.agentUsed;
					if (requestAgent !== agentFilter) return false;
				}

				// Status code filter
				if (statusCodeFilters.size > 0 && request.response?.status) {
					if (!statusCodeFilters.has(request.response.status.toString())) {
						return false;
					}
				}

				// Date range filter
				const requestDate = new Date(request.meta.timestamp);
				if (dateFrom) {
					const fromDate = new Date(dateFrom);
					fromDate.setHours(0, 0, 0, 0);
					if (requestDate < fromDate) return false;
				}
				if (dateTo) {
					const toDate = new Date(dateTo);
					toDate.setHours(23, 59, 59, 999);
					if (requestDate > toDate) return false;
				}

				return true;
			})
		: [];

	const toggleExpanded = (id: string) => {
		setExpandedRequests((prev) => {
			const next = new Set(prev);
			if (next.has(id)) {
				next.delete(id);
			} else {
				next.add(id);
			}
			return next;
		});
	};

	// Date preset helpers
	const applyDatePreset = (preset: string) => {
		const now = new Date();
		const toDate = now.toISOString().slice(0, 16);

		switch (preset) {
			case "1h": {
				const fromDate = new Date(now.getTime() - 60 * 60 * 1000);
				setDateFrom(fromDate.toISOString().slice(0, 16));
				setDateTo(toDate);
				break;
			}
			case "24h": {
				const fromDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
				setDateFrom(fromDate.toISOString().slice(0, 16));
				setDateTo(toDate);
				break;
			}
			case "7d": {
				const fromDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
				setDateFrom(fromDate.toISOString().slice(0, 16));
				setDateTo(toDate);
				break;
			}
			case "30d": {
				const fromDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
				setDateFrom(fromDate.toISOString().slice(0, 16));
				setDateTo(toDate);
				break;
			}
		}
	};

	const toggleStatusCode = (code: string) => {
		setStatusCodeFilters((prev) => {
			const next = new Set(prev);
			if (next.has(code)) {
				next.delete(code);
			} else {
				next.add(code);
			}
			return next;
		});
	};

	const getStatusCodeColor = (code: number) => {
		if (code >= 200 && code < 300) return "text-green-600";
		if (code >= 400 && code < 500) return "text-yellow-600";
		if (code >= 500) return "text-red-600";
		return "text-gray-600";
	};

	const clearAllFilters = () => {
		setAccountFilter("all");
		setAgentFilter("all");
		setDateFrom("");
		setDateTo("");
		setStatusCodeFilters(new Set());
	};

	const hasActiveFilters =
		accountFilter !== "all" ||
		agentFilter !== "all" ||
		dateFrom ||
		dateTo ||
		statusCodeFilters.size > 0;

	const decodeBase64 = (str: string | null): string => {
		if (!str) return "No data";
		try {
			// Handle edge cases like "[streamed]" from older data
			if (str === "[streamed]") {
				return "[Streaming data not captured]";
			}
			return atob(str);
		} catch (error) {
			console.error("Failed to decode base64:", error, "Input:", str);
			return `Failed to decode: ${str}`;
		}
	};

	/**
	 * Copy the given request to the clipboard as pretty-printed JSON, with
	 * any base64-encoded bodies already decoded for easier debugging.
	 */
	// copyRequest helper removed – handled inline by CopyButton

	if (loading) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-muted-foreground">Loading requests...</p>
				</CardContent>
			</Card>
		);
	}

	if (error) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-destructive">
						Error: {error instanceof Error ? error.message : String(error)}
					</p>
					<Button
						onClick={() => loadRequests()}
						variant="outline"
						size="sm"
						className="mt-2"
					>
						<RefreshCw className="mr-2 h-4 w-4" />
						Retry
					</Button>
				</CardContent>
			</Card>
		);
	}

	return (
		<Card>
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle>Request History</CardTitle>
						<CardDescription>
							Detailed request and response data (last 200)
						</CardDescription>
					</div>
					<div className="flex gap-2">
						<Button
							onClick={() => setShowFilters(!showFilters)}
							variant={showFilters ? "default" : "outline"}
							size="sm"
							className="relative"
						>
							<Filter className="h-4 w-4 mr-2" />
							Filters
							{hasActiveFilters && !showFilters && (
								<span className="absolute -top-1 -right-1 h-2 w-2 bg-primary rounded-full animate-pulse" />
							)}
						</Button>
						<Button onClick={() => loadRequests()} variant="ghost" size="icon">
							<RefreshCw className="h-4 w-4" />
						</Button>
					</div>
				</div>
			</CardHeader>
			<CardContent>
				{/* Active Filters Display */}
				{hasActiveFilters && (
					<div className="mb-4 p-3 bg-muted/50 rounded-lg">
						<div className="flex flex-wrap items-center gap-2">
							{accountFilter !== "all" && (
								<Badge variant="outline" className="gap-1.5 pr-1">
									<User className="h-3 w-3" />
									{accountFilter}
									<button
										type="button"
										onClick={() => setAccountFilter("all")}
										className="ml-1 p-0.5 hover:bg-destructive/20 rounded"
									>
										<X className="h-3 w-3" />
									</button>
								</Badge>
							)}
							{agentFilter !== "all" && (
								<Badge variant="outline" className="gap-1.5 pr-1">
									<Bot className="h-3 w-3" />
									{agentFilter}
									<button
										type="button"
										onClick={() => setAgentFilter("all")}
										className="ml-1 p-0.5 hover:bg-destructive/20 rounded"
									>
										<X className="h-3 w-3" />
									</button>
								</Badge>
							)}
							{statusCodeFilters.size > 0 && (
								<Badge variant="outline" className="gap-1.5 pr-1">
									<Hash className="h-3 w-3" />
									{Array.from(statusCodeFilters).join(", ")}
									<button
										type="button"
										onClick={() => setStatusCodeFilters(new Set())}
										className="ml-1 p-0.5 hover:bg-destructive/20 rounded"
									>
										<X className="h-3 w-3" />
									</button>
								</Badge>
							)}
							{(dateFrom || dateTo) && (
								<Badge variant="outline" className="gap-1.5 pr-1">
									<Calendar className="h-3 w-3" />
									{dateFrom && dateTo
										? "Custom range"
										: dateFrom
											? `From ${new Date(dateFrom).toLocaleDateString()}`
											: `Until ${new Date(dateTo).toLocaleDateString()}`}
									<button
										type="button"
										onClick={() => {
											setDateFrom("");
											setDateTo("");
										}}
										className="ml-1 p-0.5 hover:bg-destructive/20 rounded"
									>
										<X className="h-3 w-3" />
									</button>
								</Badge>
							)}
							<div className="ml-auto flex items-center gap-2">
								<span className="text-xs text-muted-foreground">
									{filteredRequests.length} of {data?.requests.length || 0}{" "}
									requests
								</span>
								<Button
									variant="ghost"
									size="sm"
									onClick={clearAllFilters}
									className="h-7 text-xs"
								>
									Clear all
								</Button>
							</div>
						</div>
					</div>
				)}

				{/* Filters Panel */}
				{showFilters && (
					<div className="mb-6 border rounded-lg bg-card">
						<div className="p-4 border-b">
							<div className="flex items-center justify-between">
								<h3 className="font-medium">Filters</h3>
								<Button
									variant="ghost"
									size="sm"
									onClick={() => setShowFilters(false)}
									className="h-8 w-8 p-0"
								>
									<X className="h-4 w-4" />
								</Button>
							</div>
						</div>

						<div className="p-4 space-y-4">
							{/* Time Range Section */}
							<div>
								<h4 className="text-sm font-medium mb-3 flex items-center gap-2">
									<Clock className="h-4 w-4" />
									Time Range
								</h4>
								<div className="flex flex-wrap gap-2 mb-3">
									<Button
										variant={dateFrom || dateTo ? "outline" : "secondary"}
										size="sm"
										onClick={() => applyDatePreset("1h")}
									>
										Last hour
									</Button>
									<Button
										variant={dateFrom || dateTo ? "outline" : "secondary"}
										size="sm"
										onClick={() => applyDatePreset("24h")}
									>
										Last 24h
									</Button>
									<Button
										variant={dateFrom || dateTo ? "outline" : "secondary"}
										size="sm"
										onClick={() => applyDatePreset("7d")}
									>
										Last 7 days
									</Button>
									<Button
										variant={dateFrom || dateTo ? "outline" : "secondary"}
										size="sm"
										onClick={() => applyDatePreset("30d")}
									>
										Last 30 days
									</Button>
								</div>
								<div className="grid grid-cols-2 gap-3">
									<div>
										<Label htmlFor="date-from" className="text-xs">
											From
										</Label>
										<Input
											id="date-from"
											type="datetime-local"
											value={dateFrom}
											onChange={(e) => setDateFrom(e.target.value)}
											className="h-9 text-sm"
										/>
									</div>
									<div>
										<Label htmlFor="date-to" className="text-xs">
											To
										</Label>
										<Input
											id="date-to"
											type="datetime-local"
											value={dateTo}
											onChange={(e) => setDateTo(e.target.value)}
											className="h-9 text-sm"
										/>
									</div>
								</div>
							</div>

							<div className="h-px bg-border" />

							{/* Resource Filters */}
							<div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
								{/* Account Filter */}
								<div>
									<Label className="text-xs flex items-center gap-1 mb-2">
										<User className="h-3 w-3" />
										Account
									</Label>
									<Select
										value={accountFilter}
										onValueChange={setAccountFilter}
									>
										<SelectTrigger className="h-9">
											<SelectValue placeholder="All accounts" />
										</SelectTrigger>
										<SelectContent>
											<SelectItem value="all">All accounts</SelectItem>
											{uniqueAccounts.map((account) => (
												<SelectItem key={account} value={account || ""}>
													{account}
												</SelectItem>
											))}
										</SelectContent>
									</Select>
								</div>

								{/* Agent Filter */}
								<div>
									<Label className="text-xs flex items-center gap-1 mb-2">
										<Bot className="h-3 w-3" />
										Agent
									</Label>
									<Select value={agentFilter} onValueChange={setAgentFilter}>
										<SelectTrigger className="h-9">
											<SelectValue placeholder="All agents" />
										</SelectTrigger>
										<SelectContent>
											<SelectItem value="all">All agents</SelectItem>
											{uniqueAgents.map((agent) => (
												<SelectItem key={agent} value={agent || ""}>
													{agent}
												</SelectItem>
											))}
										</SelectContent>
									</Select>
								</div>

								{/* Status Code Filter */}
								<div>
									<Label className="text-xs flex items-center gap-1 mb-2">
										<Hash className="h-3 w-3" />
										Status Code
									</Label>
									<DropdownMenu>
										<DropdownMenuTrigger asChild>
											<Button
												variant="outline"
												className="h-9 w-full justify-between font-normal"
											>
												{statusCodeFilters.size > 0
													? `${statusCodeFilters.size} selected`
													: "All codes"}
												<ChevronDown className="h-4 w-4 opacity-50" />
											</Button>
										</DropdownMenuTrigger>
										<DropdownMenuContent className="w-56 max-h-64 overflow-y-auto">
											<div className="p-2">
												<div className="text-xs font-medium text-muted-foreground mb-2">
													Select status codes
												</div>
												{uniqueStatusCodes.map((code) => (
													<button
														key={code}
														type="button"
														className="flex items-center gap-2 p-2 hover:bg-accent rounded cursor-pointer w-full text-left"
														onClick={() => toggleStatusCode(code.toString())}
													>
														<div
															className={`w-4 h-4 border rounded-sm flex items-center justify-center ${
																statusCodeFilters.has(code.toString())
																	? "bg-primary border-primary"
																	: "border-input"
															}`}
														>
															{statusCodeFilters.has(code.toString()) && (
																<svg
																	className="w-3 h-3 text-primary-foreground"
																	fill="none"
																	viewBox="0 0 24 24"
																	stroke="currentColor"
																	aria-label="Selected"
																>
																	<title>Selected</title>
																	<path
																		strokeLinecap="round"
																		strokeLinejoin="round"
																		strokeWidth={3}
																		d="M5 13l4 4L19 7"
																	/>
																</svg>
															)}
														</div>
														<span
															className={`text-sm font-medium ${getStatusCodeColor(code)}`}
														>
															{code}
														</span>
													</button>
												))}
											</div>
										</DropdownMenuContent>
									</DropdownMenu>
								</div>
							</div>
						</div>
					</div>
				)}

				{!data ? (
					<p className="text-muted-foreground">No requests found</p>
				) : filteredRequests.length === 0 ? (
					<p className="text-muted-foreground">
						No requests match the selected filters
					</p>
				) : (
					<div className="space-y-2">
						{filteredRequests.map((request) => {
							const isExpanded = expandedRequests.has(request.id);
							const isError = request.error || !request.meta.success;
							const statusCode = request.response?.status;
							const summary = data.summaries.get(request.id);

							return (
								<div
									key={request.id}
									className={`border rounded-lg p-3 transition-all duration-300 ${
										isError ? "border-destructive/50" : "border-border"
									} ${request.meta.pending ? "animate-pulse opacity-70" : "opacity-100"}`}
								>
									<button
										type="button"
										className="flex items-center justify-between cursor-pointer w-full text-left"
										onClick={() => toggleExpanded(request.id)}
									>
										<div className="flex items-center gap-2 flex-wrap">
											{isExpanded ? (
												<ChevronDown className="h-4 w-4" />
											) : (
												<ChevronRight className="h-4 w-4" />
											)}
											<span className="text-sm font-mono">
												{new Date(request.meta.timestamp).toLocaleTimeString()}
											</span>
											{(request.meta.method || summary?.method) && (
												<span className="text-sm font-medium">
													{request.meta.method || summary?.method}
												</span>
											)}
											{(request.meta.path || summary?.path) && (
												<span className="text-sm text-muted-foreground font-mono">
													{request.meta.path || summary?.path}
												</span>
											)}
											{statusCode && (
												<span
													className={`text-sm font-medium ${
														statusCode >= 200 && statusCode < 300
															? "text-green-600"
															: statusCode >= 400 && statusCode < 500
																? "text-yellow-600"
																: "text-red-600"
													}`}
												>
													{statusCode}
												</span>
											)}
											{summary?.model && (
												<Badge variant="secondary" className="text-xs">
													{summary.model}
												</Badge>
											)}
											{(summary?.agentUsed || request.meta.agentUsed) && (
												<Badge variant="secondary" className="text-xs">
													Agent: {summary?.agentUsed || request.meta.agentUsed}
												</Badge>
											)}
											{(summary?.totalTokens || request.meta.pending) && (
												<Badge variant="outline" className="text-xs">
													{summary?.totalTokens
														? formatTokens(summary.totalTokens)
														: "--"}{" "}
													tokens
												</Badge>
											)}
											{(summary?.costUsd || request.meta.pending) && (
												<Badge variant="default" className="text-xs">
													{summary?.costUsd && summary.costUsd > 0
														? formatCost(summary.costUsd)
														: "--"}
												</Badge>
											)}
											{summary?.tokensPerSecond &&
												summary.tokensPerSecond > 0 && (
													<Badge variant="secondary" className="text-xs">
														{formatTokensPerSecond(summary.tokensPerSecond)}
													</Badge>
												)}
											{(request.meta.accountName || request.meta.accountId) && (
												<span className="text-sm text-muted-foreground">
													via{" "}
													{request.meta.accountName ||
														`${request.meta.accountId?.slice(0, 8)}...`}
												</span>
											)}
											{request.meta.rateLimited && (
												<Badge variant="warning" className="text-xs">
													Rate Limited
												</Badge>
											)}
											{request.error && (
												<span className="text-sm text-destructive">
													Error: {request.error}
												</span>
											)}
										</div>
										<div className="text-sm text-muted-foreground flex items-center gap-2">
											{(summary?.responseTimeMs || request.meta.pending) && (
												<span>
													{summary?.responseTimeMs
														? formatDuration(summary.responseTimeMs)
														: "--"}
												</span>
											)}
											{request.meta.retry !== undefined &&
												request.meta.retry > 0 && (
													<span>Retry {request.meta.retry}</span>
												)}
											<span>ID: {request.id.slice(0, 8)}...</span>
										</div>
									</button>

									{/* Action buttons */}
									<div className="flex justify-end gap-2 mt-2">
										<Button
											variant="ghost"
											size="icon"
											onClick={() => setModalRequest(request)}
											title="View Details"
										>
											<Eye className="h-4 w-4" />
										</Button>
										<CopyButton
											variant="ghost"
											size="icon"
											title="Copy as JSON"
											getValue={() => {
												const decoded: RequestPayload & { decoded?: true } = {
													...request,
													request: {
														...request.request,
														body: request.request.body
															? decodeBase64(request.request.body)
															: null,
													},
													response: request.response
														? {
																...request.response,
																body: request.response.body
																	? decodeBase64(request.response.body)
																	: null,
															}
														: null,
													decoded: true,
												};
												return JSON.stringify(decoded, null, 2);
											}}
										/>
									</div>

									{isExpanded && (
										<div className="mt-3 space-y-3">
											<TokenUsageDisplay summary={summary} />
											<Button
												variant="outline"
												size="sm"
												onClick={() => setModalRequest(request)}
												className="w-full"
											>
												<Eye className="h-4 w-4 mr-2" />
												View More Details
											</Button>
										</div>
									)}
								</div>
							);
						})}
					</div>
				)}
			</CardContent>

			{modalRequest && (
				<RequestDetailsModal
					request={modalRequest}
					summary={data?.summaries.get(modalRequest.id)}
					isOpen={true}
					onClose={() => setModalRequest(null)}
				/>
			)}
		</Card>
	);
}
</file>

<file path="packages/http-api/src/handlers/tools.ts">
import type { DatabaseOperations } from "@ccflare/database";
import { BadRequest, errorResponse, jsonResponse } from "@ccflare/http-common";

/**
 * Create system prompt interceptor handlers
 */
export function createSystemPromptInterceptorHandler(
	dbOps: DatabaseOperations,
) {
	return {
		/**
		 * Get system prompt interceptor configuration
		 */
		getSystemPromptConfig: (): Response => {
			const config = dbOps.getInterceptorConfig("system_prompt");

			// Return default configuration if none exists
			if (!config) {
				// Try to get the last-seen system prompt as the default target
				const lastSeenPrompt = dbOps.getSystemKV("last_seen_system_prompt");
				const DEFAULT_TARGET_PROMPT =
					"You are Claude Code, Anthropic's official CLI for Claude.";
				const defaultTemplate =
					"You are a helpful assistant.\n\n---\n\n{{env_block}}\n\n{{git_status_block}}";

				return jsonResponse({
					isEnabled: false,
					targetPrompt: lastSeenPrompt || DEFAULT_TARGET_PROMPT,
					replacementPrompt: defaultTemplate,
					toolsEnabled: true,
				});
			}

			return jsonResponse({
				isEnabled: config.isEnabled,
				targetPrompt: config.config.targetPrompt,
				replacementPrompt: config.config.replacementPrompt,
				toolsEnabled: config.config.toolsEnabled,
			});
		},

		/**
		 * Set system prompt interceptor configuration
		 */
		setSystemPromptConfig: async (req: Request): Promise<Response> => {
			try {
				const body = await req.json();

				// Validate required fields exist and have correct types
				if (body.isEnabled === undefined || body.isEnabled === null) {
					return errorResponse(BadRequest("isEnabled is required"));
				}
				if (typeof body.isEnabled !== "boolean") {
					return errorResponse(BadRequest("isEnabled must be a boolean"));
				}

				if (body.targetPrompt === undefined || body.targetPrompt === null) {
					return errorResponse(BadRequest("targetPrompt is required"));
				}
				if (typeof body.targetPrompt !== "string") {
					return errorResponse(BadRequest("targetPrompt must be a string"));
				}
				if (body.targetPrompt.trim() === "") {
					return errorResponse(BadRequest("targetPrompt cannot be empty"));
				}

				if (
					body.replacementPrompt === undefined ||
					body.replacementPrompt === null
				) {
					return errorResponse(BadRequest("replacementPrompt is required"));
				}
				if (typeof body.replacementPrompt !== "string") {
					return errorResponse(
						BadRequest("replacementPrompt must be a string"),
					);
				}
				// Note: Empty strings are intentionally allowed for replacementPrompt
				// This enables users to effectively disable prompt replacement

				if (body.toolsEnabled === undefined || body.toolsEnabled === null) {
					return errorResponse(BadRequest("toolsEnabled is required"));
				}
				if (typeof body.toolsEnabled !== "boolean") {
					return errorResponse(BadRequest("toolsEnabled must be a boolean"));
				}

				// Save configuration to database
				dbOps.setInterceptorConfig("system_prompt", body.isEnabled, {
					targetPrompt: body.targetPrompt,
					replacementPrompt: body.replacementPrompt,
					toolsEnabled: body.toolsEnabled,
				});

				return jsonResponse({
					success: true,
					isEnabled: body.isEnabled,
					targetPrompt: body.targetPrompt,
					replacementPrompt: body.replacementPrompt,
					toolsEnabled: body.toolsEnabled,
				});
			} catch (error) {
				if (error instanceof SyntaxError) {
					return errorResponse(BadRequest("Invalid JSON"));
				}
				throw error;
			}
		},

		/**
		 * Reset system prompt interceptor configuration
		 */
		resetSystemPromptConfig: (): Response => {
			// Delete the interceptor config, which will cause the GET endpoint
			// to return the default state with last-seen prompt
			dbOps.deleteInterceptorConfig("system_prompt");

			// Return 204 No Content to indicate successful deletion
			return new Response(null, { status: 204 });
		},
	};
}
</file>

<file path="packages/http-api/src/router.ts">
import { validateNumber } from "@ccflare/core";
import {
	createAccountAddHandler,
	createAccountPauseHandler,
	createAccountRemoveHandler,
	createAccountRenameHandler,
	createAccountResumeHandler,
	createAccountsListHandler,
	createAccountTierUpdateHandler,
} from "./handlers/accounts";
import {
	createAgentPreferenceUpdateHandler,
	createAgentsListHandler,
	createBulkAgentPreferenceUpdateHandler,
	createWorkspacesListHandler,
} from "./handlers/agents";
import { createAgentUpdateHandler } from "./handlers/agents-update";
import { createAnalyticsHandler } from "./handlers/analytics";
import { createConfigHandlers } from "./handlers/config";
import { createHealthHandler } from "./handlers/health";
import { createLogsStreamHandler } from "./handlers/logs";
import { createLogsHistoryHandler } from "./handlers/logs-history";
import {
	createCleanupHandler,
	createCompactHandler,
} from "./handlers/maintenance";
import {
	createOAuthCallbackHandler,
	createOAuthInitHandler,
} from "./handlers/oauth";
import {
	createRequestsDetailHandler,
	createRequestsSummaryHandler,
} from "./handlers/requests";
import { createRequestsStreamHandler } from "./handlers/requests-stream";
import { createStatsHandler, createStatsResetHandler } from "./handlers/stats";
import { createSystemPromptInterceptorHandler } from "./handlers/tools";
import type { APIContext } from "./types";
import { errorResponse } from "./utils/http-error";

/**
 * API Router that handles all API endpoints
 */
export class APIRouter {
	private context: APIContext;
	private handlers: Map<
		string,
		(req: Request, url: URL) => Response | Promise<Response>
	>;

	constructor(context: APIContext) {
		this.context = context;
		this.handlers = new Map();
		this.registerHandlers();
	}

	private registerHandlers(): void {
		const { db, config, dbOps } = this.context;

		// Create handlers
		const healthHandler = createHealthHandler(db, config);
		const statsHandler = createStatsHandler(dbOps);
		const statsResetHandler = createStatsResetHandler(dbOps);
		const accountsHandler = createAccountsListHandler(db);
		const accountAddHandler = createAccountAddHandler(dbOps, config);
		const _accountRemoveHandler = createAccountRemoveHandler(dbOps);
		const _accountTierHandler = createAccountTierUpdateHandler(dbOps);
		const requestsSummaryHandler = createRequestsSummaryHandler(db);
		const requestsDetailHandler = createRequestsDetailHandler(dbOps);
		const configHandlers = createConfigHandlers(config);
		const logsStreamHandler = createLogsStreamHandler();
		const logsHistoryHandler = createLogsHistoryHandler();
		const analyticsHandler = createAnalyticsHandler(this.context);
		const oauthInitHandler = createOAuthInitHandler(dbOps);
		const oauthCallbackHandler = createOAuthCallbackHandler(dbOps);
		const agentsHandler = createAgentsListHandler(dbOps);
		const workspacesHandler = createWorkspacesListHandler();
		const requestsStreamHandler = createRequestsStreamHandler();
		const cleanupHandler = createCleanupHandler(dbOps, config);
		const compactHandler = createCompactHandler(dbOps);
		const toolsHandler = createSystemPromptInterceptorHandler(dbOps);

		// Register routes
		this.handlers.set("GET:/health", () => healthHandler());
		this.handlers.set("GET:/api/stats", () => statsHandler());
		this.handlers.set("POST:/api/stats/reset", () => statsResetHandler());
		this.handlers.set("GET:/api/accounts", () => accountsHandler());
		this.handlers.set("POST:/api/accounts", (req) => accountAddHandler(req));
		this.handlers.set("POST:/api/oauth/init", (req) => oauthInitHandler(req));
		this.handlers.set("POST:/api/oauth/callback", (req) =>
			oauthCallbackHandler(req),
		);
		this.handlers.set("GET:/api/requests", (_req, url) => {
			const limitParam = url.searchParams.get("limit");
			const limit =
				validateNumber(limitParam || "50", "limit", {
					min: 1,
					max: 1000,
					integer: true,
				}) || 50;
			return requestsSummaryHandler(limit);
		});
		this.handlers.set("GET:/api/requests/detail", (_req, url) => {
			const limitParam = url.searchParams.get("limit");
			const limit =
				validateNumber(limitParam || "100", "limit", {
					min: 1,
					max: 1000,
					integer: true,
				}) || 100;
			return requestsDetailHandler(limit);
		});
		this.handlers.set("GET:/api/requests/stream", () =>
			requestsStreamHandler(),
		);
		this.handlers.set("GET:/api/config", () => configHandlers.getConfig());
		this.handlers.set("GET:/api/config/strategy", () =>
			configHandlers.getStrategy(),
		);
		this.handlers.set("POST:/api/config/strategy", (req) =>
			configHandlers.setStrategy(req),
		);
		this.handlers.set("GET:/api/strategies", () =>
			configHandlers.getStrategies(),
		);
		this.handlers.set("GET:/api/config/model", () =>
			configHandlers.getDefaultAgentModel(),
		);
		this.handlers.set("POST:/api/config/model", (req) =>
			configHandlers.setDefaultAgentModel(req),
		);
		this.handlers.set("GET:/api/config/retention", () =>
			configHandlers.getRetention(),
		);
		this.handlers.set("POST:/api/config/retention", (req) =>
			configHandlers.setRetention(req),
		);
		this.handlers.set("POST:/api/maintenance/cleanup", () => cleanupHandler());
		this.handlers.set("POST:/api/maintenance/compact", () => compactHandler());
		this.handlers.set("GET:/api/logs/stream", () => logsStreamHandler());
		this.handlers.set("GET:/api/logs/history", () => logsHistoryHandler());
		this.handlers.set("GET:/api/analytics", (_req, url) => {
			return analyticsHandler(url.searchParams);
		});
		this.handlers.set("GET:/api/agents", () => agentsHandler());
		this.handlers.set("POST:/api/agents/bulk-preference", (req) => {
			const bulkHandler = createBulkAgentPreferenceUpdateHandler(
				this.context.dbOps,
			);
			return bulkHandler(req);
		});
		this.handlers.set("GET:/api/workspaces", () => workspacesHandler());
		this.handlers.set("GET:/api/tools/interceptors/system-prompt", () =>
			toolsHandler.getSystemPromptConfig(),
		);
		this.handlers.set("POST:/api/tools/interceptors/system-prompt", (req) =>
			toolsHandler.setSystemPromptConfig(req),
		);
		this.handlers.set("DELETE:/api/tools/interceptors/system-prompt", () =>
			toolsHandler.resetSystemPromptConfig(),
		);
	}

	/**
	 * Wrap a handler with error handling
	 */
	private wrapHandler(
		handler: (req: Request, url: URL) => Response | Promise<Response>,
	): (req: Request, url: URL) => Promise<Response> {
		return async (req: Request, url: URL) => {
			try {
				return await handler(req, url);
			} catch (error) {
				return errorResponse(error);
			}
		};
	}

	/**
	 * Handle an incoming request
	 */
	async handleRequest(url: URL, req: Request): Promise<Response | null> {
		const path = url.pathname;
		const method = req.method;
		const key = `${method}:${path}`;

		// Check for exact match
		const handler = this.handlers.get(key);
		if (handler) {
			return await this.wrapHandler(handler)(req, url);
		}

		// Check for dynamic account endpoints
		if (path.startsWith("/api/accounts/")) {
			const parts = path.split("/");
			const accountId = parts[3];

			// Account tier update
			if (path.endsWith("/tier") && method === "POST") {
				const tierHandler = createAccountTierUpdateHandler(this.context.dbOps);
				return await this.wrapHandler((req) => tierHandler(req, accountId))(
					req,
					url,
				);
			}

			// Account pause
			if (path.endsWith("/pause") && method === "POST") {
				const pauseHandler = createAccountPauseHandler(this.context.dbOps);
				return await this.wrapHandler((req) => pauseHandler(req, accountId))(
					req,
					url,
				);
			}

			// Account resume
			if (path.endsWith("/resume") && method === "POST") {
				const resumeHandler = createAccountResumeHandler(this.context.dbOps);
				return await this.wrapHandler((req) => resumeHandler(req, accountId))(
					req,
					url,
				);
			}

			// Account rename
			if (path.endsWith("/rename") && method === "POST") {
				const renameHandler = createAccountRenameHandler(this.context.dbOps);
				return await this.wrapHandler((req) => renameHandler(req, accountId))(
					req,
					url,
				);
			}

			// Account removal
			if (parts.length === 4 && method === "DELETE") {
				const removeHandler = createAccountRemoveHandler(this.context.dbOps);
				return await this.wrapHandler((req) => removeHandler(req, accountId))(
					req,
					url,
				);
			}
		}

		// Check for dynamic agent endpoints
		if (path.startsWith("/api/agents/")) {
			const parts = path.split("/");
			const agentId = parts[3];

			// Agent preference update
			if (path.endsWith("/preference") && method === "POST") {
				const preferenceHandler = createAgentPreferenceUpdateHandler(
					this.context.dbOps,
				);
				return await this.wrapHandler((req) => preferenceHandler(req, agentId))(
					req,
					url,
				);
			}

			// Agent update (PATCH /api/agents/:id)
			if (parts.length === 4 && method === "PATCH") {
				const updateHandler = createAgentUpdateHandler(this.context.dbOps);
				return await this.wrapHandler((req) => updateHandler(req, agentId))(
					req,
					url,
				);
			}
		}

		// No matching route
		return null;
	}
}
</file>

<file path="packages/dashboard-web/src/components/agents/AgentEditDialog.tsx">
import { getModelDisplayName } from "@ccflare/core";
import type {
	Agent,
	AgentTool,
	AgentUpdatePayload,
	AllowedModel,
} from "@ccflare/types";
import { ALL_TOOLS, ALLOWED_MODELS } from "@ccflare/types";
import { Cpu, Edit3, FileText, Palette, Save, Shield, X } from "lucide-react";
import { useMemo, useState } from "react";
import { TOOL_PRESETS } from "../../constants";
import { useUpdateAgent } from "../../hooks/queries";
import { cn } from "../../lib/utils";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "../ui/dialog";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../ui/tabs";

interface AgentEditDialogProps {
	agent: Agent;
	open: boolean;
	onOpenChange: (open: boolean) => void;
}

type ToolPresetMode = keyof typeof TOOL_PRESETS;

// Helper function to get all combinations of array elements
function getCombinations<T>(arr: T[], size: number): T[][] {
	if (size === 0) return [[]];
	if (size > arr.length) return [];

	const result: T[][] = [];

	function combine(start: number, combo: T[]) {
		if (combo.length === size) {
			result.push([...combo]);
			return;
		}

		for (let i = start; i < arr.length; i++) {
			combo.push(arr[i]);
			combine(i + 1, combo);
			combo.pop();
		}
	}

	combine(0, []);
	return result;
}

const COLORS = [
	{ name: "gray", class: "bg-gray-500" },
	{ name: "blue", class: "bg-blue-500" },
	{ name: "green", class: "bg-green-500" },
	{ name: "yellow", class: "bg-yellow-500" },
	{ name: "orange", class: "bg-orange-500" },
	{ name: "red", class: "bg-red-500" },
	{ name: "purple", class: "bg-purple-500" },
	{ name: "pink", class: "bg-pink-500" },
	{ name: "indigo", class: "bg-indigo-500" },
	{ name: "cyan", class: "bg-cyan-500" },
];

const TOOL_MODE_INFO = {
	all: {
		label: "All Tools",
		description: "Full access to all available tools",
		icon: "🚀",
	},
	edit: {
		label: "Edit Mode",
		description: "File modification tools only",
		icon: "✏️",
	},
	"read-only": {
		label: "Read Only",
		description: "File reading and search tools",
		icon: "👁️",
	},
	execution: {
		label: "Execution",
		description: "Command execution tools only",
		icon: "⚡",
	},
};

export function AgentEditDialog({
	agent,
	open,
	onOpenChange,
}: AgentEditDialogProps) {
	const updateAgent = useUpdateAgent();

	const [description, setDescription] = useState(
		agent.description.replace(/\\n/g, "\n"),
	);
	const [model, setModel] = useState<AllowedModel>(agent.model);
	const [color, setColor] = useState(agent.color);
	const [systemPrompt, setSystemPrompt] = useState(agent.systemPrompt);

	// Initialize selected modes based on current tools
	const [selectedModes, setSelectedModes] = useState<Set<ToolPresetMode>>(
		() => {
			if (!agent.tools || agent.tools.length === 0) {
				return new Set(["all"]);
			}

			const toolsSet = new Set(agent.tools);
			const matchingModes = new Set<ToolPresetMode>();

			// First, try to find exact matches with single presets
			for (const [mode, presetTools] of Object.entries(TOOL_PRESETS)) {
				if (mode === "all") continue;
				const presetSet = new Set(presetTools);
				if (
					toolsSet.size === presetSet.size &&
					[...toolsSet].every((tool) => presetSet.has(tool))
				) {
					matchingModes.add(mode as ToolPresetMode);
				}
			}

			// If we found exact single preset matches, return them
			if (matchingModes.size > 0) {
				return matchingModes;
			}

			// Otherwise, find the combination of presets that exactly matches our tools
			const presetModes = Object.keys(TOOL_PRESETS).filter(
				(m) => m !== "all",
			) as ToolPresetMode[];

			// Try all combinations of presets to find exact matches
			for (let i = 1; i <= presetModes.length; i++) {
				const combinations = getCombinations(presetModes, i);
				for (const combo of combinations) {
					const comboTools = new Set<AgentTool>();
					for (const mode of combo) {
						TOOL_PRESETS[mode].forEach((tool) => comboTools.add(tool));
					}
					// Check if this combination exactly matches our tools
					if (
						comboTools.size === toolsSet.size &&
						[...toolsSet].every((tool) => comboTools.has(tool))
					) {
						return new Set(combo);
					}
				}
			}

			// If no exact combination found, return empty set (will trigger custom mode)
			return new Set<ToolPresetMode>();
		},
	);

	const [customTools, setCustomTools] = useState<AgentTool[]>(
		agent.tools || [],
	);

	const [isCustomMode, setIsCustomMode] = useState(() => {
		// Start in custom mode if:
		// 1. No modes are selected (tools don't match any preset combination)
		// 2. Or if we have the "all" preset selected and there are tools
		if (selectedModes.size === 0) {
			return true;
		}
		if (selectedModes.has("all") && agent.tools && agent.tools.length > 0) {
			return true;
		}
		return false;
	});

	// Compute effective tools based on selected modes
	const effectiveTools = useMemo(() => {
		if (isCustomMode) {
			return customTools;
		}

		if (selectedModes.has("all")) {
			return [];
		}

		const toolSet = new Set<AgentTool>();
		for (const mode of selectedModes) {
			if (mode !== "all") {
				TOOL_PRESETS[mode].forEach((tool) => toolSet.add(tool));
			}
		}
		return Array.from(toolSet);
	}, [selectedModes, customTools, isCustomMode]);

	const handleModeToggle = (mode: ToolPresetMode) => {
		const newModes = new Set(selectedModes);

		if (mode === "all") {
			// If selecting "all", clear other selections
			if (newModes.has("all")) {
				newModes.delete("all");
			} else {
				newModes.clear();
				newModes.add("all");
			}
		} else {
			// Toggle the mode
			if (newModes.has(mode)) {
				newModes.delete(mode);
			} else {
				newModes.add(mode);
				// Remove "all" if selecting specific modes
				newModes.delete("all");
			}
		}

		setSelectedModes(newModes);

		// Calculate the tools from the new preset selection
		const newToolSet = new Set<AgentTool>();
		for (const m of newModes) {
			if (m !== "all") {
				TOOL_PRESETS[m].forEach((tool) => newToolSet.add(tool));
			}
		}

		// Check if custom tools match the new preset selection
		const customToolSet = new Set(customTools);
		const hasExtraTools = [...customToolSet].some(
			(tool) => !newToolSet.has(tool),
		);
		const _missingTools = [...newToolSet].some(
			(tool) => !customToolSet.has(tool),
		);

		// Only stay in custom mode if we have extra tools that aren't in the presets
		if (isCustomMode && hasExtraTools && newModes.size > 0) {
			// Stay in custom mode but update the selection
			setIsCustomMode(true);
		} else {
			// Switch to preset mode
			setIsCustomMode(false);
			setCustomTools(Array.from(newToolSet));
		}
	};

	const handleCustomModeToggle = () => {
		if (!isCustomMode) {
			// Entering custom mode - keep current tools
			setCustomTools(effectiveTools);
			setIsCustomMode(true);
		} else {
			// Exiting custom mode - try to find matching presets
			const toolSet = new Set(customTools);

			// Try to find matching preset combinations
			const presetModes = Object.keys(TOOL_PRESETS).filter(
				(m) => m !== "all",
			) as ToolPresetMode[];

			for (let i = 1; i <= presetModes.length; i++) {
				const combinations = getCombinations(presetModes, i);
				for (const combo of combinations) {
					const comboTools = new Set<AgentTool>();
					for (const mode of combo) {
						TOOL_PRESETS[mode].forEach((tool) => comboTools.add(tool));
					}
					// Check if this combination exactly matches our tools
					if (
						comboTools.size === toolSet.size &&
						[...toolSet].every((tool) => comboTools.has(tool))
					) {
						// Found a matching preset combination
						setSelectedModes(new Set(combo));
						setIsCustomMode(false);
						return;
					}
				}
			}

			// If no exact match found, just exit custom mode with empty selection
			setSelectedModes(new Set());
			setIsCustomMode(false);
		}
	};

	const handleSave = async () => {
		try {
			const tools = effectiveTools;

			// Determine mode for API - only send if it's a single exact match
			let mode: string | undefined;
			if (!isCustomMode && selectedModes.size === 1) {
				const [selectedMode] = selectedModes;
				if (selectedMode === "all" && tools.length === 0) {
					mode = "all";
				} else if (selectedMode !== "all") {
					const presetTools = TOOL_PRESETS[selectedMode];
					if (
						tools.length === presetTools.length &&
						tools.every((t) => presetTools.includes(t))
					) {
						mode = selectedMode;
					}
				}
			}

			await updateAgent.mutateAsync({
				id: agent.id,
				payload: {
					description: description.replace(/\n/g, "\\n"),
					model,
					color,
					systemPrompt,
					mode: mode as AgentUpdatePayload["mode"],
					tools: mode ? undefined : tools,
				},
			});

			onOpenChange(false);
		} catch (error) {
			console.error("Failed to update agent:", error);
		}
	};

	const handleToolToggle = (tool: AgentTool) => {
		const newTools = customTools.includes(tool)
			? customTools.filter((t) => t !== tool)
			: [...customTools, tool];

		setCustomTools(newTools);

		// Check if the new tool selection matches any preset combination
		const newToolSet = new Set(newTools);

		// Try to find matching preset combinations
		const presetModes = Object.keys(TOOL_PRESETS).filter(
			(m) => m !== "all",
		) as ToolPresetMode[];

		for (let i = 1; i <= presetModes.length; i++) {
			const combinations = getCombinations(presetModes, i);
			for (const combo of combinations) {
				const comboTools = new Set<AgentTool>();
				for (const mode of combo) {
					TOOL_PRESETS[mode].forEach((tool) => comboTools.add(tool));
				}
				// Check if this combination exactly matches our tools
				if (
					comboTools.size === newToolSet.size &&
					[...newToolSet].every((tool) => comboTools.has(tool))
				) {
					// Found a matching preset combination
					setSelectedModes(new Set(combo));
					setIsCustomMode(false);
					return;
				}
			}
		}

		// No matching preset combination found, stay in custom mode
		setIsCustomMode(true);
	};

	return (
		<Dialog open={open} onOpenChange={onOpenChange}>
			<DialogContent className="max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
				<DialogHeader className="space-y-4 pb-6 border-b">
					<DialogTitle className="flex items-center gap-3 text-xl">
						<div className="p-2 bg-primary/10 rounded-lg">
							<Edit3 className="h-5 w-5 text-primary" />
						</div>
						<span>Edit Agent Configuration</span>
					</DialogTitle>
					<DialogDescription className="flex items-center gap-2">
						<Badge variant="secondary" className="gap-1.5">
							{agent.name}
						</Badge>
						<span className="text-muted-foreground">
							Customize how this agent behaves and what it can access
						</span>
					</DialogDescription>
				</DialogHeader>

				<Tabs defaultValue="general" className="flex-1 overflow-y-auto">
					<TabsList className="grid w-full grid-cols-4">
						<TabsTrigger value="general" className="gap-2">
							<FileText className="h-4 w-4" />
							General
						</TabsTrigger>
						<TabsTrigger value="description" className="gap-2">
							<Edit3 className="h-4 w-4" />
							Description
						</TabsTrigger>
						<TabsTrigger value="tools" className="gap-2">
							<Shield className="h-4 w-4" />
							Tools
						</TabsTrigger>
						<TabsTrigger value="prompt" className="gap-2">
							<Cpu className="h-4 w-4" />
							Prompt
						</TabsTrigger>
					</TabsList>

					<div className="overflow-y-auto flex-1 px-1">
						<TabsContent value="general" className="mt-6 space-y-6">
							{/* Model */}
							<div className="space-y-3">
								<Label className="text-base font-medium">Language Model</Label>
								<Select
									value={model}
									onValueChange={(value) => setModel(value as AllowedModel)}
								>
									<SelectTrigger className="w-full">
										<SelectValue />
									</SelectTrigger>
									<SelectContent>
										{ALLOWED_MODELS.map((m) => (
											<SelectItem key={m} value={m}>
												<div className="flex items-center gap-2">
													<Cpu className="h-4 w-4" />
													{getModelDisplayName(m)}
													{m.includes("opus") && (
														<Badge variant="secondary" className="ml-2 text-xs">
															Advanced
														</Badge>
													)}
												</div>
											</SelectItem>
										))}
									</SelectContent>
								</Select>
							</div>

							{/* Color */}
							<div className="space-y-3">
								<Label className="text-base font-medium flex items-center gap-2">
									<Palette className="h-4 w-4" />
									Theme Color
								</Label>
								<div className="grid grid-cols-5 gap-3">
									{COLORS.map(({ name, class: colorClass }) => (
										<button
											key={name}
											type="button"
											onClick={() => setColor(name)}
											className={cn(
												"relative h-12 rounded-lg border-2 transition-all",
												"hover:scale-105 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
												color === name
													? "border-primary shadow-lg"
													: "border-transparent",
											)}
										>
											<div
												className={cn(
													"h-full w-full rounded-md",
													colorClass,
													"opacity-90",
												)}
											/>
											{color === name && (
												<div className="absolute inset-0 flex items-center justify-center">
													<div className="h-3 w-3 rounded-full bg-white shadow-sm" />
												</div>
											)}
										</button>
									))}
								</div>
							</div>
						</TabsContent>

						<TabsContent value="description" className="mt-6 space-y-4">
							<div className="space-y-3">
								<Label htmlFor="description" className="text-base font-medium">
									Agent Description
								</Label>
								<textarea
									id="description"
									value={description}
									onChange={(e) => setDescription(e.target.value)}
									rows={12}
									className="flex min-h-[300px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 resize-none font-mono"
									placeholder="Describe what this agent does and when to use it..."
								/>
								<p className="text-xs text-muted-foreground">
									This description helps users understand when to use this agent
								</p>
							</div>
						</TabsContent>

						<TabsContent value="tools" className="mt-6 space-y-6">
							<div className="space-y-6">
								<div className="space-y-4">
									<div className="flex items-center justify-between">
										<Label className="text-base font-medium">
											Tool Access Presets
										</Label>
										<Badge variant="outline" className="gap-1.5">
											{effectiveTools.length === 0
												? "All tools"
												: `${effectiveTools.length} tools selected`}
										</Badge>
									</div>

									<p className="text-sm text-muted-foreground">
										Select one or more presets to combine their tool sets, or
										use custom selection for fine-grained control.
									</p>

									<div className="grid gap-3">
										{(
											Object.keys(TOOL_MODE_INFO) as Array<
												keyof typeof TOOL_MODE_INFO
											>
										).map((mode) => {
											const info = TOOL_MODE_INFO[mode];
											const isSelected = selectedModes.has(mode);
											const toolCount = TOOL_PRESETS[mode]?.length || 0;

											return (
												<button
													key={mode}
													type="button"
													onClick={() => handleModeToggle(mode)}
													disabled={isCustomMode}
													className={cn(
														"relative flex items-start gap-4 rounded-lg border p-4 text-left transition-all",
														"hover:bg-accent/50",
														isSelected && !isCustomMode
															? "border-primary bg-primary/5"
															: "border-border",
														isCustomMode && "opacity-50 cursor-not-allowed",
													)}
												>
													<input
														type="checkbox"
														checked={isSelected && !isCustomMode}
														onChange={() => {}}
														className="mt-0.5 h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
														disabled={isCustomMode}
													/>
													<div className="text-2xl">{info.icon}</div>
													<div className="flex-1 space-y-1">
														<div className="font-medium">{info.label}</div>
														<div className="text-sm text-muted-foreground">
															{info.description}
														</div>
														<Badge variant="secondary" className="mt-2">
															{mode === "all"
																? "All tools"
																: `${toolCount} tools`}
														</Badge>
													</div>
												</button>
											);
										})}
									</div>
								</div>

								{/* Custom Mode Toggle */}
								<div className="border-t pt-6">
									<button
										type="button"
										onClick={handleCustomModeToggle}
										className={cn(
											"relative flex items-start gap-4 rounded-lg border p-4 text-left transition-all w-full",
											"hover:bg-accent/50",
											isCustomMode
												? "border-primary bg-primary/5"
												: "border-border",
										)}
									>
										<input
											type="checkbox"
											checked={isCustomMode}
											onChange={() => {}}
											className="mt-0.5 h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
										/>
										<div className="text-2xl">⚙️</div>
										<div className="flex-1 space-y-1">
											<div className="font-medium">Custom Selection</div>
											<div className="text-sm text-muted-foreground">
												Manually select specific tools
											</div>
										</div>
									</button>

									{/* Custom Tools Selection */}
									{isCustomMode && (
										<div className="mt-4 space-y-3">
											<div className="flex items-center justify-between">
												<Label className="text-sm font-medium">
													Select Tools ({customTools.length} selected)
												</Label>
												<div className="flex gap-2">
													<Button
														type="button"
														variant="ghost"
														size="sm"
														onClick={() => setCustomTools(ALL_TOOLS)}
													>
														Select All
													</Button>
													<Button
														type="button"
														variant="ghost"
														size="sm"
														onClick={() => setCustomTools([])}
													>
														Clear
													</Button>
												</div>
											</div>
											<div className="grid grid-cols-2 gap-2 rounded-lg border p-4 max-h-64 overflow-y-auto">
												{ALL_TOOLS.map((tool) => (
													<label
														key={tool}
														className="flex items-center gap-3 p-2 rounded-md hover:bg-accent cursor-pointer"
													>
														<input
															type="checkbox"
															checked={customTools.includes(tool)}
															onChange={() => handleToolToggle(tool)}
															className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
														/>
														<span className="text-sm">{tool}</span>
													</label>
												))}
											</div>
										</div>
									)}
								</div>
							</div>
						</TabsContent>

						<TabsContent value="prompt" className="mt-6 space-y-4">
							<div className="space-y-3">
								<Label htmlFor="systemPrompt" className="text-base font-medium">
									System Prompt
								</Label>
								<textarea
									id="systemPrompt"
									value={systemPrompt}
									onChange={(e) => setSystemPrompt(e.target.value)}
									rows={12}
									className="flex min-h-[300px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 resize-none font-mono"
									placeholder="Enter the system prompt that defines this agent's behavior..."
								/>
								<p className="text-xs text-muted-foreground">
									This prompt will be used to initialize the agent's behavior
									and capabilities
								</p>
							</div>
						</TabsContent>
					</div>
				</Tabs>

				<DialogFooter className="border-t pt-6">
					<Button
						variant="outline"
						onClick={() => onOpenChange(false)}
						disabled={updateAgent.isPending}
					>
						<X className="h-4 w-4 mr-2" />
						Cancel
					</Button>
					<Button onClick={handleSave} disabled={updateAgent.isPending}>
						<Save className="h-4 w-4 mr-2" />
						{updateAgent.isPending ? "Saving..." : "Save Changes"}
					</Button>
				</DialogFooter>
			</DialogContent>
		</Dialog>
	);
}
</file>

<file path="packages/dashboard-web/src/api.ts">
import { HttpClient, HttpError } from "@ccflare/http-common";
import type {
	AccountResponse,
	Agent,
	AgentUpdatePayload,
	AgentWorkspace,
	AnalyticsResponse,
	LogEvent,
	RequestPayload,
	RequestResponse,
	StatsWithAccounts,
} from "@ccflare/types";
import { API_LIMITS, API_TIMEOUT } from "./constants";

// Re-export types with dashboard-specific aliases for backward compatibility
export type Account = AccountResponse;
export type Stats = StatsWithAccounts;
export type LogEntry = LogEvent;
export type RequestSummary = RequestResponse;

// Re-export types directly
export type {
	Agent,
	AgentWorkspace,
	RequestPayload,
	RequestResponse,
} from "@ccflare/types";

// Agent response interface
export interface AgentsResponse {
	agents: Agent[];
	globalAgents: Agent[];
	workspaceAgents: Agent[];
	workspaces: AgentWorkspace[];
}

/**
 * Configuration for the system prompt interceptor feature
 * Controls how system prompts are intercepted and modified
 */
export interface SystemPromptConfig {
	/** Whether the system prompt interceptor is enabled */
	isEnabled: boolean;
	/** The target prompt to look for and replace */
	targetPrompt: string;
	/** The replacement prompt with {{env_block}} placeholder for environment variables */
	replacementPrompt: string;
	/** Whether tools are enabled in the intercepted system prompt */
	toolsEnabled: boolean;
}

class API extends HttpClient {
	constructor() {
		super({
			baseUrl: "",
			defaultHeaders: {
				"Content-Type": "application/json",
			},
			timeout: API_TIMEOUT,
			retries: 1,
		});
	}

	async getStats(): Promise<Stats> {
		return this.get<Stats>("/api/stats");
	}

	async getAccounts(): Promise<Account[]> {
		return this.get<Account[]>("/api/accounts");
	}

	async initAddAccount(data: {
		name: string;
		mode: "max" | "console";
		tier: number;
	}): Promise<{ authUrl: string; sessionId: string }> {
		try {
			return await this.post<{ authUrl: string; sessionId: string }>(
				"/api/oauth/init",
				data,
			);
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async completeAddAccount(data: {
		sessionId: string;
		code: string;
	}): Promise<{ message: string; mode: string; tier: number }> {
		try {
			return await this.post<{ message: string; mode: string; tier: number }>(
				"/api/oauth/callback",
				data,
			);
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async removeAccount(name: string, confirm: string): Promise<void> {
		try {
			await this.delete(`/api/accounts/${name}`, {
				body: JSON.stringify({ confirm }),
			});
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async resetStats(): Promise<void> {
		await this.post("/api/stats/reset");
	}

	async getLogHistory(): Promise<LogEntry[]> {
		return this.get<LogEntry[]>("/api/logs/history");
	}

	// SSE streaming requires special handling, keep as-is
	streamLogs(onLog: (log: LogEntry) => void): EventSource {
		const eventSource = new EventSource(`/api/logs/stream`);
		eventSource.addEventListener("message", (event) => {
			try {
				const data = JSON.parse(event.data);
				// Skip non-log messages (like the initial "connected" message)
				if (data.ts && data.level && data.msg) {
					onLog(data as LogEntry);
				}
			} catch (e) {
				console.error("Error parsing log event:", e);
			}
		});
		return eventSource;
	}

	async getRequestsDetail(
		limit: number = API_LIMITS.requestsDetail,
	): Promise<RequestPayload[]> {
		return this.get<RequestPayload[]>(`/api/requests/detail?limit=${limit}`);
	}

	async getRequestsSummary(
		limit: number = API_LIMITS.requestsSummary,
	): Promise<RequestSummary[]> {
		return this.get<RequestSummary[]>(`/api/requests?limit=${limit}`);
	}

	async getAnalytics(
		range = "24h",
		filters?: {
			accounts?: string[];
			models?: string[];
			status?: "all" | "success" | "error";
		},
		mode: "normal" | "cumulative" = "normal",
		modelBreakdown?: boolean,
	): Promise<AnalyticsResponse> {
		const params = new URLSearchParams({ range });

		if (filters?.accounts?.length) {
			params.append("accounts", filters.accounts.join(","));
		}
		if (filters?.models?.length) {
			params.append("models", filters.models.join(","));
		}
		if (filters?.status && filters.status !== "all") {
			params.append("status", filters.status);
		}
		if (mode === "cumulative") {
			params.append("mode", "cumulative");
		}
		if (modelBreakdown) {
			params.append("modelBreakdown", "true");
		}

		return this.get<AnalyticsResponse>(`/api/analytics?${params}`);
	}

	async pauseAccount(accountId: string): Promise<void> {
		try {
			await this.post(`/api/accounts/${accountId}/pause`);
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async resumeAccount(accountId: string): Promise<void> {
		try {
			await this.post(`/api/accounts/${accountId}/resume`);
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async renameAccount(
		accountId: string,
		newName: string,
	): Promise<{ newName: string }> {
		try {
			const response = await this.post<{
				success: boolean;
				message: string;
				newName: string;
			}>(`/api/accounts/${accountId}/rename`, { name: newName });
			return { newName: response.newName };
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async getStrategy(): Promise<string> {
		const data = await this.get<{ strategy: string }>("/api/config/strategy");
		return data.strategy;
	}

	async listStrategies(): Promise<string[]> {
		return this.get<string[]>("/api/strategies");
	}

	async setStrategy(strategy: string): Promise<void> {
		try {
			await this.post("/api/config/strategy", { strategy });
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async getAgents(): Promise<AgentsResponse> {
		return await this.get<AgentsResponse>("/api/agents");
	}

	async updateAgentPreference(agentId: string, model: string): Promise<void> {
		try {
			await this.post(`/api/agents/${agentId}/preference`, { model });
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async updateAgent(
		agentId: string,
		payload: AgentUpdatePayload,
	): Promise<Agent> {
		try {
			const response = await this.patch<{ success: boolean; agent: Agent }>(
				`/api/agents/${agentId}`,
				payload,
			);
			return response.agent;
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async getDefaultAgentModel(): Promise<string> {
		const data = await this.get<{ model: string }>("/api/config/model");
		return data.model;
	}

	async setDefaultAgentModel(model: string): Promise<void> {
		try {
			await this.post("/api/config/model", { model });
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async setBulkAgentPreferences(
		model: string,
	): Promise<{ updatedCount: number }> {
		try {
			const response = await this.post<{
				success: boolean;
				updatedCount: number;
				model: string;
			}>("/api/agents/bulk-preference", { model });
			return { updatedCount: response.updatedCount };
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	// Retention settings
	async getRetention(): Promise<{ payloadDays: number; requestDays: number }> {
		return this.get<{ payloadDays: number; requestDays: number }>(
			"/api/config/retention",
		);
	}

	async setRetention(partial: {
		payloadDays?: number;
		requestDays?: number;
	}): Promise<void> {
		await this.post("/api/config/retention", partial);
	}

	async cleanupNow(): Promise<{
		removedRequests: number;
		removedPayloads: number;
		cutoffIso: string;
	}> {
		return this.post<{
			removedRequests: number;
			removedPayloads: number;
			cutoffIso: string;
		}>("/api/maintenance/cleanup");
	}

	async compactDb(): Promise<{ ok: boolean }> {
		return this.post<{ ok: boolean }>("/api/maintenance/compact");
	}

	// System prompt interceptor
	async getSystemPromptOverride(): Promise<{
		isEnabled: boolean;
		targetPrompt: string;
		replacementPrompt: string;
		toolsEnabled: boolean;
	}> {
		return this.get<{
			isEnabled: boolean;
			targetPrompt: string;
			replacementPrompt: string;
			toolsEnabled: boolean;
		}>("/api/tools/interceptors/system-prompt");
	}

	async setSystemPromptOverride(data: {
		isEnabled: boolean;
		targetPrompt: string;
		replacementPrompt: string;
		toolsEnabled: boolean;
	}): Promise<{
		success: boolean;
		isEnabled: boolean;
		targetPrompt: string;
		replacementPrompt: string;
		toolsEnabled: boolean;
	}> {
		return this.post<{
			success: boolean;
			isEnabled: boolean;
			targetPrompt: string;
			replacementPrompt: string;
			toolsEnabled: boolean;
		}>("/api/tools/interceptors/system-prompt", data);
	}

	async resetSystemPromptOverride(): Promise<void> {
		await this.delete("/api/tools/interceptors/system-prompt");
	}
}

export const api = new API();
</file>

<file path="packages/dashboard-web/src/hooks/queries.ts">
import type { AgentUpdatePayload } from "@ccflare/types";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { api } from "../api";
import { REFRESH_INTERVALS } from "../constants";
import { queryKeys } from "../lib/query-keys";

export const useAccounts = () => {
	return useQuery({
		queryKey: queryKeys.accounts(),
		queryFn: () => api.getAccounts(),
		refetchInterval: REFRESH_INTERVALS.fast, // Refresh every 10 seconds for rate limit updates
	});
};

export const useAgents = () => {
	return useQuery({
		queryKey: queryKeys.agents(),
		queryFn: () => api.getAgents(),
		refetchInterval: 30000, // Poll every 30 seconds for new agents
		refetchIntervalInBackground: true, // Continue polling when tab is not focused
	});
};

export const useStats = (refetchInterval?: number) => {
	return useQuery({
		queryKey: queryKeys.stats(),
		queryFn: () => api.getStats(),
		refetchInterval: refetchInterval ?? REFRESH_INTERVALS.fast,
	});
};

export const useAnalytics = (
	timeRange: string,
	filters: {
		accounts?: string[];
		models?: string[];
		status?: "all" | "success" | "error";
	},
	viewMode: "normal" | "cumulative",
	modelBreakdown?: boolean,
) => {
	return useQuery({
		queryKey: queryKeys.analytics(timeRange, filters, viewMode, modelBreakdown),
		queryFn: () =>
			api.getAnalytics(timeRange, filters, viewMode, modelBreakdown),
	});
};

export const useRequests = (limit: number, refetchInterval?: number) => {
	return useQuery({
		queryKey: queryKeys.requests(limit),
		queryFn: async () => {
			const [requestsDetail, requestsSummary] = await Promise.all([
				api.getRequestsDetail(limit),
				api.getRequestsSummary(limit),
			]);
			return { requests: requestsDetail, detailsMap: requestsSummary };
		},
		refetchInterval: refetchInterval ?? REFRESH_INTERVALS.fast,
	});
};

export const useRequestDetails = (id: string) => {
	return useQuery({
		queryKey: queryKeys.requestDetails(id),
		queryFn: () =>
			api
				.getRequestsDetail(1)
				.then((requests) => requests.find((r) => r.id === id)),
		enabled: !!id,
	});
};

export const useLogHistory = () => {
	return useQuery({
		queryKey: queryKeys.logHistory(),
		queryFn: () => api.getLogHistory(),
	});
};

// Mutations
export const useRemoveAccount = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: ({
			name,
			confirmInput,
		}: {
			name: string;
			confirmInput: string;
		}) => api.removeAccount(name, confirmInput),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.accounts() });
		},
	});
};

export const useRenameAccount = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: ({
			accountId,
			newName,
		}: {
			accountId: string;
			newName: string;
		}) => api.renameAccount(accountId, newName),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.accounts() });
		},
	});
};

export const useResetStats = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: () => api.resetStats(),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.stats() });
		},
	});
};

export const useUpdateAgentPreference = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: ({ agentId, model }: { agentId: string; model: string }) =>
			api.updateAgentPreference(agentId, model),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.agents() });
		},
	});
};

export const useDefaultAgentModel = () => {
	return useQuery({
		queryKey: queryKeys.defaultAgentModel(),
		queryFn: () => api.getDefaultAgentModel(),
		refetchInterval: REFRESH_INTERVALS.slow, // Poll for config changes
		refetchIntervalInBackground: true, // Continue polling when tab is not focused
	});
};

export const useSetDefaultAgentModel = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: (model: string) => api.setDefaultAgentModel(model),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: queryKeys.defaultAgentModel(),
			});
			queryClient.invalidateQueries({ queryKey: queryKeys.agents() });
		},
	});
};

export const useBulkUpdateAgentPreferences = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: (model: string) => api.setBulkAgentPreferences(model),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.agents() });
		},
	});
};

export const useUpdateAgent = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: ({
			id,
			payload,
		}: {
			id: string;
			payload: AgentUpdatePayload;
		}) => api.updateAgent(id, payload),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.agents() });
		},
	});
};

// Note: Clear logs functionality appears to be removed from the API

// Retention settings
export const useRetention = () => {
	return useQuery({
		queryKey: ["retention"],
		queryFn: () => api.getRetention(),
	});
};

export const useSetRetention = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: (partial: { payloadDays?: number; requestDays?: number }) =>
			api.setRetention(partial),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ["retention"] });
		},
	});
};

export const useCleanupNow = () => {
	return useMutation({
		mutationFn: () => api.cleanupNow(),
	});
};

export const useCompactDb = () => {
	return useMutation({
		mutationFn: () => api.compactDb(),
	});
};

/**
 * Hook to fetch the current system prompt interceptor configuration
 * Polls for changes at a slow interval and continues in background
 */

export const useSystemPromptOverride = () => {
	return useQuery({
		queryKey: queryKeys.systemPromptOverride(),
		queryFn: () => api.getSystemPromptOverride(),
		refetchInterval: REFRESH_INTERVALS.slow, // Poll for config changes
	});
};

export const useSetSystemPromptOverride = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: (data: {
			isEnabled: boolean;
			targetPrompt: string;
			replacementPrompt: string;
			toolsEnabled: boolean;
		}) => api.setSystemPromptOverride(data),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: queryKeys.systemPromptOverride(),
			});
		},
	});
};

export const useResetSystemPromptOverride = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: () => api.resetSystemPromptOverride(),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: queryKeys.systemPromptOverride(),
			});
		},
	});
};
</file>

</files>
