================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-08-23T09:39:35.231853

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
apps/
  lander/
    src/
      _headers
      _redirects
      index.html
      screenshot-analytics.png
      screenshot-dashboard.png
      screenshot-logs.png
      styles.css
    package.json
  server/
    src/
      server.ts
    package.json
    tsconfig.json
  tui/
    src/
      components/
        charts/
          BarChart.tsx
          LineChart.tsx
          PieChart.tsx
          SparklineChart.tsx
          index.ts
          utils.ts
        AccountsScreen.tsx
        AnalyticsScreen.tsx
        LogsScreen.tsx
        RequestsScreen.tsx
        ServerScreen.tsx
        StatsScreen.tsx
        StrategyScreen.tsx
        TokenUsageDisplay.tsx
      types/
        open.d.ts
      App.tsx
      main.ts
    .185e63fbdedbfd2c-00000000.bun-build
    .185e6799df3f337c-00000000.bun-build
    .185e67b8df588fff-00000000.bun-build
    .185e67dcf757deb1-00000000.bun-build
    .185e69fadf7ffeea-00000000.bun-build
    .185e6bbad77fdfed-00000000.bun-build
    package.json
    tsconfig.json
packages/
  agents/
    src/
      discovery.ts
      index.ts
      paths.ts
      workspace-persistence.ts
    package.json
    tsconfig.json
  cli-commands/
    src/
      commands/
        account.ts
        analyze.ts
        help.ts
        stats.ts
      prompts/
        adapter.ts
        index.ts
        std-adapter.ts
      utils/
        browser.ts
      index.ts
      runner.ts
    package.json
    tsconfig.json
  config/
    src/
      index.ts
      paths-common.ts
      paths.ts
    package.json
    tsconfig.json
  core/
    src/
      constants.ts
      errors.ts
      index.ts
      lifecycle.ts
      models.ts
      pricing.ts
      request-events.ts
      strategy.ts
      validation.ts
    package.json
    tsconfig.json
  core-di/
    src/
      container.ts
      index.ts
    package.json
    tsconfig.json
  dashboard-web/
    src/
      components/
        accounts/
          AccountAddForm.tsx
          AccountList.tsx
          AccountListItem.tsx
          DeleteConfirmationDialog.tsx
          RateLimitProgress.tsx
          RenameAccountDialog.tsx
          index.ts
        agents/
          AgentCard.tsx
          AgentEditDialog.tsx
          WorkspaceCard.tsx
          index.ts
        analytics/
          AnalyticsCharts.tsx
          AnalyticsControls.tsx
          AnalyticsFilters.tsx
          ModelAnalytics.tsx
          TokenSpeedAnalytics.tsx
          index.ts
        charts/
          BaseAreaChart.tsx
          BaseBarChart.tsx
          BaseLineChart.tsx
          BasePieChart.tsx
          BaseScatterChart.tsx
          ChartContainer.tsx
          ChartTooltip.tsx
          CostChart.tsx
          ModelPerformanceChart.tsx
          ModelPerformanceComparison.tsx
          ModelTokenSpeedChart.tsx
          MultiModelChart.tsx
          RequestVolumeChart.tsx
          ResponseTimeChart.tsx
          TokenSpeedChart.tsx
          TokenUsageChart.tsx
          chart-utils.ts
          index.ts
          types.ts
        conversation/
          Message.tsx
          MessageBubble.tsx
          ThinkingBlock.tsx
          ToolResultBlock.tsx
          ToolUsageBlock.tsx
          index.ts
        overview/
          ChartsSection.tsx
          DataRetentionCard.tsx
          LoadingSkeleton.tsx
          MetricCard.tsx
          RateLimitInfo.tsx
          SystemStatus.tsx
          TimeRangeSelector.tsx
        tools/
          SystemPromptInterceptorCard.tsx
        ui/
          badge.tsx
          button.tsx
          card.tsx
          dialog.tsx
          dropdown-menu.tsx
          input.tsx
          label.tsx
          popover.tsx
          progress.tsx
          select.tsx
          separator.tsx
          skeleton.tsx
          switch.tsx
          tabs.tsx
          textarea.tsx
        AccountsTab.tsx
        AgentsTab.tsx
        AnalyticsTab.tsx
        ConversationView.tsx
        CopyButton.tsx
        LogsTab.tsx
        OverviewTab.tsx
        RequestDetailsModal.tsx
        RequestsTab.tsx
        StatsTab.tsx
        StrategyCard.tsx
        TokenUsageDisplay.tsx
        ToolsTab.tsx
        navigation.tsx
        theme-toggle.tsx
      constants/
        index.ts
      contexts/
        theme-context.tsx
      hooks/
        queries.ts
        useApiError.ts
        useCollapsible.ts
        useRequestStream.ts
      lib/
        chart-utils.ts
        query-keys.ts
        utils.ts
      App.tsx
      api.ts
      favicon.svg
      frontend.tsx
      global.d.ts
      index.css
      index.html
    styles/
      globals.css
    build.ts
    bunfig.toml
    components.json
    package.json
    tsconfig.json
  database/
    src/
      repositories/
        account.repository.ts
        agent-preference.repository.ts
        base.repository.ts
        interceptor.repository.ts
        oauth.repository.ts
        request.repository.ts
        stats.repository.ts
        strategy.repository.ts
        system-kv.repository.ts
      analyze-performance.ts
      async-writer.ts
      database-operations.ts
      factory.ts
      index.ts
      migrations.ts
      paths.ts
      performance-indexes.ts
    package.json
    tsconfig.json
  errors/
    src/
      index.ts
    package.json
    tsconfig.json
  http-api/
    src/
      handlers/
        accounts.ts
        agents-update.ts
        agents.ts
        analytics.ts
        config.ts
        health.ts
        logs-history.ts
        logs.ts
        maintenance.ts
        oauth.ts
        requests-stream.ts
        requests.ts
        stats.ts
        tools.ts
      utils/
        handler-factory.ts
        http-error.ts
      index.ts
      router.ts
      types.ts
    package.json
    tsconfig.json
  http-common/
    src/
      client.ts
      errors.ts
      headers.ts
      index.ts
      responses.ts
    package.json
    tsconfig.json
  load-balancer/
    src/
      strategies/
        index.ts
      index.ts
    package.json
    tsconfig.json
  logger/
    src/
      file-writer.ts
      index.ts
    package.json
    tsconfig.json
  oauth-flow/
    src/
      index.ts
    package.json
  providers/
    src/
      oauth/
        base-oauth-provider.ts
        index.ts
        pkce.ts
      providers/
        anthropic/
          index.ts
          oauth.ts
          provider.ts
        index.ts
      base.ts
      index.ts
      registry.ts
      types.ts
    package.json
    tsconfig.json
  proxy/
    src/
      handlers/
        account-selector.ts
        agent-interceptor.ts
        index.ts
        proxy-operations.ts
        proxy-types.ts
        request-handler.ts
        response-processor.ts
        token-manager.ts
      constants.ts
      index.ts
      post-processor.worker.ts
      proxy.ts
      response-handler.ts
      stream-tee.ts
      types.ts
      worker-messages.ts
    package.json
    tsconfig.json
  tui-core/
    src/
      accounts.ts
      analytics.ts
      args.ts
      index.ts
      logs.ts
      requests.ts
      stats.ts
      strategy.ts
    package.json
    tsconfig.json
  types/
    src/
      account.ts
      agent-constants.ts
      agent.ts
      api.ts
      context.ts
      conversation.ts
      index.ts
      logging.ts
      request.ts
      stats.ts
      strategy.ts
    package.json
    tsconfig.json
  ui-common/
    src/
      components/
        TokenUsageDisplay.tsx
      parsers/
        parse-conversation.ts
      utils/
        clean-line-numbers.ts
        generate-message-key.ts
        normalize-text.ts
      formatters.ts
      index.ts
      presenters.ts
    package.json
    tsconfig.json
  ui-constants/
    src/
      index.ts
    package.json
    tsconfig.json
.biomeignore
.env.example
LICENSE
biome.json
package.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: LICENSE
================
MIT License

Copyright (c) 2025 snipeship

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: .biomeignore
================
**/dist
**/dist/**
**/build
**/build/**
**/node_modules
**/node_modules/**
**/*.min.js
**/*.min.css
**/*.bundle.js
packages/dashboard-web/dist
packages/dashboard-web/dist/**

================
File: package.json
================
{
	"private": true,
	"name": "ccflare",
	"workspaces": [
		"apps/*",
		"packages/*"
	],
	"scripts": {
		"ccflare": "bun run build && bun run tui",
		"tui": "bun run apps/tui/src/main.ts",
		"dev": "bun run tui",
		"start": "bun run apps/server/src/server.ts",
		"server": "bun run apps/server/src/server.ts",
		"dev:server": "bun run --hot apps/server/src/server.ts",
		"dev:dashboard": "bun --hot packages/dashboard-web/src/index.tsx",
		"typecheck": "bunx tsc --noEmit",
		"build": "bun run build:dashboard && bun run build:tui",
		"build:dashboard": "bun run --cwd packages/dashboard-web build",
		"build:tui": "bun run --cwd apps/tui build",
		"build:lander": "bun run --cwd apps/lander build",
		"format": "bunx biome format --write .",
		"lint": "bunx --bun biome check --write --unsafe ."
	},
	"engines": {
		"bun": ">=1.2.8"
	},
	"devDependencies": {
		"@biomejs/biome": "2.1.2",
		"bun-types": "latest",
		"@types/bun": "latest",
		"typescript": "^5.0.0"
	},
	"overrides": {
		"react": "^19.0.0",
		"@types/react": "^19.0.0"
	}
}

================
File: tsconfig.json
================
{
	"compilerOptions": {
		"lib": ["ESNext", "DOM", "DOM.Iterable"],
		"module": "esnext",
		"target": "esnext",
		"moduleResolution": "bundler",
		"moduleDetection": "force",
		"allowImportingTsExtensions": true,
		"noEmit": true,
		"strict": true,
		"skipLibCheck": true,
		"allowSyntheticDefaultImports": true,
		"forceConsistentCasingInFileNames": true,
		"allowJs": true,
		"types": ["bun-types"],
		"jsx": "react-jsx",
		"baseUrl": ".",
		"paths": {
			"@ccflare/*": ["packages/*/src"]
		}
	},
	"include": ["packages/*/src/**/*", "apps/*/src/**/*"]
}

================
File: .env.example
================
# Port for the proxy server (optional, defaults to 8080)
PORT=8080

# Load-balancing strategy: least-requests | round-robin | session | weighted | weighted-round-robin
# - least-requests: Route to account with fewest requests (default)
# - round-robin: Distribute requests evenly across all accounts
# - session: Maintain 5-hour sessions per account
# - weighted: Route based on tier-adjusted request count (respects 1x, 5x, 20x tiers)
# - weighted-round-robin: Round-robin that gives more slots to higher tier accounts
LB_STRATEGY=least-requests

# Log level: DEBUG | INFO | WARN | ERROR (optional, defaults to INFO)
LOG_LEVEL=INFO

# Log format: pretty | json (optional, defaults to pretty)
# - pretty: Human-readable format with timestamps
# - json: Structured JSON logs for log aggregators
LOG_FORMAT=pretty

# Example of how to use the proxy with your application:
# ANTHROPIC_BASE_URL=http://localhost:8080

================
File: biome.json
================
{
	"$schema": "https://biomejs.dev/schemas/2.1.2/schema.json",
	"vcs": {
		"enabled": true,
		"clientKind": "git",
		"useIgnoreFile": true
	},
	"files": {
		"ignoreUnknown": false,
		"includes": ["apps/**", "packages/**"]
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "tab"
	},
	"linter": {
		"enabled": true,
		"rules": {
			"recommended": true
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "double"
		}
	},
	"assist": {
		"enabled": true,
		"actions": {
			"source": {
				"organizeImports": "on"
			}
		}
	}
}

================
File: packages/database/package.json
================
{
	"name": "@ccflare/database",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit",
		"analyze": "bun run ./src/analyze-performance.ts"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/logger": "workspace:*"
	}
}

================
File: packages/database/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/database/src/database-operations.ts
================
import { Database } from "bun:sqlite";
import { mkdirSync } from "node:fs";
import { dirname } from "node:path";
import type { Disposable } from "@ccflare/core";
import type { Account, StrategyStore } from "@ccflare/types";
import { ensureSchema, runMigrations } from "./migrations";
import { resolveDbPath } from "./paths";
import { AccountRepository } from "./repositories/account.repository";
import { AgentPreferenceRepository } from "./repositories/agent-preference.repository";
import {
	type InterceptorConfig,
	InterceptorRepository,
} from "./repositories/interceptor.repository";
import { OAuthRepository } from "./repositories/oauth.repository";
import {
	type RequestData,
	RequestRepository,
} from "./repositories/request.repository";
import { StatsRepository } from "./repositories/stats.repository";
import { StrategyRepository } from "./repositories/strategy.repository";
import { SystemKVRepository } from "./repositories/system-kv.repository";

export interface RuntimeConfig {
	sessionDurationMs?: number;
}

/**
 * DatabaseOperations using Repository Pattern
 * Provides a clean, organized interface for database operations
 */
export class DatabaseOperations implements StrategyStore, Disposable {
	private db: Database;
	private runtime?: RuntimeConfig;

	// Repositories
	private accounts: AccountRepository;
	private requests: RequestRepository;
	private oauth: OAuthRepository;
	private strategy: StrategyRepository;
	private stats: StatsRepository;
	private agentPreferences: AgentPreferenceRepository;
	private interceptor: InterceptorRepository;
	private systemKV: SystemKVRepository;

	constructor(dbPath?: string) {
		const resolvedPath = dbPath ?? resolveDbPath();

		// Ensure the directory exists
		const dir = dirname(resolvedPath);
		mkdirSync(dir, { recursive: true });

		this.db = new Database(resolvedPath, { create: true });

		// Configure SQLite for better concurrency
		this.db.exec("PRAGMA journal_mode = WAL"); // Enable Write-Ahead Logging
		this.db.exec("PRAGMA busy_timeout = 5000"); // Wait up to 5 seconds before throwing "database is locked"
		this.db.exec("PRAGMA synchronous = NORMAL"); // Better performance while maintaining safety

		ensureSchema(this.db);
		runMigrations(this.db);

		// Initialize repositories
		this.accounts = new AccountRepository(this.db);
		this.requests = new RequestRepository(this.db);
		this.oauth = new OAuthRepository(this.db);
		this.strategy = new StrategyRepository(this.db);
		this.stats = new StatsRepository(this.db);
		this.agentPreferences = new AgentPreferenceRepository(this.db);
		this.interceptor = new InterceptorRepository(this.db);
		this.systemKV = new SystemKVRepository(this.db);
	}

	setRuntimeConfig(runtime: RuntimeConfig): void {
		this.runtime = runtime;
	}

	getDatabase(): Database {
		return this.db;
	}

	// Account operations delegated to repository
	getAllAccounts(): Account[] {
		return this.accounts.findAll();
	}

	getAccount(accountId: string): Account | null {
		return this.accounts.findById(accountId);
	}

	updateAccountTokens(
		accountId: string,
		accessToken: string,
		expiresAt: number,
		refreshToken?: string,
	): void {
		this.accounts.updateTokens(accountId, accessToken, expiresAt, refreshToken);
	}

	updateAccountUsage(accountId: string): void {
		const sessionDuration =
			this.runtime?.sessionDurationMs || 5 * 60 * 60 * 1000;
		this.accounts.incrementUsage(accountId, sessionDuration);
	}

	markAccountRateLimited(accountId: string, until: number): void {
		this.accounts.setRateLimited(accountId, until);
	}

	updateAccountRateLimitMeta(
		accountId: string,
		status: string,
		reset: number | null,
		remaining?: number | null,
	): void {
		this.accounts.updateRateLimitMeta(accountId, status, reset, remaining);
	}

	updateAccountTier(accountId: string, tier: number): void {
		this.accounts.updateTier(accountId, tier);
	}

	pauseAccount(accountId: string): void {
		this.accounts.pause(accountId);
	}

	resumeAccount(accountId: string): void {
		this.accounts.resume(accountId);
	}

	renameAccount(accountId: string, newName: string): void {
		this.accounts.rename(accountId, newName);
	}

	resetAccountSession(accountId: string, timestamp: number): void {
		this.accounts.resetSession(accountId, timestamp);
	}

	updateAccountRequestCount(accountId: string, count: number): void {
		this.accounts.updateRequestCount(accountId, count);
	}

	// Request operations delegated to repository
	saveRequestMeta(
		id: string,
		method: string,
		path: string,
		accountUsed: string | null,
		statusCode: number | null,
		timestamp?: number,
	): void {
		this.requests.saveMeta(
			id,
			method,
			path,
			accountUsed,
			statusCode,
			timestamp,
		);
	}

	saveRequest(
		id: string,
		method: string,
		path: string,
		accountUsed: string | null,
		statusCode: number | null,
		success: boolean,
		errorMessage: string | null,
		responseTime: number,
		failoverAttempts: number,
		usage?: RequestData["usage"],
		agentUsed?: string,
	): void {
		this.requests.save({
			id,
			method,
			path,
			accountUsed,
			statusCode,
			success,
			errorMessage,
			responseTime,
			failoverAttempts,
			usage,
			agentUsed,
		});
	}

	updateRequestUsage(requestId: string, usage: RequestData["usage"]): void {
		this.requests.updateUsage(requestId, usage);
	}

	saveRequestPayload(id: string, data: unknown): void {
		this.requests.savePayload(id, data);
	}

	getRequestPayload(id: string): unknown | null {
		return this.requests.getPayload(id);
	}

	listRequestPayloads(limit = 50): Array<{ id: string; json: string }> {
		return this.requests.listPayloads(limit);
	}

	listRequestPayloadsWithAccountNames(
		limit = 50,
	): Array<{ id: string; json: string; account_name: string | null }> {
		return this.requests.listPayloadsWithAccountNames(limit);
	}

	// OAuth operations delegated to repository
	createOAuthSession(
		sessionId: string,
		accountName: string,
		verifier: string,
		mode: "console" | "max",
		tier: number,
		ttlMinutes = 10,
	): void {
		this.oauth.createSession(
			sessionId,
			accountName,
			verifier,
			mode,
			tier,
			ttlMinutes,
		);
	}

	getOAuthSession(sessionId: string): {
		accountName: string;
		verifier: string;
		mode: "console" | "max";
		tier: number;
	} | null {
		return this.oauth.getSession(sessionId);
	}

	deleteOAuthSession(sessionId: string): void {
		this.oauth.deleteSession(sessionId);
	}

	cleanupExpiredOAuthSessions(): number {
		return this.oauth.cleanupExpiredSessions();
	}

	// Strategy operations delegated to repository
	getStrategy(name: string): {
		name: string;
		config: Record<string, unknown>;
		updatedAt: number;
	} | null {
		return this.strategy.getStrategy(name);
	}

	setStrategy(name: string, config: Record<string, unknown>): void {
		this.strategy.set(name, config);
	}

	listStrategies(): Array<{
		name: string;
		config: Record<string, unknown>;
		updatedAt: number;
	}> {
		return this.strategy.list();
	}

	deleteStrategy(name: string): boolean {
		return this.strategy.delete(name);
	}

	// Analytics methods delegated to request repository
	getRecentRequests(limit = 100): Array<{
		id: string;
		timestamp: number;
		method: string;
		path: string;
		account_used: string | null;
		status_code: number | null;
		success: boolean;
		response_time_ms: number | null;
	}> {
		return this.requests.getRecentRequests(limit);
	}

	getRequestStats(since?: number): {
		totalRequests: number;
		successfulRequests: number;
		failedRequests: number;
		avgResponseTime: number | null;
	} {
		return this.requests.getRequestStats(since);
	}

	aggregateStats(rangeMs?: number) {
		return this.requests.aggregateStats(rangeMs);
	}

	getRecentErrors(limit?: number): string[] {
		return this.requests.getRecentErrors(limit);
	}

	getTopModels(limit?: number): Array<{ model: string; count: number }> {
		return this.requests.getTopModels(limit);
	}

	getRequestsByAccount(since?: number): Array<{
		accountId: string;
		accountName: string | null;
		requestCount: number;
		successRate: number;
	}> {
		return this.requests.getRequestsByAccount(since);
	}

	// Cleanup operations (payload by age; request metadata by age; plus orphan sweep)
	cleanupOldRequests(
		payloadRetentionMs: number,
		requestRetentionMs?: number,
	): {
		removedRequests: number;
		removedPayloads: number;
	} {
		const now = Date.now();
		const payloadCutoff = now - payloadRetentionMs;
		let removedRequests = 0;
		if (
			typeof requestRetentionMs === "number" &&
			Number.isFinite(requestRetentionMs)
		) {
			const requestCutoff = now - requestRetentionMs;
			removedRequests = this.requests.deleteOlderThan(requestCutoff);
		}
		const removedPayloadsByAge =
			this.requests.deletePayloadsOlderThan(payloadCutoff);
		const removedOrphans = this.requests.deleteOrphanedPayloads();
		const removedPayloads = removedPayloadsByAge + removedOrphans;
		return { removedRequests, removedPayloads };
	}

	// Agent preference operations delegated to repository
	getAgentPreference(agentId: string): { model: string } | null {
		return this.agentPreferences.getPreference(agentId);
	}

	getAllAgentPreferences(): Array<{ agent_id: string; model: string }> {
		return this.agentPreferences.getAllPreferences();
	}

	setAgentPreference(agentId: string, model: string): void {
		this.agentPreferences.setPreference(agentId, model);
	}

	deleteAgentPreference(agentId: string): boolean {
		return this.agentPreferences.deletePreference(agentId);
	}

	setBulkAgentPreferences(agentIds: string[], model: string): void {
		this.agentPreferences.setBulkPreferences(agentIds, model);
	}

	// Interceptor operations delegated to repository
	getInterceptorConfig(
		id: string,
	): { isEnabled: boolean; config: InterceptorConfig } | null {
		return this.interceptor.getConfig(id);
	}

	setInterceptorConfig(
		id: string,
		isEnabled: boolean,
		config: InterceptorConfig,
	): void {
		this.interceptor.setConfig(id, isEnabled, config);
	}

	deleteInterceptorConfig(id: string): boolean {
		return this.interceptor.delete(id);
	}

	// System KV operations delegated to repository
	getSystemKV(key: string): string | null {
		return this.systemKV.getValue(key);
	}

	setSystemKV(key: string, value: string): void {
		this.systemKV.setValue(key, value);
	}

	close(): void {
		// Ensure all write operations are flushed before closing
		this.db.exec("PRAGMA wal_checkpoint(TRUNCATE)");
		this.db.close();
	}

	dispose(): void {
		this.close();
	}

	// Optimize database periodically to maintain performance
	optimize(): void {
		this.db.exec("PRAGMA optimize");
		this.db.exec("PRAGMA wal_checkpoint(PASSIVE)");
	}

	/** Compact and reclaim disk space (blocks DB during operation) */
	compact(): void {
		// Ensure WAL is checkpointed and truncated, then VACUUM to rebuild file
		this.db.exec("PRAGMA wal_checkpoint(TRUNCATE)");
		this.db.exec("VACUUM");
	}

	/**
	 * Get the stats repository for consolidated stats access
	 */
	getStatsRepository(): StatsRepository {
		return this.stats;
	}
}

================
File: packages/database/src/performance-indexes.ts
================
import type { Database } from "bun:sqlite";
import { Logger } from "@ccflare/logger";

const log = new Logger("PerformanceIndexes");

/**
 * Add performance indexes to improve query performance
 * This migration adds indexes based on common query patterns in the application
 */
export function addPerformanceIndexes(db: Database): void {
	log.info("Adding performance indexes...");

	// 1. Composite index on requests(timestamp, account_used) for time-based account queries
	// Used in analytics for filtering by time range and account
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_timestamp_account 
		ON requests(timestamp DESC, account_used)
	`);
	log.info("Added index: idx_requests_timestamp_account");

	// 2. Index on requests(model, timestamp) for model analytics
	// Used in model distribution and performance queries
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_model_timestamp 
		ON requests(model, timestamp DESC) 
		WHERE model IS NOT NULL
	`);
	log.info("Added index: idx_requests_model_timestamp");

	// 3. Index on requests(success, timestamp) for success rate calculations
	// Used in analytics for calculating success rates over time
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_success_timestamp 
		ON requests(success, timestamp DESC)
	`);
	log.info("Added index: idx_requests_success_timestamp");

	// 4. Index on accounts(paused) for finding active accounts
	// Used in load balancer to quickly filter active accounts
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_paused 
		ON accounts(paused) 
		WHERE paused = 0
	`);
	log.info("Added index: idx_accounts_paused");

	// 5. Index on requests(account_used, timestamp) for per-account analytics
	// Used in account performance queries
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_account_timestamp 
		ON requests(account_used, timestamp DESC)
	`);
	log.info("Added index: idx_requests_account_timestamp");

	// 6. Additional indexes based on observed query patterns

	// Index for cost analysis queries
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_cost_model 
		ON requests(cost_usd, model, timestamp DESC) 
		WHERE cost_usd > 0 AND model IS NOT NULL
	`);
	log.info("Added index: idx_requests_cost_model");

	// Index for response time analysis (for p95 calculations)
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_response_time 
		ON requests(model, response_time_ms) 
		WHERE response_time_ms IS NOT NULL AND model IS NOT NULL
	`);
	log.info("Added index: idx_requests_response_time");

	// Index for token usage analysis
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_requests_tokens 
		ON requests(timestamp DESC, total_tokens) 
		WHERE total_tokens > 0
	`);
	log.info("Added index: idx_requests_tokens");

	// Index for account name lookups (used in analytics joins)
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_name 
		ON accounts(name)
	`);
	log.info("Added index: idx_accounts_name");

	// Index for rate limit checks
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_rate_limited 
		ON accounts(rate_limited_until) 
		WHERE rate_limited_until IS NOT NULL
	`);
	log.info("Added index: idx_accounts_rate_limited");

	// Index for session management
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_session 
		ON accounts(session_start, session_request_count) 
		WHERE session_start IS NOT NULL
	`);
	log.info("Added index: idx_accounts_session");

	// Composite index for account ordering in load balancer
	db.run(`
		CREATE INDEX IF NOT EXISTS idx_accounts_request_count 
		ON accounts(request_count DESC, last_used)
	`);
	log.info("Added index: idx_accounts_request_count");

	log.info("Performance indexes added successfully");
}

/**
 * Analyze current index usage and suggest optimizations
 */
export function analyzeIndexUsage(db: Database): void {
	log.info("\nAnalyzing index usage...");

	// Get all indexes
	const indexes = db
		.prepare(
			`SELECT name, tbl_name, sql 
			FROM sqlite_master 
			WHERE type = 'index' AND name NOT LIKE 'sqlite_%'
			ORDER BY tbl_name, name`,
		)
		.all() as Array<{ name: string; tbl_name: string; sql: string }>;

	log.info(`\nTotal indexes: ${indexes.length}`);
	for (const index of indexes) {
		log.info(`- ${index.name} on ${index.tbl_name}`);
	}

	// Analyze table statistics
	const tables = ["accounts", "requests", "request_payloads"];
	for (const table of tables) {
		const count = db
			.prepare(`SELECT COUNT(*) as count FROM ${table}`)
			.get() as { count: number };
		log.info(`\n${table} table: ${count.count} rows`);
	}
}

================
File: packages/database/src/migrations.ts
================
import type { Database } from "bun:sqlite";
import { Logger } from "@ccflare/logger";
import { addPerformanceIndexes } from "./performance-indexes";

const log = new Logger("DatabaseMigrations");

export function ensureSchema(db: Database): void {
	// Create accounts table
	db.run(`
		CREATE TABLE IF NOT EXISTS accounts (
			id TEXT PRIMARY KEY,
			name TEXT NOT NULL,
			provider TEXT DEFAULT 'anthropic',
			api_key TEXT,
			refresh_token TEXT NOT NULL,
			access_token TEXT,
			expires_at INTEGER,
			created_at INTEGER NOT NULL,
			last_used INTEGER,
			request_count INTEGER DEFAULT 0,
			total_requests INTEGER DEFAULT 0,
			account_tier INTEGER DEFAULT 1
		)
	`);

	// Create requests table
	db.run(`
		CREATE TABLE IF NOT EXISTS requests (
			id TEXT PRIMARY KEY,
			timestamp INTEGER NOT NULL,
			method TEXT NOT NULL,
			path TEXT NOT NULL,
			account_used TEXT,
			status_code INTEGER,
			success BOOLEAN,
			error_message TEXT,
			response_time_ms INTEGER,
			failover_attempts INTEGER DEFAULT 0,
			model TEXT,
			prompt_tokens INTEGER DEFAULT 0,
			completion_tokens INTEGER DEFAULT 0,
			total_tokens INTEGER DEFAULT 0,
			cost_usd REAL DEFAULT 0,
			output_tokens_per_second REAL,
			input_tokens INTEGER DEFAULT 0,
			cache_read_input_tokens INTEGER DEFAULT 0,
			cache_creation_input_tokens INTEGER DEFAULT 0,
			output_tokens INTEGER DEFAULT 0,
			agent_used TEXT
		)
	`);

	// Create index for faster queries
	db.run(
		`CREATE INDEX IF NOT EXISTS idx_requests_timestamp ON requests(timestamp DESC)`,
	);

	// Create request_payloads table for storing full request/response data
	db.run(`
		CREATE TABLE IF NOT EXISTS request_payloads (
			id TEXT PRIMARY KEY,
			json TEXT NOT NULL,
			FOREIGN KEY (id) REFERENCES requests(id) ON DELETE CASCADE
		)
	`);

	// Create oauth_sessions table for secure PKCE verifier storage
	db.run(`
		CREATE TABLE IF NOT EXISTS oauth_sessions (
			id TEXT PRIMARY KEY,
			account_name TEXT NOT NULL,
			verifier TEXT NOT NULL,
			mode TEXT NOT NULL,
			tier INTEGER DEFAULT 1,
			created_at INTEGER NOT NULL,
			expires_at INTEGER NOT NULL
		)
	`);

	// Create index for faster cleanup of expired sessions
	db.run(
		`CREATE INDEX IF NOT EXISTS idx_oauth_sessions_expires ON oauth_sessions(expires_at)`,
	);

	// Create agent_preferences table for storing user-defined agent settings
	db.run(`
		CREATE TABLE IF NOT EXISTS agent_preferences (
			agent_id TEXT PRIMARY KEY,
			model TEXT NOT NULL,
			updated_at INTEGER NOT NULL
		)
	`);

	// Create interceptors table for storing tool configurations
	db.run(`
		CREATE TABLE IF NOT EXISTS interceptors (
			id TEXT PRIMARY KEY,
			is_enabled INTEGER NOT NULL DEFAULT 0,
			config TEXT NOT NULL
		)
	`);

	// Create system_kv_store table for storing system-wide key-value pairs
	db.run(`
		CREATE TABLE IF NOT EXISTS system_kv_store (
			key TEXT PRIMARY KEY,
			value TEXT
		)
	`);
}

export function runMigrations(db: Database): void {
	// Ensure base schema exists first
	ensureSchema(db);
	// Check if columns exist before adding them
	const accountsInfo = db
		.prepare("PRAGMA table_info(accounts)")
		.all() as Array<{
		cid: number;
		name: string;
		type: string;
		notnull: number;
		// biome-ignore lint/suspicious/noExplicitAny: SQLite pragma can return various default value types
		dflt_value: any;
		pk: number;
	}>;

	const accountsColumnNames = accountsInfo.map((col) => col.name);

	// Add rate_limited_until column if it doesn't exist
	if (!accountsColumnNames.includes("rate_limited_until")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN rate_limited_until INTEGER",
		).run();
		log.info("Added rate_limited_until column to accounts table");
	}

	// Add session_start column if it doesn't exist
	if (!accountsColumnNames.includes("session_start")) {
		db.prepare("ALTER TABLE accounts ADD COLUMN session_start INTEGER").run();
		log.info("Added session_start column to accounts table");
	}

	// Add session_request_count column if it doesn't exist
	if (!accountsColumnNames.includes("session_request_count")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN session_request_count INTEGER DEFAULT 0",
		).run();
		log.info("Added session_request_count column to accounts table");
	}

	// Add account_tier column if it doesn't exist
	if (!accountsColumnNames.includes("account_tier")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN account_tier INTEGER DEFAULT 1",
		).run();
		log.info("Added account_tier column to accounts table");
	}

	// Add paused column if it doesn't exist
	if (!accountsColumnNames.includes("paused")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN paused INTEGER DEFAULT 0",
		).run();
		log.info("Added paused column to accounts table");
	}

	// Add rate_limit_reset column if it doesn't exist
	if (!accountsColumnNames.includes("rate_limit_reset")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN rate_limit_reset INTEGER",
		).run();
		log.info("Added rate_limit_reset column to accounts table");
	}

	// Add rate_limit_status column if it doesn't exist
	if (!accountsColumnNames.includes("rate_limit_status")) {
		db.prepare("ALTER TABLE accounts ADD COLUMN rate_limit_status TEXT").run();
		log.info("Added rate_limit_status column to accounts table");
	}

	// Add rate_limit_remaining column if it doesn't exist
	if (!accountsColumnNames.includes("rate_limit_remaining")) {
		db.prepare(
			"ALTER TABLE accounts ADD COLUMN rate_limit_remaining INTEGER",
		).run();
		log.info("Added rate_limit_remaining column to accounts table");
	}

	// Check columns in requests table
	const requestsInfo = db
		.prepare("PRAGMA table_info(requests)")
		.all() as Array<{
		cid: number;
		name: string;
		type: string;
		notnull: number;
		// biome-ignore lint/suspicious/noExplicitAny: SQLite pragma can return various default value types
		dflt_value: any;
		pk: number;
	}>;

	const requestsColumnNames = requestsInfo.map((col) => col.name);

	// Add model column if it doesn't exist
	if (!requestsColumnNames.includes("model")) {
		db.prepare("ALTER TABLE requests ADD COLUMN model TEXT").run();
		log.info("Added model column to requests table");
	}

	// Add prompt_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("prompt_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN prompt_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added prompt_tokens column to requests table");
	}

	// Add completion_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("completion_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN completion_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added completion_tokens column to requests table");
	}

	// Add total_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("total_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN total_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added total_tokens column to requests table");
	}

	// Add cost_usd column if it doesn't exist
	if (!requestsColumnNames.includes("cost_usd")) {
		db.prepare("ALTER TABLE requests ADD COLUMN cost_usd REAL DEFAULT 0").run();
		log.info("Added cost_usd column to requests table");
	}

	// Add input_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("input_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN input_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added input_tokens column to requests table");
	}

	// Add cache_read_input_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("cache_read_input_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN cache_read_input_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added cache_read_input_tokens column to requests table");
	}

	// Add cache_creation_input_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("cache_creation_input_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN cache_creation_input_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added cache_creation_input_tokens column to requests table");
	}

	// Add output_tokens column if it doesn't exist
	if (!requestsColumnNames.includes("output_tokens")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN output_tokens INTEGER DEFAULT 0",
		).run();
		log.info("Added output_tokens column to requests table");
	}

	// Add agent_used column if it doesn't exist
	if (!requestsColumnNames.includes("agent_used")) {
		db.prepare("ALTER TABLE requests ADD COLUMN agent_used TEXT").run();
		log.info("Added agent_used column to requests table");
	}

	// Add output_tokens_per_second column if it doesn't exist
	if (!requestsColumnNames.includes("output_tokens_per_second")) {
		db.prepare(
			"ALTER TABLE requests ADD COLUMN output_tokens_per_second REAL",
		).run();
		log.info("Added output_tokens_per_second column to requests table");
	}

	// Add performance indexes
	addPerformanceIndexes(db);
}

================
File: packages/database/src/analyze-performance.ts
================
#!/usr/bin/env bun
import { Database } from "bun:sqlite";
import { Logger } from "@ccflare/logger";
import { resolveDbPath } from "./paths";
import { analyzeIndexUsage } from "./performance-indexes";

const log = new Logger("PerformanceAnalysis");

/**
 * Analyze query performance and index usage
 */
function analyzeQueryPerformance(db: Database) {
	log.info("\n=== Query Performance Analysis ===\n");

	// Test queries that should benefit from the new indexes
	const testQueries = [
		{
			name: "Time-based account analytics",
			query: `
				SELECT COUNT(*), account_used 
				FROM requests 
				WHERE timestamp > ? AND account_used IS NOT NULL 
				GROUP BY account_used
			`,
			params: [Date.now() - 24 * 60 * 60 * 1000], // Last 24 hours
		},
		{
			name: "Model performance with timestamp filter",
			query: `
				SELECT model, COUNT(*), AVG(response_time_ms)
				FROM requests 
				WHERE timestamp > ? AND model IS NOT NULL 
				GROUP BY model
			`,
			params: [Date.now() - 24 * 60 * 60 * 1000],
		},
		{
			name: "Success rate calculation",
			query: `
				SELECT 
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as success_rate
				FROM requests 
				WHERE timestamp > ?
			`,
			params: [Date.now() - 24 * 60 * 60 * 1000],
		},
		{
			name: "Active accounts lookup",
			query: `
				SELECT id, name, request_count 
				FROM accounts 
				WHERE paused = 0 
				ORDER BY request_count DESC
			`,
			params: [],
		},
		{
			name: "Cost analysis by model",
			query: `
				SELECT model, SUM(cost_usd) as total_cost
				FROM requests 
				WHERE cost_usd > 0 AND model IS NOT NULL 
				GROUP BY model 
				ORDER BY total_cost DESC
			`,
			params: [],
		},
		{
			name: "P95 response time calculation",
			query: `
				WITH ordered_times AS (
					SELECT 
						response_time_ms,
						ROW_NUMBER() OVER (ORDER BY response_time_ms) as row_num,
						COUNT(*) OVER () as total_count
					FROM requests 
					WHERE model = ? AND response_time_ms IS NOT NULL
				)
				SELECT response_time_ms as p95_response_time
				FROM ordered_times
				WHERE row_num = CAST(CEIL(total_count * 0.95) AS INTEGER)
				LIMIT 1
			`,
			params: ["claude-3-5-sonnet-20241022"],
		},
	];

	// Run each test query with EXPLAIN QUERY PLAN
	for (const test of testQueries) {
		log.info(`\n--- ${test.name} ---`);

		try {
			// Get query plan
			const planStmt = db.prepare(`EXPLAIN QUERY PLAN ${test.query}`);
			const plan = planStmt.all(...test.params);
			log.info("Query Plan:");
			for (const row of plan) {
				log.info(`  ${JSON.stringify(row)}`);
			}

			// Time the actual query
			const start = performance.now();
			const stmt = db.prepare(test.query);
			const result = stmt.all(...test.params);
			const duration = performance.now() - start;

			log.info(`Execution time: ${duration.toFixed(2)}ms`);
			log.info(`Rows returned: ${result.length}`);
		} catch (error) {
			log.error(`Error: ${error}`);
		}
	}
}

/**
 * Show index statistics
 */
function showIndexStats(db: Database) {
	log.info("\n=== Index Statistics ===\n");

	// Get index list with size estimates
	const indexes = db
		.prepare(`
			SELECT 
				m.name as index_name,
				m.tbl_name as table_name,
				m.sql as create_sql,
				s.stat as stat_value
			FROM sqlite_master m
			LEFT JOIN sqlite_stat1 s ON m.name = s.idx
			WHERE m.type = 'index' 
				AND m.name NOT LIKE 'sqlite_%'
				AND m.name LIKE 'idx_%'
			ORDER BY m.tbl_name, m.name
		`)
		.all() as Array<{
		index_name: string;
		table_name: string;
		create_sql: string;
		stat_value: string | null;
	}>;

	log.info(`Total performance indexes: ${indexes.length}\n`);

	let currentTable = "";
	for (const index of indexes) {
		if (index.table_name !== currentTable) {
			currentTable = index.table_name;
			log.info(`\n${currentTable}:`);
		}
		log.info(`  - ${index.index_name}`);
		if (index.stat_value) {
			log.info(`    Stats: ${index.stat_value}`);
		}
	}

	// Run ANALYZE to update statistics
	log.info("\nRunning ANALYZE to update statistics...");
	db.exec("ANALYZE");
	log.info("Statistics updated.");
}

/**
 * Main function
 */
function main() {
	const dbPath = resolveDbPath();
	log.info(`Analyzing database at: ${dbPath}\n`);

	const db = new Database(dbPath, { readonly: true });

	try {
		// Show basic index usage analysis
		analyzeIndexUsage(db);

		// Show detailed index statistics
		showIndexStats(db);

		// Analyze query performance
		analyzeQueryPerformance(db);

		log.info("\n=== Analysis Complete ===\n");
	} finally {
		db.close();
	}
}

// Run if called directly
if (import.meta.main) {
	main();
}

================
File: packages/database/src/factory.ts
================
import { registerDisposable, unregisterDisposable } from "@ccflare/core";
import { DatabaseOperations, type RuntimeConfig } from "./index";

let instance: DatabaseOperations | null = null;
let dbPath: string | undefined;
let runtimeConfig: RuntimeConfig | undefined;

export function initialize(
	dbPathParam?: string,
	runtimeConfigParam?: RuntimeConfig,
): void {
	dbPath = dbPathParam;
	runtimeConfig = runtimeConfigParam;
}

export function getInstance(): DatabaseOperations {
	if (!instance) {
		instance = new DatabaseOperations(dbPath);
		if (runtimeConfig) {
			instance.setRuntimeConfig(runtimeConfig);
		}
		// Register with lifecycle manager
		registerDisposable(instance);
	}
	return instance;
}

export function closeAll(): void {
	if (instance) {
		unregisterDisposable(instance);
		instance.close();
		instance = null;
	}
}

export function reset(): void {
	closeAll();
}

export const DatabaseFactory = {
	initialize,
	getInstance,
	closeAll,
	reset,
};

================
File: packages/database/src/async-writer.ts
================
import type { Disposable } from "@ccflare/core";
import { Logger } from "@ccflare/logger";

const logger = new Logger("async-db-writer");

type DbJob = () => void | Promise<void>;

export class AsyncDbWriter implements Disposable {
	private queue: DbJob[] = [];
	private running = false;
	private intervalId: Timer | null = null;

	constructor() {
		// Process queue every 100ms
		this.intervalId = setInterval(() => void this.processQueue(), 100);
	}

	enqueue(job: DbJob): void {
		this.queue.push(job);
		// Immediately try to process if not already running
		void this.processQueue();
	}

	private async processQueue(): Promise<void> {
		if (this.running || this.queue.length === 0) {
			return;
		}

		this.running = true;

		try {
			while (this.queue.length > 0) {
				const job = this.queue.shift();
				if (!job) continue;
				try {
					await job();
				} catch (error) {
					logger.error("Failed to execute DB job", error);
				}
			}
		} finally {
			this.running = false;
		}
	}

	async dispose(): Promise<void> {
		logger.info("Flushing async DB writer queue...");

		// Stop the interval
		if (this.intervalId) {
			clearInterval(this.intervalId);
			this.intervalId = null;
		}

		// Process any remaining jobs
		await this.processQueue();

		logger.info("Async DB writer queue flushed", {
			remainingJobs: this.queue.length,
		});
	}
}

================
File: packages/database/src/index.ts
================
// Re-export the DatabaseOperations class
import { DatabaseOperations } from "./database-operations";
export { DatabaseOperations };

// Re-export other utilities
export { AsyncDbWriter } from "./async-writer";
export type { RuntimeConfig } from "./database-operations";
export { DatabaseFactory } from "./factory";
export { ensureSchema, runMigrations } from "./migrations";
export { resolveDbPath } from "./paths";
export { analyzeIndexUsage } from "./performance-indexes";

// Re-export repository types
export type { StatsRepository } from "./repositories/stats.repository";

================
File: packages/database/src/paths.ts
================
import { join } from "node:path";
import { getPlatformConfigDir } from "@ccflare/config";

export function resolveDbPath(): string {
	// Check for explicit DB path from environment
	const explicitPath = process.env.ccflare_DB_PATH;
	if (explicitPath) {
		return explicitPath;
	}

	// Use common platform config directory
	const configDir = getPlatformConfigDir();
	return join(configDir, "ccflare.db");
}

================
File: packages/database/src/repositories/base.repository.ts
================
import type { Database } from "bun:sqlite";

type QueryParams = Array<string | number | boolean | null | Buffer>;

export abstract class BaseRepository<_T> {
	constructor(protected db: Database) {}

	protected query<R>(sql: string, params: QueryParams = []): R[] {
		return this.db.query<R, QueryParams>(sql).all(...params) as R[];
	}

	protected get<R>(sql: string, params: QueryParams = []): R | null {
		const result = this.db.query<R, QueryParams>(sql).get(...params);
		return result as R | null;
	}

	protected run(sql: string, params: QueryParams = []): void {
		this.db.run(sql, params);
	}

	protected runWithChanges(sql: string, params: QueryParams = []): number {
		const result = this.db.run(sql, params);
		return result.changes;
	}
}

================
File: packages/database/src/repositories/request.repository.ts
================
import { BaseRepository } from "./base.repository";

export interface RequestData {
	id: string;
	method: string;
	path: string;
	accountUsed: string | null;
	statusCode: number | null;
	success: boolean;
	errorMessage: string | null;
	responseTime: number;
	failoverAttempts: number;
	agentUsed?: string;
	usage?: {
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
		tokensPerSecond?: number;
	};
}

export class RequestRepository extends BaseRepository<RequestData> {
	saveMeta(
		id: string,
		method: string,
		path: string,
		accountUsed: string | null,
		statusCode: number | null,
		timestamp?: number,
	): void {
		this.run(
			`
			INSERT INTO requests (
				id, timestamp, method, path, account_used, 
				status_code, success, error_message, response_time_ms, failover_attempts
			)
			VALUES (?, ?, ?, ?, ?, ?, 0, NULL, 0, 0)
		`,
			[id, timestamp || Date.now(), method, path, accountUsed, statusCode],
		);
	}

	save(data: RequestData): void {
		const { usage } = data;
		this.run(
			`
			INSERT OR REPLACE INTO requests (
				id, timestamp, method, path, account_used, 
				status_code, success, error_message, response_time_ms, failover_attempts,
				model, prompt_tokens, completion_tokens, total_tokens, cost_usd,
				input_tokens, cache_read_input_tokens, cache_creation_input_tokens, output_tokens,
				agent_used, output_tokens_per_second
			)
			VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		`,
			[
				data.id,
				Date.now(),
				data.method,
				data.path,
				data.accountUsed,
				data.statusCode,
				data.success ? 1 : 0,
				data.errorMessage,
				data.responseTime,
				data.failoverAttempts,
				usage?.model || null,
				usage?.promptTokens || null,
				usage?.completionTokens || null,
				usage?.totalTokens || null,
				usage?.costUsd || null,
				usage?.inputTokens || null,
				usage?.cacheReadInputTokens || null,
				usage?.cacheCreationInputTokens || null,
				usage?.outputTokens || null,
				data.agentUsed || null,
				usage?.tokensPerSecond || null,
			],
		);
	}

	updateUsage(requestId: string, usage: RequestData["usage"]): void {
		if (!usage) return;

		this.run(
			`
			UPDATE requests
			SET 
				model = COALESCE(?, model),
				prompt_tokens = COALESCE(?, prompt_tokens),
				completion_tokens = COALESCE(?, completion_tokens),
				total_tokens = COALESCE(?, total_tokens),
				cost_usd = COALESCE(?, cost_usd),
				input_tokens = COALESCE(?, input_tokens),
				cache_read_input_tokens = COALESCE(?, cache_read_input_tokens),
				cache_creation_input_tokens = COALESCE(?, cache_creation_input_tokens),
				output_tokens = COALESCE(?, output_tokens),
				output_tokens_per_second = COALESCE(?, output_tokens_per_second)
			WHERE id = ?
		`,
			[
				usage.model || null,
				usage.promptTokens || null,
				usage.completionTokens || null,
				usage.totalTokens || null,
				usage.costUsd || null,
				usage.inputTokens || null,
				usage.cacheReadInputTokens || null,
				usage.cacheCreationInputTokens || null,
				usage.outputTokens || null,
				usage.tokensPerSecond || null,
				requestId,
			],
		);
	}

	// Payload management
	savePayload(id: string, data: unknown): void {
		const json = JSON.stringify(data);
		this.run(
			`INSERT OR REPLACE INTO request_payloads (id, json) VALUES (?, ?)`,
			[id, json],
		);
	}

	getPayload(id: string): unknown | null {
		const row = this.get<{ json: string }>(
			`SELECT json FROM request_payloads WHERE id = ?`,
			[id],
		);

		if (!row) return null;

		try {
			return JSON.parse(row.json);
		} catch {
			return null;
		}
	}

	listPayloads(limit = 50): Array<{ id: string; json: string }> {
		return this.query<{ id: string; json: string }>(
			`
			SELECT rp.id, rp.json 
			FROM request_payloads rp
			JOIN requests r ON rp.id = r.id
			ORDER BY r.timestamp DESC
			LIMIT ?
		`,
			[limit],
		);
	}

	listPayloadsWithAccountNames(
		limit = 50,
	): Array<{ id: string; json: string; account_name: string | null }> {
		return this.query<{
			id: string;
			json: string;
			account_name: string | null;
		}>(
			`
			SELECT rp.id, rp.json, a.name as account_name
			FROM request_payloads rp
			JOIN requests r ON rp.id = r.id
			LEFT JOIN accounts a ON r.account_used = a.id
			ORDER BY r.timestamp DESC
			LIMIT ?
		`,
			[limit],
		);
	}

	// Analytics queries
	getRecentRequests(limit = 100): Array<{
		id: string;
		timestamp: number;
		method: string;
		path: string;
		account_used: string | null;
		status_code: number | null;
		success: boolean;
		response_time_ms: number | null;
	}> {
		return this.query<{
			id: string;
			timestamp: number;
			method: string;
			path: string;
			account_used: string | null;
			status_code: number | null;
			success: 0 | 1;
			response_time_ms: number | null;
		}>(
			`
			SELECT id, timestamp, method, path, account_used, status_code, success, response_time_ms
			FROM requests
			ORDER BY timestamp DESC
			LIMIT ?
		`,
			[limit],
		).map((row) => ({
			...row,
			success: row.success === 1,
		}));
	}

	getRequestStats(since?: number): {
		totalRequests: number;
		successfulRequests: number;
		failedRequests: number;
		avgResponseTime: number | null;
	} {
		const whereClause = since ? "WHERE timestamp > ?" : "";
		const params = since ? [since] : [];

		const result = this.get<{
			total_requests: number;
			successful_requests: number;
			failed_requests: number;
			avg_response_time: number | null;
		}>(
			`
			SELECT 
				COUNT(*) as total_requests,
				SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_requests,
				SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) as failed_requests,
				AVG(response_time_ms) as avg_response_time
			FROM requests
			${whereClause}
		`,
			params,
		);

		return {
			totalRequests: result?.total_requests || 0,
			successfulRequests: result?.successful_requests || 0,
			failedRequests: result?.failed_requests || 0,
			avgResponseTime: result?.avg_response_time || null,
		};
	}

	/**
	 * Aggregate statistics with optional time range
	 * Consolidates duplicate SQL queries from stats handlers
	 */
	aggregateStats(rangeMs?: number): {
		totalRequests: number;
		successfulRequests: number;
		avgResponseTime: number | null;
		totalTokens: number;
		totalCostUsd: number;
		inputTokens: number;
		outputTokens: number;
		cacheReadInputTokens: number;
		cacheCreationInputTokens: number;
		avgTokensPerSecond: number | null;
	} {
		const whereClause = rangeMs ? "WHERE timestamp > ?" : "";
		const params = rangeMs ? [Date.now() - rangeMs] : [];

		const result = this.get<{
			total_requests: number;
			successful_requests: number;
			avg_response_time: number | null;
			total_tokens: number | null;
			total_cost_usd: number | null;
			input_tokens: number | null;
			output_tokens: number | null;
			cache_read_input_tokens: number | null;
			cache_creation_input_tokens: number | null;
			avg_tokens_per_second: number | null;
		}>(
			`
			SELECT 
				COUNT(*) as total_requests,
				SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful_requests,
				AVG(response_time_ms) as avg_response_time,
				SUM(total_tokens) as total_tokens,
				SUM(cost_usd) as total_cost_usd,
				SUM(input_tokens) as input_tokens,
				SUM(output_tokens) as output_tokens,
				SUM(cache_read_input_tokens) as cache_read_input_tokens,
				SUM(cache_creation_input_tokens) as cache_creation_input_tokens,
				AVG(output_tokens_per_second) as avg_tokens_per_second
			FROM requests
			${whereClause}
		`,
			params,
		);

		return {
			totalRequests: result?.total_requests || 0,
			successfulRequests: result?.successful_requests || 0,
			avgResponseTime: result?.avg_response_time || null,
			totalTokens: result?.total_tokens || 0,
			totalCostUsd: result?.total_cost_usd || 0,
			inputTokens: result?.input_tokens || 0,
			outputTokens: result?.output_tokens || 0,
			cacheReadInputTokens: result?.cache_read_input_tokens || 0,
			cacheCreationInputTokens: result?.cache_creation_input_tokens || 0,
			avgTokensPerSecond: result?.avg_tokens_per_second || null,
		};
	}

	/**
	 * Get top models by usage
	 */
	getTopModels(limit = 10): Array<{ model: string; count: number }> {
		return this.query<{ model: string; count: number }>(
			`
			SELECT model, COUNT(*) as count
			FROM requests
			WHERE model IS NOT NULL
			GROUP BY model
			ORDER BY count DESC
			LIMIT ?
		`,
			[limit],
		);
	}

	/**
	 * Get recent error messages
	 */
	getRecentErrors(limit = 10): string[] {
		const errors = this.query<{ error_message: string }>(
			`
			SELECT error_message
			FROM requests
			WHERE success = 0 AND error_message IS NOT NULL
			ORDER BY timestamp DESC
			LIMIT ?
		`,
			[limit],
		);
		return errors.map((e: { error_message: string }) => e.error_message);
	}

	getRequestsByAccount(since?: number): Array<{
		accountId: string;
		accountName: string | null;
		requestCount: number;
		successRate: number;
	}> {
		const whereClause = since ? "WHERE r.timestamp > ?" : "";
		const params = since ? [since] : [];

		return this.query<{
			account_id: string;
			account_name: string | null;
			request_count: number;
			success_rate: number;
		}>(
			`
			SELECT 
				r.account_used as account_id,
				a.name as account_name,
				COUNT(*) as request_count,
				SUM(CASE WHEN r.success = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as success_rate
			FROM requests r
			LEFT JOIN accounts a ON r.account_used = a.id
			${whereClause}
			GROUP BY r.account_used
			ORDER BY request_count DESC
		`,
			params,
		).map((row) => ({
			accountId: row.account_id,
			accountName: row.account_name,
			requestCount: row.request_count,
			successRate: row.success_rate,
		}));
	}

	deleteOlderThan(cutoffTs: number): number {
		return this.runWithChanges(`DELETE FROM requests WHERE timestamp < ?`, [
			cutoffTs,
		]);
	}

	deleteOrphanedPayloads(): number {
		return this.runWithChanges(
			`DELETE FROM request_payloads WHERE id NOT IN (SELECT id FROM requests)`,
		);
	}

	deletePayloadsOlderThan(cutoffTs: number): number {
		return this.runWithChanges(
			`DELETE FROM request_payloads WHERE id IN (SELECT id FROM requests WHERE timestamp < ?)`,
			[cutoffTs],
		);
	}
}

================
File: packages/database/src/repositories/interceptor.repository.ts
================
import { BaseRepository } from "./base.repository";

export interface InterceptorConfig {
	targetPrompt: string;
	replacementPrompt: string;
	toolsEnabled: boolean;
}

interface InterceptorRow {
	id: string;
	is_enabled: number;
	config: string;
}

export class InterceptorRepository extends BaseRepository<InterceptorRow> {
	getConfig(
		id: string,
	): { isEnabled: boolean; config: InterceptorConfig } | null {
		const row = super.get<InterceptorRow>(
			"SELECT id, is_enabled, config FROM interceptors WHERE id = ?",
			[id],
		);

		if (!row) {
			return null;
		}

		return {
			isEnabled: row.is_enabled === 1,
			config: JSON.parse(row.config) as InterceptorConfig,
		};
	}

	setConfig(id: string, isEnabled: boolean, config: InterceptorConfig): void {
		const configJson = JSON.stringify(config);
		const isEnabledInt = isEnabled ? 1 : 0;

		this.run(
			"INSERT OR REPLACE INTO interceptors (id, is_enabled, config) VALUES (?, ?, ?)",
			[id, isEnabledInt, configJson],
		);
	}

	/**
	 * Delete an interceptor configuration
	 */
	delete(id: string): boolean {
		const changes = this.runWithChanges(
			"DELETE FROM interceptors WHERE id = ?",
			[id],
		);
		return changes > 0;
	}
}

================
File: packages/database/src/repositories/strategy.repository.ts
================
import { BaseRepository } from "./base.repository";

export interface StrategyData {
	name: string;
	config: Record<string, unknown>;
	updatedAt: number;
}

export class StrategyRepository extends BaseRepository<StrategyData> {
	getStrategy(name: string): StrategyData | null {
		const row = super.get<{ name: string; config: string; updated_at: number }>(
			`SELECT name, config, updated_at FROM strategies WHERE name = ?`,
			[name],
		);

		if (!row) return null;

		return {
			name: row.name,
			config: JSON.parse(row.config),
			updatedAt: row.updated_at,
		};
	}

	set(name: string, config: Record<string, unknown>): void {
		const now = Date.now();
		const configJson = JSON.stringify(config);

		this.run(
			`INSERT OR REPLACE INTO strategies (name, config, updated_at) VALUES (?, ?, ?)`,
			[name, configJson, now],
		);
	}

	list(): StrategyData[] {
		const rows = this.query<{
			name: string;
			config: string;
			updated_at: number;
		}>(`SELECT name, config, updated_at FROM strategies ORDER BY name`);

		return rows.map((row) => ({
			name: row.name,
			config: JSON.parse(row.config),
			updatedAt: row.updated_at,
		}));
	}

	delete(name: string): boolean {
		const changes = this.runWithChanges(
			`DELETE FROM strategies WHERE name = ?`,
			[name],
		);
		return changes > 0;
	}
}

================
File: packages/database/src/repositories/stats.repository.ts
================
/**
 * Consolidated stats repository to eliminate duplication between tui-core and http-api
 */
import type { Database } from "bun:sqlite";
import { NO_ACCOUNT_ID } from "@ccflare/types";

export interface AccountStats {
	name: string;
	requestCount: number;
	successRate: number;
	totalRequests?: number;
}

export interface AggregatedStats {
	totalRequests: number;
	successfulRequests: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	inputTokens: number;
	outputTokens: number;
	cacheReadInputTokens: number;
	cacheCreationInputTokens: number;
	avgTokensPerSecond: number | null;
}

export class StatsRepository {
	constructor(private db: Database) {}

	/**
	 * Get aggregated statistics for all requests
	 */
	getAggregatedStats(): AggregatedStats {
		const stats = this.db
			.query(
				`SELECT 
					COUNT(*) as totalRequests,
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successfulRequests,
					AVG(response_time_ms) as avgResponseTime,
					SUM(input_tokens) as inputTokens,
					SUM(output_tokens) as outputTokens,
					SUM(cache_creation_input_tokens) as cacheCreationInputTokens,
					SUM(cache_read_input_tokens) as cacheReadInputTokens,
					SUM(cost_usd) as totalCostUsd,
					AVG(output_tokens_per_second) as avgTokensPerSecond
				FROM requests`,
			)
			.get() as AggregatedStats;

		// Calculate total tokens
		const totalTokens =
			(stats.inputTokens || 0) +
			(stats.outputTokens || 0) +
			(stats.cacheCreationInputTokens || 0) +
			(stats.cacheReadInputTokens || 0);

		return {
			...stats,
			totalTokens,
			avgResponseTime: stats.avgResponseTime || 0,
			totalCostUsd: stats.totalCostUsd || 0,
		};
	}

	/**
	 * Get account statistics with success rates
	 * This consolidates the duplicated logic between tui-core and http-api
	 */
	getAccountStats(limit = 10, includeUnauthenticated = true): AccountStats[] {
		// Get account request counts
		const accountStatsQuery = includeUnauthenticated
			? `
				SELECT 
					COALESCE(a.id, ?) as id,
					COALESCE(a.name, ?) as name,
					COUNT(r.id) as requestCount,
					COALESCE(a.total_requests, 0) as totalRequests
				FROM requests r
				LEFT JOIN accounts a ON a.id = r.account_used
				GROUP BY COALESCE(a.id, ?), COALESCE(a.name, ?)
				HAVING requestCount > 0
				ORDER BY requestCount DESC
				LIMIT ?
			`
			: `
				SELECT 
					a.id,
					a.name,
					a.request_count as requestCount,
					a.total_requests as totalRequests
				FROM accounts a
				WHERE a.request_count > 0
				ORDER BY a.request_count DESC
				LIMIT ?
			`;

		const params = includeUnauthenticated
			? [NO_ACCOUNT_ID, NO_ACCOUNT_ID, NO_ACCOUNT_ID, NO_ACCOUNT_ID, limit]
			: [limit];

		const accountStats = this.db
			.query(accountStatsQuery)
			.all(...params) as Array<{
			id: string;
			name: string;
			requestCount: number;
			totalRequests: number;
		}>;

		// Calculate success rate per account using a batch query
		if (accountStats.length === 0) return [];

		const accountIds = accountStats.map((a) => a.id);
		const placeholders = accountIds.map(() => "?").join(",");

		const successRates = this.db
			.query(
				`SELECT 
					account_used as accountId,
					COUNT(*) as total,
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successful
				FROM requests
				WHERE account_used IN (${placeholders})
				GROUP BY account_used`,
			)
			.all(...accountIds) as Array<{
			accountId: string;
			total: number;
			successful: number;
		}>;

		// Create a map for O(1) lookup
		const successRateMap = new Map(
			successRates.map((sr) => [
				sr.accountId,
				sr.total > 0 ? Math.round((sr.successful / sr.total) * 100) : 0,
			]),
		);

		// Combine the data
		return accountStats.map((acc) => ({
			name: acc.name,
			requestCount: acc.requestCount,
			successRate: successRateMap.get(acc.id) || 0,
			totalRequests: acc.totalRequests,
		}));
	}

	/**
	 * Get count of active accounts
	 */
	getActiveAccountCount(): number {
		const result = this.db
			.query("SELECT COUNT(*) as count FROM accounts WHERE request_count > 0")
			.get() as { count: number };
		return result.count;
	}

	/**
	 * Get recent errors (already exists in request.repository, but adding for completeness)
	 */
	getRecentErrors(limit = 10): string[] {
		const errors = this.db
			.query(
				`SELECT DISTINCT error_message
				FROM requests
				WHERE error_message IS NOT NULL
					AND error_message != ''
				ORDER BY timestamp DESC
				LIMIT ?`,
			)
			.all(limit) as Array<{ error_message: string }>;

		return errors.map((e) => e.error_message);
	}

	/**
	 * Get top models by usage
	 */
	getTopModels(
		limit = 5,
	): Array<{ model: string; count: number; percentage: number }> {
		const models = this.db
			.query(
				`WITH model_counts AS (
					SELECT 
						model,
						COUNT(*) as count
					FROM requests
					WHERE model IS NOT NULL
					GROUP BY model
				),
				total AS (
					SELECT COUNT(*) as total FROM requests WHERE model IS NOT NULL
				)
				SELECT 
					mc.model,
					mc.count,
					ROUND(CAST(mc.count AS REAL) / t.total * 100, 2) as percentage
				FROM model_counts mc, total t
				ORDER BY mc.count DESC
				LIMIT ?`,
			)
			.all(limit) as Array<{
			model: string;
			count: number;
			percentage: number;
		}>;

		return models;
	}
}

================
File: packages/database/src/repositories/oauth.repository.ts
================
import { BaseRepository } from "./base.repository";

export interface OAuthSession {
	accountName: string;
	verifier: string;
	mode: "console" | "max";
	tier: number;
}

export class OAuthRepository extends BaseRepository<OAuthSession> {
	createSession(
		sessionId: string,
		accountName: string,
		verifier: string,
		mode: "console" | "max",
		tier: number,
		ttlMinutes = 10,
	): void {
		const now = Date.now();
		const expiresAt = now + ttlMinutes * 60 * 1000;

		this.run(
			`
			INSERT INTO oauth_sessions (id, account_name, verifier, mode, tier, created_at, expires_at)
			VALUES (?, ?, ?, ?, ?, ?, ?)
		`,
			[sessionId, accountName, verifier, mode, tier, now, expiresAt],
		);
	}

	getSession(sessionId: string): OAuthSession | null {
		const row = this.get<{
			account_name: string;
			verifier: string;
			mode: "console" | "max";
			tier: number;
			expires_at: number;
		}>(
			`
			SELECT account_name, verifier, mode, tier, expires_at 
			FROM oauth_sessions 
			WHERE id = ? AND expires_at > ?
		`,
			[sessionId, Date.now()],
		);

		if (!row) return null;

		return {
			accountName: row.account_name,
			verifier: row.verifier,
			mode: row.mode,
			tier: row.tier,
		};
	}

	deleteSession(sessionId: string): void {
		this.run(`DELETE FROM oauth_sessions WHERE id = ?`, [sessionId]);
	}

	cleanupExpiredSessions(): number {
		return this.runWithChanges(
			`DELETE FROM oauth_sessions WHERE expires_at <= ?`,
			[Date.now()],
		);
	}
}

================
File: packages/database/src/repositories/agent-preference.repository.ts
================
import { BaseRepository } from "./base.repository";

export interface AgentPreference {
	agentId: string;
	model: string;
	updatedAt: number;
}

export class AgentPreferenceRepository extends BaseRepository<AgentPreference> {
	/**
	 * Get model preference for a specific agent
	 */
	getPreference(agentId: string): { model: string } | null {
		const row = this.get<{ model: string }>(
			`SELECT model FROM agent_preferences WHERE agent_id = ?`,
			[agentId],
		);
		return row;
	}

	/**
	 * Get all agent preferences
	 */
	getAllPreferences(): Array<{ agent_id: string; model: string }> {
		return this.query<{ agent_id: string; model: string }>(
			`SELECT agent_id, model FROM agent_preferences`,
		);
	}

	/**
	 * Set model preference for an agent
	 */
	setPreference(agentId: string, model: string): void {
		this.run(
			`INSERT OR REPLACE INTO agent_preferences (agent_id, model, updated_at) VALUES (?, ?, ?)`,
			[agentId, model, Date.now()],
		);
	}

	/**
	 * Delete preference for an agent
	 */
	deletePreference(agentId: string): boolean {
		const changes = this.runWithChanges(
			`DELETE FROM agent_preferences WHERE agent_id = ?`,
			[agentId],
		);
		return changes > 0;
	}

	/**
	 * Set preferences for all agents in bulk
	 */
	setBulkPreferences(agentIds: string[], model: string): void {
		if (agentIds.length === 0) {
			return;
		}

		const now = Date.now();
		const placeholders = agentIds.map(() => "(?, ?, ?)").join(", ");
		const values = agentIds.flatMap((id) => [id, model, now]);

		this.run(
			`INSERT OR REPLACE INTO agent_preferences (agent_id, model, updated_at) VALUES ${placeholders}`,
			values,
		);
	}
}

================
File: packages/database/src/repositories/system-kv.repository.ts
================
import { BaseRepository } from "./base.repository";

interface SystemKVRow {
	key: string;
	value: string;
}

export class SystemKVRepository extends BaseRepository<SystemKVRow> {
	getValue(key: string): string | null {
		const row = super.get<SystemKVRow>(
			"SELECT value FROM system_kv_store WHERE key = ?",
			[key],
		);

		return row?.value ?? null;
	}

	setValue(key: string, value: string): void {
		this.run(
			"INSERT OR REPLACE INTO system_kv_store (key, value) VALUES (?, ?)",
			[key, value],
		);
	}
}

================
File: packages/database/src/repositories/account.repository.ts
================
import { type Account, type AccountRow, toAccount } from "@ccflare/types";
import { BaseRepository } from "./base.repository";

export class AccountRepository extends BaseRepository<Account> {
	findAll(): Account[] {
		const rows = this.query<AccountRow>(`
			SELECT 
				id, name, provider, api_key, refresh_token, access_token,
				expires_at, created_at, last_used, request_count, total_requests,
				rate_limited_until, session_start, session_request_count,
				COALESCE(account_tier, 1) as account_tier,
				COALESCE(paused, 0) as paused,
				rate_limit_reset, rate_limit_status, rate_limit_remaining
			FROM accounts
		`);
		return rows.map(toAccount);
	}

	findById(accountId: string): Account | null {
		const row = this.get<AccountRow>(
			`
			SELECT 
				id, name, provider, api_key, refresh_token, access_token,
				expires_at, created_at, last_used, request_count, total_requests,
				rate_limited_until, session_start, session_request_count,
				COALESCE(account_tier, 1) as account_tier,
				COALESCE(paused, 0) as paused,
				rate_limit_reset, rate_limit_status, rate_limit_remaining
			FROM accounts
			WHERE id = ?
		`,
			[accountId],
		);

		return row ? toAccount(row) : null;
	}

	updateTokens(
		accountId: string,
		accessToken: string,
		expiresAt: number,
		refreshToken?: string,
	): void {
		if (refreshToken) {
			this.run(
				`UPDATE accounts SET access_token = ?, expires_at = ?, refresh_token = ? WHERE id = ?`,
				[accessToken, expiresAt, refreshToken, accountId],
			);
		} else {
			this.run(
				`UPDATE accounts SET access_token = ?, expires_at = ? WHERE id = ?`,
				[accessToken, expiresAt, accountId],
			);
		}
	}

	incrementUsage(accountId: string, sessionDurationMs: number): void {
		const now = Date.now();
		this.run(
			`
			UPDATE accounts 
			SET 
				last_used = ?,
				request_count = request_count + 1,
				total_requests = total_requests + 1,
				session_start = CASE
					WHEN session_start IS NULL OR ? - session_start >= ? THEN ?
					ELSE session_start
				END,
				session_request_count = CASE
					WHEN session_start IS NULL OR ? - session_start >= ? THEN 1
					ELSE session_request_count + 1
				END
			WHERE id = ?
		`,
			[now, now, sessionDurationMs, now, now, sessionDurationMs, accountId],
		);
	}

	setRateLimited(accountId: string, until: number): void {
		this.run(`UPDATE accounts SET rate_limited_until = ? WHERE id = ?`, [
			until,
			accountId,
		]);
	}

	updateRateLimitMeta(
		accountId: string,
		status: string,
		reset: number | null,
		remaining?: number | null,
	): void {
		this.run(
			`UPDATE accounts SET rate_limit_status = ?, rate_limit_reset = ?, rate_limit_remaining = ? WHERE id = ?`,
			[status, reset, remaining ?? null, accountId],
		);
	}

	updateTier(accountId: string, tier: number): void {
		this.run(`UPDATE accounts SET account_tier = ? WHERE id = ?`, [
			tier,
			accountId,
		]);
	}

	pause(accountId: string): void {
		this.run(`UPDATE accounts SET paused = 1 WHERE id = ?`, [accountId]);
	}

	resume(accountId: string): void {
		this.run(`UPDATE accounts SET paused = 0 WHERE id = ?`, [accountId]);
	}

	resetSession(accountId: string, timestamp: number): void {
		this.run(
			`UPDATE accounts SET session_start = ?, session_request_count = 0 WHERE id = ?`,
			[timestamp, accountId],
		);
	}

	updateRequestCount(accountId: string, count: number): void {
		this.run(`UPDATE accounts SET session_request_count = ? WHERE id = ?`, [
			count,
			accountId,
		]);
	}

	rename(accountId: string, newName: string): void {
		this.run(`UPDATE accounts SET name = ? WHERE id = ?`, [newName, accountId]);
	}
}

================
File: packages/core-di/package.json
================
{
	"name": "@ccflare/core-di",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	}
}

================
File: packages/core-di/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/core-di/src/container.ts
================
type ServiceFactory<T> = () => T;
type ServiceKey = string | symbol;

class Container {
	private services = new Map<ServiceKey, unknown>();
	private factories = new Map<ServiceKey, ServiceFactory<unknown>>();

	register<T>(key: ServiceKey, factory: ServiceFactory<T>): void {
		this.factories.set(key, factory);
	}

	registerInstance<T>(key: ServiceKey, instance: T): void {
		this.services.set(key, instance);
	}

	resolve<T>(key: ServiceKey): T {
		// Check if instance already exists
		if (this.services.has(key)) {
			return this.services.get(key) as T;
		}

		// Check if factory exists
		const factory = this.factories.get(key);
		if (!factory) {
			throw new Error(`Service '${String(key)}' not registered`);
		}

		// Create instance and cache it (singleton)
		const instance = factory();
		this.services.set(key, instance);
		return instance as T;
	}

	has(key: ServiceKey): boolean {
		return this.factories.has(key) || this.services.has(key);
	}

	clear(): void {
		this.services.clear();
		this.factories.clear();
	}
}

// Global container instance
export const container = new Container();

================
File: packages/core-di/src/index.ts
================
import { container as _container } from "./container";

export const container = _container;

// Service keys - using symbols for better encapsulation
export const SERVICE_KEYS = {
	Logger: Symbol("Logger"),
	Config: Symbol("Config"),
	Database: Symbol("Database"),
	PricingLogger: Symbol("PricingLogger"),
	AsyncWriter: Symbol("AsyncWriter"),
} as const;

// Type-safe service resolution helper
export function getService<T>(key: keyof typeof SERVICE_KEYS): T {
	return container.resolve<T>(SERVICE_KEYS[key]);
}

================
File: packages/types/package.json
================
{
	"name": "@ccflare/types",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	}
}

================
File: packages/types/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/types/src/account.ts
================
// AccountTier represents the tier level (1, 5, or 20)
export type AccountTier = number;

// Database row types that match the actual database schema
export interface AccountRow {
	id: string;
	name: string;
	provider: string | null;
	api_key: string | null;
	refresh_token: string;
	access_token: string | null;
	expires_at: number | null;
	created_at: number;
	last_used: number | null;
	request_count: number;
	total_requests: number;
	rate_limited_until?: number | null;
	session_start?: number | null;
	session_request_count?: number;
	account_tier: number;
	paused?: 0 | 1;
	rate_limit_reset?: number | null;
	rate_limit_status?: string | null;
	rate_limit_remaining?: number | null;
}

// Domain model - used throughout the application
export interface Account {
	id: string;
	name: string;
	provider: string;
	api_key: string | null;
	refresh_token: string;
	access_token: string | null;
	expires_at: number | null;
	request_count: number;
	total_requests: number;
	last_used: number | null;
	created_at: number;
	rate_limited_until: number | null;
	session_start: number | null;
	session_request_count: number;
	account_tier: number; // 1, 5, or 20
	paused: boolean;
	rate_limit_reset: number | null;
	rate_limit_status: string | null;
	rate_limit_remaining: number | null;
}

// API response type - what clients receive
export interface AccountResponse {
	id: string;
	name: string;
	provider: string;
	requestCount: number;
	totalRequests: number;
	lastUsed: string | null;
	created: string;
	tier: number;
	paused: boolean;
	tokenStatus: "valid" | "expired";
	tokenExpiresAt: string | null; // ISO timestamp of token expiration
	rateLimitStatus: string;
	rateLimitReset: string | null;
	rateLimitRemaining: number | null;
	sessionInfo: string;
}

// UI display type - used in TUI and web dashboard
export interface AccountDisplay {
	id: string;
	name: string;
	provider: string;
	tierDisplay: string;
	created: Date;
	lastUsed: Date | null;
	requestCount: number;
	totalRequests: number;
	tokenStatus: "valid" | "expired";
	rateLimitStatus: string;
	sessionInfo: string;
	paused: boolean;
	tier?: number;
	account_tier?: number;
	rate_limited_until?: number | null;
	session_start?: number | null;
	session_request_count?: number;
	access_token?: string | null;
}

// CLI list item type
export interface AccountListItem {
	id: string;
	name: string;
	provider: string;
	tier: number;
	tierDisplay: string;
	created: Date;
	lastUsed: Date | null;
	requestCount: number;
	totalRequests: number;
	paused: boolean;
	tokenStatus: "valid" | "expired";
	rateLimitStatus: string;
	sessionInfo: string;
	mode: "max" | "console";
}

// Account creation types
export interface AddAccountOptions {
	name: string;
	mode?: "max" | "console";
	tier?: 1 | 5 | 20;
}

export interface AccountDeleteRequest {
	confirm: string;
}

// Type mappers
export function toAccount(row: AccountRow): Account {
	return {
		id: row.id,
		name: row.name,
		provider: row.provider || "anthropic",
		api_key: row.api_key,
		refresh_token: row.refresh_token,
		access_token: row.access_token,
		expires_at: row.expires_at,
		created_at: row.created_at,
		last_used: row.last_used,
		request_count: row.request_count,
		total_requests: row.total_requests,
		rate_limited_until: row.rate_limited_until || null,
		session_start: row.session_start || null,
		session_request_count: row.session_request_count || 0,
		account_tier: row.account_tier || 1,
		paused: row.paused === 1,
		rate_limit_reset: row.rate_limit_reset || null,
		rate_limit_status: row.rate_limit_status || null,
		rate_limit_remaining: row.rate_limit_remaining || null,
	};
}

export function toAccountResponse(account: Account): AccountResponse {
	const tokenStatus = account.access_token ? "valid" : "expired";
	const isRateLimited =
		account.rate_limited_until && account.rate_limited_until > Date.now();
	const rateLimitStatus =
		isRateLimited && account.rate_limited_until
			? `Rate limited until ${new Date(account.rate_limited_until).toLocaleString()}`
			: "OK";

	const sessionInfo = account.session_start
		? `Session: ${account.session_request_count} requests`
		: "No active session";

	return {
		id: account.id,
		name: account.name,
		provider: account.provider,
		requestCount: account.request_count,
		totalRequests: account.total_requests,
		lastUsed: account.last_used
			? new Date(account.last_used).toISOString()
			: null,
		created: new Date(account.created_at).toISOString(),
		tier: account.account_tier,
		paused: account.paused,
		tokenStatus,
		tokenExpiresAt: account.expires_at
			? new Date(account.expires_at).toISOString()
			: null,
		rateLimitStatus,
		rateLimitReset: account.rate_limit_reset
			? new Date(account.rate_limit_reset).toISOString()
			: null,
		rateLimitRemaining: account.rate_limit_remaining,
		sessionInfo,
	};
}

export function toAccountDisplay(account: Account): AccountDisplay {
	const tokenStatus = account.access_token ? "valid" : "expired";
	const isRateLimited =
		account.rate_limited_until && account.rate_limited_until > Date.now();
	const rateLimitStatus =
		isRateLimited && account.rate_limited_until
			? `Rate limited until ${new Date(account.rate_limited_until).toLocaleString()}`
			: "OK";

	const sessionInfo = account.session_start
		? `Session: ${account.session_request_count} requests`
		: "No active session";

	return {
		id: account.id,
		name: account.name,
		provider: account.provider,
		tierDisplay: `Tier ${account.account_tier}`,
		created: new Date(account.created_at),
		lastUsed: account.last_used ? new Date(account.last_used) : null,
		requestCount: account.request_count,
		totalRequests: account.total_requests,
		tokenStatus,
		rateLimitStatus,
		sessionInfo,
		paused: account.paused,
		tier: account.account_tier,
		account_tier: account.account_tier,
		rate_limited_until: account.rate_limited_until,
		session_start: account.session_start,
		session_request_count: account.session_request_count,
		access_token: account.access_token,
	};
}

================
File: packages/types/src/stats.ts
================
// Stats types
export interface Stats {
	totalRequests: number;
	successRate: number;
	activeAccounts: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	topModels: Array<{ model: string; count: number }>;
	avgTokensPerSecond: number | null;
}

export interface StatsResponse {
	totalRequests: number;
	successRate: number;
	activeAccounts: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	topModels: Array<{ model: string; count: number }>;
	avgTokensPerSecond: number | null;
}

export interface StatsWithAccounts extends Stats {
	accounts: Array<{
		name: string;
		requestCount: number;
		successRate: number;
	}>;
	recentErrors: string[];
}

// Analytics types
export interface TimePoint {
	ts: number; // period start (ms)
	model?: string; // Optional model name for per-model time series
	requests: number;
	tokens: number;
	costUsd: number;
	successRate: number; // 0-100
	errorRate: number; // 0-100
	cacheHitRate: number; // 0-100
	avgResponseTime: number; // ms
	avgTokensPerSecond: number | null;
}

export interface TokenBreakdown {
	inputTokens: number;
	cacheReadInputTokens: number;
	cacheCreationInputTokens: number;
	outputTokens: number;
}

export interface ModelPerformance {
	model: string;
	avgResponseTime: number;
	p95ResponseTime: number;
	errorRate: number;
	avgTokensPerSecond: number | null;
	minTokensPerSecond: number | null;
	maxTokensPerSecond: number | null;
}

export interface AnalyticsResponse {
	meta?: {
		range: string;
		bucket: string;
		cumulative?: boolean;
	};
	totals: {
		requests: number;
		successRate: number;
		activeAccounts: number;
		avgResponseTime: number;
		totalTokens: number;
		totalCostUsd: number;
		avgTokensPerSecond: number | null;
	};
	timeSeries: TimePoint[];
	tokenBreakdown: TokenBreakdown;
	modelDistribution: Array<{ model: string; count: number }>;
	accountPerformance: Array<{
		name: string;
		requests: number;
		successRate: number;
	}>;
	costByModel: Array<{
		model: string;
		costUsd: number;
		requests: number;
		totalTokens?: number;
	}>;
	modelPerformance: ModelPerformance[];
}

// Health check response
export interface HealthResponse {
	status: string;
	accounts: number;
	timestamp: string;
	strategy: string;
}

// Config types
export interface ConfigResponse {
	lb_strategy: string;
	port: number;
	sessionDurationMs: number;
	default_agent_model: string;
}

export interface StrategyUpdateRequest {
	strategy: string;
}

export interface TierUpdateRequest {
	tier: number;
}

================
File: packages/types/src/agent.ts
================
import { CLAUDE_MODEL_IDS } from "@ccflare/core";

export type AgentSource = "global" | "workspace";

export type AgentTool =
	| "Bash"
	| "Glob"
	| "Grep"
	| "LS"
	| "Read"
	| "Edit"
	| "MultiEdit"
	| "Write"
	| "NotebookRead"
	| "NotebookEdit"
	| "WebFetch"
	| "TodoWrite"
	| "WebSearch";

export interface AgentWorkspace {
	path: string;
	name: string;
	lastSeen: number; // timestamp
}

export interface Agent {
	id: string;
	name: string;
	description: string;
	color: string;
	model: AllowedModel;
	systemPrompt: string;
	source: AgentSource;
	workspace?: string; // workspace path if source is "workspace"
	tools?: AgentTool[]; // parsed from tools: front-matter
	filePath: string; // absolute path of the markdown file
}

export type AgentResponse = Agent[];

export const ALLOWED_MODELS = [
	CLAUDE_MODEL_IDS.OPUS_4,
	CLAUDE_MODEL_IDS.OPUS_4_1,
	CLAUDE_MODEL_IDS.SONNET_4,
] as const;

export type AllowedModel = (typeof ALLOWED_MODELS)[number];

================
File: packages/types/src/context.ts
================
import type { Database } from "bun:sqlite";
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import type { Account } from "./account";
import type { RequestMeta } from "./api";
import type { StrategyStore } from "./strategy";

// API context for HTTP handlers
export interface APIContext {
	db: Database;
	config: Config;
	dbOps: DatabaseOperations;
}

// Load balancing strategy interface
export interface LoadBalancingStrategy {
	/**
	 * Return a filtered & ordered list of candidate accounts.
	 * Accounts that are rate-limited should be filtered out.
	 * The first account in the list should be tried first.
	 */
	select(accounts: Account[], meta: RequestMeta): Account[];

	/**
	 * Optional initialization method to inject dependencies
	 * Used for strategies that need access to a StrategyStore
	 */
	initialize?(store: StrategyStore): void;
}

================
File: packages/types/src/api.ts
================
export interface RequestMeta {
	id: string;
	method: string;
	path: string;
	timestamp: number;
	agentUsed?: string | null;
}

export interface AgentUpdatePayload {
	description?: string;
	model?: string;
	tools?: string[];
	color?: string;
	systemPrompt?: string;
	mode?: "all" | "edit" | "read-only" | "execution" | "custom";
}

// Retention and maintenance API shapes
export interface RetentionGetResponse {
	payloadDays: number;
	requestDays: number;
}

export interface RetentionSetRequest {
	payloadDays?: number;
	requestDays?: number;
}

export interface CleanupResponse {
	removedRequests: number;
	removedPayloads: number;
	cutoffIso: string;
}

export interface CompactResponse {
	ok: boolean;
}

================
File: packages/types/src/strategy.ts
================
import type { Account } from "./account";

export enum StrategyName {
	Session = "session",
}

/**
 * Interface for strategy-specific database operations
 * Allows strategies to interact with the database without direct SQL access
 */
export interface StrategyStore {
	/**
	 * Reset session for an account
	 * Updates session_start and session_request_count
	 */
	resetAccountSession(accountId: string, timestamp: number): void;

	/**
	 * Get all accounts (optional method for strategies that need full account list)
	 */
	getAllAccounts?(): Account[];

	/**
	 * Update account request count
	 */
	updateAccountRequestCount?(accountId: string, count: number): void;

	/**
	 * Get account by ID
	 */
	getAccount?(accountId: string): Account | null;
}

================
File: packages/types/src/request.ts
================
// Database row type
export interface RequestRow {
	id: string;
	timestamp: number;
	method: string;
	path: string;
	account_used: string | null;
	status_code: number | null;
	success: 0 | 1;
	error_message: string | null;
	response_time_ms: number | null;
	failover_attempts: number;
	model: string | null;
	prompt_tokens: number | null;
	completion_tokens: number | null;
	total_tokens: number | null;
	cost_usd: number | null;
	input_tokens: number | null;
	cache_read_input_tokens: number | null;
	cache_creation_input_tokens: number | null;
	output_tokens: number | null;
	agent_used: string | null;
	output_tokens_per_second: number | null;
}

// Domain model
export interface Request {
	id: string;
	timestamp: number;
	method: string;
	path: string;
	accountUsed: string | null;
	statusCode: number | null;
	success: boolean;
	errorMessage: string | null;
	responseTimeMs: number | null;
	failoverAttempts: number;
	model?: string;
	promptTokens?: number;
	completionTokens?: number;
	totalTokens?: number;
	costUsd?: number;
	inputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	outputTokens?: number;
	agentUsed?: string;
	tokensPerSecond?: number;
}

// API response type
export interface RequestResponse {
	id: string;
	timestamp: string;
	method: string;
	path: string;
	accountUsed: string | null;
	statusCode: number | null;
	success: boolean;
	errorMessage: string | null;
	responseTimeMs: number | null;
	failoverAttempts: number;
	model?: string;
	promptTokens?: number;
	completionTokens?: number;
	totalTokens?: number;
	inputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	outputTokens?: number;
	costUsd?: number;
	agentUsed?: string;
	tokensPerSecond?: number;
}

// Detailed request with payload
export interface RequestPayload {
	id: string;
	request: {
		headers: Record<string, string>;
		body: string | null;
	};
	response: {
		status: number;
		headers: Record<string, string>;
		body: string | null;
	} | null;
	error?: string;
	meta: {
		accountId?: string;
		accountName?: string;
		retry?: number;
		timestamp: number;
		success?: boolean;
		rateLimited?: boolean;
		accountsAttempted?: number;
		pending?: boolean;
		path?: string;
		method?: string;
		agentUsed?: string;
	};
}

// Type mappers
export function toRequest(row: RequestRow): Request {
	return {
		id: row.id,
		timestamp: row.timestamp,
		method: row.method,
		path: row.path,
		accountUsed: row.account_used,
		statusCode: row.status_code,
		success: row.success === 1,
		errorMessage: row.error_message,
		responseTimeMs: row.response_time_ms,
		failoverAttempts: row.failover_attempts,
		model: row.model || undefined,
		promptTokens: row.prompt_tokens || undefined,
		completionTokens: row.completion_tokens || undefined,
		totalTokens: row.total_tokens || undefined,
		costUsd: row.cost_usd || undefined,
		inputTokens: row.input_tokens || undefined,
		cacheReadInputTokens: row.cache_read_input_tokens || undefined,
		cacheCreationInputTokens: row.cache_creation_input_tokens || undefined,
		outputTokens: row.output_tokens || undefined,
		agentUsed: row.agent_used || undefined,
		tokensPerSecond: row.output_tokens_per_second || undefined,
	};
}

export function toRequestResponse(request: Request): RequestResponse {
	return {
		id: request.id,
		timestamp: new Date(request.timestamp).toISOString(),
		method: request.method,
		path: request.path,
		accountUsed: request.accountUsed,
		statusCode: request.statusCode,
		success: request.success,
		errorMessage: request.errorMessage,
		responseTimeMs: request.responseTimeMs,
		failoverAttempts: request.failoverAttempts,
		model: request.model,
		promptTokens: request.promptTokens,
		completionTokens: request.completionTokens,
		totalTokens: request.totalTokens,
		inputTokens: request.inputTokens,
		cacheReadInputTokens: request.cacheReadInputTokens,
		cacheCreationInputTokens: request.cacheCreationInputTokens,
		outputTokens: request.outputTokens,
		costUsd: request.costUsd,
		agentUsed: request.agentUsed,
		tokensPerSecond: request.tokensPerSecond,
	};
}

// Special account ID for requests without an account
export const NO_ACCOUNT_ID = "no_account";

================
File: packages/types/src/agent-constants.ts
================
import type { AgentTool } from "./agent";

export const ALL_TOOLS: AgentTool[] = [
	"Bash",
	"Glob",
	"Grep",
	"LS",
	"Read",
	"Edit",
	"MultiEdit",
	"Write",
	"NotebookRead",
	"NotebookEdit",
	"WebFetch",
	"TodoWrite",
	"WebSearch",
];

export const TOOL_PRESETS = {
	all: [] as AgentTool[], // empty means don't set tools property
	edit: ["Edit", "MultiEdit", "Write", "NotebookEdit"] as AgentTool[],
	"read-only": [
		"Glob",
		"Grep",
		"LS",
		"Read",
		"NotebookRead",
		"WebFetch",
		"TodoWrite",
		"WebSearch",
	] as AgentTool[],
	execution: ["Bash"] as AgentTool[],
} as const;

================
File: packages/types/src/conversation.ts
================
export type Role = "user" | "assistant" | "system";

export interface ToolUse {
	id?: string;
	name: string;
	input?: Record<string, unknown>;
}

export interface ToolResult {
	tool_use_id: string;
	content: string;
}

export enum ContentBlockType {
	Text = "text",
	ToolUse = "tool_use",
	ToolResult = "tool_result",
	Thinking = "thinking",
}

export interface ContentBlock {
	type: ContentBlockType;
	text?: string;
	thinking?: string;
	id?: string;
	name?: string;
	input?: Record<string, unknown>;
	tool_use_id?: string;
	content?: string;
}

export interface MessageData {
	role: Role;
	content: string;
	contentBlocks?: ContentBlock[];
	tools?: ToolUse[];
	toolResults?: ToolResult[];
}

================
File: packages/types/src/index.ts
================
// Re-export all types organized by domain
export * from "./account";
export * from "./agent";
export * from "./agent-constants";
// Keep existing exports for backward compatibility
export * from "./api";
export * from "./context";
export * from "./conversation";
export * from "./logging";
export * from "./request";
export * from "./stats";
export * from "./strategy";

================
File: packages/types/src/logging.ts
================
export interface LogEvent {
	ts: number;
	level: "DEBUG" | "INFO" | "WARN" | "ERROR";
	msg: string;
}

================
File: packages/core/package.json
================
{
	"name": "@ccflare/core",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/types": "workspace:*"
	}
}

================
File: packages/core/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/core/src/validation.ts
================
/**
 * Input validation and sanitization utilities
 */
import { ValidationError } from "./errors";

/**
 * Validates and sanitizes a string input
 */
export function validateString(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		minLength?: number;
		maxLength?: number;
		pattern?: RegExp;
		allowedValues?: readonly string[];
		transform?: (value: string) => string;
	} = {},
): string | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Ensure it's a string
	if (typeof value !== "string") {
		throw new ValidationError(`${field} must be a string`, field, value);
	}

	// Apply transformation if provided
	const sanitized = options.transform ? options.transform(value) : value;

	// Validate length
	if (options.minLength !== undefined && sanitized.length < options.minLength) {
		throw new ValidationError(
			`${field} must be at least ${options.minLength} characters long`,
			field,
			value,
		);
	}

	if (options.maxLength !== undefined && sanitized.length > options.maxLength) {
		throw new ValidationError(
			`${field} must be at most ${options.maxLength} characters long`,
			field,
			value,
		);
	}

	// Validate pattern
	if (options.pattern && !options.pattern.test(sanitized)) {
		throw new ValidationError(`${field} has an invalid format`, field, value);
	}

	// Validate allowed values
	if (options.allowedValues && !options.allowedValues.includes(sanitized)) {
		throw new ValidationError(
			`${field} must be one of: ${options.allowedValues.join(", ")}`,
			field,
			value,
		);
	}

	return sanitized;
}

/**
 * Validates and sanitizes a number input
 */
export function validateNumber(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		min?: number;
		max?: number;
		integer?: boolean;
		allowedValues?: readonly number[];
	} = {},
): number | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Convert string to number if needed
	let num: number;
	if (typeof value === "string") {
		num = Number(value);
		if (Number.isNaN(num)) {
			throw new ValidationError(
				`${field} must be a valid number`,
				field,
				value,
			);
		}
	} else if (typeof value === "number") {
		num = value;
	} else {
		throw new ValidationError(`${field} must be a number`, field, value);
	}

	// Validate integer
	if (options.integer && !Number.isInteger(num)) {
		throw new ValidationError(`${field} must be an integer`, field, value);
	}

	// Validate range
	if (options.min !== undefined && num < options.min) {
		throw new ValidationError(
			`${field} must be at least ${options.min}`,
			field,
			value,
		);
	}

	if (options.max !== undefined && num > options.max) {
		throw new ValidationError(
			`${field} must be at most ${options.max}`,
			field,
			value,
		);
	}

	// Validate allowed values
	if (options.allowedValues && !options.allowedValues.includes(num)) {
		throw new ValidationError(
			`${field} must be one of: ${options.allowedValues.join(", ")}`,
			field,
			value,
		);
	}

	return num;
}

/**
 * Validates and sanitizes a boolean input
 */
export function validateBoolean(
	value: unknown,
	field: string,
	options: { required?: boolean } = {},
): boolean | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Handle boolean
	if (typeof value === "boolean") {
		return value;
	}

	// Handle string booleans
	if (typeof value === "string") {
		const lower = value.toLowerCase();
		if (lower === "true" || lower === "1" || lower === "yes") {
			return true;
		}
		if (lower === "false" || lower === "0" || lower === "no") {
			return false;
		}
	}

	// Handle numbers
	if (typeof value === "number") {
		return value !== 0;
	}

	throw new ValidationError(`${field} must be a boolean`, field, value);
}

/**
 * Validates and sanitizes an array input
 */
export function validateArray<T>(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		minLength?: number;
		maxLength?: number;
		itemValidator?: (item: unknown, index: number) => T;
	} = {},
): T[] | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Ensure it's an array
	if (!Array.isArray(value)) {
		throw new ValidationError(`${field} must be an array`, field, value);
	}

	// Validate length
	if (options.minLength !== undefined && value.length < options.minLength) {
		throw new ValidationError(
			`${field} must contain at least ${options.minLength} items`,
			field,
			value,
		);
	}

	if (options.maxLength !== undefined && value.length > options.maxLength) {
		throw new ValidationError(
			`${field} must contain at most ${options.maxLength} items`,
			field,
			value,
		);
	}

	// Validate items
	if (options.itemValidator) {
		return value.map((item, index) => {
			try {
				return options.itemValidator?.(item, index);
			} catch (error) {
				if (error instanceof ValidationError) {
					throw new ValidationError(
						`${field}[${index}]: ${error.message}`,
						`${field}[${index}]`,
						item,
					);
				}
				throw error;
			}
		}) as T[];
	}

	return value as T[];
}

/**
 * Validates and sanitizes an object input
 */
export function validateObject<T extends Record<string, unknown>>(
	value: unknown,
	field: string,
	options: {
		required?: boolean;
		schema?: {
			[K in keyof T]: (value: unknown) => T[K];
		};
	} = {},
): T | undefined {
	// Handle undefined/null
	if (value === undefined || value === null) {
		if (options.required) {
			throw new ValidationError(`${field} is required`, field);
		}
		return undefined;
	}

	// Ensure it's an object
	if (typeof value !== "object" || Array.isArray(value)) {
		throw new ValidationError(`${field} must be an object`, field, value);
	}

	// Validate schema
	if (options.schema) {
		const result = {} as T;
		const obj = value as Record<string, unknown>;

		for (const [key, validator] of Object.entries(options.schema)) {
			try {
				result[key as keyof T] = validator(obj[key]);
			} catch (error) {
				if (error instanceof ValidationError) {
					throw new ValidationError(
						`${field}.${key}: ${error.message}`,
						`${field}.${key}`,
						obj[key],
					);
				}
				throw error;
			}
		}

		return result;
	}

	return value as T;
}

/**
 * Common string sanitizers
 */
export const sanitizers = {
	trim: (value: string) => value.trim(),
	lowercase: (value: string) => value.toLowerCase(),
	uppercase: (value: string) => value.toUpperCase(),
	removeWhitespace: (value: string) => value.replace(/\s+/g, ""),
	alphanumeric: (value: string) => value.replace(/[^a-zA-Z0-9]/g, ""),
	alphanumericWithSpaces: (value: string) =>
		value.replace(/[^a-zA-Z0-9\s]/g, ""),
	email: (value: string) => value.trim().toLowerCase(),
	url: (value: string) => {
		try {
			const parsed = new URL(value);
			return parsed.toString();
		} catch {
			throw new ValidationError("Invalid URL format", "url", value);
		}
	},
};

/**
 * Common validation patterns
 */
export const patterns = {
	email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
	uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
	alphanumeric: /^[a-zA-Z0-9]+$/,
	alphanumericWithSpaces: /^[a-zA-Z0-9\s]+$/,
	// Account name: alphanumeric with spaces, hyphens, underscores, plus @ and . for email addresses
	accountName: /^[a-zA-Z0-9\s\-_@.+]+$/,
	// Path pattern for API endpoints
	apiPath: /^\/v1\/[a-zA-Z0-9\-_/]*$/,
};

================
File: packages/core/src/errors.ts
================
/**
 * Custom error classes for standardized error handling across the application
 */

/**
 * Base error class for all application errors
 */
export abstract class AppError extends Error {
	public readonly timestamp: Date;
	public readonly context?: Record<string, unknown>;

	constructor(
		message: string,
		public readonly code: string,
		public readonly statusCode: number,
		context?: Record<string, unknown>,
	) {
		super(message);
		this.name = this.constructor.name;
		this.timestamp = new Date();
		this.context = context;
		Error.captureStackTrace(this, this.constructor);
	}

	toJSON() {
		return {
			name: this.name,
			message: this.message,
			code: this.code,
			statusCode: this.statusCode,
			timestamp: this.timestamp,
			context: this.context,
		};
	}
}

/**
 * Authentication and authorization errors
 */
export class AuthError extends AppError {
	constructor(message: string, context?: Record<string, unknown>) {
		super(message, "AUTH_ERROR", 401, context);
	}
}

export class TokenRefreshError extends AuthError {
	constructor(accountId: string, originalError?: Error) {
		super("Failed to refresh access token", {
			accountId,
			originalError: originalError?.message,
		});
	}
}

/**
 * Rate limiting errors
 */
export class RateLimitError extends AppError {
	constructor(
		public readonly accountId: string,
		public readonly resetTime: number,
		public readonly remaining?: number,
	) {
		super("Rate limit exceeded", "RATE_LIMIT_ERROR", 429, {
			accountId,
			resetTime,
			remaining,
		});
	}
}

/**
 * Validation errors
 */
export class ValidationError extends AppError {
	constructor(
		message: string,
		public readonly field?: string,
		public readonly value?: unknown,
	) {
		super(message, "VALIDATION_ERROR", 400, { field, value });
	}
}

/**
 * Provider errors
 */
export class ProviderError extends AppError {
	constructor(
		message: string,
		public readonly provider: string,
		statusCode = 502,
		context?: Record<string, unknown>,
	) {
		super(message, "PROVIDER_ERROR", statusCode, { provider, ...context });
	}
}

export class OAuthError extends ProviderError {
	constructor(
		message: string,
		provider: string,
		public readonly oauthCode?: string,
	) {
		super(message, provider, 400, { oauthCode });
	}
}

/**
 * Service unavailable errors
 */
export class ServiceUnavailableError extends AppError {
	constructor(
		message: string,
		public readonly service?: string,
	) {
		super(message, "SERVICE_UNAVAILABLE", 503, { service });
	}
}

/**
 * Type guards
 */
export function isAppError(error: unknown): error is AppError {
	return error instanceof AppError;
}

/**
 * Error logger that sanitizes sensitive data
 */
export function logError(
	error: unknown,
	logger: { error: (msg: string, ...args: unknown[]) => void },
): void {
	if (isAppError(error)) {
		// Sanitize sensitive context data
		const sanitizedContext = error.context
			? sanitizeErrorContext(error.context)
			: undefined;
		logger.error(`${error.name}: ${error.message}`, {
			code: error.code,
			statusCode: error.statusCode,
			context: sanitizedContext,
		});
	} else if (error instanceof Error) {
		logger.error(`Error: ${error.message}`, {
			name: error.name,
			stack: error.stack,
		});
	} else {
		logger.error("Unknown error", error);
	}
}

/**
 * Sanitize error context to remove sensitive data
 */
function sanitizeErrorContext(
	context: Record<string, unknown>,
): Record<string, unknown> {
	const sanitized: Record<string, unknown> = {};
	const sensitiveKeys = ["token", "password", "secret", "key", "authorization"];

	for (const [key, value] of Object.entries(context)) {
		const lowerKey = key.toLowerCase();
		if (sensitiveKeys.some((sensitive) => lowerKey.includes(sensitive))) {
			sanitized[key] = "[REDACTED]";
		} else if (typeof value === "object" && value !== null) {
			sanitized[key] = sanitizeErrorContext(value as Record<string, unknown>);
		} else {
			sanitized[key] = value;
		}
	}

	return sanitized;
}

================
File: packages/core/src/pricing.ts
================
import { promises as fs } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { TIME_CONSTANTS } from "./constants";
import { CLAUDE_MODEL_IDS, MODEL_DISPLAY_NAMES } from "./models";

export interface TokenBreakdown {
	inputTokens?: number;
	outputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
}

interface ModelCost {
	input: number;
	output: number;
	cache_read?: number;
	cache_write?: number;
}

interface ModelDef {
	id: string;
	name: string;
	cost?: ModelCost;
}

interface ApiResponse {
	[provider: string]: {
		models?: {
			[modelId: string]: ModelDef;
		};
	};
}

// Bundled fallback pricing for Anthropic models (dollars per 1M tokens)
const BUNDLED_PRICING: ApiResponse = {
	anthropic: {
		models: {
			[CLAUDE_MODEL_IDS.HAIKU_3_5]: {
				id: CLAUDE_MODEL_IDS.HAIKU_3_5,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.HAIKU_3_5],
				cost: {
					input: 0.8,
					output: 4,
					cache_read: 0.08,
					cache_write: 1,
				},
			},
			[CLAUDE_MODEL_IDS.SONNET_3_5]: {
				id: CLAUDE_MODEL_IDS.SONNET_3_5,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.SONNET_3_5],
				cost: {
					input: 3,
					output: 15,
					cache_read: 0.3,
					cache_write: 3.75,
				},
			},
			[CLAUDE_MODEL_IDS.SONNET_4]: {
				id: CLAUDE_MODEL_IDS.SONNET_4,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.SONNET_4],
				cost: {
					input: 3,
					output: 15,
					cache_read: 0.3,
					cache_write: 3.75,
				},
			},
			[CLAUDE_MODEL_IDS.OPUS_4]: {
				id: CLAUDE_MODEL_IDS.OPUS_4,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.OPUS_4],
				cost: {
					input: 15,
					output: 75,
					cache_read: 1.5,
					cache_write: 18.75,
				},
			},
			[CLAUDE_MODEL_IDS.OPUS_4_1]: {
				id: CLAUDE_MODEL_IDS.OPUS_4_1,
				name: MODEL_DISPLAY_NAMES[CLAUDE_MODEL_IDS.OPUS_4_1],
				cost: {
					input: 15,
					output: 75,
					cache_read: 1.5,
					cache_write: 18.75,
				},
			},
		},
	},
};

interface Logger {
	warn(message: string, ...args: unknown[]): void;
}

class PriceCatalogue {
	private static instance: PriceCatalogue;
	private priceData: ApiResponse | null = null;
	private lastFetch = 0;
	private warnedModels = new Set<string>();
	private logger: Logger | null = null;

	private constructor() {}

	setLogger(logger: Logger): void {
		this.logger = logger;
	}

	static get(): PriceCatalogue {
		if (!PriceCatalogue.instance) {
			PriceCatalogue.instance = new PriceCatalogue();
		}
		return PriceCatalogue.instance;
	}

	private getCacheDir(): string {
		return join(tmpdir(), "ccflare");
	}

	private getCachePath(): string {
		return join(this.getCacheDir(), "models.dev.json");
	}

	private getCacheDurationMs(): number {
		const hours = Number(process.env.CF_PRICING_REFRESH_HOURS) || 24;
		return hours * TIME_CONSTANTS.HOUR;
	}

	private async ensureCacheDir(): Promise<void> {
		try {
			await fs.mkdir(this.getCacheDir(), { recursive: true });
		} catch (error) {
			this.logger?.warn("Failed to create cache directory: %s", error);
		}
	}

	private async loadFromCache(): Promise<ApiResponse | null> {
		try {
			const cachePath = this.getCachePath();
			const stats = await fs.stat(cachePath);
			const age = Date.now() - stats.mtime.getTime();

			if (age < this.getCacheDurationMs()) {
				const content = await fs.readFile(cachePath, "utf-8");
				return JSON.parse(content);
			}
		} catch {
			// Cache miss or error - that's ok
		}
		return null;
	}

	private async saveToCache(data: ApiResponse): Promise<void> {
		try {
			await this.ensureCacheDir();
			const cachePath = this.getCachePath();
			await fs.writeFile(cachePath, JSON.stringify(data, null, 2));
		} catch (error) {
			this.logger?.warn("Failed to save pricing cache: %s", error);
		}
	}

	private async fetchRemote(): Promise<ApiResponse | null> {
		if (process.env.CF_PRICING_OFFLINE === "1") {
			return null;
		}

		try {
			const response = await fetch("https://models.dev/api.json");
			if (!response.ok) {
				throw new Error(`HTTP ${response.status}: ${response.statusText}`);
			}
			const data = await response.json();
			await this.saveToCache(data);
			return data;
		} catch (error) {
			this.logger?.warn("Failed to fetch pricing data: %s", error);
			return null;
		}
	}

	async getPricing(): Promise<ApiResponse> {
		// Return cached data if available
		if (
			this.priceData &&
			Date.now() - this.lastFetch < this.getCacheDurationMs()
		) {
			return this.priceData;
		}

		// Always attempt to fetch fresh pricing first (once per process start)
		let data = await this.fetchRemote();

		// If remote fetch failed (offline or error), fall back to disk cache
		if (!data) {
			data = await this.loadFromCache();
		}

		// Fall back to bundled pricing
		if (!data) {
			data = BUNDLED_PRICING;
		}

		this.priceData = data;
		this.lastFetch = Date.now();
		return data;
	}

	warnOnce(modelId: string): void {
		if (!this.warnedModels.has(modelId)) {
			this.warnedModels.add(modelId);
			this.logger?.warn(
				"Price for model %s not found - cost set to 0",
				modelId,
			);
		}
	}
}

/**
 * Set the logger for pricing warnings
 */
export function setPricingLogger(logger: Logger): void {
	PriceCatalogue.get().setLogger(logger);
}

/**
 * Get the cost rate for a specific model and token type
 * @returns Cost in dollars per token (NOT per million)
 * @throws If model or cost type is unknown
 */
async function getCostRate(
	modelId: string,
	kind: "input" | "output" | "cache_read" | "cache_write",
): Promise<number> {
	const catalogue = PriceCatalogue.get();
	const pricing = await catalogue.getPricing();

	// Search all providers for the model
	for (const provider of Object.values(pricing)) {
		if (provider.models?.[modelId]) {
			const model = provider.models[modelId];
			if (!model.cost) {
				throw new Error(`Model ${modelId} has no cost information`);
			}

			const costKey =
				kind === "cache_read" || kind === "cache_write"
					? kind
					: kind === "input"
						? "input"
						: "output";
			const costPerMillion = model.cost[costKey];

			if (costPerMillion === undefined) {
				throw new Error(`Model ${modelId} has no ${kind} cost`);
			}

			// Convert from per-million to per-token
			return costPerMillion / 1_000_000;
		}
	}

	throw new Error(`Model ${modelId} not found in pricing catalogue`);
}

/**
 * Estimate the total cost in USD for a request based on token counts
 * @returns Cost in dollars (NOT per million)
 */
export async function estimateCostUSD(
	modelId: string,
	tokens: TokenBreakdown,
): Promise<number> {
	const catalogue = PriceCatalogue.get();

	try {
		let totalCost = 0;

		if (tokens.inputTokens) {
			const rate = await getCostRate(modelId, "input");
			totalCost += tokens.inputTokens * rate;
		}

		if (tokens.outputTokens) {
			const rate = await getCostRate(modelId, "output");
			totalCost += tokens.outputTokens * rate;
		}

		if (tokens.cacheReadInputTokens) {
			const rate = await getCostRate(modelId, "cache_read");
			totalCost += tokens.cacheReadInputTokens * rate;
		}

		if (tokens.cacheCreationInputTokens) {
			const rate = await getCostRate(modelId, "cache_write");
			totalCost += tokens.cacheCreationInputTokens * rate;
		}

		return totalCost;
	} catch (_error) {
		catalogue.warnOnce(modelId);
		return 0;
	}
}

================
File: packages/core/src/lifecycle.ts
================
export interface Disposable {
	dispose(): Promise<void> | void;
}

class LifecycleManager {
	private disposables: Set<Disposable> = new Set();
	private isShuttingDown = false;

	register(disposable: Disposable): void {
		this.disposables.add(disposable);
	}

	unregister(disposable: Disposable): void {
		this.disposables.delete(disposable);
	}

	async shutdown(): Promise<void> {
		if (this.isShuttingDown) {
			return;
		}

		this.isShuttingDown = true;
		const errors: Error[] = [];

		// Dispose in reverse order of registration
		const disposableArray = Array.from(this.disposables).reverse();

		for (const disposable of disposableArray) {
			try {
				await disposable.dispose();
			} catch (error) {
				errors.push(
					error instanceof Error
						? error
						: new Error(`Disposal error: ${String(error)}`),
				);
			}
		}

		this.disposables.clear();
		this.isShuttingDown = false;

		if (errors.length > 0) {
			throw new AggregateError(errors, "Errors occurred during shutdown");
		}
	}

	clear(): void {
		this.disposables.clear();
		this.isShuttingDown = false;
	}
}

// Global lifecycle manager instance
const lifecycleManager = new LifecycleManager();

export function registerDisposable(disposable: Disposable): void {
	lifecycleManager.register(disposable);
}

export function unregisterDisposable(disposable: Disposable): void {
	lifecycleManager.unregister(disposable);
}

export async function shutdown(): Promise<void> {
	await lifecycleManager.shutdown();
}

export function clearDisposables(): void {
	lifecycleManager.clear();
}

================
File: packages/core/src/strategy.ts
================
import { type Account, StrategyName } from "@ccflare/types";

// Array of all strategies for backwards compatibility
export const STRATEGIES = Object.values(StrategyName);

export function isValidStrategy(strategy: string): strategy is StrategyName {
	return Object.values(StrategyName).includes(strategy as StrategyName);
}

// Default load balancing strategy
export const DEFAULT_STRATEGY = StrategyName.Session;

// Helper to check if an account is available (not rate-limited or paused)
export function isAccountAvailable(
	account: Account,
	now = Date.now(),
): boolean {
	return (
		!account.paused &&
		(!account.rate_limited_until || account.rate_limited_until < now)
	);
}

// Re-export from types package for backwards compatibility
export { StrategyName } from "@ccflare/types";

================
File: packages/core/src/constants.ts
================
/**
 * Centralized constants for the ccflare application
 * All magic numbers should be defined here to improve maintainability
 */

// Time constants (all in milliseconds)
export const TIME_CONSTANTS = {
	// Base units
	SECOND: 1000,
	MINUTE: 60 * 1000,
	HOUR: 60 * 60 * 1000,
	DAY: 24 * 60 * 60 * 1000,

	// Session durations
	SESSION_DURATION_DEFAULT: 5 * 60 * 60 * 1000, // 5 hours
	SESSION_DURATION_FALLBACK: 3600000, // 1 hour

	// Timeouts
	STREAM_TIMEOUT_DEFAULT: 1000 * 60 * 1, // 1 minute
	OAUTH_STATE_TTL: 10, // 10 minutes (stored separately as minutes)
	RETRY_DELAY_DEFAULT: 1000, // 1 second

	// Cache durations
	CACHE_YEAR: 31536000, // 365 days in seconds for HTTP cache headers
} as const;

// Buffer sizes (in bytes unless specified)
export const BUFFER_SIZES = {
	// Stream usage buffer size in KB (multiplied by 1024 to get bytes)
	STREAM_USAGE_BUFFER_KB: 64,
	STREAM_USAGE_BUFFER_BYTES: 64 * 1024,

	// Stream body max size
	STREAM_BODY_MAX_KB: 256,
	STREAM_BODY_MAX_BYTES: 256 * 1024, // 256KB default

	// Anthropic provider stream cap
	ANTHROPIC_STREAM_CAP_BYTES: 32768, // 32KB

	// Stream tee default max bytes
	STREAM_TEE_MAX_BYTES: 1024 * 1024, // 1MB

	// Log file size
	LOG_FILE_MAX_SIZE: 10 * 1024 * 1024, // 10MB
} as const;

// Network constants
export const NETWORK = {
	// Ports
	DEFAULT_PORT: 8080,

	// Timeouts
	IDLE_TIMEOUT_MAX: 255, // Max allowed by Bun
} as const;

// Cache control headers
export const CACHE = {
	// HTTP cache control max-age values (in seconds)
	STATIC_ASSETS_MAX_AGE: 31536000, // 1 year
	CACHE_CONTROL_IMMUTABLE: "public, max-age=31536000, immutable",
	CACHE_CONTROL_STATIC: "public, max-age=31536000",
	CACHE_CONTROL_NO_CACHE: "no-cache, no-store, must-revalidate",
} as const;

// Request/Response limits
export const LIMITS = {
	// Request history limits
	REQUEST_HISTORY_DEFAULT: 50,
	REQUEST_DETAILS_DEFAULT: 100,
	REQUEST_HISTORY_MAX: 1000,
	LOG_READ_DEFAULT: 1000,

	// Account name constraints
	ACCOUNT_NAME_MIN_LENGTH: 1,
	ACCOUNT_NAME_MAX_LENGTH: 100,

	// UI formatting
	CONSOLE_SEPARATOR_LENGTH: 100,
	CONSOLE_COLUMN_PADDING: {
		NAME: 20,
		TYPE: 10,
		TIER: 6,
		REQUESTS: 12,
		TOKEN: 10,
		STATUS: 20,
	},
} as const;

// HTTP status codes
export const HTTP_STATUS = {
	OK: 200,
	NOT_FOUND: 404,
	TOO_MANY_REQUESTS: 429,
	INTERNAL_SERVER_ERROR: 500,
	SERVICE_UNAVAILABLE: 503,
} as const;

// Account tiers - removed unused ACCOUNT_TIERS export
// Statistical calculations - removed unused STATS export

================
File: packages/core/src/index.ts
================
// Re-export only used items from each module
export {
	BUFFER_SIZES,
	CACHE,
	HTTP_STATUS,
	LIMITS,
	NETWORK,
	TIME_CONSTANTS,
} from "./constants";

export {
	logError,
	OAuthError,
	ProviderError,
	RateLimitError,
	ServiceUnavailableError,
	TokenRefreshError,
	ValidationError,
} from "./errors";

export * from "./lifecycle";
export {
	CLAUDE_MODEL_IDS,
	type ClaudeModelId,
	DEFAULT_AGENT_MODEL,
	DEFAULT_MODEL,
	getModelDisplayName,
	getModelShortName,
	isValidModelId,
	MODEL_DISPLAY_NAMES,
	MODEL_SHORT_NAMES,
} from "./models";
export {
	estimateCostUSD,
	setPricingLogger,
	type TokenBreakdown,
} from "./pricing";
export * from "./request-events";
export * from "./strategy";
export {
	patterns,
	sanitizers,
	validateNumber,
	validateString,
} from "./validation";

================
File: packages/core/src/models.ts
================
/**
 * Centralized model definitions and constants
 * All Claude model IDs and metadata should be defined here
 */

// Full model IDs as used by the Anthropic API
export const CLAUDE_MODEL_IDS = {
	// Claude 3.5 models
	HAIKU_3_5: "claude-3-5-haiku-20241022",
	SONNET_3_5: "claude-3-5-sonnet-20241022",

	// Claude 4 models
	SONNET_4: "claude-sonnet-4-20250514",
	OPUS_4: "claude-opus-4-20250514",
	OPUS_4_1: "claude-opus-4-1-20250805",

	// Legacy Claude 3 models (for documentation/API examples)
	OPUS_3: "claude-3-opus-20240229",
	SONNET_3: "claude-3-sonnet-20240229",
} as const;

// Model display names
export const MODEL_DISPLAY_NAMES: Record<string, string> = {
	[CLAUDE_MODEL_IDS.HAIKU_3_5]: "Claude Haiku 3.5",
	[CLAUDE_MODEL_IDS.SONNET_3_5]: "Claude Sonnet 3.5 v2",
	[CLAUDE_MODEL_IDS.SONNET_4]: "Claude Sonnet 4",
	[CLAUDE_MODEL_IDS.OPUS_4]: "Claude Opus 4",
	[CLAUDE_MODEL_IDS.OPUS_4_1]: "Claude Opus 4.1",
	[CLAUDE_MODEL_IDS.OPUS_3]: "Claude Opus 3",
	[CLAUDE_MODEL_IDS.SONNET_3]: "Claude Sonnet 3",
};

// Short model names used in UI (for color mapping, etc.)
export const MODEL_SHORT_NAMES: Record<string, string> = {
	[CLAUDE_MODEL_IDS.HAIKU_3_5]: "claude-3.5-haiku",
	[CLAUDE_MODEL_IDS.SONNET_3_5]: "claude-3.5-sonnet",
	[CLAUDE_MODEL_IDS.SONNET_4]: "claude-sonnet-4",
	[CLAUDE_MODEL_IDS.OPUS_4]: "claude-opus-4",
	[CLAUDE_MODEL_IDS.OPUS_4_1]: "claude-opus-4.1",
	[CLAUDE_MODEL_IDS.OPUS_3]: "claude-3-opus",
	[CLAUDE_MODEL_IDS.SONNET_3]: "claude-3-sonnet",
};

// Default model for various contexts
export const DEFAULT_MODEL = CLAUDE_MODEL_IDS.SONNET_4;
export const DEFAULT_AGENT_MODEL = CLAUDE_MODEL_IDS.SONNET_4;

// Type for all valid model IDs
export type ClaudeModelId =
	(typeof CLAUDE_MODEL_IDS)[keyof typeof CLAUDE_MODEL_IDS];

// Helper function to get short name from full model ID
export function getModelShortName(modelId: string): string {
	return MODEL_SHORT_NAMES[modelId] || modelId;
}

// Helper function to get display name from model ID
export function getModelDisplayName(modelId: string): string {
	return MODEL_DISPLAY_NAMES[modelId] || modelId;
}

// Helper function to validate if a string is a valid model ID
export function isValidModelId(modelId: string): modelId is ClaudeModelId {
	return Object.values(CLAUDE_MODEL_IDS).includes(modelId as ClaudeModelId);
}

================
File: packages/core/src/request-events.ts
================
import { EventEmitter } from "node:events";

export type RequestStartEvt = {
	type: "start";
	id: string;
	timestamp: number;
	method: string;
	path: string;
	accountId: string | null;
	statusCode: number;
	agentUsed: string | null;
};

export type RequestSummaryEvt = {
	type: "summary";
	payload: import("@ccflare/types").RequestResponse;
};

export type RequestPayloadEvt = {
	type: "payload";
	payload: import("@ccflare/types").RequestPayload;
};

export type RequestEvt =
	| RequestStartEvt
	| RequestSummaryEvt
	| RequestPayloadEvt;

class RequestEventBus extends EventEmitter {}
export const requestEvents = new RequestEventBus();

================
File: packages/logger/package.json
================
{
	"name": "@ccflare/logger",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}

================
File: packages/logger/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/logger/src/file-writer.ts
================
import { createWriteStream, existsSync, mkdirSync, statSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import {
	BUFFER_SIZES,
	type Disposable,
	LIMITS,
	registerDisposable,
} from "@ccflare/core";
import type { LogEvent } from "@ccflare/types";

export class LogFileWriter implements Disposable {
	private logDir: string;
	private logFile: string;
	private stream: ReturnType<typeof createWriteStream> | null = null;
	private maxFileSize = BUFFER_SIZES.LOG_FILE_MAX_SIZE;

	constructor() {
		// Create log directory in tmp folder
		this.logDir = join(tmpdir(), "ccflare-logs");
		if (!existsSync(this.logDir)) {
			mkdirSync(this.logDir, { recursive: true });
		}

		this.logFile = join(this.logDir, "app.log");
		this.initStream();
	}

	private initStream(): void {
		// Check if we need to rotate
		if (existsSync(this.logFile)) {
			const stats = statSync(this.logFile);
			if (stats.size > this.maxFileSize) {
				this.rotateLog();
			}
		}

		// Create write stream with append mode
		this.stream = createWriteStream(this.logFile, { flags: "a" });
	}

	private rotateLog(): void {
		if (this.stream) {
			this.stream.end();
		}

		// Simple rotation: just delete old log
		// In production, you might want to keep a few rotated files
		if (existsSync(this.logFile)) {
			// For now, just delete the old file
			// In a production system, you'd rename it to keep history
			try {
				require("node:fs").unlinkSync(this.logFile);
			} catch (_e) {
				console.error("Failed to rotate log:", _e);
			}
		}
	}

	write(event: LogEvent): void {
		if (!this.stream || this.stream.destroyed) {
			this.initStream();
		}

		const line = `${JSON.stringify(event)}\n`;
		if (this.stream) {
			this.stream.write(line);
		}
	}

	async readLogs(limit: number = LIMITS.LOG_READ_DEFAULT): Promise<LogEvent[]> {
		if (!existsSync(this.logFile)) {
			return [];
		}

		try {
			const content = await Bun.file(this.logFile).text();
			const lines = content.trim().split("\n").filter(Boolean);

			// Return the last N logs
			return lines
				.slice(-limit)
				.map((line) => {
					try {
						return JSON.parse(line);
					} catch {
						return null;
					}
				})
				.filter((log): log is LogEvent => log !== null);
		} catch (_e) {
			console.error("Failed to read logs:", _e);
			return [];
		}
	}

	close(): void {
		if (this.stream) {
			this.stream.end();
			this.stream = null;
		}
	}

	dispose(): void {
		this.close();
	}
}

// Singleton instance
export const logFileWriter = new LogFileWriter();

// Register with lifecycle manager
registerDisposable(logFileWriter);

================
File: packages/logger/src/index.ts
================
import { EventEmitter } from "node:events";
import type { LogEvent } from "@ccflare/types";
import { logFileWriter } from "./file-writer";

export enum LogLevel {
	DEBUG = 0,
	INFO = 1,
	WARN = 2,
	ERROR = 3,
}

export type LogFormat = "pretty" | "json";

// Event emitter for log streaming
export const logBus = new EventEmitter();

export class Logger {
	private level: LogLevel;
	private prefix: string;
	private format: LogFormat;
	private silentConsole: boolean;

	constructor(prefix: string = "", level: LogLevel = LogLevel.INFO) {
		this.prefix = prefix;
		this.level = this.getLogLevelFromEnv() || level;
		this.format = (process.env.LOG_FORMAT as LogFormat) || "pretty";
		// Only show console output in debug mode or if ccflare_DEBUG is set
		this.silentConsole = !(
			process.env.ccflare_DEBUG === "1" || this.level === LogLevel.DEBUG
		);
	}

	private getLogLevelFromEnv(): LogLevel | null {
		const envLevel = process.env.LOG_LEVEL?.toUpperCase();
		if (envLevel && envLevel in LogLevel) {
			return LogLevel[envLevel as keyof typeof LogLevel];
		}
		return null;
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
	private formatMessage(level: string, message: string, data?: any): string {
		const timestamp = new Date().toISOString();

		if (this.format === "json") {
			const logEntry = {
				ts: timestamp,
				level,
				prefix: this.prefix || undefined,
				msg: message,
				...(data && { data }),
			};
			return JSON.stringify(logEntry);
		} else {
			const prefix = this.prefix ? `[${this.prefix}] ` : "";
			const dataStr = data ? ` ${JSON.stringify(data)}` : "";
			return `[${timestamp}] ${level}: ${prefix}${message}${dataStr}`;
		}
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
	debug(message: string, data?: any): void {
		if (this.level <= LogLevel.DEBUG) {
			const msg = this.formatMessage("DEBUG", message, data);
			const event: LogEvent = {
				ts: Date.now(),
				level: "DEBUG",
				msg: message,
			};
			logBus.emit("log", event);
			logFileWriter.write(event);
			if (!this.silentConsole) console.log(msg);
		}
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
	info(message: string, data?: any): void {
		if (this.level <= LogLevel.INFO) {
			const msg = this.formatMessage("INFO", message, data);
			const event: LogEvent = {
				ts: Date.now(),
				level: "INFO",
				msg: message,
			};
			logBus.emit("log", event);
			logFileWriter.write(event);
			if (!this.silentConsole) console.log(msg);
		}
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any data type
	warn(message: string, data?: any): void {
		if (this.level <= LogLevel.WARN) {
			const msg = this.formatMessage("WARN", message, data);
			const event: LogEvent = {
				ts: Date.now(),
				level: "WARN",
				msg: message,
			};
			logBus.emit("log", event);
			logFileWriter.write(event);
			if (!this.silentConsole) console.warn(msg);
		}
	}

	// biome-ignore lint/suspicious/noExplicitAny: Logger needs to accept any error type
	error(message: string, error?: any): void {
		if (this.level <= LogLevel.ERROR) {
			const msg = this.formatMessage("ERROR", message, error);
			const event: LogEvent = {
				ts: Date.now(),
				level: "ERROR",
				msg: message,
			};
			logBus.emit("log", event);
			logFileWriter.write(event);
			if (!this.silentConsole) console.error(msg);
		}
	}

	setLevel(level: LogLevel): void {
		this.level = level;
		// Update silentConsole when level changes
		this.silentConsole = !(
			process.env.ccflare_DEBUG === "1" || this.level === LogLevel.DEBUG
		);
	}

	getLevel(): LogLevel {
		return this.level;
	}
}

// Default logger instance
export const log = new Logger();
export { logFileWriter } from "./file-writer";

================
File: packages/proxy/package.json
================
{
	"name": "@ccflare/proxy",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/agents": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/core": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/ui-common": "workspace:*",
		"@dqbd/tiktoken": "^1.0.21"
	}
}

================
File: packages/proxy/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/proxy/src/worker-messages.ts
================
/**
 * Unified message protocol for main thread <-> worker communication
 * Handles both streaming and non-streaming responses
 */

export interface StartMessage {
	type: "start";
	requestId: string;
	accountId: string | null;
	method: string;
	path: string;
	timestamp: number;

	// Request details
	requestHeaders: Record<string, string>;
	requestBody: string | null; // base64 encoded

	// Response details
	responseStatus: number;
	responseHeaders: Record<string, string>;
	isStream: boolean;

	// Provider info for rate limit parsing
	providerName: string;

	// Agent info
	agentUsed: string | null;

	// Retry info
	retryAttempt: number;
	failoverAttempts: number;
}

export interface ChunkMessage {
	type: "chunk";
	requestId: string;
	data: Uint8Array;
}

export interface EndMessage {
	type: "end";
	requestId: string;
	responseBody?: string | null; // base64 encoded, for non-streaming
	success: boolean;
	error?: string;
}

export interface ControlMessage {
	type: "shutdown";
}

export type WorkerMessage =
	| StartMessage
	| ChunkMessage
	| EndMessage
	| ControlMessage
	| SummaryMessage
	| PayloadMessage;

// Response from worker (if needed in future)
export interface WorkerResponse {
	type: "ack" | "error";
	requestId?: string;
	message?: string;
}

// Worker to main thread messages
export interface SummaryMessage {
	type: "summary";
	summary: import("@ccflare/types").RequestResponse;
}

export interface PayloadMessage {
	type: "payload";
	payload: import("@ccflare/types").RequestPayload;
}

export type OutgoingWorkerMessage = SummaryMessage | PayloadMessage;

================
File: packages/proxy/src/stream-tee.ts
================
import { BUFFER_SIZES } from "@ccflare/core";

/**
 * Tees a ReadableStream to capture data without blocking the original stream.
 * Allows buffering stream content for analytics while maintaining streaming performance.
 */
export function teeStream(
	upstream: ReadableStream<Uint8Array>,
	options: {
		onChunk?: (chunk: Uint8Array) => void;
		onClose?: (buffered: Uint8Array[]) => void;
		onError?: (error: Error) => void;
		maxBytes?: number; // Max bytes to buffer (default: 1MB)
	} = {},
): ReadableStream<Uint8Array> {
	const {
		onChunk,
		onClose,
		onError,
		maxBytes = BUFFER_SIZES.STREAM_TEE_MAX_BYTES,
	} = options;
	const reader = upstream.getReader();
	const buffered: Uint8Array[] = [];
	let totalBytes = 0;
	let truncated = false;

	return new ReadableStream({
		async pull(controller) {
			try {
				const { value, done } = await reader.read();

				if (done) {
					onClose?.(buffered);
					controller.close();
					return;
				}

				// Pass through to client immediately
				controller.enqueue(value);

				// Buffer for analytics if under limit
				if (!truncated && totalBytes + value.length <= maxBytes) {
					buffered.push(value);
					totalBytes += value.length;
				} else if (!truncated) {
					truncated = true;
					// Still buffer this chunk partially to reach exactly maxBytes
					const remaining = maxBytes - totalBytes;
					if (remaining > 0) {
						buffered.push(value.slice(0, remaining));
						totalBytes = maxBytes;
					}
				}

				// Notify chunk handler
				onChunk?.(value);
			} catch (error) {
				onError?.(error as Error);
				controller.error(error);
			}
		},

		cancel(reason) {
			return reader.cancel(reason);
		},
	});
}

/**
 * Combines buffered chunks into a single Buffer
 */
export function combineChunks(chunks: Uint8Array[]): Buffer {
	const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
	const combined = Buffer.allocUnsafe(totalLength);
	let offset = 0;

	for (const chunk of chunks) {
		combined.set(chunk, offset);
		offset += chunk.length;
	}

	return combined;
}

================
File: packages/proxy/src/types.ts
================
export interface ProxyRequest {
	method: string;
	path: string;
	headers: Headers;
	body: ArrayBuffer | null;
	query: string;
}

export interface ProxyResponse {
	status: number;
	statusText: string;
	headers: Headers;
	body: ReadableStream<Uint8Array> | string | null;
}

================
File: packages/proxy/src/constants.ts
================
// Token management constants
export const TOKEN_SAFETY_WINDOW_MS = 30_000; // 30 seconds - proactive refresh window
export const TOKEN_REFRESH_BACKOFF_MS = 60_000; // 60 seconds - backoff after refresh failure

================
File: packages/proxy/src/post-processor.worker.ts
================
declare var self: Worker;

import { BUFFER_SIZES, estimateCostUSD, TIME_CONSTANTS } from "@ccflare/core";
import { AsyncDbWriter, DatabaseOperations } from "@ccflare/database";
import { Logger } from "@ccflare/logger";
import {
	NO_ACCOUNT_ID,
	type RequestPayload,
	type RequestResponse,
} from "@ccflare/types";
import { formatCost } from "@ccflare/ui-common";
import { get_encoding } from "@dqbd/tiktoken";
import { combineChunks } from "./stream-tee";
import type {
	ChunkMessage,
	EndMessage,
	PayloadMessage,
	StartMessage,
	SummaryMessage,
	WorkerMessage,
} from "./worker-messages";

interface RequestState {
	startMessage: StartMessage;
	buffer: string;
	chunks: Uint8Array[];
	usage: {
		model?: string;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
		outputTokensComputed?: number;
		totalTokens?: number;
		costUsd?: number;
		tokensPerSecond?: number;
	};
	lastActivity: number;
	agentUsed?: string;
	firstTokenTimestamp?: number;
	lastTokenTimestamp?: number;
	providerFinalOutputTokens?: number;
	shouldSkipLogging?: boolean;
}

const log = new Logger("PostProcessor");
const requests = new Map<string, RequestState>();

// Initialize tiktoken encoder (cl100k_base is used for Claude models)
const tokenEncoder = get_encoding("cl100k_base");

// Initialize database connection for worker
const dbOps = new DatabaseOperations();
const asyncWriter = new AsyncDbWriter();

// Environment variables
const MAX_BUFFER_SIZE =
	Number(
		process.env.CF_STREAM_USAGE_BUFFER_KB ||
			BUFFER_SIZES.STREAM_USAGE_BUFFER_KB,
	) * 1024;
const TIMEOUT_MS = Number(
	process.env.CF_STREAM_TIMEOUT_MS || TIME_CONSTANTS.STREAM_TIMEOUT_DEFAULT,
);

// Check if a request should be logged
function shouldLogRequest(path: string, status: number): boolean {
	// Skip logging .well-known 404s
	if (path.startsWith("/.well-known/") && status === 404) {
		return false;
	}
	return true;
}

// Extract system prompt from request body
function _extractSystemPrompt(requestBody: string | null): string | null {
	if (!requestBody) return null;

	try {
		// Decode base64 request body
		const decodedBody = Buffer.from(requestBody, "base64").toString("utf-8");
		const parsed = JSON.parse(decodedBody);

		// Check if there's a system property in the request
		if (parsed.system) {
			// Handle both string and array formats
			if (typeof parsed.system === "string") {
				return parsed.system;
			} else if (Array.isArray(parsed.system)) {
				// Concatenate all text from system messages
				return parsed.system
					.filter(
						(item: { type?: string; text?: string }) =>
							item.type === "text" && item.text,
					)
					.map((item: { type?: string; text?: string }) => item.text)
					.join("\n");
			}
		}
	} catch (error) {
		log.debug("Failed to extract system prompt:", error);
	}

	return null;
}

// Parse SSE lines to extract usage (reuse existing logic)
function parseSSELine(line: string): { event?: string; data?: string } {
	if (line.startsWith("event: ")) {
		return { event: line.slice(7).trim() };
	}
	if (line.startsWith("data: ")) {
		return { data: line.slice(6).trim() };
	}
	return {};
}

// Extract usage data from non-stream JSON response bodies
function extractUsageFromJson(
	json: {
		model?: string;
		usage?: {
			input_tokens?: number;
			cache_read_input_tokens?: number;
			cache_creation_input_tokens?: number;
			output_tokens?: number;
		};
	},
	state: RequestState,
): void {
	if (!json) return;

	const usageObj = json.usage;
	if (!usageObj) return;

	state.usage.model = json.model ?? state.usage.model;

	state.usage.inputTokens = usageObj.input_tokens ?? 0;
	state.usage.cacheReadInputTokens = usageObj.cache_read_input_tokens ?? 0;
	state.usage.cacheCreationInputTokens =
		usageObj.cache_creation_input_tokens ?? 0;
	state.usage.outputTokens = usageObj.output_tokens ?? 0;

	// Calculate total tokens
	const prompt =
		(state.usage.inputTokens ?? 0) +
		(state.usage.cacheReadInputTokens ?? 0) +
		(state.usage.cacheCreationInputTokens ?? 0);
	const completion = state.usage.outputTokens ?? 0;
	state.usage.totalTokens = prompt + completion;
}

function extractUsageFromData(data: string, state: RequestState): void {
	try {
		const parsed = JSON.parse(data);

		// Handle message_start
		if (parsed.type === "message_start" && parsed.message?.usage) {
			const usage = parsed.message.usage;
			state.usage.inputTokens = usage.input_tokens || 0;
			state.usage.cacheReadInputTokens = usage.cache_read_input_tokens || 0;
			state.usage.cacheCreationInputTokens =
				usage.cache_creation_input_tokens || 0;
			state.usage.outputTokens = usage.output_tokens || 0;
			if (parsed.message?.model) {
				state.usage.model = parsed.message.model;
			}
		}

		// Track streaming start time on first content block
		if (parsed.type === "content_block_start" && !state.firstTokenTimestamp) {
			state.firstTokenTimestamp = Date.now();
		}

		// Handle message_delta - provider's authoritative output token count AND end time
		if (parsed.type === "message_delta") {
			state.lastTokenTimestamp = Date.now();

			if (parsed.usage?.output_tokens !== undefined) {
				state.providerFinalOutputTokens = parsed.usage.output_tokens;
				state.usage.outputTokens = parsed.usage.output_tokens;
				return; // No further processing needed
			}
		}

		// Count tokens locally as fallback (but provider's count takes precedence)
		if (
			parsed.type === "content_block_delta" &&
			parsed.delta &&
			state.providerFinalOutputTokens === undefined // Avoid double counting
		) {
			let textToCount: string | undefined;

			// Extract text from different delta types
			if (parsed.delta.type === "text_delta" && parsed.delta.text) {
				textToCount = parsed.delta.text;
			} else if (
				parsed.delta.type === "thinking_delta" &&
				parsed.delta.thinking
			) {
				textToCount = parsed.delta.thinking;
			}

			if (textToCount) {
				// Count tokens using tiktoken
				try {
					const tokens = tokenEncoder.encode(textToCount);
					state.usage.outputTokensComputed =
						(state.usage.outputTokensComputed || 0) + tokens.length;
				} catch (err) {
					log.debug("Failed to count tokens:", err);
				}
			}
		}

		// Handle any usage field in the data
		if (parsed.usage) {
			if (parsed.usage.input_tokens !== undefined) {
				state.usage.inputTokens = parsed.usage.input_tokens;
			}
			if (parsed.usage.output_tokens !== undefined) {
				state.usage.outputTokens = parsed.usage.output_tokens;
			}
			if (parsed.usage.cache_read_input_tokens !== undefined) {
				state.usage.cacheReadInputTokens = parsed.usage.cache_read_input_tokens;
			}
			if (parsed.usage.cache_creation_input_tokens !== undefined) {
				state.usage.cacheCreationInputTokens =
					parsed.usage.cache_creation_input_tokens;
			}
		}
	} catch {
		// Silent fail for non-JSON lines
	}
}

function processStreamChunk(chunk: Uint8Array, state: RequestState): void {
	const text = new TextDecoder().decode(chunk);
	state.buffer += text;
	state.lastActivity = Date.now();

	// Limit buffer size
	if (state.buffer.length > MAX_BUFFER_SIZE) {
		state.buffer = state.buffer.slice(-MAX_BUFFER_SIZE);
	}

	// Process complete lines
	const lines = state.buffer.split("\n");
	state.buffer = lines.pop() || "";

	let currentEvent = "";
	for (const line of lines) {
		const trimmed = line.trim();
		if (!trimmed) continue;

		const parsed = parseSSELine(trimmed);
		if (parsed.event) {
			currentEvent = parsed.event;
		} else if (parsed.data && currentEvent) {
			extractUsageFromData(parsed.data, state);
		}
	}
}

async function handleStart(msg: StartMessage): Promise<void> {
	// Check if we should skip logging this request
	const shouldSkip = !shouldLogRequest(msg.path, msg.responseStatus);

	// Create request state
	const state: RequestState = {
		startMessage: msg,
		buffer: "",
		chunks: [],
		usage: {},
		lastActivity: Date.now(),
		shouldSkipLogging: shouldSkip,
	};

	// Use agent from message if provided
	if (msg.agentUsed) {
		state.agentUsed = msg.agentUsed;
		log.debug(`Agent '${msg.agentUsed}' used for request ${msg.requestId}`);
	}

	requests.set(msg.requestId, state);

	// Skip all database operations for ignored requests
	if (shouldSkip) {
		log.debug(`Skipping logging for ${msg.path} (${msg.responseStatus})`);
		return;
	}

	// Save minimal request info immediately
	asyncWriter.enqueue(() =>
		dbOps.saveRequestMeta(
			msg.requestId,
			msg.method,
			msg.path,
			msg.accountId,
			msg.responseStatus,
			msg.timestamp,
		),
	);

	// Update account usage if authenticated
	if (msg.accountId && msg.accountId !== NO_ACCOUNT_ID) {
		const accountId = msg.accountId; // Capture for closure
		asyncWriter.enqueue(() => dbOps.updateAccountUsage(accountId));
	}
}

function handleChunk(msg: ChunkMessage): void {
	const state = requests.get(msg.requestId);
	if (!state) {
		log.warn(`No state found for request ${msg.requestId}`);
		return;
	}

	// Store chunk for later payload saving
	state.chunks.push(msg.data);

	// Process for usage extraction
	processStreamChunk(msg.data, state);
}

async function handleEnd(msg: EndMessage): Promise<void> {
	const state = requests.get(msg.requestId);
	if (!state) {
		log.warn(`No state found for request ${msg.requestId}`);
		return;
	}

	const { startMessage } = state;
	const responseTime = Date.now() - startMessage.timestamp;

	// Skip all database operations for ignored requests
	if (state.shouldSkipLogging) {
		// Clean up state without logging
		requests.delete(msg.requestId);
		return;
	}

	// For non-stream responses, extract usage data from response body
	if (!state.usage.model && msg.responseBody) {
		try {
			const decoded = Buffer.from(msg.responseBody, "base64").toString("utf-8");
			const json = JSON.parse(decoded);
			extractUsageFromJson(json, state);
		} catch {
			// Ignore parse errors
		}
	}

	// Calculate total tokens and cost
	if (state.usage.model) {
		// Use provider's authoritative count if available, fallback to computed
		const finalOutputTokens =
			state.providerFinalOutputTokens ??
			state.usage.outputTokens ??
			state.usage.outputTokensComputed ??
			0;

		// Update usage with final values
		state.usage.outputTokens = finalOutputTokens;
		state.usage.outputTokensComputed = undefined; // Clear to avoid confusion

		state.usage.totalTokens =
			(state.usage.inputTokens || 0) +
			finalOutputTokens +
			(state.usage.cacheReadInputTokens || 0) +
			(state.usage.cacheCreationInputTokens || 0);

		state.usage.costUsd = await estimateCostUSD(state.usage.model, {
			inputTokens: state.usage.inputTokens,
			outputTokens: finalOutputTokens,
			cacheReadInputTokens: state.usage.cacheReadInputTokens,
			cacheCreationInputTokens: state.usage.cacheCreationInputTokens,
		});

		// Calculate tokens per second using actual streaming duration
		if (
			state.firstTokenTimestamp &&
			state.lastTokenTimestamp &&
			finalOutputTokens > 0
		) {
			const durationSec =
				(state.lastTokenTimestamp - state.firstTokenTimestamp) / 1000;
			if (durationSec > 0) {
				state.usage.tokensPerSecond = finalOutputTokens / durationSec;
			} else if (finalOutputTokens > 0) {
				// If tokens were generated instantly, use a very small duration
				state.usage.tokensPerSecond = finalOutputTokens / 0.001;
			}
		}
	}

	// Update request with final data
	asyncWriter.enqueue(() =>
		dbOps.saveRequest(
			startMessage.requestId,
			startMessage.method,
			startMessage.path,
			startMessage.accountId,
			startMessage.responseStatus,
			msg.success,
			msg.error || null,
			responseTime,
			startMessage.failoverAttempts,
			state.usage.model
				? {
						model: state.usage.model,
						promptTokens:
							(state.usage.inputTokens || 0) +
							(state.usage.cacheReadInputTokens || 0) +
							(state.usage.cacheCreationInputTokens || 0),
						completionTokens: state.usage.outputTokens,
						totalTokens: state.usage.totalTokens,
						costUsd: state.usage.costUsd,
						// Keep original breakdown for payload
						inputTokens: state.usage.inputTokens,
						outputTokens: state.usage.outputTokens,
						cacheReadInputTokens: state.usage.cacheReadInputTokens,
						cacheCreationInputTokens: state.usage.cacheCreationInputTokens,
						tokensPerSecond: state.usage.tokensPerSecond,
					}
				: undefined,
			state.agentUsed,
		),
	);

	// Save payload
	let responseBody: string | null = null;

	if (msg.responseBody) {
		// Non-streaming response
		responseBody = msg.responseBody;
	} else if (state.chunks.length > 0) {
		// Streaming response - combine chunks
		const combined = combineChunks(state.chunks);
		if (combined.length > 0) {
			responseBody = combined.toString("base64");
		}
	}

	const payload = {
		request: {
			headers: startMessage.requestHeaders,
			body: startMessage.requestBody,
		},
		response: {
			status: startMessage.responseStatus,
			headers: startMessage.responseHeaders,
			body: responseBody,
		},
		meta: {
			accountId: startMessage.accountId || NO_ACCOUNT_ID,
			timestamp: startMessage.timestamp,
			success: msg.success,
			isStream: startMessage.isStream,
			retry: startMessage.retryAttempt,
		},
	};

	asyncWriter.enqueue(() =>
		dbOps.saveRequestPayload(startMessage.requestId, payload),
	);

	// Log if we have usage
	if (state.usage.model && startMessage.accountId !== NO_ACCOUNT_ID) {
		log.info(
			`Usage for request ${startMessage.requestId}: Model: ${state.usage.model}, ` +
				`Tokens: ${state.usage.totalTokens || 0}, Cost: ${formatCost(state.usage.costUsd)}`,
		);
	}

	// Post summary to main thread for real-time updates
	const summary: RequestResponse = {
		id: startMessage.requestId,
		timestamp: new Date(startMessage.timestamp).toISOString(),
		method: startMessage.method,
		path: startMessage.path,
		accountUsed: startMessage.accountId,
		statusCode: startMessage.responseStatus,
		success: msg.success,
		errorMessage: msg.error || null,
		responseTimeMs: responseTime,
		failoverAttempts: startMessage.failoverAttempts,
		model: state.usage.model,
		promptTokens: state.usage.inputTokens,
		completionTokens: state.usage.outputTokens,
		totalTokens: state.usage.totalTokens,
		inputTokens: state.usage.inputTokens,
		cacheReadInputTokens: state.usage.cacheReadInputTokens,
		cacheCreationInputTokens: state.usage.cacheCreationInputTokens,
		outputTokens: state.usage.outputTokens,
		costUsd: state.usage.costUsd,
		agentUsed: state.agentUsed,
		tokensPerSecond: state.usage.tokensPerSecond,
	};

	self.postMessage({
		type: "summary",
		summary,
	} satisfies SummaryMessage);

	// Post full payload to main thread
	const fullPayload: RequestPayload = {
		id: startMessage.requestId,
		request: {
			headers: startMessage.requestHeaders,
			body: startMessage.requestBody,
		},
		response: {
			status: startMessage.responseStatus,
			headers: startMessage.responseHeaders,
			body: responseBody,
		},
		error: msg.error,
		meta: {
			accountId: startMessage.accountId || NO_ACCOUNT_ID,
			timestamp: startMessage.timestamp,
			success: msg.success,
			retry: startMessage.retryAttempt,
			path: startMessage.path,
			method: startMessage.method,
			agentUsed: state.agentUsed,
		},
	};

	self.postMessage({
		type: "payload",
		payload: fullPayload,
	} satisfies PayloadMessage);

	// Clean up
	requests.delete(msg.requestId);
}

async function handleShutdown(): Promise<void> {
	log.info("Worker shutting down, flushing async writer...");
	await asyncWriter.dispose();
	dbOps.close();
	// Worker will be terminated by main thread
}

// Periodic cleanup of stale requests (safety net for orphaned requests)
// This should rarely trigger as the main app handles timeouts
setInterval(() => {
	const now = Date.now();
	for (const [id, state] of requests) {
		if (now - state.lastActivity > TIMEOUT_MS) {
			log.warn(
				`Request ${id} appears orphaned (no activity for ${TIMEOUT_MS}ms), cleaning up...`,
			);
			handleEnd({
				type: "end",
				requestId: id,
				success: false,
				error: "Request orphaned - no activity",
			});
		}
	}
}, TIMEOUT_MS); // Check every TIMEOUT_MS

// Message handler
self.onmessage = async (event: MessageEvent<WorkerMessage>) => {
	const msg = event.data;

	switch (msg.type) {
		case "start":
			await handleStart(msg);
			break;
		case "chunk":
			handleChunk(msg);
			break;
		case "end":
			await handleEnd(msg);
			break;
		case "shutdown":
			await handleShutdown();
			break;
		default:
			log.warn(`Unknown message type: ${(msg as { type: string }).type}`);
	}
};

================
File: packages/proxy/src/proxy.ts
================
import { requestEvents, ServiceUnavailableError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import {
	createRequestMetadata,
	ERROR_MESSAGES,
	interceptAndModifyRequest,
	type ProxyContext,
	prepareRequestBody,
	proxyUnauthenticated,
	proxyWithAccount,
	selectAccountsForRequest,
	TIMING,
	validateProviderPath,
} from "./handlers";
import type { ControlMessage, OutgoingWorkerMessage } from "./worker-messages";

export type { ProxyContext } from "./handlers";

const log = new Logger("Proxy");

// ===== WORKER MANAGEMENT =====

// Create usage worker instance
let usageWorkerInstance: Worker | null = null;

/**
 * Gets or creates the usage worker instance
 * @returns The usage worker instance
 */
export function getUsageWorker(): Worker {
	if (!usageWorkerInstance) {
		usageWorkerInstance = new Worker(
			new URL("./post-processor.worker.ts", import.meta.url).href,
			{ smol: true },
		);
		// Bun extends Worker with unref method
		if (
			"unref" in usageWorkerInstance &&
			typeof usageWorkerInstance.unref === "function"
		) {
			usageWorkerInstance.unref(); // Don't keep process alive
		}

		// Listen for summary messages from worker
		usageWorkerInstance.onmessage = (ev) => {
			const data = ev.data as OutgoingWorkerMessage;
			if (data.type === "summary") {
				requestEvents.emit("event", { type: "summary", payload: data.summary });
			} else if (data.type === "payload") {
				requestEvents.emit("event", { type: "payload", payload: data.payload });
			}
		};
	}
	return usageWorkerInstance;
}

/**
 * Gracefully terminates the usage worker
 */
export function terminateUsageWorker(): void {
	if (usageWorkerInstance) {
		// Send shutdown message to allow worker to flush
		const shutdownMsg: ControlMessage = { type: "shutdown" };
		usageWorkerInstance.postMessage(shutdownMsg);
		// Give worker time to flush before terminating
		setTimeout(() => {
			if (usageWorkerInstance) {
				usageWorkerInstance.terminate();
				usageWorkerInstance = null;
			}
		}, TIMING.WORKER_SHUTDOWN_DELAY);
	}
}

// ===== MAIN HANDLER =====

/**
 * Main proxy handler - orchestrates the entire proxy flow
 *
 * This function coordinates the proxy process by:
 * 1. Creating request metadata for tracking
 * 2. Validating the provider can handle the path
 * 3. Preparing the request body for reuse
 * 4. Selecting accounts based on load balancing strategy
 * 5. Attempting to proxy with each account in order
 * 6. Falling back to unauthenticated proxy if no accounts available
 *
 * @param req - The incoming request
 * @param url - The parsed URL
 * @param ctx - The proxy context containing strategy, database, and provider
 * @returns Promise resolving to the proxied response
 * @throws {ValidationError} If the provider cannot handle the path
 * @throws {ServiceUnavailableError} If all accounts fail to proxy the request
 * @throws {ProviderError} If unauthenticated proxy fails
 */
export async function handleProxy(
	req: Request,
	url: URL,
	ctx: ProxyContext,
): Promise<Response> {
	// 1. Validate provider can handle path
	validateProviderPath(ctx.provider, url.pathname);

	// 2. Prepare request body
	const { buffer: requestBodyBuffer } = await prepareRequestBody(req);

	// 3. Intercept and modify request for agent model preferences and system prompt
	const {
		modifiedBody,
		agentUsed,
		originalModel,
		appliedModel,
		systemPromptModified,
		toolsRemoved,
	} = await interceptAndModifyRequest(requestBodyBuffer, ctx.dbOps);

	// Use modified body if available
	const finalBodyBuffer = modifiedBody || requestBodyBuffer;
	const finalCreateBodyStream = () => {
		if (!finalBodyBuffer) return undefined;
		return new Response(finalBodyBuffer).body ?? undefined;
	};

	if (agentUsed && originalModel !== appliedModel) {
		log.info(
			`Agent ${agentUsed} detected, model changed from ${originalModel} to ${appliedModel}`,
		);
	}

	if (systemPromptModified) {
		log.info("System prompt intercepted and modified");
	}

	if (toolsRemoved) {
		log.info("Tools removed from request as per configuration");
	}

	// 4. Create request metadata with agent info
	const requestMeta = createRequestMetadata(req, url);
	requestMeta.agentUsed = agentUsed;

	// 5. Select accounts
	const accounts = selectAccountsForRequest(requestMeta, ctx);

	// 6. Handle no accounts case
	if (accounts.length === 0) {
		return proxyUnauthenticated(
			req,
			url,
			requestMeta,
			finalBodyBuffer,
			finalCreateBodyStream,
			ctx,
		);
	}

	// 7. Log selected accounts
	log.info(
		`Selected ${accounts.length} accounts: ${accounts.map((a) => a.name).join(", ")}`,
	);
	log.info(`Request: ${req.method} ${url.pathname}`);

	// 8. Try each account
	for (let i = 0; i < accounts.length; i++) {
		const response = await proxyWithAccount(
			req,
			url,
			accounts[i],
			requestMeta,
			finalBodyBuffer,
			finalCreateBodyStream,
			i,
			ctx,
		);

		if (response) {
			return response;
		}
	}

	// 9. All accounts failed
	throw new ServiceUnavailableError(
		`${ERROR_MESSAGES.ALL_ACCOUNTS_FAILED} (${accounts.length} attempted)`,
		ctx.provider.name,
	);
}

================
File: packages/proxy/src/index.ts
================
// Re-export provider-related types and functions from @ccflare/providers
export type {
	Provider,
	RateLimitInfo,
	TokenRefreshResult,
} from "@ccflare/providers";
export {
	getProvider,
	listProviders,
	registerProvider,
} from "@ccflare/providers";
export {
	getUsageWorker,
	handleProxy,
	type ProxyContext,
	terminateUsageWorker,
} from "./proxy";
export {
	forwardToClient,
	type ResponseHandlerOptions,
} from "./response-handler";
export type { ProxyRequest, ProxyResponse } from "./types";
export type {
	ChunkMessage,
	ControlMessage,
	EndMessage,
	StartMessage,
	WorkerMessage,
} from "./worker-messages";

================
File: packages/proxy/src/response-handler.ts
================
import { requestEvents } from "@ccflare/core";
import {
	sanitizeRequestHeaders,
	withSanitizedProxyHeaders,
} from "@ccflare/http-common";
import type { Account } from "@ccflare/types";
import type { ProxyContext } from "./handlers";
import type { ChunkMessage, EndMessage, StartMessage } from "./worker-messages";

/**
 * Check if a response should be considered successful/expected
 * Treats certain well-known paths that return 404 as expected
 */
function isExpectedResponse(path: string, response: Response): boolean {
	// Any .well-known path returning 404 is expected
	if (path.startsWith("/.well-known/") && response.status === 404) {
		return true;
	}

	// Otherwise use standard HTTP success logic
	return response.ok;
}

export interface ResponseHandlerOptions {
	requestId: string;
	method: string;
	path: string;
	account: Account | null;
	requestHeaders: Headers;
	requestBody: ArrayBuffer | null;
	response: Response;
	timestamp: number;
	retryAttempt: number;
	failoverAttempts: number;
	agentUsed?: string | null;
}

/**
 * Unified response handler that immediately streams responses
 * while forwarding data to worker for async processing
 */
// Forward response to client while streaming analytics to worker
export async function forwardToClient(
	options: ResponseHandlerOptions,
	ctx: ProxyContext,
): Promise<Response> {
	const {
		requestId,
		method,
		path,
		account,
		requestHeaders,
		requestBody,
		response: responseRaw,
		timestamp,
		retryAttempt, // Always 0 in new flow, but kept for message compatibility
		failoverAttempts,
		agentUsed,
	} = options;

	// Always strip compression headers *before* we do anything else
	const response = withSanitizedProxyHeaders(responseRaw);

	// Prepare objects once for serialisation - sanitize headers before storing
	const sanitizedReq = sanitizeRequestHeaders(requestHeaders);
	const requestHeadersObj = Object.fromEntries(sanitizedReq.entries());

	const responseHeadersObj = Object.fromEntries(response.headers.entries());

	const isStream = ctx.provider.isStreamingResponse?.(response) ?? false;

	// Send START message immediately
	const startMessage: StartMessage = {
		type: "start",
		requestId,
		accountId: account?.id || null,
		method,
		path,
		timestamp,
		requestHeaders: requestHeadersObj,
		requestBody: requestBody
			? Buffer.from(requestBody).toString("base64")
			: null,
		responseStatus: response.status,
		responseHeaders: responseHeadersObj,
		isStream,
		providerName: ctx.provider.name,
		agentUsed: agentUsed || null,
		retryAttempt,
		failoverAttempts,
	};
	ctx.usageWorker.postMessage(startMessage);

	// Emit request start event for real-time dashboard
	requestEvents.emit("event", {
		type: "start",
		id: requestId,
		timestamp,
		method,
		path,
		accountId: account?.id || null,
		statusCode: response.status,
		agentUsed: agentUsed || null,
	});

	/*********************************************************************
	 *  STREAMING RESPONSES — tee with Response.clone() and send chunks
	 *********************************************************************/
	if (isStream && response.body) {
		// Clone response once for background consumption.
		const analyticsClone = response.clone();

		(async () => {
			try {
				const reader = analyticsClone.body?.getReader();
				if (!reader) return; // Safety check
				// eslint-disable-next-line no-constant-condition
				while (true) {
					const { value, done } = await reader.read();
					if (done) break;
					if (value) {
						const chunkMsg: ChunkMessage = {
							type: "chunk",
							requestId,
							data: value,
						};
						ctx.usageWorker.postMessage(chunkMsg);
					}
				}
				// Finished without errors
				const endMsg: EndMessage = {
					type: "end",
					requestId,
					success: isExpectedResponse(path, analyticsClone),
				};
				ctx.usageWorker.postMessage(endMsg);
			} catch (err) {
				const endMsg: EndMessage = {
					type: "end",
					requestId,
					success: false,
					error: (err as Error).message,
				};
				ctx.usageWorker.postMessage(endMsg);
			}
		})();

		// Return the sanitized response
		return response;
	}

	/*********************************************************************
	 *  NON-STREAMING RESPONSES — read body in background, send END once
	 *********************************************************************/
	(async () => {
		try {
			const clone = response.clone();
			const bodyBuf = await clone.arrayBuffer();
			const endMsg: EndMessage = {
				type: "end",
				requestId,
				responseBody:
					bodyBuf.byteLength > 0
						? Buffer.from(bodyBuf).toString("base64")
						: null,
				success: isExpectedResponse(path, clone),
			};
			ctx.usageWorker.postMessage(endMsg);
		} catch (err) {
			const endMsg: EndMessage = {
				type: "end",
				requestId,
				success: false,
				error: (err as Error).message,
			};
			ctx.usageWorker.postMessage(endMsg);
		}
	})();

	// Return the sanitized response
	return response;
}

================
File: packages/proxy/src/handlers/agent-interceptor.ts
================
import { existsSync } from "node:fs";
import { join, resolve } from "node:path";
import { agentRegistry } from "@ccflare/agents";
import type { DatabaseOperations } from "@ccflare/database";
import { Logger } from "@ccflare/logger";
import type { Agent } from "@ccflare/types";

const log = new Logger("AgentInterceptor");

export interface AgentInterceptResult {
	modifiedBody: ArrayBuffer | null;
	agentUsed: string | null;
	originalModel: string | null;
	appliedModel: string | null;
	systemPromptModified?: boolean;
	toolsRemoved?: boolean;
}

/**
 * Detects agent usage, modifies the request body to use the preferred model,
 * and applies system prompt interception if configured
 * @param requestBodyBuffer - The buffered request body
 * @param dbOps - Database operations instance
 * @returns Modified request body and agent/system prompt modification information
 */
export async function interceptAndModifyRequest(
	requestBodyBuffer: ArrayBuffer | null,
	dbOps: DatabaseOperations,
): Promise<AgentInterceptResult> {
	// If no body, nothing to intercept
	if (!requestBodyBuffer) {
		return {
			modifiedBody: null,
			agentUsed: null,
			originalModel: null,
			appliedModel: null,
		};
	}

	try {
		// Parse the request body
		const bodyText = new TextDecoder().decode(requestBodyBuffer);
		const requestBody = JSON.parse(bodyText);

		// Extract original model
		const originalModel = requestBody.model || null;

		// Extract system prompt to detect agent usage
		const systemPrompt = extractSystemPrompt(requestBody);
		if (!systemPrompt) {
			// No system prompt, no agent detection possible
			log.info("No system prompt found in request");
			return {
				modifiedBody: requestBodyBuffer,
				agentUsed: null,
				originalModel,
				appliedModel: originalModel,
			};
		}

		// Register additional agent directories from system prompt
		log.info(`System prompt length: ${systemPrompt.length} chars`);
		if (systemPrompt.includes("CLAUDE.md")) {
			log.info("System prompt contains CLAUDE.md reference");

			// Look specifically for the Contents pattern
			if (systemPrompt.includes("Contents of")) {
				const contentsIndex = systemPrompt.indexOf("Contents of");
				const start = contentsIndex;
				const end = Math.min(systemPrompt.length, contentsIndex + 200);
				const sample = systemPrompt.substring(start, end);
				log.info(`Found 'Contents of' pattern: ${sample}`);
			} else {
				log.info("System prompt does NOT contain 'Contents of' pattern");
				// Show a sample of what we do have
				const claudeIndex = systemPrompt.indexOf("CLAUDE.md");
				const start = Math.max(0, claudeIndex - 50);
				const end = Math.min(systemPrompt.length, claudeIndex + 50);
				const sample = systemPrompt.substring(start, end);
				log.info(`Sample around CLAUDE.md: ...${sample}...`);
			}

			// Count all CLAUDE.md occurrences
			const matches = systemPrompt.match(/CLAUDE\.md/g);
			log.info(`Total CLAUDE.md occurrences: ${matches ? matches.length : 0}`);
		}

		const extraDirs = extractAgentDirectories(systemPrompt);
		log.info(
			`Found ${extraDirs.length} potential agent directories in system prompt`,
		);

		for (const dir of extraDirs) {
			log.info(`Checking potential workspace from agents directory: ${dir}`);
			// Extract workspace path from agents directory
			// Convert /path/to/project/.claude/agents to /path/to/project
			const workspacePath = dir.replace(/\/.claude\/agents$/, "");

			// Only register if the workspace exists
			if (existsSync(workspacePath)) {
				await agentRegistry.registerWorkspace(workspacePath);
				log.info(`Registered workspace: ${workspacePath}`);
			} else {
				log.info(`Workspace path does not exist: ${workspacePath}`);
			}
		}

		// Detect agent usage
		const agents = await agentRegistry.getAgents();
		const detectedAgent = agents.find((agent: Agent) =>
			systemPrompt.includes(agent.systemPrompt.trim()),
		);

		if (!detectedAgent) {
			// No agent detected, but still apply system prompt interception
			const systemPromptResult = applySystemPromptInterception(
				requestBody,
				dbOps,
			);

			// If system prompt was modified, create new buffer
			if (systemPromptResult.modified || systemPromptResult.toolsRemoved) {
				const modifiedBodyText = JSON.stringify(requestBody);
				const encodedData = new TextEncoder().encode(modifiedBodyText);
				const modifiedBody = new ArrayBuffer(encodedData.byteLength);
				new Uint8Array(modifiedBody).set(encodedData);

				return {
					modifiedBody,
					agentUsed: null,
					originalModel,
					appliedModel: originalModel,
					systemPromptModified: systemPromptResult.modified,
					toolsRemoved: systemPromptResult.toolsRemoved,
				};
			}

			return {
				modifiedBody: requestBodyBuffer,
				agentUsed: null,
				originalModel,
				appliedModel: originalModel,
			};
		}

		log.info(
			`Detected agent usage: ${detectedAgent.name} (${detectedAgent.id})`,
		);

		// Look up model preference
		const preference = dbOps.getAgentPreference(detectedAgent.id);
		const preferredModel = preference?.model || detectedAgent.model;

		// If the preferred model is the same as original, still check system prompt interception
		if (preferredModel === originalModel) {
			const systemPromptResult = applySystemPromptInterception(
				requestBody,
				dbOps,
			);

			// If system prompt was modified, create new buffer
			if (systemPromptResult.modified || systemPromptResult.toolsRemoved) {
				const modifiedBodyText = JSON.stringify(requestBody);
				const encodedData = new TextEncoder().encode(modifiedBodyText);
				const modifiedBody = new ArrayBuffer(encodedData.byteLength);
				new Uint8Array(modifiedBody).set(encodedData);

				return {
					modifiedBody,
					agentUsed: detectedAgent.id,
					originalModel,
					appliedModel: originalModel,
					systemPromptModified: systemPromptResult.modified,
					toolsRemoved: systemPromptResult.toolsRemoved,
				};
			}

			return {
				modifiedBody: requestBodyBuffer,
				agentUsed: detectedAgent.id,
				originalModel,
				appliedModel: originalModel,
			};
		}

		// Modify the request body with the preferred model
		log.info(`Modifying model from ${originalModel} to ${preferredModel}`);
		requestBody.model = preferredModel;

		// Apply system prompt interception
		const systemPromptResult = applySystemPromptInterception(
			requestBody,
			dbOps,
		);

		// Convert back to buffer
		const modifiedBodyText = JSON.stringify(requestBody);
		const encodedData = new TextEncoder().encode(modifiedBodyText);
		// Create a new ArrayBuffer to ensure compatibility
		const modifiedBody = new ArrayBuffer(encodedData.byteLength);
		new Uint8Array(modifiedBody).set(encodedData);

		return {
			modifiedBody,
			agentUsed: detectedAgent.id,
			originalModel,
			appliedModel: preferredModel,
			systemPromptModified: systemPromptResult.modified,
			toolsRemoved: systemPromptResult.toolsRemoved,
		};
	} catch (error) {
		log.error("Failed to intercept/modify request:", error);
		// On error, return original body unmodified
		return {
			modifiedBody: requestBodyBuffer,
			agentUsed: null,
			originalModel: null,
			appliedModel: null,
		};
	}
}

interface MessageContent {
	type?: string;
	text?: string;
}

interface Message {
	role?: string;
	content?: string | MessageContent[];
}

interface SystemMessage {
	type: string;
	text: string;
	cache_control?: {
		type: string;
	};
}

// Tool definition based on Anthropic API specification
interface Tool {
	type: string;
	name: string;
	description?: string;
	input_schema?: {
		type: string;
		properties?: Record<string, unknown>;
		required?: string[];
	};
}

interface RequestBody {
	messages?: Message[];
	model?: string;
	system?: string | SystemMessage[];
	tools?: Tool[];
}

/**
 * Extracts system prompt from request body
 * This will extract system messages and user messages that contain system-like content
 * @param requestBody - Parsed request body
 * @returns System prompt string or null
 */
function extractSystemPrompt(requestBody: RequestBody): string | null {
	const extractLog = new Logger("ExtractSystemPrompt");
	const allSystemContent: string[] = [];

	// First check for system field at root level (Claude Code pattern)
	if (requestBody.system) {
		extractLog.info("Found system field at root level");
		if (typeof requestBody.system === "string") {
			extractLog.info(
				`System field is string, length: ${requestBody.system.length}`,
			);
			allSystemContent.push(requestBody.system);
		}
		if (Array.isArray(requestBody.system)) {
			extractLog.info(
				`System field is array with ${requestBody.system.length} items`,
			);
			// Concatenate all text from system messages
			const systemText = requestBody.system
				.filter(
					(item): item is SystemMessage => item.type === "text" && !!item.text,
				)
				.map((item) => item.text)
				.join("\n");
			extractLog.info(`Extracted system text length: ${systemText.length}`);
			if (systemText) {
				allSystemContent.push(systemText);
			}
		}
	}

	// Then check messages array
	if (requestBody.messages && Array.isArray(requestBody.messages)) {
		extractLog.info(
			`Checking messages array with ${requestBody.messages.length} messages`,
		);

		// Look for system messages
		const systemMessage = requestBody.messages.find(
			(msg) => msg.role === "system",
		);

		if (systemMessage) {
			extractLog.info("Found system role message");
			if (typeof systemMessage.content === "string") {
				extractLog.info(
					`System message content is string, length: ${systemMessage.content.length}`,
				);
				allSystemContent.push(systemMessage.content);
			}
			if (Array.isArray(systemMessage.content)) {
				extractLog.info(
					`System message content is array with ${systemMessage.content.length} items`,
				);
				const systemText = systemMessage.content
					.filter(
						(item): item is MessageContent & { text: string } =>
							item.type === "text" && !!item.text,
					)
					.map((item) => item.text)
					.join("\n");
				extractLog.info(
					`Extracted system message text length: ${systemText.length}`,
				);
				if (systemText) {
					allSystemContent.push(systemText);
				}
			}
		} else {
			extractLog.info("No system role message found, checking user messages");
		}

		// Also check for system prompt in user messages
		const userMessage = requestBody.messages.find((msg) => msg.role === "user");

		if (userMessage && Array.isArray(userMessage.content)) {
			// Concatenate all text content from the user message
			const textContents = userMessage.content.filter(
				(item): item is MessageContent & { text: string } =>
					item.type === "text" && !!item.text,
			);

			extractLog.info(
				`Found ${textContents.length} text content items in user message`,
			);

			const allUserText = textContents.map((item) => item.text).join("\n");

			if (
				allUserText.includes("Contents of") &&
				allUserText.includes("CLAUDE.md")
			) {
				extractLog.info(
					"User message contains 'Contents of' and 'CLAUDE.md' - including in system prompt",
				);
				allSystemContent.push(allUserText);
			}
		} else if (userMessage && typeof userMessage.content === "string") {
			if (
				userMessage.content.includes("Contents of") &&
				userMessage.content.includes("CLAUDE.md")
			) {
				extractLog.info(
					"User message string contains 'Contents of' and 'CLAUDE.md' - including in system prompt",
				);
				allSystemContent.push(userMessage.content);
			}
		}
	}

	// Combine all system content
	if (allSystemContent.length > 0) {
		const combined = allSystemContent.join("\n\n");
		extractLog.info(
			`Combined system prompt length: ${combined.length} from ${allSystemContent.length} sources`,
		);
		return combined;
	}

	return null;
}

/**
 * Extracts agent directories from system prompt
 * @param systemPrompt - The system prompt text
 * @returns Array of agent directory paths
 */
function extractAgentDirectories(systemPrompt: string): string[] {
	const extractDirLog = new Logger("ExtractAgentDirs");
	const directories = new Set<string>();

	// Regex #1: Look for explicit /.claude/agents paths
	const agentPathRegex = /([\\/][\w\-. ]*?\/.claude\/agents)(?=[\s"'\]])/g;
	let match: RegExpExecArray | null;

	match = agentPathRegex.exec(systemPrompt);
	while (match !== null) {
		const dir = resolve(match[1]);
		directories.add(dir);
		match = agentPathRegex.exec(systemPrompt);
	}

	// Regex #2: Look for repo root pattern "Contents of (.*?)/CLAUDE.md"
	const repoRootRegex = /Contents of ([^\n]+?)\/CLAUDE\.md/g;

	let matchCount = 0;
	match = repoRootRegex.exec(systemPrompt);
	while (match !== null) {
		matchCount++;
		const repoRoot = match[1];
		extractDirLog.info(
			`Found CLAUDE.md path match ${matchCount}: "${match[0]}"`,
		);
		extractDirLog.info(`Extracted repo root: "${repoRoot}"`);

		// Clean up any escaped slashes
		const cleanedRoot = repoRoot.replace(/\\\//g, "/");
		const agentsDir = join(cleanedRoot, ".claude", "agents");
		const resolvedDir = resolve(agentsDir);

		extractDirLog.info(`Resolved agents dir: "${resolvedDir}"`);
		directories.add(resolvedDir);
		match = repoRootRegex.exec(systemPrompt);
	}

	if (matchCount === 0 && systemPrompt.includes("CLAUDE.md")) {
		extractDirLog.info(
			"No CLAUDE.md path matches found despite CLAUDE.md being in prompt",
		);
	}

	return Array.from(directories);
}

/**
 * Type guard to check if a system array element is a SystemMessage with text
 */
function isSystemMessageWithText(
	item: unknown,
): item is SystemMessage & { text: string } {
	return (
		typeof item === "object" &&
		item !== null &&
		"type" in item &&
		"text" in item &&
		typeof (item as SystemMessage).text === "string"
	);
}

/**
 * Applies system prompt interception if configured.
 *
 * This function extends the agent interceptor to provide template-based system prompt
 * replacement. It was implemented here rather than as a separate handler to maintain
 * cleaner architecture and ensure both features work together seamlessly.
 *
 * Note: This function is synchronous as dbOps.getInterceptorConfig is synchronous.
 *
 * @param requestBody - The parsed request body
 * @param dbOps - Database operations instance
 * @returns Object indicating if modifications were made
 */
function applySystemPromptInterception(
	requestBody: RequestBody,
	dbOps: DatabaseOperations,
): { modified: boolean; toolsRemoved: boolean } {
	const interceptLog = new Logger("SystemPromptInterceptor");

	try {
		// Early check: Fetch interceptor configuration before any processing
		const interceptorConfig = dbOps.getInterceptorConfig("system_prompt");

		// If not enabled or config missing, return unchanged
		if (!interceptorConfig || !interceptorConfig.isEnabled) {
			interceptLog.info("System prompt interceptor is not enabled");
			return { modified: false, toolsRemoved: false };
		}

		interceptLog.info("System prompt interceptor is enabled");

		// Check if this is a main agent request
		if (!Array.isArray(requestBody.system)) {
			interceptLog.info("System field is not an array, skipping interception");
			return { modified: false, toolsRemoved: false };
		}

		// Check first system message for main agent identification with type guard
		const firstSystemMessage = requestBody.system[0];
		if (!isSystemMessageWithText(firstSystemMessage)) {
			interceptLog.info(
				"First system message is not in expected format, skipping interception",
			);
			return { modified: false, toolsRemoved: false };
		}
		const firstSystemText = firstSystemMessage.text;

		// Check if it's the main Claude Code agent (not a subagent)
		const isMainAgent = firstSystemText.includes(
			"You are Claude Code, Anthropic's official CLI for Claude.",
		);
		const isSubAgent = firstSystemText.includes(
			"You are an agent for Claude Code",
		);

		if (!isMainAgent || isSubAgent) {
			interceptLog.info(
				`Not a main agent request (isMainAgent: ${isMainAgent}, isSubAgent: ${isSubAgent}), skipping interception`,
			);
			return { modified: false, toolsRemoved: false };
		}

		interceptLog.info(
			"Detected main agent request, applying system prompt interception",
		);

		// Extract the second system message (contains env block and other dynamic content)
		const secondSystemMessage = requestBody.system[1];
		if (!isSystemMessageWithText(secondSystemMessage)) {
			interceptLog.info(
				"Second system message is not in expected format, skipping interception",
			);
			return { modified: false, toolsRemoved: false };
		}

		// Capture the original system prompt before any modifications
		const originalPrompt = secondSystemMessage.text;

		// Update last-seen prompt in next tick (truly non-blocking)
		setImmediate(() => {
			_updateLastSeenPrompt(originalPrompt, dbOps);
		});

		// Extract the <env> block(s) from the original system prompt
		// Using global regex to find all env blocks
		const envBlockRegex = /<env>([\s\S]*?)<\/env>/g;
		const envBlocks = secondSystemMessage.text.match(envBlockRegex) || [];

		let envBlock = "";
		if (envBlocks.length === 0) {
			interceptLog.warn(
				"No env block found in system prompt, using empty string",
			);
		} else if (envBlocks.length === 1) {
			envBlock = envBlocks[0];
			interceptLog.info(`Extracted env block (${envBlock.length} chars)`);
		} else {
			// Multiple env blocks found - concatenate them
			envBlock = envBlocks.join("\n");
			interceptLog.warn(
				`Found ${envBlocks.length} env blocks, concatenating them (${envBlock.length} chars total)`,
			);
		}

		// Validate and apply the template
		const { targetPrompt, replacementPrompt, toolsEnabled } =
			interceptorConfig.config;

		// Validate replacementPrompt is a non-empty string
		if (!replacementPrompt || typeof replacementPrompt !== "string") {
			interceptLog.error(
				"Invalid replacementPrompt in config, skipping interception",
			);
			return { modified: false, toolsRemoved: false };
		}

		// Check if the current prompt matches the target (simplified check - could be enhanced)
		// For now, we'll always apply the replacement if the interceptor is enabled
		// Future enhancement: actually compare originalPrompt with targetPrompt

		// Validate template has the placeholder
		if (!replacementPrompt.includes("{{env_block}}")) {
			interceptLog.warn(
				"Replacement prompt missing {{env_block}} placeholder, env data may be lost",
			);
		}

		// Apply template with all occurrences replaced
		const newPrompt = replacementPrompt.replace(/\{\{env_block\}\}/g, envBlock);

		// Verify replacement actually happened
		if (newPrompt === replacementPrompt && envBlock) {
			interceptLog.warn(
				"Template replacement may have failed - prompt unchanged despite env block present",
			);
		}

		// Update the second system message
		secondSystemMessage.text = newPrompt;

		interceptLog.info(
			`Applied replacement prompt, new prompt length: ${newPrompt.length} chars`,
		);

		// Handle tools toggle
		let toolsRemoved = false;
		if (!toolsEnabled && requestBody.tools !== undefined) {
			const toolCount = requestBody.tools.length;
			delete requestBody.tools;
			toolsRemoved = true;
			interceptLog.info(
				`Removed ${toolCount} tools from request as per configuration`,
			);
		}

		return { modified: true, toolsRemoved };
	} catch (error) {
		interceptLog.error("Failed to apply system prompt interception:", error);
		return { modified: false, toolsRemoved: false };
	}
}

/**
 * Updates the last-seen system prompt in the database if it has changed.
 * This is a non-critical synchronous operation that logs errors but doesn't throw.
 * Should be called via setImmediate to avoid blocking the request.
 *
 * @param prompt - The original system prompt to store
 * @param dbOps - Database operations instance
 */
function _updateLastSeenPrompt(
	prompt: string,
	dbOps: DatabaseOperations,
): void {
	const updateLog = new Logger("UpdateLastSeenPrompt");

	try {
		const lastSeen = dbOps.getSystemKV("last_seen_system_prompt");

		// Only update if the prompt has changed
		if (prompt !== lastSeen) {
			dbOps.setSystemKV("last_seen_system_prompt", prompt);
			updateLog.info("Updated last-seen system prompt in database");
		} else {
			updateLog.info("System prompt unchanged, skipping database update");
		}
	} catch (error) {
		// Log error but don't throw - this is a non-critical background operation
		updateLog.error("Failed to update last-seen system prompt:", error);
	}
}

================
File: packages/proxy/src/handlers/request-handler.ts
================
import crypto from "node:crypto";
import { ValidationError } from "@ccflare/core";
import type { Provider } from "@ccflare/providers";
import type { RequestMeta } from "@ccflare/types";
import { ERROR_MESSAGES } from "./proxy-types";

/**
 * Creates request metadata for tracking and analytics
 * @param req - The incoming request
 * @param url - The parsed URL
 * @returns Request metadata object
 */
export function createRequestMetadata(req: Request, url: URL): RequestMeta {
	return {
		id: crypto.randomUUID(),
		method: req.method,
		path: url.pathname,
		timestamp: Date.now(),
	};
}

/**
 * Validates that the provider can handle the requested path
 * @param provider - The provider instance
 * @param pathname - The request path
 * @throws {ValidationError} If provider cannot handle the path
 */
export function validateProviderPath(
	provider: Provider,
	pathname: string,
): void {
	if (!provider.canHandle(pathname)) {
		throw new ValidationError(
			`${ERROR_MESSAGES.PROVIDER_CANNOT_HANDLE}: ${pathname}`,
			"path",
			pathname,
		);
	}
}

/**
 * Prepares request body for analytics and creates body stream factory
 * @param req - The incoming request
 * @returns Object containing the buffered body and stream factory
 */
export async function prepareRequestBody(req: Request): Promise<{
	buffer: ArrayBuffer | null;
	createStream: () => ReadableStream<Uint8Array> | undefined;
}> {
	let buffer: ArrayBuffer | null = null;

	if (req.body) {
		buffer = await req.arrayBuffer();
	}

	return {
		buffer,
		createStream: () => {
			if (!buffer) return undefined;
			return new Response(buffer).body ?? undefined;
		},
	};
}

/**
 * Makes the actual HTTP request to the provider
 * @param targetUrl - The target URL to fetch
 * @param method - HTTP method
 * @param headers - Request headers
 * @param createBodyStream - Function to create request body stream
 * @param hasBody - Whether the request has a body
 * @returns Promise resolving to the response
 */
export async function makeProxyRequest(
	targetUrl: string,
	method: string,
	headers: Headers,
	createBodyStream: () => ReadableStream<Uint8Array> | undefined,
	hasBody: boolean,
): Promise<Response> {
	return fetch(targetUrl, {
		method,
		headers,
		body: createBodyStream(),
		...(hasBody ? ({ duplex: "half" } as RequestInit) : {}),
	});
}

================
File: packages/proxy/src/handlers/response-processor.ts
================
import { logError, RateLimitError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type { Provider } from "@ccflare/providers";
import type { Account } from "@ccflare/types";
import type { ProxyContext } from "./proxy-types";

const log = new Logger("ResponseProcessor");

/**
 * Handles rate limit response for an account
 * @param account - The rate-limited account
 * @param rateLimitInfo - Parsed rate limit information
 * @param ctx - The proxy context
 */
export function handleRateLimitResponse(
	account: Account,
	rateLimitInfo: ReturnType<Provider["parseRateLimit"]>,
	ctx: ProxyContext,
): void {
	if (!rateLimitInfo.resetTime) return;

	log.warn(
		`Account ${account.name} rate-limited until ${new Date(
			rateLimitInfo.resetTime,
		).toISOString()}`,
	);

	const resetTime = rateLimitInfo.resetTime;
	ctx.asyncWriter.enqueue(() =>
		ctx.dbOps.markAccountRateLimited(account.id, resetTime),
	);

	const rateLimitError = new RateLimitError(
		account.id,
		rateLimitInfo.resetTime,
		rateLimitInfo.remaining,
	);
	logError(rateLimitError, log);
}

/**
 * Updates account metadata in the background
 * @param account - The account to update
 * @param response - The response to extract metadata from
 * @param ctx - The proxy context
 */
export function updateAccountMetadata(
	account: Account,
	response: Response,
	ctx: ProxyContext,
): void {
	// Update basic usage
	ctx.asyncWriter.enqueue(() => ctx.dbOps.updateAccountUsage(account.id));

	// Extract and update rate limit info for every response
	const rateLimitInfo = ctx.provider.parseRateLimit(response);
	// Only update rate limit metadata when we have actual rate limit headers
	if (rateLimitInfo.statusHeader) {
		const status = rateLimitInfo.statusHeader;
		ctx.asyncWriter.enqueue(() =>
			ctx.dbOps.updateAccountRateLimitMeta(
				account.id,
				status,
				rateLimitInfo.resetTime ?? null,
				rateLimitInfo.remaining,
			),
		);
	}

	// Extract tier info if supported
	if (ctx.provider.extractTierInfo) {
		const extractTierInfo = ctx.provider.extractTierInfo.bind(ctx.provider);
		(async () => {
			const tier = await extractTierInfo(response.clone() as Response);
			if (tier && tier !== account.account_tier) {
				log.info(
					`Updating account ${account.name} tier from ${account.account_tier} to ${tier}`,
				);
				ctx.asyncWriter.enqueue(() =>
					ctx.dbOps.updateAccountTier(account.id, tier),
				);
			}
		})();
	}
}

/**
 * Processes a successful proxy response
 * @param response - The provider response
 * @param account - The account used
 * @param ctx - The proxy context
 * @returns Whether the response is rate-limited
 */
export function processProxyResponse(
	response: Response,
	account: Account,
	ctx: ProxyContext,
): boolean {
	const isStream = ctx.provider.isStreamingResponse?.(response) ?? false;
	const rateLimitInfo = ctx.provider.parseRateLimit(response);

	// Handle rate limit
	if (!isStream && rateLimitInfo.isRateLimited && rateLimitInfo.resetTime) {
		handleRateLimitResponse(account, rateLimitInfo, ctx);
		// Also update metadata for rate-limited responses
		updateAccountMetadata(account, response, ctx);
		return true; // Signal rate limit
	}

	// Update account metadata in background
	updateAccountMetadata(account, response, ctx);
	return false;
}

/**
 * Handles errors that occur during proxy operations
 * @param error - The error that occurred
 * @param account - The account that failed (optional)
 * @param logger - Logger instance
 */
export function handleProxyError(
	error: unknown,
	account: Account | null,
	logger: Logger,
): void {
	logError(error, logger);
	if (account) {
		logger.error(`Failed to proxy request with account ${account.name}`);
	} else {
		logger.error("Failed to proxy request");
	}
}

================
File: packages/proxy/src/handlers/proxy-types.ts
================
import type { RuntimeConfig } from "@ccflare/config";
import type { AsyncDbWriter, DatabaseOperations } from "@ccflare/database";
import type { Provider } from "@ccflare/providers";
import type { LoadBalancingStrategy } from "@ccflare/types";

export interface ProxyContext {
	strategy: LoadBalancingStrategy;
	dbOps: DatabaseOperations;
	runtime: RuntimeConfig;
	provider: Provider;
	refreshInFlight: Map<string, Promise<string>>;
	asyncWriter: AsyncDbWriter;
	usageWorker: Worker;
}

/** Error messages used throughout the proxy module */
export const ERROR_MESSAGES = {
	NO_ACCOUNTS:
		"No active accounts available - forwarding request without authentication",
	PROVIDER_CANNOT_HANDLE: "Provider cannot handle path",
	REFRESH_NOT_FOUND: "Refresh promise not found for account",
	UNAUTHENTICATED_FAILED: "Failed to forward unauthenticated request",
	ALL_ACCOUNTS_FAILED: "All accounts failed to proxy the request",
	TOKEN_REFRESH_FAILED: "Failed to refresh access token",
	PROXY_REQUEST_FAILED: "Failed to proxy request with account",
} as const;

/** Timing constants */
export const TIMING = {
	WORKER_SHUTDOWN_DELAY: 100, // ms
} as const;

/** HTTP headers used in proxy operations */
export const HEADERS = {
	CONTENT_TYPE: "Content-Type",
	AUTHORIZATION: "Authorization",
} as const;

================
File: packages/proxy/src/handlers/proxy-operations.ts
================
import { logError, ProviderError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type { Account, RequestMeta } from "@ccflare/types";
import { forwardToClient } from "../response-handler";
import { ERROR_MESSAGES, type ProxyContext } from "./proxy-types";
import { makeProxyRequest } from "./request-handler";
import { handleProxyError, processProxyResponse } from "./response-processor";
import { getValidAccessToken } from "./token-manager";

const log = new Logger("ProxyOperations");

/**
 * Handles proxy request without authentication
 * @param req - The incoming request
 * @param url - The parsed URL
 * @param requestMeta - Request metadata
 * @param requestBodyBuffer - Buffered request body
 * @param createBodyStream - Function to create body stream
 * @param ctx - The proxy context
 * @returns Promise resolving to the response
 * @throws {ProviderError} If the unauthenticated request fails
 */
export async function proxyUnauthenticated(
	req: Request,
	url: URL,
	requestMeta: RequestMeta,
	requestBodyBuffer: ArrayBuffer | null,
	createBodyStream: () => ReadableStream<Uint8Array> | undefined,
	ctx: ProxyContext,
): Promise<Response> {
	log.warn(ERROR_MESSAGES.NO_ACCOUNTS);

	const targetUrl = ctx.provider.buildUrl(url.pathname, url.search);
	const headers = ctx.provider.prepareHeaders(
		req.headers,
		undefined,
		undefined,
	);

	try {
		const response = await makeProxyRequest(
			targetUrl,
			req.method,
			headers,
			createBodyStream,
			!!req.body,
		);

		return forwardToClient(
			{
				requestId: requestMeta.id,
				method: req.method,
				path: url.pathname,
				account: null,
				requestHeaders: req.headers,
				requestBody: requestBodyBuffer,
				response,
				timestamp: requestMeta.timestamp,
				retryAttempt: 0,
				failoverAttempts: 0,
				agentUsed: requestMeta.agentUsed,
			},
			ctx,
		);
	} catch (error) {
		logError(error, log);
		throw new ProviderError(
			ERROR_MESSAGES.UNAUTHENTICATED_FAILED,
			ctx.provider.name,
			502,
			{
				originalError: error instanceof Error ? error.message : String(error),
			},
		);
	}
}

/**
 * Attempts to proxy a request with a specific account
 * @param req - The incoming request
 * @param url - The parsed URL
 * @param account - The account to use
 * @param requestMeta - Request metadata
 * @param requestBodyBuffer - Buffered request body
 * @param createBodyStream - Function to create body stream
 * @param failoverAttempts - Number of failover attempts
 * @param ctx - The proxy context
 * @returns Promise resolving to response or null if failed
 */
export async function proxyWithAccount(
	req: Request,
	url: URL,
	account: Account,
	requestMeta: RequestMeta,
	requestBodyBuffer: ArrayBuffer | null,
	createBodyStream: () => ReadableStream<Uint8Array> | undefined,
	failoverAttempts: number,
	ctx: ProxyContext,
): Promise<Response | null> {
	try {
		log.info(`Attempting request with account: ${account.name}`);

		// Get valid access token
		const accessToken = await getValidAccessToken(account, ctx);

		// Prepare request
		const headers = ctx.provider.prepareHeaders(
			req.headers,
			accessToken,
			account.api_key || undefined,
		);
		const targetUrl = ctx.provider.buildUrl(url.pathname, url.search);

		// Make the request
		const response = await makeProxyRequest(
			targetUrl,
			req.method,
			headers,
			createBodyStream,
			!!req.body,
		);

		// Process response and check for rate limit
		const isRateLimited = processProxyResponse(response, account, ctx);
		if (isRateLimited) {
			return null; // Signal to try next account
		}

		// Forward response to client
		return forwardToClient(
			{
				requestId: requestMeta.id,
				method: req.method,
				path: url.pathname,
				account,
				requestHeaders: req.headers,
				requestBody: requestBodyBuffer,
				response,
				timestamp: requestMeta.timestamp,
				retryAttempt: 0,
				failoverAttempts,
				agentUsed: requestMeta.agentUsed,
			},
			ctx,
		);
	} catch (err) {
		handleProxyError(err, account, log);
		return null;
	}
}

================
File: packages/proxy/src/handlers/index.ts
================
export { selectAccountsForRequest } from "./account-selector";
export {
	type AgentInterceptResult,
	interceptAndModifyRequest,
} from "./agent-interceptor";
export { proxyUnauthenticated, proxyWithAccount } from "./proxy-operations";
export { ERROR_MESSAGES, type ProxyContext, TIMING } from "./proxy-types";
export {
	createRequestMetadata,
	prepareRequestBody,
	validateProviderPath,
} from "./request-handler";
export { handleProxyError } from "./response-processor";
export { getValidAccessToken } from "./token-manager";

================
File: packages/proxy/src/handlers/token-manager.ts
================
import { ServiceUnavailableError, TokenRefreshError } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type { TokenRefreshResult } from "@ccflare/providers";
import type { Account } from "@ccflare/types";
import { TOKEN_REFRESH_BACKOFF_MS, TOKEN_SAFETY_WINDOW_MS } from "../constants";
import { ERROR_MESSAGES, type ProxyContext } from "./proxy-types";

const log = new Logger("TokenManager");

// Track refresh failures for backoff
const refreshFailures = new Map<string, number>();

/**
 * Safely refreshes an access token with deduplication
 * @param account - The account to refresh token for
 * @param ctx - The proxy context
 * @returns Promise resolving to the new access token
 * @throws {TokenRefreshError} If token refresh fails
 * @throws {ServiceUnavailableError} If refresh promise is not found
 */
export async function refreshAccessTokenSafe(
	account: Account,
	ctx: ProxyContext,
): Promise<string> {
	// Check for recent refresh failures and implement backoff
	const lastFailure = refreshFailures.get(account.id);
	if (lastFailure && Date.now() - lastFailure < TOKEN_REFRESH_BACKOFF_MS) {
		log.warn(`Account ${account.name} is in refresh backoff period`);
		throw new ServiceUnavailableError(
			`Token refresh for account ${account.name} is in backoff period after recent failure`,
		);
	}

	// Check if a refresh is already in progress for this account
	if (!ctx.refreshInFlight.has(account.id)) {
		// Create a new refresh promise and store it
		const refreshPromise = ctx.provider
			.refreshToken(account, ctx.runtime.clientId)
			.then((result: TokenRefreshResult) => {
				// 1. Persist to database asynchronously
				ctx.asyncWriter.enqueue(() =>
					ctx.dbOps.updateAccountTokens(
						account.id,
						result.accessToken,
						result.expiresAt,
						result.refreshToken,
					),
				);

				// 2. Update the live in-memory account object immediately
				// This prevents subsequent requests from seeing stale token data
				account.access_token = result.accessToken;
				account.expires_at = result.expiresAt;
				if (result.refreshToken) {
					account.refresh_token = result.refreshToken;
				}
				account.last_used = Date.now();

				// Clear any previous failure record on successful refresh
				refreshFailures.delete(account.id);

				log.info(`Successfully refreshed token for account: ${account.name}`);
				return result.accessToken;
			})
			.catch((error) => {
				// Record the failure timestamp for backoff
				refreshFailures.set(account.id, Date.now());
				log.error(`Token refresh failed for account ${account.name}`, error);
				throw new TokenRefreshError(account.id, error as Error);
			})
			.finally(() => {
				// Clean up the map when done (success or failure)
				ctx.refreshInFlight.delete(account.id);
			});
		ctx.refreshInFlight.set(account.id, refreshPromise);
	}

	// Return the existing or new refresh promise
	const promise = ctx.refreshInFlight.get(account.id);
	if (!promise) {
		throw new ServiceUnavailableError(
			`${ERROR_MESSAGES.REFRESH_NOT_FOUND} ${account.id}`,
		);
	}
	return promise;
}

/**
 * Gets a valid access token for an account, refreshing if necessary
 * @param account - The account to get token for
 * @param ctx - The proxy context
 * @returns Promise resolving to a valid access token
 */
export async function getValidAccessToken(
	account: Account,
	ctx: ProxyContext,
): Promise<string> {
	// API key accounts don't use access tokens
	if (!account.refresh_token && account.api_key) {
		// Return empty string - the API key will be used in prepareHeaders
		return "";
	}

	// Check if token exists and won't expire within the safety window
	if (
		account.access_token &&
		account.expires_at &&
		account.expires_at - Date.now() > TOKEN_SAFETY_WINDOW_MS
	) {
		return account.access_token;
	}

	// Token is expired, missing, or will expire soon
	const reason = !account.access_token
		? "missing"
		: !account.expires_at
			? "no expiry"
			: account.expires_at <= Date.now()
				? "expired"
				: "expiring soon";

	log.info(`Token ${reason} for account: ${account.name}`);
	return await refreshAccessTokenSafe(account, ctx);
}

================
File: packages/proxy/src/handlers/account-selector.ts
================
import type { Account, RequestMeta } from "@ccflare/types";
import type { ProxyContext } from "./proxy-types";

/**
 * Gets accounts ordered by the load balancing strategy
 * @param meta - Request metadata
 * @param ctx - The proxy context
 * @returns Array of ordered accounts
 */
export function getOrderedAccounts(
	meta: RequestMeta,
	ctx: ProxyContext,
): Account[] {
	const allAccounts = ctx.dbOps.getAllAccounts();
	// Filter accounts by provider
	const providerAccounts = allAccounts.filter(
		(account) =>
			account.provider === ctx.provider.name || account.provider === null,
	);
	return ctx.strategy.select(providerAccounts, meta);
}

/**
 * Selects accounts for a request based on the load balancing strategy
 * @param meta - Request metadata
 * @param ctx - The proxy context
 * @returns Array of selected accounts
 */
export function selectAccountsForRequest(
	meta: RequestMeta,
	ctx: ProxyContext,
): Account[] {
	return getOrderedAccounts(meta, ctx);
}

================
File: packages/config/package.json
================
{
	"name": "@ccflare/config",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/logger": "workspace:*"
	}
}

================
File: packages/config/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/config/src/paths-common.ts
================
import { homedir } from "node:os";
import { join } from "node:path";
import { platform } from "node:process";

/**
 * Get the platform-specific configuration directory for ccflare
 */
export function getPlatformConfigDir(): string {
	if (platform === "win32") {
		// Windows: Use LOCALAPPDATA or APPDATA
		const baseDir =
			process.env.LOCALAPPDATA ??
			process.env.APPDATA ??
			join(homedir(), "AppData", "Local");
		return join(baseDir, "ccflare");
	} else {
		// Linux/macOS: Follow XDG Base Directory specification
		const xdgConfig = process.env.XDG_CONFIG_HOME;
		const baseDir = xdgConfig ?? join(homedir(), ".config");
		return join(baseDir, "ccflare");
	}
}

================
File: packages/config/src/index.ts
================
import { EventEmitter } from "node:events";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname } from "node:path";
import {
	DEFAULT_AGENT_MODEL,
	DEFAULT_STRATEGY,
	isValidStrategy,
	NETWORK,
	type StrategyName,
	TIME_CONSTANTS,
} from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import { resolveConfigPath } from "./paths";

const log = new Logger("Config");

export interface RuntimeConfig {
	clientId: string;
	retry: { attempts: number; delayMs: number; backoff: number };
	sessionDurationMs: number;
	port: number;
}

export interface ConfigData {
	lb_strategy?: StrategyName;
	client_id?: string;
	retry_attempts?: number;
	retry_delay_ms?: number;
	retry_backoff?: number;
	session_duration_ms?: number;
	port?: number;
	default_agent_model?: string;
	data_retention_days?: number;
	request_retention_days?: number;
	[key: string]: string | number | boolean | undefined;
}

export class Config extends EventEmitter {
	private configPath: string;
	private data: ConfigData = {};

	constructor(configPath?: string) {
		super();
		this.configPath = configPath ?? resolveConfigPath();
		this.loadConfig();
	}

	private loadConfig(): void {
		if (existsSync(this.configPath)) {
			try {
				const content = readFileSync(this.configPath, "utf8");
				this.data = JSON.parse(content) as ConfigData;
			} catch (error) {
				log.error(`Failed to parse config file: ${error}`);
				this.data = {};
			}
		} else {
			// Create config directory if it doesn't exist
			const dir = dirname(this.configPath);
			mkdirSync(dir, { recursive: true });

			// Initialize with default config
			this.data = {
				lb_strategy: DEFAULT_STRATEGY,
			};
			this.saveConfig();
		}
	}

	private saveConfig(): void {
		try {
			const content = JSON.stringify(this.data, null, 2);
			writeFileSync(this.configPath, content, "utf8");
		} catch (error) {
			log.error(`Failed to save config file: ${error}`);
		}
	}

	get(
		key: string,
		defaultValue?: string | number | boolean,
	): string | number | boolean | undefined {
		if (key in this.data) {
			return this.data[key];
		}

		if (defaultValue !== undefined) {
			this.set(key, defaultValue);
			return defaultValue;
		}

		return undefined;
	}

	set(key: string, value: string | number | boolean): void {
		const oldValue = this.data[key];
		this.data[key] = value;
		this.saveConfig();

		// Emit change event
		this.emit("change", { key, oldValue, newValue: value });
	}

	getStrategy(): StrategyName {
		// First check environment variable
		const envStrategy = process.env.LB_STRATEGY;
		if (envStrategy && isValidStrategy(envStrategy)) {
			return envStrategy;
		}

		// Then check config file
		const configStrategy = this.data.lb_strategy;
		if (configStrategy && isValidStrategy(configStrategy)) {
			return configStrategy;
		}

		return DEFAULT_STRATEGY;
	}

	setStrategy(strategy: StrategyName): void {
		if (!isValidStrategy(strategy)) {
			throw new Error(`Invalid strategy: ${strategy}`);
		}
		this.set("lb_strategy", strategy);
	}

	getDefaultAgentModel(): string {
		// First check environment variable
		const envModel = process.env.DEFAULT_AGENT_MODEL;
		if (envModel) {
			return envModel;
		}

		// Then check config file
		const configModel = this.data.default_agent_model;
		if (configModel) {
			return configModel;
		}

		// Default to the centralized default agent model
		return DEFAULT_AGENT_MODEL;
	}

	setDefaultAgentModel(model: string): void {
		this.set("default_agent_model", model);
	}

	private clamp(n: number, min: number, max: number): number {
		return Math.max(min, Math.min(max, n));
	}

	getDataRetentionDays(): number {
		const fromEnv = process.env.DATA_RETENTION_DAYS;
		if (fromEnv) {
			const n = parseInt(fromEnv, 10);
			if (!Number.isNaN(n)) return this.clamp(n, 1, 365);
		}
		const fromFile = this.data.data_retention_days;
		if (typeof fromFile === "number") return this.clamp(fromFile, 1, 365);
		return 7;
	}

	setDataRetentionDays(days: number): void {
		const clamped = this.clamp(days, 1, 365);
		this.set("data_retention_days", clamped);
	}

	getRequestRetentionDays(): number {
		const fromEnv = process.env.REQUEST_RETENTION_DAYS;
		if (fromEnv) {
			const n = parseInt(fromEnv, 10);
			if (!Number.isNaN(n)) return this.clamp(n, 1, 3650);
		}
		const fromFile = this.data.request_retention_days;
		if (typeof fromFile === "number") return this.clamp(fromFile, 1, 3650);
		return 365; // default metadata retention
	}

	setRequestRetentionDays(days: number): void {
		const clamped = this.clamp(days, 1, 3650);
		this.set("request_retention_days", clamped);
	}

	getAllSettings(): Record<string, string | number | boolean | undefined> {
		// Include current strategy (which might come from env)
		return {
			...this.data,
			lb_strategy: this.getStrategy(),
			default_agent_model: this.getDefaultAgentModel(),
			data_retention_days: this.getDataRetentionDays(),
			request_retention_days: this.getRequestRetentionDays(),
		};
	}

	getRuntime(): RuntimeConfig {
		// Default values
		const defaults: RuntimeConfig = {
			clientId: "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
			retry: {
				attempts: 3,
				delayMs: TIME_CONSTANTS.RETRY_DELAY_DEFAULT,
				backoff: 2,
			},
			sessionDurationMs: TIME_CONSTANTS.SESSION_DURATION_DEFAULT,
			port: NETWORK.DEFAULT_PORT,
		};

		// Override with environment variables if present
		if (process.env.CLIENT_ID) {
			defaults.clientId = process.env.CLIENT_ID;
		}
		if (process.env.RETRY_ATTEMPTS) {
			defaults.retry.attempts = parseInt(process.env.RETRY_ATTEMPTS);
		}
		if (process.env.RETRY_DELAY_MS) {
			defaults.retry.delayMs = parseInt(process.env.RETRY_DELAY_MS);
		}
		if (process.env.RETRY_BACKOFF) {
			defaults.retry.backoff = parseFloat(process.env.RETRY_BACKOFF);
		}
		if (process.env.SESSION_DURATION_MS) {
			defaults.sessionDurationMs = parseInt(process.env.SESSION_DURATION_MS);
		}
		if (process.env.PORT) {
			defaults.port = parseInt(process.env.PORT);
		}

		// Override with config file settings if present
		if (this.data.client_id) {
			defaults.clientId = this.data.client_id;
		}
		if (typeof this.data.retry_attempts === "number") {
			defaults.retry.attempts = this.data.retry_attempts;
		}
		if (typeof this.data.retry_delay_ms === "number") {
			defaults.retry.delayMs = this.data.retry_delay_ms;
		}
		if (typeof this.data.retry_backoff === "number") {
			defaults.retry.backoff = this.data.retry_backoff;
		}
		if (typeof this.data.session_duration_ms === "number") {
			defaults.sessionDurationMs = this.data.session_duration_ms;
		}
		if (typeof this.data.port === "number") {
			defaults.port = this.data.port;
		}

		return defaults;
	}
}

// Re-export types
export type { StrategyName } from "@ccflare/core";
export { resolveConfigPath } from "./paths";
export { getPlatformConfigDir } from "./paths-common";

================
File: packages/config/src/paths.ts
================
import { join } from "node:path";
import { getPlatformConfigDir } from "./paths-common";

export function resolveConfigPath(): string {
	// Check for explicit config path from environment
	const explicitPath = process.env.ccflare_CONFIG_PATH;
	if (explicitPath) {
		return explicitPath;
	}

	// Use common platform config directory
	const configDir = getPlatformConfigDir();
	return join(configDir, "ccflare.json");
}

================
File: packages/http-api/package.json
================
{
	"name": "@ccflare/http-api",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/agents": "workspace:*",
		"@ccflare/core": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/oauth-flow": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}

================
File: packages/http-api/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/http-api/src/router.ts
================
import { validateNumber } from "@ccflare/core";
import {
	createAccountAddHandler,
	createAccountPauseHandler,
	createAccountRemoveHandler,
	createAccountRenameHandler,
	createAccountResumeHandler,
	createAccountsListHandler,
	createAccountTierUpdateHandler,
} from "./handlers/accounts";
import {
	createAgentPreferenceUpdateHandler,
	createAgentsListHandler,
	createBulkAgentPreferenceUpdateHandler,
	createWorkspacesListHandler,
} from "./handlers/agents";
import { createAgentUpdateHandler } from "./handlers/agents-update";
import { createAnalyticsHandler } from "./handlers/analytics";
import { createConfigHandlers } from "./handlers/config";
import { createHealthHandler } from "./handlers/health";
import { createLogsStreamHandler } from "./handlers/logs";
import { createLogsHistoryHandler } from "./handlers/logs-history";
import {
	createCleanupHandler,
	createCompactHandler,
} from "./handlers/maintenance";
import {
	createOAuthCallbackHandler,
	createOAuthInitHandler,
} from "./handlers/oauth";
import {
	createRequestsDetailHandler,
	createRequestsSummaryHandler,
} from "./handlers/requests";
import { createRequestsStreamHandler } from "./handlers/requests-stream";
import { createStatsHandler, createStatsResetHandler } from "./handlers/stats";
import { createSystemPromptInterceptorHandler } from "./handlers/tools";
import type { APIContext } from "./types";
import { errorResponse } from "./utils/http-error";

/**
 * API Router that handles all API endpoints
 */
export class APIRouter {
	private context: APIContext;
	private handlers: Map<
		string,
		(req: Request, url: URL) => Response | Promise<Response>
	>;

	constructor(context: APIContext) {
		this.context = context;
		this.handlers = new Map();
		this.registerHandlers();
	}

	private registerHandlers(): void {
		const { db, config, dbOps } = this.context;

		// Create handlers
		const healthHandler = createHealthHandler(db, config);
		const statsHandler = createStatsHandler(dbOps);
		const statsResetHandler = createStatsResetHandler(dbOps);
		const accountsHandler = createAccountsListHandler(db);
		const accountAddHandler = createAccountAddHandler(dbOps, config);
		const _accountRemoveHandler = createAccountRemoveHandler(dbOps);
		const _accountTierHandler = createAccountTierUpdateHandler(dbOps);
		const requestsSummaryHandler = createRequestsSummaryHandler(db);
		const requestsDetailHandler = createRequestsDetailHandler(dbOps);
		const configHandlers = createConfigHandlers(config);
		const logsStreamHandler = createLogsStreamHandler();
		const logsHistoryHandler = createLogsHistoryHandler();
		const analyticsHandler = createAnalyticsHandler(this.context);
		const oauthInitHandler = createOAuthInitHandler(dbOps);
		const oauthCallbackHandler = createOAuthCallbackHandler(dbOps);
		const agentsHandler = createAgentsListHandler(dbOps);
		const workspacesHandler = createWorkspacesListHandler();
		const requestsStreamHandler = createRequestsStreamHandler();
		const cleanupHandler = createCleanupHandler(dbOps, config);
		const compactHandler = createCompactHandler(dbOps);
		const toolsHandler = createSystemPromptInterceptorHandler(dbOps);

		// Register routes
		this.handlers.set("GET:/health", () => healthHandler());
		this.handlers.set("GET:/api/stats", () => statsHandler());
		this.handlers.set("POST:/api/stats/reset", () => statsResetHandler());
		this.handlers.set("GET:/api/accounts", () => accountsHandler());
		this.handlers.set("POST:/api/accounts", (req) => accountAddHandler(req));
		this.handlers.set("POST:/api/oauth/init", (req) => oauthInitHandler(req));
		this.handlers.set("POST:/api/oauth/callback", (req) =>
			oauthCallbackHandler(req),
		);
		this.handlers.set("GET:/api/requests", (_req, url) => {
			const limitParam = url.searchParams.get("limit");
			const limit =
				validateNumber(limitParam || "50", "limit", {
					min: 1,
					max: 1000,
					integer: true,
				}) || 50;
			return requestsSummaryHandler(limit);
		});
		this.handlers.set("GET:/api/requests/detail", (_req, url) => {
			const limitParam = url.searchParams.get("limit");
			const limit =
				validateNumber(limitParam || "100", "limit", {
					min: 1,
					max: 1000,
					integer: true,
				}) || 100;
			return requestsDetailHandler(limit);
		});
		this.handlers.set("GET:/api/requests/stream", () =>
			requestsStreamHandler(),
		);
		this.handlers.set("GET:/api/config", () => configHandlers.getConfig());
		this.handlers.set("GET:/api/config/strategy", () =>
			configHandlers.getStrategy(),
		);
		this.handlers.set("POST:/api/config/strategy", (req) =>
			configHandlers.setStrategy(req),
		);
		this.handlers.set("GET:/api/strategies", () =>
			configHandlers.getStrategies(),
		);
		this.handlers.set("GET:/api/config/model", () =>
			configHandlers.getDefaultAgentModel(),
		);
		this.handlers.set("POST:/api/config/model", (req) =>
			configHandlers.setDefaultAgentModel(req),
		);
		this.handlers.set("GET:/api/config/retention", () =>
			configHandlers.getRetention(),
		);
		this.handlers.set("POST:/api/config/retention", (req) =>
			configHandlers.setRetention(req),
		);
		this.handlers.set("POST:/api/maintenance/cleanup", () => cleanupHandler());
		this.handlers.set("POST:/api/maintenance/compact", () => compactHandler());
		this.handlers.set("GET:/api/logs/stream", () => logsStreamHandler());
		this.handlers.set("GET:/api/logs/history", () => logsHistoryHandler());
		this.handlers.set("GET:/api/analytics", (_req, url) => {
			return analyticsHandler(url.searchParams);
		});
		this.handlers.set("GET:/api/agents", () => agentsHandler());
		this.handlers.set("POST:/api/agents/bulk-preference", (req) => {
			const bulkHandler = createBulkAgentPreferenceUpdateHandler(
				this.context.dbOps,
			);
			return bulkHandler(req);
		});
		this.handlers.set("GET:/api/workspaces", () => workspacesHandler());
		this.handlers.set("GET:/api/tools/interceptors/system-prompt", () =>
			toolsHandler.getSystemPromptConfig(),
		);
		this.handlers.set("POST:/api/tools/interceptors/system-prompt", (req) =>
			toolsHandler.setSystemPromptConfig(req),
		);
		this.handlers.set("DELETE:/api/tools/interceptors/system-prompt", () =>
			toolsHandler.resetSystemPromptConfig(),
		);
	}

	/**
	 * Wrap a handler with error handling
	 */
	private wrapHandler(
		handler: (req: Request, url: URL) => Response | Promise<Response>,
	): (req: Request, url: URL) => Promise<Response> {
		return async (req: Request, url: URL) => {
			try {
				return await handler(req, url);
			} catch (error) {
				return errorResponse(error);
			}
		};
	}

	/**
	 * Handle an incoming request
	 */
	async handleRequest(url: URL, req: Request): Promise<Response | null> {
		const path = url.pathname;
		const method = req.method;
		const key = `${method}:${path}`;

		// Check for exact match
		const handler = this.handlers.get(key);
		if (handler) {
			return await this.wrapHandler(handler)(req, url);
		}

		// Check for dynamic account endpoints
		if (path.startsWith("/api/accounts/")) {
			const parts = path.split("/");
			const accountId = parts[3];

			// Account tier update
			if (path.endsWith("/tier") && method === "POST") {
				const tierHandler = createAccountTierUpdateHandler(this.context.dbOps);
				return await this.wrapHandler((req) => tierHandler(req, accountId))(
					req,
					url,
				);
			}

			// Account pause
			if (path.endsWith("/pause") && method === "POST") {
				const pauseHandler = createAccountPauseHandler(this.context.dbOps);
				return await this.wrapHandler((req) => pauseHandler(req, accountId))(
					req,
					url,
				);
			}

			// Account resume
			if (path.endsWith("/resume") && method === "POST") {
				const resumeHandler = createAccountResumeHandler(this.context.dbOps);
				return await this.wrapHandler((req) => resumeHandler(req, accountId))(
					req,
					url,
				);
			}

			// Account rename
			if (path.endsWith("/rename") && method === "POST") {
				const renameHandler = createAccountRenameHandler(this.context.dbOps);
				return await this.wrapHandler((req) => renameHandler(req, accountId))(
					req,
					url,
				);
			}

			// Account removal
			if (parts.length === 4 && method === "DELETE") {
				const removeHandler = createAccountRemoveHandler(this.context.dbOps);
				return await this.wrapHandler((req) => removeHandler(req, accountId))(
					req,
					url,
				);
			}
		}

		// Check for dynamic agent endpoints
		if (path.startsWith("/api/agents/")) {
			const parts = path.split("/");
			const agentId = parts[3];

			// Agent preference update
			if (path.endsWith("/preference") && method === "POST") {
				const preferenceHandler = createAgentPreferenceUpdateHandler(
					this.context.dbOps,
				);
				return await this.wrapHandler((req) => preferenceHandler(req, agentId))(
					req,
					url,
				);
			}

			// Agent update (PATCH /api/agents/:id)
			if (parts.length === 4 && method === "PATCH") {
				const updateHandler = createAgentUpdateHandler(this.context.dbOps);
				return await this.wrapHandler((req) => updateHandler(req, agentId))(
					req,
					url,
				);
			}
		}

		// No matching route
		return null;
	}
}

================
File: packages/http-api/src/types.ts
================
// Re-export all types from the centralized types package
export type {
	AccountDeleteRequest,
	AccountResponse,
	AnalyticsResponse,
	APIContext,
	CleanupResponse,
	CompactResponse,
	ConfigResponse,
	HealthResponse,
	ModelPerformance,
	RequestResponse,
	RetentionGetResponse,
	RetentionSetRequest,
	StatsResponse,
	StrategyUpdateRequest,
	TierUpdateRequest,
	TimePoint,
	TokenBreakdown,
} from "@ccflare/types";

================
File: packages/http-api/src/index.ts
================
// Export router - the main public API
export { APIRouter } from "./router";

// Export types
export * from "./types";

// Export utilities
export * from "./utils/http-error";

================
File: packages/http-api/src/utils/http-error.ts
================
// Re-export all HTTP utilities from the shared http-common package
export {
	BadRequest,
	Conflict,
	errorResponse,
	Forbidden,
	HttpError,
	InternalServerError,
	jsonResponse,
	NotFound,
	Unauthorized,
} from "@ccflare/http-common";

================
File: packages/http-api/src/utils/handler-factory.ts
================
import { errorResponse } from "@ccflare/http-common";
import type { APIContext } from "../types";

export interface HandlerOptions {
	requiresAuth?: boolean;
	method?: string;
}

/**
 * Factory for creating consistent API handlers with error handling
 */
export function createHandler<T extends unknown[], R>(
	handler: (context: APIContext, ...args: T) => R | Promise<R>,
	_options: HandlerOptions = {},
): (...args: T) => Promise<Response> {
	return async (...args: T): Promise<Response> => {
		try {
			// In a real implementation, you'd pass the context here
			// For now, we'll assume it's available through dependency injection
			const result = await handler({} as APIContext, ...args);
			return result as Response;
		} catch (error) {
			return errorResponse(error);
		}
	};
}

/**
 * Helper for parsing and validating request body
 */
export async function parseRequestBody<T>(req: Request): Promise<T> {
	try {
		const body = await req.json();
		return body as T;
	} catch (_error) {
		throw new Error("Invalid JSON in request body");
	}
}

/**
 * Helper for extracting common query parameters
 */
export function extractQueryParams(
	url: URL,
	params: string[],
): Record<string, string | null> {
	const result: Record<string, string | null> = {};
	for (const param of params) {
		result[param] = url.searchParams.get(param);
	}
	return result;
}

================
File: packages/http-api/src/handlers/requests-stream.ts
================
import { type RequestEvt, requestEvents } from "@ccflare/core";

export function createRequestsStreamHandler() {
	return (): Response => {
		// Store the write handler outside to access it in cancel
		let writeHandler: ((data: RequestEvt) => void) | null = null;

		const stream = new ReadableStream({
			start(controller) {
				const encoder = new TextEncoder();

				// Helper to send SSE formatted data
				writeHandler = (data: RequestEvt) => {
					const message = `data: ${JSON.stringify(data)}\n\n`;
					controller.enqueue(encoder.encode(message));
				};

				// Send initial connection message
				const connectMsg = `event: connected\ndata: ok\n\n`;
				controller.enqueue(encoder.encode(connectMsg));

				// Listen for events
				requestEvents.on("event", writeHandler);
			},
			cancel() {
				// Cleanup only this specific listener
				if (writeHandler) {
					requestEvents.off("event", writeHandler);
					writeHandler = null;
				}
			},
		});

		return new Response(stream, {
			headers: {
				"Content-Type": "text/event-stream",
				Connection: "keep-alive",
				"Cache-Control": "no-cache",
			},
		});
	};
}

================
File: packages/http-api/src/handlers/oauth.ts
================
import { Config } from "@ccflare/config";
import { patterns, validateNumber, validateString } from "@ccflare/core";
import type { DatabaseOperations } from "@ccflare/database";
import {
	BadRequest,
	errorResponse,
	InternalServerError,
	jsonResponse,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import { createOAuthFlow } from "@ccflare/oauth-flow";

const log = new Logger("OAuthHandler");

/**
 * Create an OAuth initialization handler
 */
export function createOAuthInitHandler(dbOps: DatabaseOperations) {
	return async (req: Request): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate account name
			const name = validateString(body.name, "name", {
				required: true,
				minLength: 1,
				maxLength: 100,
				pattern: patterns.accountName,
			});

			if (!name) {
				return errorResponse(BadRequest("Valid account name is required"));
			}

			// Validate mode
			const mode = (validateString(body.mode, "mode", {
				allowedValues: ["max", "console"] as const,
			}) || "max") as "max" | "console";

			// Validate tier
			const tier =
				validateNumber(body.tier, "tier", {
					allowedValues: [1, 5, 20] as const,
				}) || 1;

			const config = new Config();
			const oauthFlow = await createOAuthFlow(dbOps, config);

			try {
				// Begin OAuth flow using consolidated logic
				const flowResult = await oauthFlow.begin({
					name,
					mode,
				});

				// Store tier in session for later use
				dbOps.createOAuthSession(
					flowResult.sessionId,
					name,
					flowResult.pkce.verifier,
					mode,
					tier,
					10, // 10 minute TTL
				);

				return jsonResponse({
					success: true,
					authUrl: flowResult.authUrl,
					sessionId: flowResult.sessionId,
					step: "authorize",
				});
			} catch (error) {
				if (
					error instanceof Error &&
					error.message.includes("already exists")
				) {
					return errorResponse(BadRequest(error.message));
				}
				return errorResponse(InternalServerError((error as Error).message));
			}
		} catch (error) {
			log.error("OAuth init error:", error);
			return errorResponse(
				error instanceof Error
					? error
					: new Error("Failed to initialize OAuth"),
			);
		}
	};
}

/**
 * Create an OAuth callback handler
 */
export function createOAuthCallbackHandler(dbOps: DatabaseOperations) {
	return async (req: Request): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate session ID
			const sessionId = validateString(body.sessionId, "sessionId", {
				required: true,
				pattern: patterns.uuid,
			});

			if (!sessionId) {
				return errorResponse(BadRequest("Session ID is required"));
			}

			// Validate code
			const code = validateString(body.code, "code", {
				required: true,
				minLength: 1,
			});

			if (!code) {
				return errorResponse(BadRequest("Authorization code is required"));
			}

			// Get stored PKCE verifier from database
			const oauthSession = dbOps.getOAuthSession(sessionId);
			if (!oauthSession) {
				return errorResponse(
					BadRequest("OAuth session expired or invalid. Please try again."),
				);
			}

			const {
				accountName: name,
				verifier,
				mode: savedMode,
				tier: savedTier,
			} = oauthSession;

			try {
				// Create OAuth flow instance
				const config = new Config();
				const oauthFlow = await createOAuthFlow(dbOps, config);

				// We need to reconstruct the flow data since we can't pass the full BeginResult through HTTP
				// The OAuth flow will handle the token exchange and account creation
				const oauthProvider = await import("@ccflare/providers").then((m) =>
					m.getOAuthProvider("anthropic"),
				);
				if (!oauthProvider) {
					throw new Error("OAuth provider not found");
				}
				const runtime = config.getRuntime();
				const oauthConfig = oauthProvider.getOAuthConfig(savedMode);
				oauthConfig.clientId = runtime.clientId;

				const flowData = {
					sessionId,
					authUrl: "", // Not needed for complete
					pkce: { verifier, challenge: "" }, // Only verifier is needed
					oauthConfig,
					mode: savedMode || "max", // Add mode to match BeginResult type
				};

				await oauthFlow.complete(
					{ sessionId, code, tier: savedTier, name },
					flowData,
				);

				// Clean up OAuth session from database
				dbOps.deleteOAuthSession(sessionId);

				return jsonResponse({
					success: true,
					message: `Account '${name}' added successfully!`,
					mode: savedMode === "max" ? "Claude Max" : "Claude Console",
					tier: savedTier,
				});
			} catch (error) {
				return errorResponse(
					error instanceof Error
						? error
						: new Error("Failed to complete OAuth flow"),
				);
			}
		} catch (error) {
			log.error("OAuth callback error:", error);
			return errorResponse(
				error instanceof Error
					? error
					: new Error("Failed to process OAuth callback"),
			);
		}
	};
}

================
File: packages/http-api/src/handlers/requests.ts
================
import type { Database } from "bun:sqlite";
import type { DatabaseOperations } from "@ccflare/database";
import { jsonResponse } from "@ccflare/http-common";
import type { RequestResponse } from "../types";

/**
 * Create a requests summary handler (existing functionality)
 */
export function createRequestsSummaryHandler(db: Database) {
	return (limit: number = 50): Response => {
		const requests = db
			.query(
				`
				SELECT r.*, a.name as account_name
				FROM requests r
				LEFT JOIN accounts a ON r.account_used = a.id
				ORDER BY r.timestamp DESC
				LIMIT ?1
			`,
			)
			.all(limit) as Array<{
			id: string;
			timestamp: number;
			method: string;
			path: string;
			account_used: string | null;
			account_name: string | null;
			status_code: number | null;
			success: 0 | 1;
			error_message: string | null;
			response_time_ms: number | null;
			failover_attempts: number;
			model: string | null;
			prompt_tokens: number | null;
			completion_tokens: number | null;
			total_tokens: number | null;
			input_tokens: number | null;
			cache_read_input_tokens: number | null;
			cache_creation_input_tokens: number | null;
			output_tokens: number | null;
			cost_usd: number | null;
			agent_used: string | null;
			output_tokens_per_second: number | null;
		}>;

		const response: RequestResponse[] = requests.map((request) => ({
			id: request.id,
			timestamp: new Date(request.timestamp).toISOString(),
			method: request.method,
			path: request.path,
			accountUsed: request.account_name || request.account_used,
			statusCode: request.status_code,
			success: request.success === 1,
			errorMessage: request.error_message,
			responseTimeMs: request.response_time_ms,
			failoverAttempts: request.failover_attempts,
			model: request.model || undefined,
			promptTokens: request.prompt_tokens || undefined,
			completionTokens: request.completion_tokens || undefined,
			totalTokens: request.total_tokens || undefined,
			inputTokens: request.input_tokens || undefined,
			cacheReadInputTokens: request.cache_read_input_tokens || undefined,
			cacheCreationInputTokens:
				request.cache_creation_input_tokens || undefined,
			outputTokens: request.output_tokens || undefined,
			costUsd: request.cost_usd || undefined,
			agentUsed: request.agent_used || undefined,
			tokensPerSecond: request.output_tokens_per_second || undefined,
		}));

		return jsonResponse(response);
	};
}

/**
 * Create a detailed requests handler with full payload data
 */
export function createRequestsDetailHandler(dbOps: DatabaseOperations) {
	return (limit = 100): Response => {
		const rows = dbOps.listRequestPayloadsWithAccountNames(limit);
		const parsed = rows.map((r) => {
			try {
				const data = JSON.parse(r.json);
				// Add account name to the meta field if available
				if (r.account_name && data.meta) {
					data.meta.accountName = r.account_name;
				}
				return { id: r.id, ...data };
			} catch {
				return { id: r.id, error: "Failed to parse payload" };
			}
		});

		return jsonResponse(parsed);
	};
}

================
File: packages/http-api/src/handlers/analytics.ts
================
import {
	errorResponse,
	InternalServerError,
	jsonResponse,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import { NO_ACCOUNT_ID } from "@ccflare/types";
import type { AnalyticsResponse, APIContext } from "../types";

const log = new Logger("AnalyticsHandler");

interface BucketConfig {
	bucketMs: number;
	displayName: string;
}

interface TotalsResult {
	total_requests: number;
	success_rate: number;
	avg_response_time: number;
	total_tokens: number;
	total_cost_usd: number;
	avg_tokens_per_second: number;
}

interface ActiveAccountsResult {
	active_accounts: number;
}

interface TokenBreakdownResult {
	input_tokens: number;
	cache_read_input_tokens: number;
	cache_creation_input_tokens: number;
	output_tokens: number;
}

function getRangeConfig(range: string): {
	startMs: number;
	bucket: BucketConfig;
} {
	const now = Date.now();
	const hour = 60 * 60 * 1000;
	const day = 24 * hour;

	switch (range) {
		case "1h":
			return {
				startMs: now - hour,
				bucket: { bucketMs: 60 * 1000, displayName: "1m" },
			};
		case "6h":
			return {
				startMs: now - 6 * hour,
				bucket: { bucketMs: 5 * 60 * 1000, displayName: "5m" },
			};
		case "24h":
			return {
				startMs: now - day,
				bucket: { bucketMs: hour, displayName: "1h" },
			};
		case "7d":
			return {
				startMs: now - 7 * day,
				bucket: { bucketMs: hour, displayName: "1h" },
			};
		case "30d":
			return {
				startMs: now - 30 * day,
				bucket: { bucketMs: day, displayName: "1d" },
			};
		default:
			return {
				startMs: now - day,
				bucket: { bucketMs: hour, displayName: "1h" },
			};
	}
}

export function createAnalyticsHandler(context: APIContext) {
	return async (params: URLSearchParams): Promise<Response> => {
		const { db } = context;
		const range = params.get("range") ?? "24h";
		const { startMs, bucket } = getRangeConfig(range);
		const mode = params.get("mode") ?? "normal";
		const isCumulative = mode === "cumulative";

		// Extract filters
		const accountsFilter =
			params.get("accounts")?.split(",").filter(Boolean) || [];
		const modelsFilter = params.get("models")?.split(",").filter(Boolean) || [];
		const statusFilter = params.get("status") || "all";

		// Build filter conditions
		const conditions: string[] = ["timestamp > ?"];
		const queryParams: (string | number)[] = [startMs];

		if (accountsFilter.length > 0) {
			// Handle account filter - map account names to IDs via join
			const placeholders = accountsFilter.map(() => "?").join(",");
			conditions.push(`(
				r.account_used IN (SELECT id FROM accounts WHERE name IN (${placeholders}))
				OR (r.account_used = ? AND ? IN (${placeholders}))
			)`);
			queryParams.push(
				...accountsFilter,
				NO_ACCOUNT_ID,
				NO_ACCOUNT_ID,
				...accountsFilter,
			);
		}

		if (modelsFilter.length > 0) {
			const placeholders = modelsFilter.map(() => "?").join(",");
			conditions.push(`model IN (${placeholders})`);
			queryParams.push(...modelsFilter);
		}

		if (statusFilter === "success") {
			conditions.push("success = 1");
		} else if (statusFilter === "error") {
			conditions.push("success = 0");
		}

		const whereClause = conditions.join(" AND ");

		try {
			// Get totals
			const totalsQuery = db.prepare(`
				SELECT
					COUNT(*) as total_requests,
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as success_rate,
					AVG(response_time_ms) as avg_response_time,
					SUM(COALESCE(total_tokens, 0)) as total_tokens,
					SUM(COALESCE(cost_usd, 0)) as total_cost_usd,
					AVG(output_tokens_per_second) as avg_tokens_per_second
				FROM requests r
				WHERE ${whereClause}
			`);
			const totals = totalsQuery.get(...queryParams) as TotalsResult;

			// Get active accounts count (including no_account for unauthenticated requests)
			const activeAccountsQuery = db.prepare(`
				SELECT COUNT(DISTINCT COALESCE(account_used, ?)) as active_accounts
				FROM requests r
				WHERE ${whereClause}
			`);
			const activeAccounts = activeAccountsQuery.get(
				NO_ACCOUNT_ID,
				...queryParams,
			) as ActiveAccountsResult;

			// Check if we need per-model time series
			const includeModelBreakdown = params.get("modelBreakdown") === "true";

			// Get time series data
			const timeSeriesQuery = db.prepare(`
				SELECT
					(timestamp / ?) * ? as ts,
					${includeModelBreakdown ? "model," : ""}
					COUNT(*) as requests,
					SUM(COALESCE(total_tokens, 0)) as tokens,
					SUM(COALESCE(cost_usd, 0)) as cost_usd,
					SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as success_rate,
					SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as error_rate,
					SUM(COALESCE(cache_read_input_tokens, 0)) * 100.0 / 
						NULLIF(SUM(COALESCE(input_tokens, 0) + COALESCE(cache_read_input_tokens, 0) + COALESCE(cache_creation_input_tokens, 0)), 0) as cache_hit_rate,
					AVG(response_time_ms) as avg_response_time,
					AVG(output_tokens_per_second) as avg_tokens_per_second
				FROM requests r
				WHERE ${whereClause} ${includeModelBreakdown ? "AND model IS NOT NULL" : ""}
				GROUP BY ts${includeModelBreakdown ? ", model" : ""}
				ORDER BY ts${includeModelBreakdown ? ", model" : ""}
			`);
			const timeSeries = timeSeriesQuery.all(
				bucket.bucketMs,
				bucket.bucketMs,
				...queryParams,
			) as Array<{
				ts: number;
				model?: string;
				requests: number;
				tokens: number;
				cost_usd: number;
				success_rate: number;
				error_rate: number;
				cache_hit_rate: number;
				avg_response_time: number;
				avg_tokens_per_second: number | null;
			}>;

			// Get token breakdown
			const tokenBreakdownQuery = db.prepare(`
				SELECT
					SUM(COALESCE(input_tokens, 0)) as input_tokens,
					SUM(COALESCE(cache_read_input_tokens, 0)) as cache_read_input_tokens,
					SUM(COALESCE(cache_creation_input_tokens, 0)) as cache_creation_input_tokens,
					SUM(COALESCE(output_tokens, 0)) as output_tokens
				FROM requests r
				WHERE ${whereClause}
			`);
			const tokenBreakdown = tokenBreakdownQuery.get(
				...queryParams,
			) as TokenBreakdownResult;

			// Get model distribution
			const modelDistQuery = db.prepare(`
				SELECT
					model,
					COUNT(*) as count
				FROM requests r
				WHERE ${whereClause} AND model IS NOT NULL
				GROUP BY model
				ORDER BY count DESC
				LIMIT 10
			`);
			const modelDistribution = modelDistQuery.all(...queryParams) as Array<{
				model: string;
				count: number;
			}>;

			// Get account performance (including unauthenticated requests)
			const accountPerfQuery = db.prepare(`
				SELECT
					COALESCE(a.name, ?) as name,
					COUNT(r.id) as requests,
					SUM(CASE WHEN r.success = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(r.id), 0) as success_rate
				FROM requests r
				LEFT JOIN accounts a ON a.id = r.account_used
				WHERE ${whereClause}
				GROUP BY name
				HAVING requests > 0
				ORDER BY requests DESC
			`);
			const accountPerformance = accountPerfQuery.all(
				NO_ACCOUNT_ID,
				...queryParams,
			) as Array<{
				name: string;
				requests: number;
				success_rate: number;
			}>;

			// Get model performance metrics
			const modelPerfQuery = db.prepare(`
				SELECT
					model,
					AVG(response_time_ms) as avg_response_time,
					MAX(response_time_ms) as max_response_time,
					COUNT(*) as total_requests,
					SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) as error_count,
					SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as error_rate,
					AVG(output_tokens_per_second) as avg_tokens_per_second,
					MIN(CASE WHEN output_tokens_per_second > 0 THEN output_tokens_per_second ELSE NULL END) as min_tokens_per_second,
					MAX(output_tokens_per_second) as max_tokens_per_second
				FROM requests r
				WHERE ${whereClause} AND model IS NOT NULL
				GROUP BY model
				ORDER BY total_requests DESC
				LIMIT 10
			`);
			const modelPerfData = modelPerfQuery.all(...queryParams) as Array<{
				model: string;
				avg_response_time: number;
				max_response_time: number;
				total_requests: number;
				error_count: number;
				error_rate: number;
				avg_tokens_per_second: number | null;
				min_tokens_per_second: number | null;
				max_tokens_per_second: number | null;
			}>;

			// Calculate p95 for each model using SQL window functions
			const modelPerformance = modelPerfData.map((modelData) => {
				// Use SQLite's NTILE or manual percentile calculation
				// SQLite doesn't have built-in percentile functions, but we can use a more efficient query
				const p95Result = db
					.prepare(`
					WITH ordered_times AS (
						SELECT 
							response_time_ms,
							ROW_NUMBER() OVER (ORDER BY response_time_ms) as row_num,
							COUNT(*) OVER () as total_count
						FROM requests r
						WHERE ${whereClause} AND model = ? AND response_time_ms IS NOT NULL
					)
					SELECT response_time_ms as p95_response_time
					FROM ordered_times
					WHERE row_num = CAST(CEIL(total_count * 0.95) AS INTEGER)
					LIMIT 1
				`)
					.get(...queryParams, modelData.model) as
					| { p95_response_time: number }
					| undefined;

				return {
					model: modelData.model,
					avgResponseTime: modelData.avg_response_time || 0,
					p95ResponseTime:
						p95Result?.p95_response_time || modelData.avg_response_time || 0,
					errorRate: modelData.error_rate || 0,
					avgTokensPerSecond: modelData.avg_tokens_per_second || null,
					minTokensPerSecond: modelData.min_tokens_per_second || null,
					maxTokensPerSecond: modelData.max_tokens_per_second || null,
				};
			});

			// Get cost by model
			const costByModelQuery = db.prepare(`
				SELECT
					model,
					SUM(COALESCE(cost_usd, 0)) as cost_usd,
					COUNT(*) as requests,
					SUM(COALESCE(total_tokens, 0)) as total_tokens
				FROM requests r
				WHERE ${whereClause} AND COALESCE(cost_usd, 0) > 0 AND model IS NOT NULL
				GROUP BY model
				ORDER BY cost_usd DESC
				LIMIT 10
			`);
			const costByModel = costByModelQuery.all(...queryParams) as Array<{
				model: string;
				cost_usd: number;
				requests: number;
				total_tokens: number;
			}>;

			// Transform timeSeries data
			let transformedTimeSeries = timeSeries.map((point) => ({
				ts: point.ts,
				...(point.model && { model: point.model }),
				requests: point.requests || 0,
				tokens: point.tokens || 0,
				costUsd: point.cost_usd || 0,
				successRate: point.success_rate || 0,
				errorRate: point.error_rate || 0,
				cacheHitRate: point.cache_hit_rate || 0,
				avgResponseTime: point.avg_response_time || 0,
				avgTokensPerSecond: point.avg_tokens_per_second || null,
			}));

			// Apply cumulative transformation if requested
			if (isCumulative && !includeModelBreakdown) {
				let runningRequests = 0;
				let runningTokens = 0;
				let runningCostUsd = 0;

				transformedTimeSeries = transformedTimeSeries.map((point) => {
					runningRequests += point.requests;
					runningTokens += point.tokens;
					runningCostUsd += point.costUsd;

					return {
						...point,
						requests: runningRequests,
						tokens: runningTokens,
						costUsd: runningCostUsd,
						// Keep rates as-is (not cumulative)
					};
				});
			} else if (isCumulative && includeModelBreakdown) {
				// For per-model cumulative, track running totals per model
				const runningTotals: Record<
					string,
					{ requests: number; tokens: number; costUsd: number }
				> = {};

				transformedTimeSeries = transformedTimeSeries.map((point) => {
					if (point.model) {
						if (!runningTotals[point.model]) {
							runningTotals[point.model] = {
								requests: 0,
								tokens: 0,
								costUsd: 0,
							};
						}
						runningTotals[point.model].requests += point.requests;
						runningTotals[point.model].tokens += point.tokens;
						runningTotals[point.model].costUsd += point.costUsd;

						return {
							...point,
							requests: runningTotals[point.model].requests,
							tokens: runningTotals[point.model].tokens,
							costUsd: runningTotals[point.model].costUsd,
						};
					}
					return point;
				});
			}

			const response: AnalyticsResponse = {
				meta: {
					range,
					bucket: bucket.displayName,
					cumulative: isCumulative,
				},
				totals: {
					requests: totals.total_requests || 0,
					successRate: totals.success_rate || 0,
					activeAccounts: activeAccounts.active_accounts || 0,
					avgResponseTime: totals.avg_response_time || 0,
					totalTokens: totals.total_tokens || 0,
					totalCostUsd: totals.total_cost_usd || 0,
					avgTokensPerSecond: totals.avg_tokens_per_second || null,
				},
				timeSeries: transformedTimeSeries,
				tokenBreakdown: {
					inputTokens: tokenBreakdown?.input_tokens || 0,
					cacheReadInputTokens: tokenBreakdown?.cache_read_input_tokens || 0,
					cacheCreationInputTokens:
						tokenBreakdown?.cache_creation_input_tokens || 0,
					outputTokens: tokenBreakdown?.output_tokens || 0,
				},
				modelDistribution,
				accountPerformance: accountPerformance.map((acc) => ({
					name: acc.name,
					requests: acc.requests,
					successRate: acc.success_rate || 0,
				})),
				costByModel: costByModel.map((model) => ({
					model: model.model,
					costUsd: model.cost_usd || 0,
					requests: model.requests || 0,
					totalTokens: model.total_tokens || 0,
				})),
				modelPerformance,
			};

			return jsonResponse(response);
		} catch (error) {
			log.error("Analytics error:", error);
			return errorResponse(
				InternalServerError("Failed to fetch analytics data"),
			);
		}
	};
}

================
File: packages/http-api/src/handlers/stats.ts
================
import type { DatabaseOperations } from "@ccflare/database";
import { jsonResponse } from "@ccflare/http-common";

/**
 * Create a stats handler
 */
export function createStatsHandler(dbOps: DatabaseOperations) {
	return (): Response => {
		const statsRepository = dbOps.getStatsRepository();

		// Get overall statistics using the consolidated repository
		const stats = statsRepository.getAggregatedStats();
		const activeAccounts = statsRepository.getActiveAccountCount();

		const successRate =
			stats.totalRequests > 0
				? Math.round((stats.successfulRequests / stats.totalRequests) * 100)
				: 0;

		// Get per-account stats (including unauthenticated requests)
		const accountsWithStats = statsRepository.getAccountStats(10, true);

		// Get recent errors
		const recentErrors = statsRepository.getRecentErrors();

		// Get top models
		const topModels = statsRepository.getTopModels();

		const response = {
			totalRequests: stats.totalRequests,
			successRate,
			activeAccounts,
			avgResponseTime: Math.round(stats.avgResponseTime || 0),
			totalTokens: stats.totalTokens,
			totalCostUsd: stats.totalCostUsd,
			topModels,
			avgTokensPerSecond: stats.avgTokensPerSecond,
			accounts: accountsWithStats,
			recentErrors,
		};

		return jsonResponse(response);
	};
}

/**
 * Create a stats reset handler
 */
export function createStatsResetHandler(dbOps: DatabaseOperations) {
	return async (): Promise<Response> => {
		const db = dbOps.getDatabase();
		// Clear request history
		db.run("DELETE FROM requests");
		// Reset account statistics
		db.run("UPDATE accounts SET request_count = 0, session_request_count = 0");

		return jsonResponse({
			success: true,
			message: "Statistics reset successfully",
		});
	};
}

================
File: packages/http-api/src/handlers/logs.ts
================
import { sseResponse } from "@ccflare/http-common";
import { Logger, logBus } from "@ccflare/logger";
import type { LogEvent } from "@ccflare/types";

const log = new Logger("LogsHandler");

/**
 * Create a logs stream handler using Server-Sent Events
 */
export function createLogsStreamHandler() {
	return (): Response => {
		// Use TransformStream for better Bun compatibility
		const { readable, writable } = new TransformStream();
		const writer = writable.getWriter();
		const encoder = new TextEncoder();
		let closed = false;

		// Send initial connection message
		(async () => {
			try {
				const initialData = `data: ${JSON.stringify({ connected: true })}\n\n`;
				await writer.write(encoder.encode(initialData));
			} catch (e) {
				log.error("Error sending initial message:", e);
			}
		})();

		// Listen for log events
		const handleLogEvent = async (event: LogEvent) => {
			if (closed) return;

			try {
				const data = `data: ${JSON.stringify(event)}\n\n`;
				await writer.write(encoder.encode(data));
			} catch (_error) {
				// Stream closed
				closed = true;
				logBus.off("log", handleLogEvent);
				try {
					await writer.close();
				} catch {}
			}
		};

		// Subscribe to log events
		logBus.on("log", handleLogEvent);

		// Clean up on request abort
		setTimeout(() => {
			// ReadableStream doesn't have a standard 'closed' property
			// This is a workaround for stream closure detection
			if (!closed) {
				// Just rely on the error handling in handleLogEvent
				// to detect when the stream is closed
			}
		}, 0);

		return sseResponse(readable);
	};
}

================
File: packages/http-api/src/handlers/agents.ts
================
import { agentRegistry } from "@ccflare/agents";
import { validateString } from "@ccflare/core";
import type { DatabaseOperations } from "@ccflare/database";
import {
	BadRequest,
	errorResponse,
	HttpError,
	jsonResponse,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import { ALLOWED_MODELS } from "@ccflare/types";

const log = new Logger("AgentsHandler");

export function createAgentsListHandler(dbOps: DatabaseOperations) {
	return async (): Promise<Response> => {
		try {
			const agents = await agentRegistry.getAgents();
			const preferences = dbOps.getAllAgentPreferences();

			// Create a map of preferences for easy lookup
			const prefMap = new Map(preferences.map((p) => [p.agent_id, p.model]));

			// Merge preferences with agents
			const agentsWithPreferences = agents.map((agent) => ({
				...agent,
				model: prefMap.get(agent.id) || agent.model,
			}));

			// Group agents by source
			const globalAgents = agentsWithPreferences.filter(
				(a) => a.source === "global",
			);
			const workspaceAgents = agentsWithPreferences.filter(
				(a) => a.source === "workspace",
			);

			// Get workspaces
			const workspaces = agentRegistry.getWorkspaces();

			return jsonResponse({
				agents: agentsWithPreferences,
				globalAgents,
				workspaceAgents,
				workspaces,
			});
		} catch (error) {
			log.error("Error fetching agents:", error);
			return jsonResponse({ error: "Failed to fetch agents" }, 500);
		}
	};
}

export function createAgentPreferenceUpdateHandler(dbOps: DatabaseOperations) {
	return async (req: Request, agentId: string): Promise<Response> => {
		try {
			const body = await req.json();
			const { model } = body;

			if (!model) {
				throw BadRequest("Model is required");
			}

			// Validate model is in allowed list
			if (!ALLOWED_MODELS.includes(model)) {
				throw BadRequest(
					`Invalid model. Allowed models: ${ALLOWED_MODELS.join(", ")}`,
				);
			}

			// Update preference
			dbOps.setAgentPreference(agentId, model);

			return jsonResponse({
				success: true,
				agentId,
				model,
			});
		} catch (error) {
			log.error("Error updating agent preference:", error);
			if (error instanceof HttpError) {
				return jsonResponse({ error: error.message }, error.status);
			}
			return jsonResponse({ error: "Failed to update agent preference" }, 500);
		}
	};
}

export function createWorkspacesListHandler() {
	return async (): Promise<Response> => {
		try {
			const workspaces = agentRegistry.getWorkspaces();

			// Add agent count for each workspace
			const agents = await agentRegistry.getAgents();
			const workspacesWithStats = workspaces.map((workspace) => {
				const agentCount = agents.filter(
					(a) => a.source === "workspace" && a.workspace === workspace.path,
				).length;

				return {
					...workspace,
					agentCount,
				};
			});

			return jsonResponse({ workspaces: workspacesWithStats });
		} catch (error) {
			log.error("Error fetching workspaces:", error);
			return jsonResponse({ error: "Failed to fetch workspaces" }, 500);
		}
	};
}

export function createBulkAgentPreferenceUpdateHandler(
	dbOps: DatabaseOperations,
) {
	return async (req: Request): Promise<Response> => {
		const log = new Logger("BulkAgentPreferenceUpdate");

		try {
			const body = await req.json();

			// Validate input
			const modelValidation = validateString(body.model, "model", {
				required: true,
			});

			if (!modelValidation) {
				return errorResponse(BadRequest("Model is required"));
			}

			// Validate model is in allowed list
			const allowedModels = ALLOWED_MODELS as readonly string[];
			if (!allowedModels.includes(modelValidation)) {
				return errorResponse(
					BadRequest(
						`Invalid model. Allowed models: ${ALLOWED_MODELS.join(", ")}`,
					),
				);
			}

			// Get all agents from the registry
			const agents = await agentRegistry.getAgents();
			const agentIds = agents.map((agent) => agent.id);

			if (agentIds.length === 0) {
				return jsonResponse({ message: "No agents found to update" });
			}

			// Update all agent preferences in bulk
			dbOps.setBulkAgentPreferences(agentIds, modelValidation);

			log.info(
				`Updated ${agentIds.length} agent preferences to model: ${modelValidation}`,
			);

			return jsonResponse({
				success: true,
				updatedCount: agentIds.length,
				model: modelValidation,
			});
		} catch (error) {
			log.error("Error updating agent preferences in bulk:", error);

			if (error instanceof Error) {
				return errorResponse(BadRequest(error.message));
			}

			return jsonResponse({ error: "Failed to update agent preferences" }, 500);
		}
	};
}

================
File: packages/http-api/src/handlers/logs-history.ts
================
import {
	errorResponse,
	InternalServerError,
	jsonResponse,
} from "@ccflare/http-common";
import { logFileWriter } from "@ccflare/logger";

/**
 * Create a logs history handler to fetch past logs
 */
export function createLogsHistoryHandler() {
	return async (): Promise<Response> => {
		try {
			// Get the last 1000 logs by default
			const logs = await logFileWriter.readLogs(1000);

			return jsonResponse(logs);
		} catch (_error) {
			return errorResponse(InternalServerError("Failed to fetch log history"));
		}
	};
}

================
File: packages/http-api/src/handlers/tools.ts
================
import type { DatabaseOperations } from "@ccflare/database";
import { BadRequest, errorResponse, jsonResponse } from "@ccflare/http-common";

/**
 * Create system prompt interceptor handlers
 */
export function createSystemPromptInterceptorHandler(
	dbOps: DatabaseOperations,
) {
	return {
		/**
		 * Get system prompt interceptor configuration
		 */
		getSystemPromptConfig: (): Response => {
			const config = dbOps.getInterceptorConfig("system_prompt");

			// Return default configuration if none exists
			if (!config) {
				// Try to get the last-seen system prompt as the default target
				const lastSeenPrompt = dbOps.getSystemKV("last_seen_system_prompt");
				const DEFAULT_TARGET_PROMPT =
					"You are Claude Code, Anthropic's official CLI for Claude.";

				return jsonResponse({
					isEnabled: false,
					targetPrompt: lastSeenPrompt || DEFAULT_TARGET_PROMPT,
					replacementPrompt: "",
					toolsEnabled: true,
				});
			}

			return jsonResponse({
				isEnabled: config.isEnabled,
				targetPrompt: config.config.targetPrompt,
				replacementPrompt: config.config.replacementPrompt,
				toolsEnabled: config.config.toolsEnabled,
			});
		},

		/**
		 * Set system prompt interceptor configuration
		 */
		setSystemPromptConfig: async (req: Request): Promise<Response> => {
			try {
				const body = await req.json();

				// Validate required fields exist and have correct types
				if (body.isEnabled === undefined || body.isEnabled === null) {
					return errorResponse(BadRequest("isEnabled is required"));
				}
				if (typeof body.isEnabled !== "boolean") {
					return errorResponse(BadRequest("isEnabled must be a boolean"));
				}

				if (body.targetPrompt === undefined || body.targetPrompt === null) {
					return errorResponse(BadRequest("targetPrompt is required"));
				}
				if (typeof body.targetPrompt !== "string") {
					return errorResponse(BadRequest("targetPrompt must be a string"));
				}
				if (body.targetPrompt.trim() === "") {
					return errorResponse(BadRequest("targetPrompt cannot be empty"));
				}

				if (
					body.replacementPrompt === undefined ||
					body.replacementPrompt === null
				) {
					return errorResponse(BadRequest("replacementPrompt is required"));
				}
				if (typeof body.replacementPrompt !== "string") {
					return errorResponse(
						BadRequest("replacementPrompt must be a string"),
					);
				}

				if (body.toolsEnabled === undefined || body.toolsEnabled === null) {
					return errorResponse(BadRequest("toolsEnabled is required"));
				}
				if (typeof body.toolsEnabled !== "boolean") {
					return errorResponse(BadRequest("toolsEnabled must be a boolean"));
				}

				// Save configuration to database
				dbOps.setInterceptorConfig("system_prompt", body.isEnabled, {
					targetPrompt: body.targetPrompt,
					replacementPrompt: body.replacementPrompt,
					toolsEnabled: body.toolsEnabled,
				});

				return jsonResponse({
					success: true,
					isEnabled: body.isEnabled,
					targetPrompt: body.targetPrompt,
					replacementPrompt: body.replacementPrompt,
					toolsEnabled: body.toolsEnabled,
				});
			} catch (error) {
				if (error instanceof SyntaxError) {
					return errorResponse(BadRequest("Invalid JSON"));
				}
				throw error;
			}
		},

		/**
		 * Reset system prompt interceptor configuration
		 */
		resetSystemPromptConfig: (): Response => {
			// Delete the interceptor config, which will cause the GET endpoint
			// to return the default state with last-seen prompt
			dbOps.deleteInterceptorConfig("system_prompt");

			// Return 204 No Content to indicate successful deletion
			return new Response(null, { status: 204 });
		},
	};
}

================
File: packages/http-api/src/handlers/maintenance.ts
================
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import { jsonResponse } from "@ccflare/http-common";
import type { CleanupResponse } from "../types";

export function createCleanupHandler(
	dbOps: DatabaseOperations,
	config: Config,
) {
	return (): Response => {
		const payloadDays = config.getDataRetentionDays();
		const requestDays = config.getRequestRetentionDays();
		const payloadMs = payloadDays * 24 * 60 * 60 * 1000;
		const requestMs = requestDays * 24 * 60 * 60 * 1000;
		const { removedRequests, removedPayloads } = dbOps.cleanupOldRequests(
			payloadMs,
			requestMs,
		);
		const cutoffIso = new Date(
			Date.now() - Math.min(payloadMs, requestMs),
		).toISOString();
		const payload: CleanupResponse = {
			removedRequests,
			removedPayloads,
			cutoffIso,
		};
		return jsonResponse(payload);
	};
}

export function createCompactHandler(dbOps: DatabaseOperations) {
	return (): Response => {
		dbOps.compact();
		return jsonResponse({ ok: true });
	};
}

================
File: packages/http-api/src/handlers/health.ts
================
import type { Database } from "bun:sqlite";
import type { Config } from "@ccflare/config";
import { jsonResponse } from "@ccflare/http-common";
import type { HealthResponse } from "../types";

/**
 * Create a health check handler
 */
export function createHealthHandler(db: Database, config: Config) {
	return (): Response => {
		const accountCount = db
			.query("SELECT COUNT(*) as count FROM accounts")
			.get() as { count: number } | undefined;

		const response: HealthResponse = {
			status: "ok",
			accounts: accountCount?.count || 0,
			timestamp: new Date().toISOString(),
			strategy: config.getStrategy(),
		};

		return jsonResponse(response);
	};
}

================
File: packages/http-api/src/handlers/accounts.ts
================
import type { Database } from "bun:sqlite";
import * as cliCommands from "@ccflare/cli-commands";
import type { Config } from "@ccflare/config";
import {
	patterns,
	sanitizers,
	validateNumber,
	validateString,
} from "@ccflare/core";
import type { DatabaseOperations } from "@ccflare/database";
import {
	BadRequest,
	errorResponse,
	InternalServerError,
	jsonResponse,
	NotFound,
} from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import type { AccountResponse } from "../types";

const log = new Logger("AccountsHandler");

/**
 * Create an accounts list handler
 */
export function createAccountsListHandler(db: Database) {
	return (): Response => {
		const now = Date.now();
		const sessionDuration = 5 * 60 * 60 * 1000; // 5 hours

		const accounts = db
			.query(
				`
				SELECT 
					id,
					name,
					provider,
					request_count,
					total_requests,
					last_used,
					created_at,
					expires_at,
					rate_limited_until,
					rate_limit_reset,
					rate_limit_status,
					rate_limit_remaining,
					session_start,
					session_request_count,
					COALESCE(account_tier, 1) as account_tier,
					COALESCE(paused, 0) as paused,
					CASE 
						WHEN expires_at > ?1 THEN 1 
						ELSE 0 
					END as token_valid,
					CASE 
						WHEN rate_limited_until > ?2 THEN 1
						ELSE 0
					END as rate_limited,
					CASE
						WHEN session_start IS NOT NULL AND ?3 - session_start < ?4 THEN
							'Active: ' || session_request_count || ' reqs'
						ELSE '-'
					END as session_info
				FROM accounts
				ORDER BY request_count DESC
			`,
			)
			.all(now, now, now, sessionDuration) as Array<{
			id: string;
			name: string;
			provider: string | null;
			request_count: number;
			total_requests: number;
			last_used: number | null;
			created_at: number;
			expires_at: number | null;
			rate_limited_until: number | null;
			rate_limit_reset: number | null;
			rate_limit_status: string | null;
			rate_limit_remaining: number | null;
			session_start: number | null;
			session_request_count: number;
			account_tier: number;
			paused: 0 | 1;
			token_valid: 0 | 1;
			rate_limited: 0 | 1;
			session_info: string | null;
		}>;

		const response: AccountResponse[] = accounts.map((account) => {
			let rateLimitStatus = "OK";

			// Use unified rate limit status if available
			if (account.rate_limit_status) {
				rateLimitStatus = account.rate_limit_status;
				if (account.rate_limit_reset && account.rate_limit_reset > now) {
					const minutesLeft = Math.ceil(
						(account.rate_limit_reset - now) / 60000,
					);
					rateLimitStatus = `${account.rate_limit_status} (${minutesLeft}m)`;
				}
			} else if (
				account.rate_limited &&
				account.rate_limited_until &&
				account.rate_limited_until > now
			) {
				// Fall back to legacy rate limit check
				const minutesLeft = Math.ceil(
					(account.rate_limited_until - now) / 60000,
				);
				rateLimitStatus = `Rate limited (${minutesLeft}m)`;
			}

			return {
				id: account.id,
				name: account.name,
				provider: account.provider || "anthropic",
				requestCount: account.request_count,
				totalRequests: account.total_requests,
				lastUsed: account.last_used
					? new Date(account.last_used).toISOString()
					: null,
				created: new Date(account.created_at).toISOString(),
				tier: account.account_tier,
				paused: account.paused === 1,
				tokenStatus: account.token_valid ? "valid" : "expired",
				tokenExpiresAt: account.expires_at
					? new Date(account.expires_at).toISOString()
					: null,
				rateLimitStatus,
				rateLimitReset: account.rate_limit_reset
					? new Date(account.rate_limit_reset).toISOString()
					: null,
				rateLimitRemaining: account.rate_limit_remaining,
				sessionInfo: account.session_info || "",
			};
		});

		return jsonResponse(response);
	};
}

/**
 * Create an account tier update handler
 */
export function createAccountTierUpdateHandler(dbOps: DatabaseOperations) {
	return async (req: Request, accountId: string): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate tier input
			const tier = validateNumber(body.tier, "tier", {
				required: true,
				allowedValues: [1, 5, 20] as const,
			});

			if (tier === undefined) {
				return errorResponse(BadRequest("Tier is required"));
			}

			dbOps.updateAccountTier(accountId, tier);

			return jsonResponse({ success: true, tier });
		} catch (_error) {
			return errorResponse(
				InternalServerError("Failed to update account tier"),
			);
		}
	};
}

/**
 * Create an account add handler (manual token addition)
 * This is primarily used for adding accounts with existing tokens
 * For OAuth flow, use the OAuth handlers
 */
export function createAccountAddHandler(
	dbOps: DatabaseOperations,
	_config: Config,
) {
	return async (req: Request): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate account name
			const name = validateString(body.name, "name", {
				required: true,
				minLength: 1,
				maxLength: 100,
				pattern: patterns.accountName,
				transform: sanitizers.trim,
			});

			if (!name) {
				return errorResponse(BadRequest("Account name is required"));
			}

			// Validate tokens
			const accessToken = validateString(body.accessToken, "accessToken", {
				required: true,
				minLength: 1,
			});

			const refreshToken = validateString(body.refreshToken, "refreshToken", {
				required: true,
				minLength: 1,
			});

			if (!accessToken || !refreshToken) {
				return errorResponse(
					BadRequest("Access token and refresh token are required"),
				);
			}

			// Validate provider
			const provider =
				validateString(body.provider, "provider", {
					allowedValues: ["anthropic"] as const,
				}) || "anthropic";

			// Validate tier
			const tier = (validateNumber(body.tier, "tier", {
				allowedValues: [1, 5, 20] as const,
			}) || 1) as 1 | 5 | 20;

			try {
				// Add account directly to database
				const accountId = crypto.randomUUID();
				const now = Date.now();

				dbOps.getDatabase().run(
					`INSERT INTO accounts (
						id, name, provider, refresh_token, access_token,
						created_at, request_count, total_requests, account_tier
					) VALUES (?, ?, ?, ?, ?, ?, 0, 0, ?)`,
					[accountId, name, provider, refreshToken, accessToken, now, tier],
				);

				return jsonResponse({
					success: true,
					message: `Account ${name} added successfully`,
					tier,
					accountId,
				});
			} catch (error) {
				if (
					error instanceof Error &&
					error.message.includes("already exists")
				) {
					return errorResponse(BadRequest(error.message));
				}
				return errorResponse(InternalServerError((error as Error).message));
			}
		} catch (error) {
			log.error("Account add error:", error);
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to add account"),
			);
		}
	};
}

/**
 * Create an account remove handler
 */
export function createAccountRemoveHandler(dbOps: DatabaseOperations) {
	return async (req: Request, accountName: string): Promise<Response> => {
		try {
			// Parse and validate confirmation
			const body = await req.json();

			// Validate confirmation string
			const confirm = validateString(body.confirm, "confirm", {
				required: true,
			});

			if (confirm !== accountName) {
				return errorResponse(
					BadRequest("Confirmation string does not match account name", {
						confirmationRequired: true,
					}),
				);
			}

			const result = cliCommands.removeAccount(dbOps, accountName);

			if (!result.success) {
				return errorResponse(NotFound(result.message));
			}

			return jsonResponse({
				success: true,
				message: result.message,
			});
		} catch (error) {
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to remove account"),
			);
		}
	};
}

/**
 * Create an account pause handler
 */
export function createAccountPauseHandler(dbOps: DatabaseOperations) {
	return async (_req: Request, accountId: string): Promise<Response> => {
		try {
			// Get account name by ID
			const db = dbOps.getDatabase();
			const account = db
				.query<{ name: string }, [string]>(
					"SELECT name FROM accounts WHERE id = ?",
				)
				.get(accountId);

			if (!account) {
				return errorResponse(NotFound("Account not found"));
			}

			const result = cliCommands.pauseAccount(dbOps, account.name);

			if (!result.success) {
				return errorResponse(BadRequest(result.message));
			}

			return jsonResponse({
				success: true,
				message: result.message,
			});
		} catch (error) {
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to pause account"),
			);
		}
	};
}

/**
 * Create an account resume handler
 */
export function createAccountResumeHandler(dbOps: DatabaseOperations) {
	return async (_req: Request, accountId: string): Promise<Response> => {
		try {
			// Get account name by ID
			const db = dbOps.getDatabase();
			const account = db
				.query<{ name: string }, [string]>(
					"SELECT name FROM accounts WHERE id = ?",
				)
				.get(accountId);

			if (!account) {
				return errorResponse(NotFound("Account not found"));
			}

			const result = cliCommands.resumeAccount(dbOps, account.name);

			if (!result.success) {
				return errorResponse(BadRequest(result.message));
			}

			return jsonResponse({
				success: true,
				message: result.message,
			});
		} catch (error) {
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to resume account"),
			);
		}
	};
}

/**
 * Create an account rename handler
 */
export function createAccountRenameHandler(dbOps: DatabaseOperations) {
	return async (req: Request, accountId: string): Promise<Response> => {
		try {
			const body = await req.json();

			// Validate new name
			const newName = validateString(body.name, "name", {
				required: true,
				minLength: 1,
				maxLength: 100,
				pattern: patterns.accountName,
				transform: sanitizers.trim,
			});

			if (!newName) {
				return errorResponse(BadRequest("New account name is required"));
			}

			// Check if account exists
			const db = dbOps.getDatabase();
			const account = db
				.query<{ name: string }, [string]>(
					"SELECT name FROM accounts WHERE id = ?",
				)
				.get(accountId);

			if (!account) {
				return errorResponse(NotFound("Account not found"));
			}

			// Check if new name is already taken
			const existingAccount = db
				.query<{ id: string }, [string, string]>(
					"SELECT id FROM accounts WHERE name = ? AND id != ?",
				)
				.get(newName, accountId);

			if (existingAccount) {
				return errorResponse(
					BadRequest(`Account name '${newName}' is already taken`),
				);
			}

			// Rename the account
			dbOps.renameAccount(accountId, newName);

			return jsonResponse({
				success: true,
				message: `Account renamed from '${account.name}' to '${newName}'`,
				newName,
			});
		} catch (error) {
			log.error("Account rename error:", error);
			return errorResponse(
				error instanceof Error ? error : new Error("Failed to rename account"),
			);
		}
	};
}

================
File: packages/http-api/src/handlers/config.ts
================
import type { Config } from "@ccflare/config";
import {
	DEFAULT_AGENT_MODEL,
	NETWORK,
	STRATEGIES,
	type StrategyName,
	TIME_CONSTANTS,
	validateNumber,
	validateString,
} from "@ccflare/core";
import { BadRequest, errorResponse, jsonResponse } from "@ccflare/http-common";
import type { ConfigResponse, RetentionSetRequest } from "../types";

/**
 * Create config handlers
 */
export function createConfigHandlers(config: Config) {
	return {
		/**
		 * Get all configuration settings
		 */
		getConfig: (): Response => {
			const settings = config.getAllSettings();
			const response: ConfigResponse = {
				lb_strategy: (settings.lb_strategy as string) || "round_robin",
				port: (settings.port as number) || NETWORK.DEFAULT_PORT,
				sessionDurationMs:
					(settings.sessionDurationMs as number) ||
					TIME_CONSTANTS.SESSION_DURATION_FALLBACK,
				default_agent_model:
					(settings.default_agent_model as string) || DEFAULT_AGENT_MODEL,
			};
			return jsonResponse(response);
		},

		/**
		 * Get current strategy
		 */
		getStrategy: (): Response => {
			const strategy = config.getStrategy();
			return jsonResponse({ strategy });
		},

		/**
		 * Update strategy
		 */
		setStrategy: async (req: Request): Promise<Response> => {
			const body = await req.json();

			// Validate strategy input
			const strategyValidation = validateString(body.strategy, "strategy", {
				required: true,
				allowedValues: STRATEGIES,
			});

			if (!strategyValidation) {
				return errorResponse(BadRequest("Strategy is required"));
			}

			const strategy = strategyValidation as StrategyName;
			config.setStrategy(strategy);

			return jsonResponse({ success: true, strategy });
		},

		/**
		 * Get available strategies
		 */
		getStrategies: (): Response => {
			return jsonResponse(STRATEGIES);
		},

		/**
		 * Get default agent model
		 */
		getDefaultAgentModel: (): Response => {
			const model = config.getDefaultAgentModel();
			return jsonResponse({ model });
		},

		/**
		 * Set default agent model
		 */
		setDefaultAgentModel: async (req: Request): Promise<Response> => {
			const body = await req.json();

			// Validate model input
			const modelValidation = validateString(body.model, "model", {
				required: true,
			});

			if (!modelValidation) {
				return errorResponse(BadRequest("Model is required"));
			}

			config.setDefaultAgentModel(modelValidation);

			return jsonResponse({ success: true, model: modelValidation });
		},

		/**
		 * Get current data retention in days
		 */
		getRetention: (): Response => {
			return jsonResponse({
				payloadDays: config.getDataRetentionDays(),
				requestDays: config.getRequestRetentionDays(),
			});
		},

		/**
		 * Set data retention in days
		 */
		setRetention: async (req: Request): Promise<Response> => {
			const body = (await req.json()) as RetentionSetRequest;
			let updated = false;
			if (body.payloadDays !== undefined) {
				const payloadDays = validateNumber(body.payloadDays, "payloadDays", {
					min: 1,
					max: 365,
					integer: true,
				});
				if (typeof payloadDays !== "number") {
					return errorResponse(BadRequest("Invalid 'payloadDays'"));
				}
				config.setDataRetentionDays(payloadDays);
				updated = true;
			}
			if (body.requestDays !== undefined) {
				const requestDays = validateNumber(body.requestDays, "requestDays", {
					min: 1,
					max: 3650,
					integer: true,
				});
				if (typeof requestDays !== "number") {
					return errorResponse(BadRequest("Invalid 'requestDays'"));
				}
				config.setRequestRetentionDays(requestDays);
				updated = true;
			}
			if (!updated) {
				return errorResponse(BadRequest("No retention fields provided"));
			}
			return new Response(null, { status: 204 });
		},
	};
}

================
File: packages/http-api/src/handlers/agents-update.ts
================
import { agentRegistry } from "@ccflare/agents";
import type { DatabaseOperations } from "@ccflare/database";
import { errorResponse, jsonResponse } from "@ccflare/http-common";
import type { AgentTool, AllowedModel } from "@ccflare/types";
import { ALLOWED_MODELS, TOOL_PRESETS } from "@ccflare/types";

type ToolMode = keyof typeof TOOL_PRESETS | "custom";

interface AgentUpdateRequest {
	description?: string;
	model?: AllowedModel;
	tools?: AgentTool[];
	color?: string;
	systemPrompt?: string;
	mode?: ToolMode;
}

export function createAgentUpdateHandler(dbOps: DatabaseOperations) {
	return async (req: Request, agentId: string): Promise<Response> => {
		try {
			const body = (await req.json()) as AgentUpdateRequest;

			// Validate individual pieces
			const updates: Partial<{
				description: string;
				model: AllowedModel;
				tools: AgentTool[];
				color: string;
				systemPrompt: string;
			}> = {};

			if (body.description !== undefined) {
				if (typeof body.description !== "string") {
					return errorResponse("Description must be a string");
				}
				updates.description = body.description;
			}

			if (body.model !== undefined) {
				if (!ALLOWED_MODELS.includes(body.model)) {
					return errorResponse(
						`Model must be one of: ${ALLOWED_MODELS.join(", ")}`,
					);
				}
				updates.model = body.model;
			}

			if (body.color !== undefined) {
				if (typeof body.color !== "string") {
					return errorResponse("Color must be a string");
				}
				updates.color = body.color;
			}

			if (body.systemPrompt !== undefined) {
				if (typeof body.systemPrompt !== "string") {
					return errorResponse("System prompt must be a string");
				}
				updates.systemPrompt = body.systemPrompt;
			}

			// Handle tools - either from mode or explicit tools array
			if (body.mode !== undefined) {
				if (body.mode === "custom") {
					if (!body.tools || !Array.isArray(body.tools)) {
						return errorResponse(
							"Tools array is required when mode is 'custom'",
						);
					}
					updates.tools = body.tools;
				} else if (body.mode in TOOL_PRESETS) {
					updates.tools = TOOL_PRESETS[body.mode];
				} else {
					return errorResponse(
						`Invalid mode. Must be one of: ${Object.keys(TOOL_PRESETS).join(", ")}, custom`,
					);
				}
			} else if (body.tools !== undefined) {
				if (!Array.isArray(body.tools)) {
					return errorResponse("Tools must be an array");
				}
				updates.tools = body.tools;
			}

			// Update agent using the registry
			const updated = await agentRegistry.updateAgent(agentId, updates, {
				deleteAgentPreference: (id: string) => dbOps.deleteAgentPreference(id),
			});

			return jsonResponse({ success: true, agent: updated });
		} catch (error) {
			if (error instanceof Error && error.message.includes("not found")) {
				return errorResponse(`Agent with id ${agentId} not found`);
			}
			console.error("Error updating agent:", error);
			return errorResponse("Failed to update agent");
		}
	};
}

================
File: packages/providers/package.json
================
{
	"name": "@ccflare/providers",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*"
	}
}

================
File: packages/providers/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/providers/src/base.ts
================
import type { Account } from "@ccflare/types";
import type { Provider, RateLimitInfo, TokenRefreshResult } from "./types";

export abstract class BaseProvider implements Provider {
	abstract name: string;

	/**
	 * Check if this provider can handle the given request path
	 * Default implementation: handle all paths
	 */
	canHandle(_path: string): boolean {
		return true;
	}

	/**
	 * Refresh the access token for an account
	 * Must be implemented by each provider
	 */
	abstract refreshToken(
		account: Account,
		clientId: string,
	): Promise<TokenRefreshResult>;

	/**
	 * Build the target URL for the provider
	 * Must be implemented by each provider
	 */
	abstract buildUrl(path: string, query: string): string;

	/**
	 * Prepare headers for the provider request
	 * Default implementation: Add Bearer token (if provided) and remove host header
	 * @param headers - Original request headers
	 * @param accessToken - OAuth access token (for Bearer authentication)
	 * @param apiKey - API key (provider-specific header)
	 */
	prepareHeaders(
		headers: Headers,
		accessToken?: string,
		_apiKey?: string,
	): Headers {
		const newHeaders = new Headers(headers);
		if (accessToken) {
			newHeaders.set("Authorization", `Bearer ${accessToken}`);
		}
		// Note: API key handling is provider-specific and should be
		// implemented in the provider subclass
		newHeaders.delete("host");
		return newHeaders;
	}

	/**
	 * Parse rate limit information from response
	 * Default implementation: Check unified headers first, then fall back to 429 status
	 *
	 * Note: The default implementation considers any unified status other than "allowed"
	 * to be a hard rate limit. Providers should override this method if they need to
	 * distinguish between soft warnings (e.g., "allowed_warning") and hard limits.
	 */
	parseRateLimit(response: Response): RateLimitInfo {
		// Check for unified rate limit headers (used by Anthropic and others)
		const statusHeader = response.headers.get(
			"anthropic-ratelimit-unified-status",
		);
		const resetHeader = response.headers.get(
			"anthropic-ratelimit-unified-reset",
		);

		if (statusHeader || resetHeader) {
			const resetTime = resetHeader ? Number(resetHeader) * 1000 : undefined; // Convert to ms
			return {
				isRateLimited: statusHeader !== "allowed",
				resetTime,
				statusHeader: statusHeader || undefined,
			};
		}

		// Fall back to traditional 429 check
		if (response.status !== 429) {
			return { isRateLimited: false };
		}

		// Try to extract reset time from headers
		const retryAfter = response.headers.get("retry-after");
		let resetTime: number | undefined;

		if (retryAfter) {
			// Retry-After can be seconds or HTTP date
			const seconds = Number(retryAfter);
			if (!Number.isNaN(seconds)) {
				resetTime = Date.now() + seconds * 1000;
			} else {
				resetTime = new Date(retryAfter).getTime();
			}
		}

		return { isRateLimited: true, resetTime };
	}

	/**
	 * Process the response before returning to client
	 * Default implementation: Return response as-is
	 */
	async processResponse(
		response: Response,
		_account: Account | null,
	): Promise<Response> {
		return response;
	}

	/**
	 * Extract tier information from response if available
	 * Default implementation: Return null (no tier info)
	 */
	async extractTierInfo?(_response: Response): Promise<number | null> {
		return null;
	}

	/**
	 * Extract usage information from response if available
	 * Default implementation: Return null (no usage info)
	 */
	async extractUsageInfo?(_response: Response): Promise<{
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
	} | null> {
		return null;
	}

	/**
	 * Check if the response is a streaming response
	 * Default implementation: Check for text/event-stream or stream in content-type
	 */
	isStreamingResponse?(response: Response): boolean {
		const contentType = response.headers.get("content-type") ?? "";
		return (
			contentType.includes("text/event-stream") ||
			contentType.includes("stream")
		);
	}
}

================
File: packages/providers/src/types.ts
================
import type { Account } from "@ccflare/types";

export interface TokenRefreshResult {
	accessToken: string;
	expiresAt: number;
	refreshToken: string; // Always required - either new token or existing one
}

export interface RateLimitInfo {
	isRateLimited: boolean;
	resetTime?: number;
	statusHeader?: string;
	remaining?: number;
}

export interface Provider {
	name: string;

	/**
	 * Check if this provider can handle the given request path
	 */
	canHandle(path: string): boolean;

	/**
	 * Refresh the access token for an account
	 */
	refreshToken(account: Account, clientId: string): Promise<TokenRefreshResult>;

	/**
	 * Build the target URL for the provider
	 */
	buildUrl(path: string, query: string): string;

	/**
	 * Prepare headers for the provider request
	 * @param headers - Original request headers
	 * @param accessToken - OAuth access token (for Bearer authentication)
	 * @param apiKey - API key (provider-specific header)
	 */
	prepareHeaders(
		headers: Headers,
		accessToken?: string,
		apiKey?: string,
	): Headers;

	/**
	 * Parse rate limit information from response
	 */
	parseRateLimit(response: Response): RateLimitInfo;

	/**
	 * Process the response before returning to client
	 */
	processResponse(
		response: Response,
		account: Account | null,
	): Promise<Response>;

	/**
	 * Extract tier information from response if available
	 */
	extractTierInfo?(response: Response): Promise<number | null>;

	/**
	 * Extract usage information from response if available
	 */
	extractUsageInfo?(response: Response): Promise<{
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
	} | null>;

	/**
	 * Check if the response is a streaming response
	 */
	isStreamingResponse?(response: Response): boolean;
}

// OAuth-specific types
export interface OAuthProviderConfig {
	authorizeUrl: string;
	tokenUrl: string;
	clientId: string;
	scopes: string[];
	redirectUri: string;
	mode?: string;
}

export interface OAuthProvider {
	getOAuthConfig(mode?: string): OAuthProviderConfig;
	exchangeCode(
		code: string,
		verifier: string,
		config: OAuthProviderConfig,
	): Promise<TokenResult>;
	generateAuthUrl(config: OAuthProviderConfig, pkce: PKCEChallenge): string;
}

export interface PKCEChallenge {
	verifier: string;
	challenge: string;
}

export interface TokenResult {
	refreshToken: string;
	accessToken: string;
	expiresAt: number;
}

================
File: packages/providers/src/registry.ts
================
import type { OAuthProvider, Provider } from "./types";

class ProviderRegistry {
	private providers = new Map<string, Provider>();
	private oauthProviders = new Map<string, OAuthProvider>();

	/**
	 * Register a provider
	 */
	registerProvider(provider: Provider): void {
		this.providers.set(provider.name, provider);

		// Auto-register OAuth provider if supported
		if (
			"supportsOAuth" in provider &&
			typeof provider.supportsOAuth === "function" &&
			"getOAuthProvider" in provider &&
			typeof provider.getOAuthProvider === "function"
		) {
			const supportsOAuth = provider.supportsOAuth as () => boolean;
			if (supportsOAuth()) {
				const getOAuthProvider =
					provider.getOAuthProvider as () => OAuthProvider;
				const oauthProvider = getOAuthProvider();
				this.oauthProviders.set(provider.name, oauthProvider);
			}
		}
	}

	/**
	 * Get a provider by name
	 */
	getProvider(name: string): Provider | undefined {
		return this.providers.get(name);
	}

	/**
	 * Get an OAuth provider by name
	 */
	getOAuthProvider(name: string): OAuthProvider | undefined {
		return this.oauthProviders.get(name);
	}

	/**
	 * List all registered provider names
	 */
	listProviders(): string[] {
		return Array.from(this.providers.keys());
	}

	/**
	 * List all providers that support OAuth
	 */
	listOAuthProviders(): string[] {
		return Array.from(this.oauthProviders.keys());
	}

	/**
	 * Unregister a provider (useful for testing)
	 */
	unregisterProvider(name: string): boolean {
		this.oauthProviders.delete(name);
		return this.providers.delete(name);
	}

	/**
	 * Clear all providers (useful for testing)
	 */
	clear(): void {
		this.providers.clear();
		this.oauthProviders.clear();
	}
}

// Create singleton registry instance
export const registry = new ProviderRegistry();

// Export convenience functions
export const registerProvider = (provider: Provider) =>
	registry.registerProvider(provider);
export const getProvider = (name: string) => registry.getProvider(name);
export const getOAuthProvider = (name: string) =>
	registry.getOAuthProvider(name);
export const listProviders = () => registry.listProviders();
export const listOAuthProviders = () => registry.listOAuthProviders();

================
File: packages/providers/src/index.ts
================
// Export all types

// Export base provider class
export { BaseProvider } from "./base";
// Export OAuth utilities
export * from "./oauth";
// Export providers
export * from "./providers/index";
// Export registry functions
export {
	getOAuthProvider,
	getProvider,
	listOAuthProviders,
	listProviders,
	registerProvider,
} from "./registry";
export * from "./types";

import { AnthropicProvider } from "./providers/anthropic/provider";
// Auto-register built-in providers
import { registry } from "./registry";

registry.registerProvider(new AnthropicProvider());

================
File: packages/providers/src/oauth/base-oauth-provider.ts
================
import { generatePKCE } from "./pkce";

export interface OAuthConfig {
	clientId: string;
	authorizationUrl: string;
	tokenUrl: string;
	redirectUri: string;
	scopes: string[];
}

export interface OAuthTokens {
	accessToken: string;
	refreshToken?: string;
	expiresAt: number;
}

/**
 * Base class for OAuth providers to reduce duplication
 */
export abstract class BaseOAuthProvider {
	protected config: OAuthConfig;

	constructor(config: OAuthConfig) {
		this.config = config;
	}

	/**
	 * Generate authorization URL with PKCE
	 */
	async generateAuthUrl(
		state: string,
	): Promise<{ url: string; verifier: string }> {
		const { challenge: codeChallenge, verifier: codeVerifier } =
			await generatePKCE();

		const params = new URLSearchParams({
			response_type: "code",
			client_id: this.config.clientId,
			redirect_uri: this.config.redirectUri,
			scope: this.config.scopes.join(" "),
			state,
			code_challenge: codeChallenge,
			code_challenge_method: "S256",
		});

		// Allow subclasses to add custom parameters
		this.addCustomAuthParams(params);

		const url = `${this.config.authorizationUrl}?${params.toString()}`;
		return { url, verifier: codeVerifier };
	}

	/**
	 * Exchange authorization code for tokens
	 */
	async exchangeCodeForTokens(
		code: string,
		verifier: string,
	): Promise<OAuthTokens> {
		const body = new URLSearchParams({
			grant_type: "authorization_code",
			client_id: this.config.clientId,
			code,
			redirect_uri: this.config.redirectUri,
			code_verifier: verifier,
		});

		// Allow subclasses to add custom token parameters
		this.addCustomTokenParams(body);

		const response = await fetch(this.config.tokenUrl, {
			method: "POST",
			headers: {
				"Content-Type": "application/x-www-form-urlencoded",
			},
			body: body.toString(),
		});

		if (!response.ok) {
			const error = await response.text();
			throw new Error(`Token exchange failed: ${error}`);
		}

		const data = await response.json();
		return this.parseTokenResponse(data);
	}

	/**
	 * Refresh tokens using refresh token
	 */
	async refreshTokens(refreshToken: string): Promise<OAuthTokens> {
		const body = new URLSearchParams({
			grant_type: "refresh_token",
			client_id: this.config.clientId,
			refresh_token: refreshToken,
		});

		const response = await fetch(this.config.tokenUrl, {
			method: "POST",
			headers: {
				"Content-Type": "application/x-www-form-urlencoded",
			},
			body: body.toString(),
		});

		if (!response.ok) {
			const error = await response.text();
			throw new Error(`Token refresh failed: ${error}`);
		}

		const data = await response.json();
		return this.parseTokenResponse(data);
	}

	/**
	 * Hook for subclasses to add custom authorization parameters
	 */
	protected addCustomAuthParams(_params: URLSearchParams): void {
		// Default implementation does nothing
	}

	/**
	 * Hook for subclasses to add custom token exchange parameters
	 */
	protected addCustomTokenParams(_params: URLSearchParams): void {
		// Default implementation does nothing
	}

	/**
	 * Parse token response - must be implemented by subclasses
	 */
	protected abstract parseTokenResponse(data: unknown): OAuthTokens;
}

================
File: packages/providers/src/oauth/index.ts
================
export { BaseOAuthProvider, type OAuthTokens } from "./base-oauth-provider";
export { generatePKCE } from "./pkce";

================
File: packages/providers/src/oauth/pkce.ts
================
import type { PKCEChallenge } from "../types";

/**
 * Generate a PKCE challenge for OAuth flows
 */
export async function generatePKCE(): Promise<PKCEChallenge> {
	// Generate random verifier
	const verifierBytes = new Uint8Array(32);
	crypto.getRandomValues(verifierBytes);
	const verifier = base64urlEncode(verifierBytes);

	// Calculate SHA-256 challenge
	const encoder = new TextEncoder();
	const data = encoder.encode(verifier);
	const hashBuffer = await crypto.subtle.digest("SHA-256", data);
	const challenge = base64urlEncode(new Uint8Array(hashBuffer));

	return { verifier, challenge };
}

/**
 * Base64 URL encode without padding
 */
function base64urlEncode(bytes: Uint8Array): string {
	const base64 = btoa(String.fromCharCode(...bytes));
	return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}

================
File: packages/providers/src/providers/index.ts
================
export {
	AnthropicOAuthProvider,
	AnthropicProvider,
} from "./anthropic/index";

================
File: packages/providers/src/providers/anthropic/oauth.ts
================
import { OAuthError } from "@ccflare/core";
import type {
	OAuthProvider,
	OAuthProviderConfig,
	PKCEChallenge,
	TokenResult,
} from "../../types";

export class AnthropicOAuthProvider implements OAuthProvider {
	getOAuthConfig(mode: "console" | "max" = "console"): OAuthProviderConfig {
		const baseUrl =
			mode === "console"
				? "https://console.anthropic.com"
				: "https://claude.ai";

		return {
			authorizeUrl: `${baseUrl}/oauth/authorize`,
			tokenUrl: "https://console.anthropic.com/v1/oauth/token",
			clientId: "", // Will be passed from config
			scopes: ["org:create_api_key", "user:profile", "user:inference"],
			redirectUri: "https://console.anthropic.com/oauth/code/callback",
			mode,
		};
	}

	generateAuthUrl(config: OAuthProviderConfig, pkce: PKCEChallenge): string {
		const url = new URL(config.authorizeUrl);
		url.searchParams.set("code", "true");
		url.searchParams.set("client_id", config.clientId);
		url.searchParams.set("response_type", "code");
		url.searchParams.set("redirect_uri", config.redirectUri);
		url.searchParams.set("scope", config.scopes.join(" "));
		url.searchParams.set("code_challenge", pkce.challenge);
		url.searchParams.set("code_challenge_method", "S256");
		url.searchParams.set("state", pkce.verifier);
		return url.toString();
	}

	async exchangeCode(
		code: string,
		verifier: string,
		config: OAuthProviderConfig,
	): Promise<TokenResult> {
		const splits = code.split("#");
		const response = await fetch(config.tokenUrl, {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify({
				code: splits[0],
				state: splits[1],
				grant_type: "authorization_code",
				client_id: config.clientId,
				redirect_uri: config.redirectUri,
				code_verifier: verifier,
			}),
		});

		if (!response.ok) {
			let errorDetails: { error?: string; error_description?: string } | null =
				null;
			try {
				errorDetails = await response.json();
			} catch {
				// Failed to parse error response
			}

			const errorMessage =
				errorDetails?.error_description ||
				errorDetails?.error ||
				response.statusText ||
				"OAuth token exchange failed";

			throw new OAuthError(errorMessage, "anthropic", errorDetails?.error);
		}

		const json = (await response.json()) as {
			refresh_token: string;
			access_token: string;
			expires_in: number;
		};

		return {
			refreshToken: json.refresh_token,
			accessToken: json.access_token,
			expiresAt: Date.now() + json.expires_in * 1000,
		};
	}
}

================
File: packages/providers/src/providers/anthropic/index.ts
================
export { AnthropicOAuthProvider } from "./oauth";
export { AnthropicProvider } from "./provider";

================
File: packages/providers/src/providers/anthropic/provider.ts
================
import { BUFFER_SIZES } from "@ccflare/core";
import { sanitizeProxyHeaders } from "@ccflare/http-common";
import { Logger } from "@ccflare/logger";
import type { Account } from "@ccflare/types";
import { BaseProvider } from "../../base";
import type { RateLimitInfo, TokenRefreshResult } from "../../types";

// Hard rate limit statuses that should block account usage
const HARD_LIMIT_STATUSES = new Set([
	"rate_limited",
	"blocked",
	"queueing_hard",
	"payment_required",
]);

// Soft warning statuses that should not block account usage
const _SOFT_WARNING_STATUSES = new Set(["allowed_warning", "queueing_soft"]);

const log = new Logger("AnthropicProvider");

export class AnthropicProvider extends BaseProvider {
	name = "anthropic";

	canHandle(_path: string): boolean {
		// Handle all paths for now since this is Anthropic-specific
		return true;
	}

	async refreshToken(
		account: Account,
		clientId: string,
	): Promise<TokenRefreshResult> {
		if (!account.refresh_token) {
			throw new Error(`No refresh token available for account ${account.name}`);
		}

		log.info(
			`Refreshing token for account ${account.name} with client ID: ${clientId}`,
		);

		const response = await fetch(
			"https://console.anthropic.com/v1/oauth/token",
			{
				method: "POST",
				headers: {
					"Content-Type": "application/json",
				},
				body: JSON.stringify({
					grant_type: "refresh_token",
					refresh_token: account.refresh_token,
					client_id: clientId,
				}),
			},
		);

		if (!response.ok) {
			let errorMessage = response.statusText;
			let errorData: unknown = null;
			try {
				errorData = await response.json();
				const errorObj = errorData as { error?: string; message?: string };
				errorMessage = errorObj.error || errorObj.message || errorMessage;
			} catch {
				// If we can't parse the error response, use the status text
			}
			log.error(
				`Token refresh failed for ${account.name}: Status ${response.status}, Error: ${errorMessage}`,
				errorData,
			);
			throw new Error(
				`Failed to refresh token for account ${account.name}: ${errorMessage}`,
			);
		}

		const json = (await response.json()) as {
			access_token: string;
			expires_in: number;
			refresh_token?: string;
		};

		// Ensure we always return a refresh token
		const refreshToken = json.refresh_token || account.refresh_token;

		if (!json.refresh_token) {
			log.warn(
				`Anthropic refresh endpoint did not return a refresh_token for ${account.name} - continuing with previous one`,
			);
		} else {
			log.info(
				`Token refresh successful for ${account.name}, new refresh token provided`,
			);
		}

		return {
			accessToken: json.access_token,
			expiresAt: Date.now() + json.expires_in * 1000,
			refreshToken: refreshToken,
		};
	}

	buildUrl(path: string, query: string): string {
		return `https://api.anthropic.com${path}${query}`;
	}

	prepareHeaders(
		headers: Headers,
		accessToken?: string,
		apiKey?: string,
	): Headers {
		const newHeaders = new Headers(headers);

		// Set authentication header
		if (accessToken) {
			newHeaders.set("Authorization", `Bearer ${accessToken}`);
		} else if (apiKey) {
			newHeaders.set("x-api-key", apiKey);
		}

		// Remove host header
		newHeaders.delete("host");

		// Remove compression headers to avoid decompression issues
		newHeaders.delete("accept-encoding");
		newHeaders.delete("content-encoding");

		return newHeaders;
	}

	parseRateLimit(response: Response): RateLimitInfo {
		// Check for unified rate limit headers
		const statusHeader = response.headers.get(
			"anthropic-ratelimit-unified-status",
		);
		const resetHeader = response.headers.get(
			"anthropic-ratelimit-unified-reset",
		);
		const remainingHeader = response.headers.get(
			"anthropic-ratelimit-unified-remaining",
		);

		if (statusHeader || resetHeader) {
			const resetTime = resetHeader ? Number(resetHeader) * 1000 : undefined; // Convert to ms
			const remaining = remainingHeader ? Number(remainingHeader) : undefined;

			// Only mark as rate limited for hard limit statuses or 429
			const isRateLimited =
				HARD_LIMIT_STATUSES.has(statusHeader || "") || response.status === 429;

			return {
				isRateLimited,
				resetTime,
				statusHeader: statusHeader || undefined,
				remaining,
			};
		}

		// Fall back to 429 status with x-ratelimit-reset header
		if (response.status !== 429) {
			return { isRateLimited: false };
		}

		const rateLimitReset = response.headers.get("x-ratelimit-reset");
		const resetTime = rateLimitReset
			? parseInt(rateLimitReset) * 1000
			: Date.now() + 60000; // Default to 1 minute

		return {
			isRateLimited: true,
			resetTime,
		};
	}

	async processResponse(
		response: Response,
		_account: Account | null,
	): Promise<Response> {
		// Sanitize headers by removing hop-by-hop headers
		const headers = sanitizeProxyHeaders(response.headers);

		return new Response(response.body, {
			status: response.status,
			statusText: response.statusText,
			headers,
		});
	}

	async extractTierInfo(response: Response): Promise<number | null> {
		try {
			const clone = response.clone();
			const json = (await clone.json()) as {
				type?: string;
				usage?: {
					rate_limit_tokens?: number;
				};
			};

			// Check for tier information in response
			if (json.type === "message" && json.usage?.rate_limit_tokens) {
				const rateLimit = json.usage.rate_limit_tokens;
				if (rateLimit >= 800000) return 20;
				if (rateLimit >= 200000) return 5;
				return 1;
			}
		} catch {
			// Ignore JSON parsing errors
		}

		return null;
	}

	async extractUsageInfo(response: Response): Promise<{
		model?: string;
		promptTokens?: number;
		completionTokens?: number;
		totalTokens?: number;
		costUsd?: number;
		inputTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		outputTokens?: number;
	} | null> {
		try {
			const clone = response.clone();
			const contentType = response.headers.get("content-type");

			// Handle streaming responses (SSE)
			if (contentType?.includes("text/event-stream")) {
				// Use bounded reader to avoid consuming entire stream
				const reader = clone.body?.getReader();
				if (!reader) return null;

				let buffered = "";
				const maxBytes = BUFFER_SIZES.ANTHROPIC_STREAM_CAP_BYTES;
				const decoder = new TextDecoder();
				let foundMessageStart = false;

				try {
					while (buffered.length < maxBytes) {
						const { value, done } = await reader.read();
						if (done) break;

						buffered += decoder.decode(value, { stream: true });

						// Check if we have the message_start event
						if (buffered.includes("event: message_start")) {
							foundMessageStart = true;
							// Read a bit more to ensure we get the data line
							const { value: nextValue, done: nextDone } = await reader.read();
							if (!nextDone && nextValue) {
								buffered += decoder.decode(nextValue, { stream: true });
							}
							break;
						}
					}
				} finally {
					// Cancel the reader to prevent hanging
					reader.cancel().catch(() => {});
				}

				if (!foundMessageStart) return null;

				// Parse the buffered content
				const lines = buffered.split("\n");

				// Parse SSE events
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i];
					if (line.startsWith("event: message_start")) {
						// Next line should be the data
						const dataLine = lines[i + 1];
						if (dataLine?.startsWith("data: ")) {
							try {
								const jsonStr = dataLine.slice(6); // Remove "data: " prefix
								const data = JSON.parse(jsonStr) as {
									message?: {
										model?: string;
										usage?: {
											input_tokens?: number;
											output_tokens?: number;
											cache_creation_input_tokens?: number;
											cache_read_input_tokens?: number;
										};
									};
								};

								if (data.message?.usage) {
									const usage = data.message.usage;
									const inputTokens = usage.input_tokens || 0;
									const cacheCreationInputTokens =
										usage.cache_creation_input_tokens || 0;
									const cacheReadInputTokens =
										usage.cache_read_input_tokens || 0;
									const outputTokens = usage.output_tokens || 0;
									const promptTokens =
										inputTokens +
										cacheCreationInputTokens +
										cacheReadInputTokens;
									const completionTokens = outputTokens;
									const totalTokens = promptTokens + completionTokens;

									// Extract cost from header if available
									const costHeader = response.headers.get(
										"anthropic-billing-cost",
									);
									const costUsd = costHeader
										? parseFloat(costHeader)
										: undefined;

									return {
										model: data.message.model,
										promptTokens,
										completionTokens,
										totalTokens,
										costUsd,
										inputTokens,
										cacheReadInputTokens,
										cacheCreationInputTokens,
										outputTokens,
									};
								}
							} catch {
								// Ignore parse errors
							}
						}
					}
				}

				// For streaming responses, we only extract initial usage
				// Output tokens will be accumulated during streaming but we can't capture that here
				return null;
			} else {
				// Handle non-streaming JSON responses
				const json = (await clone.json()) as {
					model?: string;
					usage?: {
						input_tokens?: number;
						output_tokens?: number;
						cache_creation_input_tokens?: number;
						cache_read_input_tokens?: number;
					};
				};

				if (!json.usage) return null;

				const inputTokens = json.usage.input_tokens || 0;
				const cacheCreationInputTokens =
					json.usage.cache_creation_input_tokens || 0;
				const cacheReadInputTokens = json.usage.cache_read_input_tokens || 0;
				const outputTokens = json.usage.output_tokens || 0;
				const promptTokens =
					inputTokens + cacheCreationInputTokens + cacheReadInputTokens;
				const completionTokens = outputTokens;
				const totalTokens = promptTokens + completionTokens;

				// Extract cost from header if available
				const costHeader = response.headers.get("anthropic-billing-cost");
				const costUsd = costHeader ? parseFloat(costHeader) : undefined;

				return {
					model: json.model,
					promptTokens,
					completionTokens,
					totalTokens,
					costUsd,
					inputTokens,
					cacheReadInputTokens,
					cacheCreationInputTokens,
					outputTokens,
				};
			}
		} catch {
			// Ignore parsing errors
			return null;
		}
	}

	/**
	 * Check if this provider supports OAuth
	 */
	supportsOAuth(): boolean {
		return true;
	}

	/**
	 * Get the OAuth provider for this provider
	 */
	getOAuthProvider() {
		// Lazy load to avoid circular dependencies
		const { AnthropicOAuthProvider } = require("./oauth.js");
		return new AnthropicOAuthProvider();
	}
}

================
File: packages/agents/package.json
================
{
	"name": "@ccflare/agents",
	"version": "1.0.0",
	"description": "Agent discovery and management for ccflare",
	"main": "dist/index.js",
	"types": "dist/index.d.ts",
	"scripts": {
		"build": "tsc",
		"dev": "tsc --watch",
		"clean": "rm -rf dist",
		"lint": "biome check --write",
		"format": "biome format --write",
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/config": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/types": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^22.5.4",
		"typescript": "^5.7.2"
	}
}

================
File: packages/agents/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"outDir": "./dist",
		"rootDir": "./src"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}

================
File: packages/agents/src/discovery.ts
================
import { existsSync } from "node:fs";
import { readdir, readFile, writeFile } from "node:fs/promises";
import { basename, join, resolve } from "node:path";
import { Config } from "@ccflare/config";
import { Logger } from "@ccflare/logger";
import {
	type Agent,
	type AgentTool,
	type AgentWorkspace,
	ALLOWED_MODELS,
	type AllowedModel,
} from "@ccflare/types";
import { getAgentsDirectory } from "./paths";
import { workspacePersistence } from "./workspace-persistence";

interface AgentCache {
	agents: Agent[];
	timestamp: number;
}

const CACHE_TTL_MS = 30 * 1000; // 30 seconds
const DEFAULT_COLOR = "gray";

const log = new Logger("AgentRegistry");

export class AgentRegistry {
	private cache: AgentCache | null = null;
	private workspaces: Map<string, AgentWorkspace> = new Map();
	private initialized = false;
	private config: Config;

	constructor() {
		this.config = new Config();
	}

	// Initialize the registry (load persisted workspaces)
	async initialize(): Promise<void> {
		if (this.initialized) return;

		try {
			const savedWorkspaces = await workspacePersistence.loadWorkspaces();
			for (const workspace of savedWorkspaces) {
				this.workspaces.set(workspace.path, workspace);
			}
			log.info(
				`Initialized with ${savedWorkspaces.length} persisted workspaces`,
			);
			this.initialized = true;

			// Load agents from all workspaces
			if (savedWorkspaces.length > 0) {
				await this.loadAgents();
			}
		} catch (error) {
			log.error("Failed to initialize agent registry:", error);
			this.initialized = true; // Mark as initialized even on error
		}
	}

	private isValidModel(model: string): model is AllowedModel {
		return ALLOWED_MODELS.includes(model as AllowedModel);
	}

	private async loadAgentFromFile(
		filePath: string,
		source: "global" | "workspace",
		workspace?: string,
	): Promise<Agent | null> {
		try {
			const content = await readFile(filePath, "utf-8");

			// Extract frontmatter manually
			const frontmatterMatch = content.match(
				/^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/,
			);
			if (!frontmatterMatch) {
				log.error(`No valid frontmatter found in ${filePath}`);
				return null;
			}

			const frontmatterContent = frontmatterMatch[1];
			const systemPrompt = frontmatterMatch[2];

			// Parse frontmatter into a data object
			const data: Record<string, string> = {};
			const lines = frontmatterContent.split("\n");
			let currentKey = "";
			let currentValue = "";

			for (const line of lines) {
				// Check if this line starts a new key-value pair
				const keyMatch = line.match(/^(\w+):\s*(.*)$/);
				if (keyMatch) {
					// Save previous key-value pair if exists
					if (currentKey) {
						data[currentKey] = currentValue.trim();
					}
					// Start new key-value pair
					currentKey = keyMatch[1];
					currentValue = keyMatch[2];
				} else if (currentKey && line.trim()) {
					// This is a continuation of the previous value
					currentValue += ` ${line.trim()}`;
				}
			}
			// Save the last key-value pair
			if (currentKey) {
				data[currentKey] = currentValue.trim();
			}

			// Validate required fields
			if (!data.name || !data.description) {
				log.warn(
					`Agent file ${filePath} missing required fields (name, description)`,
				);
				return null;
			}

			// Parse and validate model
			const defaultModel = this.config.getDefaultAgentModel();
			let model: AllowedModel = defaultModel as AllowedModel;

			// Handle shorthand model names
			if (data.model) {
				const modelLower = data.model.toLowerCase();
				if (modelLower === "opus") {
					model = ALLOWED_MODELS[0]; // claude-opus-4-20250514
				} else if (modelLower === "sonnet") {
					model = ALLOWED_MODELS[1]; // claude-sonnet-4-20250514
				} else if (this.isValidModel(data.model)) {
					model = data.model as AllowedModel;
				} else {
					log.warn(
						`Agent file ${filePath} has invalid model: ${data.model}. Using default.`,
					);
				}
			}

			// Parse tools from frontmatter
			let tools: AgentTool[] | undefined;
			if (data.tools) {
				tools = data.tools
					.split(",")
					.map((t: string) => t.trim() as AgentTool)
					.filter(Boolean);
			}

			const id = basename(filePath, ".md");

			return {
				id,
				name: data.name,
				description: data.description,
				color: data.color || DEFAULT_COLOR,
				model,
				systemPrompt: systemPrompt.trim(),
				source,
				workspace,
				tools,
				filePath,
			};
		} catch (error) {
			log.error(`Error loading agent from ${filePath}:`, error);
			return null;
		}
	}

	async loadAgents(): Promise<void> {
		const agents: Agent[] = [];
		const seenIds = new Set<string>();

		// Load global agents
		const globalDir = getAgentsDirectory();
		if (existsSync(globalDir)) {
			try {
				const files = await readdir(globalDir);
				const mdFiles = files.filter((file) => file.endsWith(".md"));

				for (const file of mdFiles) {
					const filePath = join(globalDir, file);
					const agent = await this.loadAgentFromFile(filePath, "global");

					if (agent) {
						if (seenIds.has(agent.id)) {
							log.warn(
								`Duplicate agent id ${agent.id} found in ${filePath} - keeping first occurrence`,
							);
							continue;
						}

						seenIds.add(agent.id);
						agents.push(agent);
					}
				}

				log.info(`Loaded ${mdFiles.length} global agents from ${globalDir}`);
			} catch (error) {
				log.error(`Error loading global agents from ${globalDir}:`, error);
			}
		}

		// Load workspace agents
		for (const [workspacePath, workspace] of this.workspaces) {
			const workspaceAgentsDir = join(workspacePath, ".claude", "agents");

			if (!existsSync(workspaceAgentsDir)) {
				log.debug(
					`Workspace agents directory does not exist: ${workspaceAgentsDir}`,
				);
				continue;
			}

			try {
				const files = await readdir(workspaceAgentsDir);
				const mdFiles = files.filter((file) => file.endsWith(".md"));

				for (const file of mdFiles) {
					const filePath = join(workspaceAgentsDir, file);
					const agent = await this.loadAgentFromFile(
						filePath,
						"workspace",
						workspacePath,
					);

					if (agent) {
						// For workspace agents, prefix the ID with workspace path to ensure uniqueness
						const workspaceAgentId = `${workspace.name}:${agent.id}`;

						if (seenIds.has(workspaceAgentId)) {
							log.warn(
								`Duplicate agent id ${workspaceAgentId} found in ${filePath} - keeping first occurrence`,
							);
							continue;
						}

						// Update the agent ID to include workspace prefix
						agent.id = workspaceAgentId;
						seenIds.add(workspaceAgentId);
						agents.push(agent);
					}
				}

				log.info(
					`Loaded ${mdFiles.length} agents from workspace ${workspace.name} (${workspacePath})`,
				);
			} catch (error) {
				log.error(
					`Error loading agents from workspace ${workspacePath}:`,
					error,
				);
			}
		}

		this.cache = { agents, timestamp: Date.now() };
		log.info(
			`Total agents loaded: ${agents.length} (${agents.filter((a) => a.source === "global").length} global, ${agents.filter((a) => a.source === "workspace").length} workspace)`,
		);
	}

	async getAgents(): Promise<Agent[]> {
		// Ensure we're initialized
		await this.initialize();

		// Check if cache is valid
		if (this.cache && Date.now() - this.cache.timestamp < CACHE_TTL_MS) {
			return this.cache.agents;
		}

		// Reload agents
		await this.loadAgents();
		return this.cache?.agents || [];
	}

	async findAgentByPrompt(systemPrompt: string): Promise<Agent | undefined> {
		const agents = await this.getAgents();

		// Normalize the prompt for comparison
		const normalizedPrompt = systemPrompt.trim();

		return agents.find((agent) => {
			// Check if the agent's system prompt is contained within the provided prompt
			// This handles cases where the agent prompt is part of a larger system prompt
			return normalizedPrompt.includes(agent.systemPrompt);
		});
	}

	// Force reload agents (useful for testing or manual refresh)
	async refresh(): Promise<void> {
		this.cache = null;
		await this.loadAgents();
	}

	// Register a workspace
	async registerWorkspace(workspacePath: string): Promise<void> {
		const normalizedPath = resolve(workspacePath);

		// Check if this workspace is already registered
		if (this.workspaces.has(normalizedPath)) {
			// Update last seen time
			const workspace = this.workspaces.get(normalizedPath);
			if (workspace) {
				workspace.lastSeen = Date.now();
			}
			return;
		}

		// Extract workspace name from path
		const pathParts = normalizedPath.split("/");
		const workspaceName = pathParts[pathParts.length - 1] || "workspace";

		// Create new workspace entry
		const workspace: AgentWorkspace = {
			path: normalizedPath,
			name: workspaceName,
			lastSeen: Date.now(),
		};

		this.workspaces.set(normalizedPath, workspace);
		log.info(`Registered workspace: ${workspaceName} at ${normalizedPath}`);

		// Save workspaces to disk
		await this.saveWorkspaces();

		// Refresh to load agents from the new workspace
		await this.refresh();
	}

	// Get current workspaces
	getWorkspaces(): AgentWorkspace[] {
		return Array.from(this.workspaces.values());
	}

	// Save workspaces to disk
	private async saveWorkspaces(): Promise<void> {
		try {
			await workspacePersistence.saveWorkspaces(this.getWorkspaces());
		} catch (error) {
			log.error("Failed to save workspaces:", error);
		}
	}

	// Clear all workspaces (useful for testing)
	async clearWorkspaces(): Promise<void> {
		this.workspaces.clear();
		this.cache = null;
		await this.saveWorkspaces();
		log.info("Cleared all workspaces");
	}

	// Remove old workspaces that haven't been seen recently (e.g., 7 days)
	async pruneOldWorkspaces(
		maxAgeMs: number = 7 * 24 * 60 * 60 * 1000,
	): Promise<void> {
		const now = Date.now();
		const toRemove: string[] = [];

		for (const [path, workspace] of this.workspaces) {
			if (now - workspace.lastSeen > maxAgeMs) {
				toRemove.push(path);
			}
		}

		for (const path of toRemove) {
			this.workspaces.delete(path);
			log.info(`Removed stale workspace: ${path}`);
		}

		if (toRemove.length > 0) {
			this.cache = null; // Clear cache to force reload
			await this.saveWorkspaces();
		}
	}

	// Update an agent in the filesystem
	async updateAgent(
		agentId: string,
		updates: Partial<
			Pick<Agent, "description" | "model" | "tools" | "color" | "systemPrompt">
		>,
		dbOps?: { deleteAgentPreference: (agentId: string) => boolean },
	): Promise<Agent> {
		// Ensure we're initialized
		await this.initialize();

		// Find the agent
		const agents = await this.getAgents();
		const agent = agents.find((a) => a.id === agentId);
		if (!agent) {
			throw new Error(`Agent with id ${agentId} not found`);
		}

		// Prepare front-matter updates
		const frontMatterUpdates: Record<string, unknown> = {};

		if (updates.description !== undefined) {
			frontMatterUpdates.description = updates.description;
		}
		if (updates.model !== undefined) {
			frontMatterUpdates.model = updates.model;
		}
		if (updates.tools !== undefined) {
			if (updates.tools.length === 0) {
				// Remove tools property entirely for "all" mode
				frontMatterUpdates.tools = undefined;
			} else {
				frontMatterUpdates.tools = updates.tools.join(", ");
			}
		}
		if (updates.color !== undefined) {
			frontMatterUpdates.color = updates.color;
		}

		// Reconstruct the agent file
		const currentContent = await readFile(agent.filePath, "utf-8");
		const frontmatterMatch = currentContent.match(
			/^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/,
		);

		if (!frontmatterMatch) {
			throw new Error(`Invalid agent file format: ${agent.filePath}`);
		}

		// Parse existing frontmatter
		const existingFrontmatter = frontmatterMatch[1];
		const existingData: Record<string, string> = {};
		const lines = existingFrontmatter.split("\n");
		let currentKey = "";
		let currentValue = "";

		for (const line of lines) {
			const keyMatch = line.match(/^(\w+):\s*(.*)$/);
			if (keyMatch) {
				if (currentKey) {
					existingData[currentKey] = currentValue.trim();
				}
				currentKey = keyMatch[1];
				currentValue = keyMatch[2];
			} else if (currentKey && line.trim()) {
				currentValue += ` ${line.trim()}`;
			}
		}
		if (currentKey) {
			existingData[currentKey] = currentValue.trim();
		}

		// Apply updates to frontmatter
		if (updates.description !== undefined) {
			existingData.description = updates.description;
		}
		if (updates.model !== undefined) {
			existingData.model = updates.model;
		}
		if (updates.tools !== undefined) {
			if (updates.tools.length === 0) {
				delete existingData.tools;
			} else {
				existingData.tools = updates.tools.join(", ");
			}
		}
		if (updates.color !== undefined) {
			existingData.color = updates.color;
		}

		// Reconstruct frontmatter with proper formatting
		const newFrontmatter = Object.entries(existingData)
			.map(([key, value]) => `${key}: ${value}`)
			.join("\n");

		// Use updated system prompt or existing one
		const newSystemPrompt =
			updates.systemPrompt !== undefined
				? updates.systemPrompt
				: frontmatterMatch[2].trim();

		// Write the updated file
		const newContent = `---\n${newFrontmatter}\n---\n\n${newSystemPrompt}`;
		await writeFile(agent.filePath, newContent, "utf-8");

		// If model was updated, clear any database preference to avoid conflicts
		if (updates.model && dbOps?.deleteAgentPreference) {
			try {
				dbOps.deleteAgentPreference(agentId);
			} catch (error) {
				log.warn(`Failed to clear agent preference for ${agentId}:`, error);
			}
		}

		// Force cache refresh
		await this.refresh();

		// Return updated agent
		const updatedAgents = await this.getAgents();
		const updatedAgent = updatedAgents.find((a) => a.id === agentId);
		if (!updatedAgent) {
			throw new Error(`Failed to reload updated agent ${agentId}`);
		}

		return updatedAgent;
	}
}

// Create singleton instance
export const agentRegistry = new AgentRegistry();

================
File: packages/agents/src/index.ts
================
export type { Agent, AgentSource, AgentWorkspace } from "@ccflare/types";
export { AgentRegistry, agentRegistry } from "./discovery";
export { getAgentsDirectory } from "./paths";
export { workspacePersistence } from "./workspace-persistence";

================
File: packages/agents/src/paths.ts
================
import { homedir } from "node:os";
import { join } from "node:path";

export function getAgentsDirectory(): string {
	return join(homedir(), ".claude", "agents");
}

================
File: packages/agents/src/workspace-persistence.ts
================
import { existsSync } from "node:fs";
import { readFile, writeFile } from "node:fs/promises";
import { homedir } from "node:os";
import { join } from "node:path";
import { Logger } from "@ccflare/logger";
import type { AgentWorkspace } from "@ccflare/types";

const log = new Logger("WorkspacePersistence");

const WORKSPACES_FILE = join(homedir(), ".ccflare", "workspaces.json");

interface WorkspacesData {
	version: number;
	workspaces: AgentWorkspace[];
}

export class WorkspacePersistence {
	async loadWorkspaces(): Promise<AgentWorkspace[]> {
		try {
			if (!existsSync(WORKSPACES_FILE)) {
				log.debug("No workspaces file found");
				return [];
			}

			const content = await readFile(WORKSPACES_FILE, "utf-8");
			const data: WorkspacesData = JSON.parse(content);

			if (data.version !== 1) {
				log.warn(`Unknown workspaces file version: ${data.version}`);
				return [];
			}

			log.info(`Loaded ${data.workspaces.length} workspaces from disk`);
			return data.workspaces;
		} catch (error) {
			log.error("Failed to load workspaces:", error);
			return [];
		}
	}

	async saveWorkspaces(workspaces: AgentWorkspace[]): Promise<void> {
		try {
			const data: WorkspacesData = {
				version: 1,
				workspaces,
			};

			const content = JSON.stringify(data, null, 2);

			// Ensure directory exists
			const dir = join(homedir(), ".ccflare");
			if (!existsSync(dir)) {
				const { mkdir } = await import("node:fs/promises");
				await mkdir(dir, { recursive: true });
			}

			await writeFile(WORKSPACES_FILE, content, "utf-8");
			log.info(`Saved ${workspaces.length} workspaces to disk`);
		} catch (error) {
			log.error("Failed to save workspaces:", error);
		}
	}
}

export const workspacePersistence = new WorkspacePersistence();

================
File: packages/tui-core/package.json
================
{
	"name": "@ccflare/tui-core",
	"version": "1.0.0",
	"description": "Core controller logic for ccflare TUI",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/cli-commands": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/core": "workspace:*",
		"@ccflare/oauth-flow": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/types": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^20.0.0"
	}
}

================
File: packages/tui-core/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"module": "ESNext",
		"target": "ESNext",
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"types": ["node"]
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules"]
}

================
File: packages/tui-core/src/requests.ts
================
import { DatabaseFactory } from "@ccflare/database";
import type { RequestPayload } from "@ccflare/types";

export type { RequestPayload };

export interface RequestSummary {
	id: string;
	model?: string;
	inputTokens?: number;
	outputTokens?: number;
	totalTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	costUsd?: number;
	responseTimeMs?: number;
}

export async function getRequests(limit = 100): Promise<RequestPayload[]> {
	const dbOps = DatabaseFactory.getInstance();
	const rows = dbOps.listRequestPayloads(limit);

	const parsed = rows.map((r: { id: string; json: string }) => {
		try {
			const data = JSON.parse(r.json);
			// Add account name if we have accountId
			if (data.meta?.accountId) {
				const account = dbOps.getAccount(data.meta.accountId);
				if (account) {
					data.meta.accountName = account.name;
				}
			}
			return { id: r.id, ...data } as RequestPayload;
		} catch {
			return {
				id: r.id,
				error: "Failed to parse payload",
				request: { headers: {}, body: null },
				response: null,
				meta: { timestamp: Date.now() },
			} as RequestPayload;
		}
	});

	return parsed;
}

export async function getRequestSummaries(
	limit = 100,
): Promise<Map<string, RequestSummary>> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();

	const summaries = db
		.query(`
		SELECT 
			id,
			model,
			input_tokens as inputTokens,
			output_tokens as outputTokens,
			total_tokens as totalTokens,
			cache_read_input_tokens as cacheReadInputTokens,
			cache_creation_input_tokens as cacheCreationInputTokens,
			cost_usd as costUsd,
			response_time_ms as responseTimeMs
		FROM requests
		ORDER BY timestamp DESC
		LIMIT ?
	`)
		.all(limit) as Array<{
		id: string;
		model?: string;
		inputTokens?: number;
		outputTokens?: number;
		totalTokens?: number;
		cacheReadInputTokens?: number;
		cacheCreationInputTokens?: number;
		costUsd?: number;
		responseTimeMs?: number;
	}>;

	const summaryMap = new Map<string, RequestSummary>();
	summaries.forEach((summary) => {
		summaryMap.set(summary.id, {
			id: summary.id,
			model: summary.model || undefined,
			inputTokens: summary.inputTokens || undefined,
			outputTokens: summary.outputTokens || undefined,
			totalTokens: summary.totalTokens || undefined,
			cacheReadInputTokens: summary.cacheReadInputTokens || undefined,
			cacheCreationInputTokens: summary.cacheCreationInputTokens || undefined,
			costUsd: summary.costUsd || undefined,
			responseTimeMs: summary.responseTimeMs || undefined,
		});
	});

	return summaryMap;
}

================
File: packages/tui-core/src/analytics.ts
================
import { DatabaseFactory } from "@ccflare/database";

export interface TimeSeriesDataPoint {
	time: number;
	requests: number;
	tokens: number;
	cost: number;
	responseTime: number;
	errorRate: number;
	cacheHitRate: number;
	successRate: number;
}

export interface ModelDistribution {
	model: string;
	count: number;
	percentage: number;
}

export interface Analytics {
	timeSeries: TimeSeriesDataPoint[];
	modelDistribution: ModelDistribution[];
}

function getRangeConfig(range: string): {
	startMs: number;
	bucketMs: number;
} {
	const now = Date.now();
	const hour = 60 * 60 * 1000;
	const day = 24 * hour;

	switch (range) {
		case "1h":
			return {
				startMs: now - hour,
				bucketMs: 5 * 60 * 1000, // 5 minutes
			};
		case "6h":
			return {
				startMs: now - 6 * hour,
				bucketMs: 15 * 60 * 1000, // 15 minutes
			};
		case "24h":
			return {
				startMs: now - day,
				bucketMs: 30 * 60 * 1000, // 30 minutes
			};
		case "7d":
			return {
				startMs: now - 7 * day,
				bucketMs: 60 * 60 * 1000, // 1 hour
			};
		default:
			return {
				startMs: now - day,
				bucketMs: 30 * 60 * 1000, // 30 minutes
			};
	}
}

export async function getAnalytics(timeRange: string): Promise<Analytics> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	const { startMs, bucketMs } = getRangeConfig(timeRange);

	// Get time series data
	const timeSeriesQuery = db.prepare(`
		SELECT
			(timestamp / ?) * ? as ts,
			COUNT(*) as requests,
			SUM(COALESCE(total_tokens, 0)) as tokens,
			SUM(COALESCE(cost_usd, 0)) as cost,
			AVG(response_time_ms) as avg_response_time,
			SUM(CASE WHEN success = 0 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as error_rate,
			SUM(COALESCE(cache_read_input_tokens, 0)) * 100.0 / 
				NULLIF(SUM(COALESCE(input_tokens, 0) + COALESCE(cache_read_input_tokens, 0) + COALESCE(cache_creation_input_tokens, 0)), 0) as cache_hit_rate,
			SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) as success_rate
		FROM requests
		WHERE timestamp > ?
		GROUP BY ts
		ORDER BY ts
	`);

	const timeSeries = timeSeriesQuery.all(bucketMs, bucketMs, startMs) as Array<{
		ts: number;
		requests: number;
		tokens: number;
		cost: number;
		avg_response_time: number;
		error_rate: number;
		cache_hit_rate: number;
		success_rate: number;
	}>;

	// Get model distribution
	const modelDistQuery = db.prepare(`
		SELECT
			model,
			COUNT(*) as count
		FROM requests
		WHERE timestamp > ? AND model IS NOT NULL
		GROUP BY model
		ORDER BY count DESC
	`);

	const modelDistData = modelDistQuery.all(startMs) as Array<{
		model: string;
		count: number;
	}>;

	const totalModelRequests = modelDistData.reduce((sum, m) => sum + m.count, 0);

	const modelDistribution = modelDistData.map((m) => ({
		model: m.model,
		count: m.count,
		percentage:
			totalModelRequests > 0 ? (m.count / totalModelRequests) * 100 : 0,
	}));

	return {
		timeSeries: timeSeries.map((point) => ({
			time: point.ts,
			requests: point.requests || 0,
			tokens: point.tokens || 0,
			cost: point.cost || 0,
			responseTime: point.avg_response_time || 0,
			errorRate: point.error_rate || 0,
			cacheHitRate: point.cache_hit_rate || 0,
			successRate: point.success_rate || 0,
		})),
		modelDistribution,
	};
}

================
File: packages/tui-core/src/args.ts
================
import { parseArgs as nodeParseArgs } from "node:util";

export interface ParsedArgs {
	help?: boolean;
	serve?: boolean;
	port?: number;
	logs?: boolean | number;
	stats?: boolean;
	addAccount?: string;
	mode?: "max" | "console";
	tier?: 1 | 5 | 20;
	list?: boolean;
	remove?: string;
	pause?: string;
	resume?: string;
	analyze?: boolean;
	resetStats?: boolean;
	clearHistory?: boolean;
	getModel?: boolean;
	setModel?: string;
}

export function parseArgs(args: string[]): ParsedArgs {
	try {
		const { values } = nodeParseArgs({
			args,
			options: {
				help: { type: "boolean", short: "h" },
				serve: { type: "boolean" },
				port: { type: "string" },
				logs: { type: "string" },
				stats: { type: "boolean" },
				"add-account": { type: "string" },
				mode: { type: "string" },
				tier: { type: "string" },
				list: { type: "boolean" },
				remove: { type: "string" },
				pause: { type: "string" },
				resume: { type: "string" },
				analyze: { type: "boolean" },
				"reset-stats": { type: "boolean" },
				"clear-history": { type: "boolean" },
				"get-model": { type: "boolean" },
				"set-model": { type: "string" },
			},
			allowPositionals: true,
		});

		const result: ParsedArgs = {};

		if (values.help) result.help = true;
		if (values.serve) result.serve = true;
		if (values.port) result.port = parseInt(values.port, 10);
		if (values.logs !== undefined) {
			result.logs = values.logs ? parseInt(values.logs, 10) : true;
		}
		if (values.stats) result.stats = true;
		if (values["add-account"]) result.addAccount = values["add-account"];
		if (values.mode) result.mode = values.mode as "max" | "console";
		if (values.tier) result.tier = parseInt(values.tier, 10) as 1 | 5 | 20;
		if (values.list) result.list = true;
		if (values.remove) result.remove = values.remove;
		if (values.pause) result.pause = values.pause;
		if (values.resume) result.resume = values.resume;
		if (values.analyze) result.analyze = true;
		if (values["reset-stats"]) result.resetStats = true;
		if (values["clear-history"]) result.clearHistory = true;
		if (values["get-model"]) result.getModel = true;
		if (values["set-model"]) result.setModel = values["set-model"];

		return result;
	} catch (error) {
		console.error("Error parsing arguments:", error);
		return { help: true };
	}
}

================
File: packages/tui-core/src/stats.ts
================
import * as cliCommands from "@ccflare/cli-commands";
import { DatabaseFactory } from "@ccflare/database";

export interface Stats {
	totalRequests: number;
	successRate: number;
	activeAccounts: number;
	avgResponseTime: number;
	totalTokens: number;
	totalCostUsd: number;
	avgTokensPerSecond: number | null;
	tokenDetails?: {
		inputTokens: number;
		cacheReadInputTokens: number;
		cacheCreationInputTokens: number;
		outputTokens: number;
	};
	accounts: Array<{
		name: string;
		requestCount: number;
		successRate: number;
	}>;
	recentErrors: string[];
}

export async function getStats(): Promise<Stats> {
	const dbOps = DatabaseFactory.getInstance();
	const statsRepository = dbOps.getStatsRepository();

	// Get overall statistics using the consolidated repository
	const stats = statsRepository.getAggregatedStats();
	const activeAccounts = statsRepository.getActiveAccountCount();

	const successRate =
		stats && stats.totalRequests > 0
			? Math.round((stats.successfulRequests / stats.totalRequests) * 100)
			: 0;

	// Get per-account stats using the consolidated repository
	const accountsWithStats = statsRepository.getAccountStats(10, false);

	// Get recent errors
	const recentErrors = statsRepository.getRecentErrors();

	return {
		totalRequests: stats.totalRequests,
		successRate,
		activeAccounts,
		avgResponseTime: Math.round(stats.avgResponseTime || 0),
		totalTokens: stats.totalTokens,
		totalCostUsd: stats.totalCostUsd,
		avgTokensPerSecond: stats.avgTokensPerSecond,
		tokenDetails:
			stats.inputTokens || stats.outputTokens
				? {
						inputTokens: stats.inputTokens,
						cacheReadInputTokens: stats.cacheReadInputTokens,
						cacheCreationInputTokens: stats.cacheCreationInputTokens,
						outputTokens: stats.outputTokens,
					}
				: undefined,
		accounts: accountsWithStats,
		recentErrors,
	};
}

export async function resetStats(): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	// Clear request history
	db.run("DELETE FROM requests");
	// Reset account statistics
	db.run("UPDATE accounts SET request_count = 0, session_request_count = 0");
}

export async function clearHistory(): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	db.run("DELETE FROM requests");
}

export async function analyzePerformance(): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	cliCommands.analyzePerformance(db);
}

================
File: packages/tui-core/src/logs.ts
================
import { logBus, logFileWriter } from "@ccflare/logger";
import type { LogEvent } from "@ccflare/types";

export function streamLogs(callback: (log: LogEvent) => void): () => void {
	const listener = (event: LogEvent) => {
		callback(event);
	};

	logBus.on("log", listener);

	// Return unsubscribe function
	return () => {
		logBus.off("log", listener);
	};
}

export async function getLogHistory(limit = 1000): Promise<LogEvent[]> {
	try {
		return await logFileWriter.readLogs(limit);
	} catch (error) {
		console.error("Failed to read log history:", error);
		return [];
	}
}

================
File: packages/tui-core/src/strategy.ts
================
import { Config } from "@ccflare/config";

async function getPort(): Promise<number> {
	const config = new Config();
	const runtime = config.getRuntime();
	return runtime.port || 8080;
}

export async function getStrategy(): Promise<string> {
	const port = await getPort();
	const baseUrl = `http://localhost:${port}`;
	const res = await fetch(`${baseUrl}/api/config/strategy`);
	if (!res.ok) throw new Error("Failed to fetch strategy");
	const data = (await res.json()) as { strategy: string };
	return data.strategy;
}

export async function listStrategies(): Promise<string[]> {
	const port = await getPort();
	const baseUrl = `http://localhost:${port}`;
	const res = await fetch(`${baseUrl}/api/strategies`);
	if (!res.ok) throw new Error("Failed to list strategies");
	return res.json() as Promise<string[]>;
}

export async function setStrategy(strategy: string): Promise<void> {
	const port = await getPort();
	const baseUrl = `http://localhost:${port}`;
	const res = await fetch(`${baseUrl}/api/config/strategy`, {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({ strategy }),
	});
	if (!res.ok) {
		const error = (await res.json()) as { error?: string };
		throw new Error(error.error || "Failed to set strategy");
	}
}

================
File: packages/tui-core/src/accounts.ts
================
import * as cliCommands from "@ccflare/cli-commands";
import { openBrowser } from "@ccflare/cli-commands";
import { Config } from "@ccflare/config";
import { DatabaseFactory } from "@ccflare/database";
import { type BeginResult, createOAuthFlow } from "@ccflare/oauth-flow";
import type { AccountListItem, AddAccountOptions } from "@ccflare/types";

export interface OAuthFlowResult extends BeginResult {
	// Extends BeginResult from oauth-flow package
}

/**
 * Begin OAuth flow for adding an account (TUI version)
 * Returns the auth URL and PKCE data needed to complete the flow
 */
export async function beginAddAccount(
	options: AddAccountOptions,
): Promise<OAuthFlowResult> {
	const { name, mode = "max" } = options;
	const config = new Config();
	const dbOps = DatabaseFactory.getInstance();

	// Create OAuth flow instance
	const oauthFlow = await createOAuthFlow(dbOps, config);

	// Begin OAuth flow
	const flowResult = await oauthFlow.begin({ name, mode });

	// Open browser
	console.log(`\nOpening browser to authenticate...`);
	const browserOpened = await openBrowser(flowResult.authUrl);
	if (!browserOpened) {
		console.log(
			`Please open the following URL in your browser:\n${flowResult.authUrl}`,
		);
	}

	return flowResult;
}

/**
 * Complete OAuth flow after receiving authorization code
 */
export async function completeAddAccount(
	options: AddAccountOptions & { code: string; flowData: OAuthFlowResult },
): Promise<void> {
	const { name, mode = "max", tier = 1, code, flowData } = options;
	const config = new Config();
	const dbOps = DatabaseFactory.getInstance();

	// Create OAuth flow instance
	const oauthFlow = await createOAuthFlow(dbOps, config);

	// Complete OAuth flow
	console.log("\nExchanging code for tokens...");
	const _account = await oauthFlow.complete(
		{ sessionId: flowData.sessionId, code, tier, name },
		flowData,
	);

	console.log(`\nAccount '${name}' added successfully!`);
	console.log(`Type: ${mode === "max" ? "Claude Max" : "Claude Console"}`);
	console.log(`Tier: ${tier}x`);
}

/**
 * Legacy function for non-TUI usage
 */
export async function addAccount(options: AddAccountOptions): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	const config = new Config();
	await cliCommands.addAccount(dbOps, config, {
		name: options.name,
		mode: options.mode || "max",
		tier: options.tier || 1,
	});
}

export async function getAccounts(): Promise<AccountListItem[]> {
	const dbOps = DatabaseFactory.getInstance();
	return await cliCommands.getAccountsList(dbOps);
}

export async function removeAccount(name: string): Promise<void> {
	const dbOps = DatabaseFactory.getInstance();
	await cliCommands.removeAccount(dbOps, name);
}

export async function pauseAccount(
	name: string,
): Promise<{ success: boolean; message: string }> {
	const dbOps = DatabaseFactory.getInstance();
	return cliCommands.pauseAccount(dbOps, name);
}

export async function resumeAccount(
	name: string,
): Promise<{ success: boolean; message: string }> {
	const dbOps = DatabaseFactory.getInstance();
	return cliCommands.resumeAccount(dbOps, name);
}

================
File: packages/tui-core/src/index.ts
================
export * from "./accounts";
export * from "./analytics";
export * from "./args";
export * from "./logs";
export * from "./requests";
export * from "./stats";
export * from "./strategy";

================
File: packages/ui-common/package.json
================
{
	"name": "@ccflare/ui-common",
	"private": true,
	"version": "0.0.0",
	"type": "module",
	"exports": {
		".": "./src/index.ts",
		"./*": "./src/*.ts"
	},
	"scripts": {
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/types": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^22.10.2",
		"typescript": "^5.7.2"
	}
}

================
File: packages/ui-common/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist"
	},
	"include": ["src/**/*"]
}

================
File: packages/ui-common/src/presenters.ts
================
import type {
	Account,
	AccountDisplay,
	AccountResponse,
	Request,
	RequestResponse,
	StatsResponse,
	StatsWithAccounts,
} from "@ccflare/types";
import {
	formatCost,
	formatDuration,
	formatPercentage,
	formatTimestamp,
	formatTokens,
} from "./formatters";

/**
 * Account presenter - formats account data for display
 */
export class AccountPresenter {
	constructor(private account: Account | AccountResponse | AccountDisplay) {}

	get tierDisplay(): string {
		let tier: number | undefined;
		if ("tier" in this.account) {
			tier = this.account.tier;
		} else if ("account_tier" in this.account) {
			tier = this.account.account_tier;
		}
		return `Tier ${tier || 1}`;
	}

	get tokenStatus(): "valid" | "expired" {
		if ("tokenStatus" in this.account) {
			return this.account.tokenStatus;
		}
		if ("access_token" in this.account) {
			return this.account.access_token ? "valid" : "expired";
		}
		return "expired";
	}

	get rateLimitStatus(): string {
		if ("rateLimitStatus" in this.account) {
			return this.account.rateLimitStatus;
		}

		if (
			"rate_limited_until" in this.account &&
			this.account.rate_limited_until
		) {
			const isRateLimited = this.account.rate_limited_until > Date.now();
			return isRateLimited
				? `Rate limited until ${formatTimestamp(this.account.rate_limited_until)}`
				: "OK";
		}
		return "OK";
	}

	get sessionInfo(): string {
		if ("sessionInfo" in this.account) {
			return this.account.sessionInfo;
		}

		if ("session_start" in this.account && this.account.session_start) {
			const count =
				"session_request_count" in this.account
					? this.account.session_request_count
					: 0;
			return `Session: ${count} requests`;
		}
		return "No active session";
	}

	get requestCount(): number {
		return "requestCount" in this.account
			? this.account.requestCount
			: this.account.request_count;
	}

	get totalRequests(): number {
		return "totalRequests" in this.account
			? this.account.totalRequests
			: this.account.total_requests;
	}

	get isPaused(): boolean {
		if ("paused" in this.account) {
			return this.account.paused;
		}
		return false;
	}

	get isRateLimited(): boolean {
		if ("rate_limited_until" in this.account) {
			return Boolean(
				this.account.rate_limited_until &&
					this.account.rate_limited_until > Date.now(),
			);
		}
		const status = this.rateLimitStatus.toLowerCase();
		return status !== "ok" && !status.startsWith("allowed");
	}
}

/**
 * Request presenter - formats request data for display
 */
export class RequestPresenter {
	constructor(private request: Request | RequestResponse) {}

	get statusDisplay(): string {
		const code = this.request.statusCode;
		if (!code) return "N/A";
		return code.toString();
	}

	get responseTimeDisplay(): string {
		const time = this.request.responseTimeMs;
		if (!time) return "N/A";
		return formatDuration(time);
	}

	get tokensDisplay(): string {
		return formatTokens(this.request.totalTokens);
	}

	get costDisplay(): string {
		return formatCost(this.request.costUsd);
	}

	get isSuccess(): boolean {
		return this.request.success;
	}

	get hasTokenUsage(): boolean {
		return Boolean(this.request.inputTokens || this.request.outputTokens);
	}
}

/**
 * Stats presenter - formats stats data for display
 */
export class StatsPresenter {
	constructor(private stats: StatsResponse | StatsWithAccounts) {}

	get successRateDisplay(): string {
		return formatPercentage(this.stats.successRate);
	}

	get avgResponseTimeDisplay(): string {
		return formatDuration(this.stats.avgResponseTime);
	}

	get totalTokensDisplay(): string {
		return formatTokens(this.stats.totalTokens);
	}

	get totalCostDisplay(): string {
		return formatCost(this.stats.totalCostUsd);
	}

	get topModel(): string | null {
		if (!this.stats.topModels || this.stats.topModels.length === 0) {
			return null;
		}
		return this.stats.topModels[0].model;
	}

	get hasAccounts(): boolean {
		return "accounts" in this.stats && this.stats.accounts.length > 0;
	}
}

================
File: packages/ui-common/src/index.ts
================
// Export all formatters

// Export all components
export * from "./components/TokenUsageDisplay";
export * from "./formatters";
// Export parsers
export * from "./parsers/parse-conversation";
// Export all presenters
export * from "./presenters";
// Export utilities
export * from "./utils/clean-line-numbers";
export * from "./utils/generate-message-key";
export * from "./utils/normalize-text";

================
File: packages/ui-common/src/formatters.ts
================
import { TIME_CONSTANTS } from "@ccflare/core";

/**
 * Format duration in milliseconds to human-readable string
 */
export function formatDuration(ms: number): string {
	if (ms < TIME_CONSTANTS.SECOND) return `${ms}ms`;
	if (ms < TIME_CONSTANTS.MINUTE)
		return `${(ms / TIME_CONSTANTS.SECOND).toFixed(1)}s`;
	if (ms < TIME_CONSTANTS.HOUR)
		return `${(ms / TIME_CONSTANTS.MINUTE).toFixed(1)}m`;
	return `${(ms / TIME_CONSTANTS.HOUR).toFixed(1)}h`;
}

/**
 * Format tokens with locale-aware thousands separator
 */
export function formatTokens(tokens?: number): string {
	if (!tokens || tokens === 0) return "0";
	return tokens.toLocaleString();
}

/**
 * Format USD cost with 4 decimal places
 */
export function formatCost(cost?: number): string {
	if (!cost || cost === 0) return "$0.0000";
	return `$${cost.toFixed(4)}`;
}

/**
 * Format percentage with specified decimal places
 */
export function formatPercentage(value: number, decimals = 1): string {
	return `${value.toFixed(decimals)}%`;
}

/**
 * Format number with locale-aware thousands separator
 */
export function formatNumber(value: number): string {
	return value.toLocaleString();
}

/**
 * Format timestamp to locale string
 */
export function formatTimestamp(timestamp: number | string): string {
	const date =
		typeof timestamp === "string" ? new Date(timestamp) : new Date(timestamp);
	return date.toLocaleString();
}

/**
 * Format tokens per second with 1 decimal place
 */
export function formatTokensPerSecond(tokensPerSecond?: number | null): string {
	if (!tokensPerSecond || tokensPerSecond === 0) return "0 tok/s";
	return `${tokensPerSecond.toFixed(1)} tok/s`;
}

================
File: packages/ui-common/src/parsers/parse-conversation.ts
================
import {
	ContentBlockType,
	type MessageData,
	type ToolUse,
} from "@ccflare/types";
import { normalizeText } from "../utils/normalize-text";

export function parseRequestMessages(body: string | null): MessageData[] {
	if (!body) return [];

	try {
		const parsed = JSON.parse(body);
		if (!parsed.messages || !Array.isArray(parsed.messages)) return [];

		return parsed.messages
			.map(
				(msg: {
					role: "user" | "assistant" | "system";
					content:
						| string
						| Array<{
								type: string;
								text?: string;
								thinking?: string;
								id?: string;
								name?: string;
								input?: Record<string, unknown>;
								tool_use_id?: string;
								content?: string | Array<{ type: string; text?: string }>;
						  }>;
				}): MessageData | null => {
					const message: MessageData = {
						role: msg.role,
						content: "",
						contentBlocks: [],
						tools: [],
						toolResults: [],
					};

					if (typeof msg.content === "string") {
						message.content = msg.content;
					} else if (Array.isArray(msg.content)) {
						// Process content blocks
						const textContents: string[] = [];

						for (const item of msg.content) {
							if (item.type === "text") {
								// Filter out system reminders
								let text = normalizeText(item.text || "");
								if (text.includes("<system-reminder>")) {
									text = text
										.split(/<system-reminder>[\s\S]*?<\/system-reminder>/g)
										.join("")
										.trim();
								}
								if (text) {
									textContents.push(text);
									message.contentBlocks?.push({
										type: ContentBlockType.Text,
										text,
									});
								}
							} else if (item.type === "tool_use") {
								message.tools?.push({
									id: item.id,
									name: item.name || "unknown",
									input: item.input,
								});
								message.contentBlocks?.push({
									type: ContentBlockType.ToolUse,
									id: item.id,
									name: item.name,
									input: item.input,
								});
							} else if (item.type === "tool_result") {
								const resultContent = Array.isArray((item as any).content)
									? (
											(item as any).content as Array<{
												type: string;
												text?: string;
											}>
										)
											.map((c) =>
												normalizeText(typeof c.text === "string" ? c.text : ""),
											)
											.join("")
									: typeof (item as any).content === "string"
										? normalizeText((item as any).content as string)
										: "";
								message.toolResults?.push({
									tool_use_id: (item as any).tool_use_id || "",
									content: resultContent,
								});
								message.contentBlocks?.push({
									type: ContentBlockType.ToolResult,
									tool_use_id: (item as any).tool_use_id,
									content: resultContent,
								});
							} else if (item.type === "thinking") {
								const thinking = normalizeText((item as any).thinking || "");
								if (thinking) {
									message.contentBlocks?.push({
										type: ContentBlockType.Thinking,
										thinking,
									});
								}
							}
						}

						message.content = textContents.join("\n\n").trim();
						if (
							!message.content &&
							message.tools?.length === 0 &&
							message.toolResults?.length === 0
						) {
							return null;
						}
					}

					return message;
				},
			)
			.filter((msg: MessageData | null): msg is MessageData => msg !== null);
	} catch (error) {
		console.error("Failed to parse request body:", error);
		return [];
	}
}

export function parseAssistantMessage(body: string | null): MessageData | null {
	if (!body) return null;

	try {
		const lines = body.split("\n");
		const message: MessageData = {
			role: "assistant",
			content: "",
			contentBlocks: [],
			tools: [],
			toolResults: [],
		};

		let currentContent = "";
		let currentThinking = "";
		let isStreaming = false;

		for (const line of lines) {
			if (line.startsWith("event:")) {
				isStreaming = true;
				continue;
			}

			if (line.startsWith("data:")) {
				const dataStr = line.substring(5).trim();
				if (!dataStr || dataStr === "[DONE]") continue;

				try {
					const data = JSON.parse(dataStr);

					// Handle different event types
					if (data.type === "content_block_start") {
						if (data.content_block?.type === "tool_use") {
							const tool: ToolUse = {
								id: data.content_block.id,
								name: data.content_block.name,
								input: {},
							};
							message.tools?.push(tool);
							message.contentBlocks?.push({
								type: ContentBlockType.ToolUse,
								id: data.content_block.id,
								name: data.content_block.name,
								input: {},
							});
						} else if (data.content_block?.type === "thinking") {
							// Thinking block will be added when content is received
						}
					} else if (data.type === "content_block_delta") {
						if (data.delta?.type === "text_delta") {
							currentContent += data.delta.text || "";
						} else if (data.delta?.type === "thinking_delta") {
							currentThinking += data.delta.thinking || "";
						} else if (
							data.delta?.type === "input_json_delta" &&
							data.index !== undefined
						) {
							// Update tool input
							const hasThinking = message.contentBlocks?.some(
								(b) => b.type === ContentBlockType.Thinking,
							);
							const toolIndex = data.index - (hasThinking ? 1 : 0);
							if (message.tools?.[toolIndex]) {
								try {
									const partialJson = data.delta.partial_json || "";
									// This is a simplified approach - in production you'd want proper JSON streaming
									if (partialJson && message.contentBlocks) {
										const blockIndex = message.contentBlocks.findIndex(
											(b) =>
												b.type === ContentBlockType.ToolUse &&
												b.id === message.tools?.[toolIndex].id,
										);
										if (blockIndex !== -1) {
											// Try to parse the partial JSON, fallback to empty object
											try {
												message.contentBlocks[blockIndex].input =
													JSON.parse(partialJson);
											} catch {
												// If parsing fails, store raw string in a temporary field
												message.contentBlocks[blockIndex].input = {
													_partial: partialJson,
												};
											}
										}
									}
								} catch (_e) {
									// Ignore JSON parsing errors for partial data
								}
							}
						}
					}
				} catch (_e) {
					// Skip invalid JSON
				}
			}
		}

		// If no streaming data found, try parsing as direct response
		if (!isStreaming) {
			try {
				const parsed = JSON.parse(body);
				if (parsed.content) {
					if (typeof parsed.content === "string") {
						currentContent = normalizeText(parsed.content);
					} else if (Array.isArray(parsed.content)) {
						for (const item of parsed.content) {
							if (item.type === "text" && item.text) {
								const norm = normalizeText(item.text);
								currentContent += norm;
								message.contentBlocks?.push({
									type: ContentBlockType.Text,
									text: norm,
								});
							} else if (item.type === "tool_use") {
								message.tools?.push({
									id: item.id,
									name: item.name || "unknown",
									input: item.input,
								});
								message.contentBlocks?.push({
									type: ContentBlockType.ToolUse,
									...item,
								});
							} else if (item.type === "thinking") {
								const thinking = normalizeText((item as any).thinking || "");
								if (thinking) {
									message.contentBlocks?.push({
										type: ContentBlockType.Thinking,
										thinking,
									});
								}
							} else if (item.type === "tool_result") {
								const resultContent = Array.isArray((item as any).content)
									? (
											(item as any).content as Array<{
												type: string;
												text?: string;
											}>
										)
											.map((c) =>
												normalizeText(typeof c.text === "string" ? c.text : ""),
											)
											.join("")
									: typeof (item as any).content === "string"
										? normalizeText((item as any).content as string)
										: "";
								message.toolResults?.push({
									tool_use_id: (item as any).tool_use_id || "",
									content: resultContent,
								});
								message.contentBlocks?.push({
									type: ContentBlockType.ToolResult,
									tool_use_id: (item as any).tool_use_id,
									content: resultContent,
								});
							}
						}
					}
				}
			} catch (_e) {
				// Not JSON, might be plain text
				currentContent = body;
			}
		}

		message.content = currentContent.trim();

		if (currentThinking) {
			message.contentBlocks?.unshift({
				type: ContentBlockType.Thinking,
				thinking: currentThinking,
			});
		}

		if (
			!message.content &&
			!currentThinking &&
			(!message.tools || message.tools.length === 0) &&
			(!message.toolResults || message.toolResults.length === 0)
		) {
			return null;
		}

		return message;
	} catch (error) {
		console.error("Failed to parse response body:", error);
		return null;
	}
}

================
File: packages/ui-common/src/utils/generate-message-key.ts
================
import type { MessageData } from "@ccflare/types";

export const genMessageKey = (msg: MessageData, index: number): string => {
	const preview = msg.content?.slice(0, 20).replace(/\s/g, "-");
	return [
		"msg",
		msg.role,
		index,
		preview ||
			msg.tools?.[0]?.name ||
			msg.toolResults?.[0]?.tool_use_id ||
			"empty",
	].join("-");
};

================
File: packages/ui-common/src/utils/clean-line-numbers.ts
================
/**
 * Replace leading numeric line markers such as "123→" or "123â" by "123: ".
 */
export const cleanLineNumbers = (str: string): string => {
	// Be defensive at runtime: only operate on real strings
	if (typeof str !== "string") return "";
	return str.replace(/^(\s*)(\d+)[→â]\s*/gm, "$1$2: ");
};

================
File: packages/ui-common/src/utils/normalize-text.ts
================
/**
 * Normalize tool/text content that may arrive with mojibake (UTF-8 seen as Latin-1),
 * and optionally strip a single pair of wrapping quotes.
 */
export function normalizeText(input: unknown): string {
	let s = typeof input === "string" ? input : "";
	if (!s) return "";

	// 1) If it's a JSON-encoded string (e.g., "...\n..."), try to parse directly
	if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
		try {
			s = JSON.parse(s);
		} catch {
			// If JSON.parse fails, fall back to manual unquoting
			s = s.slice(1, -1);
		}
	} else if (/\\[nrt"\\]/.test(s)) {
		// 2) If it contains escaped sequences, decode them via JSON.parse wrapper
		try {
			const literal =
				'"' +
				s
					.replace(/\\/g, "\\\\")
					.replace(/\n/g, "\\n")
					.replace(/\r/g, "\\r")
					.replace(/\t/g, "\\t")
					.replace(/"/g, '\\"') +
				'"';
			s = JSON.parse(literal);
		} catch {
			// Ignore if decoding fails
		}
	}

	// 3) Heuristic: repair mojibake (UTF-8 mis-decoded as Latin-1)
	if (/[ÃÂâ]/.test(s)) {
		try {
			const bytes = new Uint8Array(
				Array.from(s, (ch) => ch.charCodeAt(0) & 0xff),
			);
			const recoded = new TextDecoder("utf-8", { fatal: false }).decode(bytes);
			if (recoded && recoded !== s) {
				s = recoded;
			}
		} catch {
			// Ignore decoding errors
		}
	}

	return s;
}

================
File: packages/ui-common/src/components/TokenUsageDisplay.tsx
================
import {
	formatCost,
	formatDuration,
	formatTokens,
	formatTokensPerSecond,
} from "../formatters";

/**
 * Token usage data structure
 */
export interface TokenUsageData {
	inputTokens?: number;
	outputTokens?: number;
	cacheReadInputTokens?: number;
	cacheCreationInputTokens?: number;
	totalTokens?: number;
	costUsd?: number;
	responseTimeMs?: number;
	tokensPerSecond?: number;
}

/**
 * Processed token usage information for display
 */
export interface TokenUsageInfo {
	hasData: boolean;
	sections: {
		inputTokens?: { label: string; value: string };
		outputTokens?: { label: string; value: string };
		cacheReadTokens?: { label: string; value: string };
		cacheCreationTokens?: { label: string; value: string };
		totalTokens?: { label: string; value: string };
		cost?: { label: string; value: string };
		responseTime?: { label: string; value: string };
		tokensPerSecond?: { label: string; value: string };
	};
}

/**
 * Process token usage data for display
 * This contains the shared business logic for both dashboard and TUI
 */
export function processTokenUsage(
	data: TokenUsageData | undefined,
): TokenUsageInfo {
	if (!data || (!data.inputTokens && !data.outputTokens)) {
		return {
			hasData: false,
			sections: {},
		};
	}

	const sections: TokenUsageInfo["sections"] = {};

	// Input tokens
	if (data.inputTokens !== undefined) {
		sections.inputTokens = {
			label: "Input Tokens",
			value: formatTokens(data.inputTokens),
		};
	}

	// Output tokens
	if (data.outputTokens !== undefined) {
		sections.outputTokens = {
			label: "Output Tokens",
			value: formatTokens(data.outputTokens),
		};
	}

	// Cache read tokens
	if (
		data.cacheReadInputTokens !== undefined &&
		data.cacheReadInputTokens > 0
	) {
		sections.cacheReadTokens = {
			label: "Cache Read Tokens",
			value: formatTokens(data.cacheReadInputTokens),
		};
	}

	// Cache creation tokens
	if (
		data.cacheCreationInputTokens !== undefined &&
		data.cacheCreationInputTokens > 0
	) {
		sections.cacheCreationTokens = {
			label: "Cache Creation Tokens",
			value: formatTokens(data.cacheCreationInputTokens),
		};
	}

	// Total tokens
	if (data.totalTokens !== undefined) {
		sections.totalTokens = {
			label: "Total Tokens",
			value: formatTokens(data.totalTokens),
		};
	}

	// Cost
	if (data.costUsd !== undefined && data.costUsd > 0) {
		sections.cost = {
			label: "Cost",
			value: formatCost(data.costUsd),
		};
	}

	// Response time
	if (data.responseTimeMs !== undefined) {
		sections.responseTime = {
			label: "Response Time",
			value: formatDuration(data.responseTimeMs),
		};
	}

	// Tokens per second
	if (data.tokensPerSecond !== undefined && data.tokensPerSecond > 0) {
		sections.tokensPerSecond = {
			label: "Speed",
			value: formatTokensPerSecond(data.tokensPerSecond),
		};
	}

	return {
		hasData: true,
		sections,
	};
}

/**
 * Helper to determine if there are cache tokens to display
 */
export function hasCacheTokens(data: TokenUsageData | undefined): boolean {
	if (!data) return false;
	return (
		(data.cacheReadInputTokens !== undefined &&
			data.cacheReadInputTokens > 0) ||
		(data.cacheCreationInputTokens !== undefined &&
			data.cacheCreationInputTokens > 0)
	);
}

================
File: packages/ui-constants/package.json
================
{
	"name": "@ccflare/ui-constants",
	"version": "1.0.0",
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"scripts": {
		"typecheck": "tsc --noEmit",
		"lint": "biome check --write --unsafe"
	},
	"devDependencies": {
		"@types/bun": "1.1.15",
		"typescript": "5.7.2"
	}
}

================
File: packages/ui-constants/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"baseUrl": ".",
		"outDir": "./dist",
		"rootDir": "./src"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}

================
File: packages/ui-constants/src/index.ts
================
// Color palette used across UI components
export const COLORS = {
	primary: "#f38020",
	success: "#10b981",
	warning: "#f59e0b",
	error: "#ef4444",
	blue: "#3b82f6",
	purple: "#8b5cf6",
	pink: "#ec4899",
} as const;

// Chart color sequence for multi-series charts
export const CHART_COLORS = [
	COLORS.primary,
	COLORS.blue,
	COLORS.purple,
	COLORS.pink,
	COLORS.success,
] as const;

// Time range options for analytics
export type TimeRange = "1h" | "6h" | "24h" | "7d" | "30d";

export const TIME_RANGES: Record<TimeRange, string> = {
	"1h": "Last Hour",
	"6h": "Last 6 Hours",
	"24h": "Last 24 Hours",
	"7d": "Last 7 Days",
	"30d": "Last 30 Days",
} as const;

// Chart dimensions
export const CHART_HEIGHTS = {
	small: 250,
	medium: 300,
	large: 400,
} as const;

// Common chart tooltip styles
export const CHART_TOOLTIP_STYLE = {
	default: {
		backgroundColor: "var(--background)",
		border: "1px solid var(--border)",
		borderRadius: "var(--radius)",
	},
	success: {
		backgroundColor: COLORS.success,
		border: `1px solid ${COLORS.success}`,
		borderRadius: "var(--radius)",
		color: "#fff",
	},
	dark: {
		backgroundColor: "rgba(0,0,0,0.8)",
		border: "1px solid rgba(255,255,255,0.2)",
		borderRadius: "8px",
		backdropFilter: "blur(8px)",
	},
} as const;

// Chart common properties
export const CHART_PROPS = {
	strokeDasharray: "3 3",
	gridClassName: "stroke-muted",
} as const;

// API and data refresh intervals (in milliseconds)
export const REFRESH_INTERVALS = {
	default: 30000, // 30 seconds
	fast: 10000, // 10 seconds
	slow: 60000, // 1 minute
} as const;

// API timeout
export const API_TIMEOUT = 30000; // 30 seconds

// React Query configuration
export const QUERY_CONFIG = {
	staleTime: 10000, // Consider data stale after 10 seconds
} as const;

// API default limits
export const API_LIMITS = {
	requestsDetail: 100,
	requestsSummary: 50,
} as const;

================
File: packages/load-balancer/package.json
================
{
	"name": "@ccflare/load-balancer",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/logger": "workspace:*"
	}
}

================
File: packages/load-balancer/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/load-balancer/src/index.ts
================
export { SessionStrategy } from "./strategies";

================
File: packages/load-balancer/src/strategies/index.ts
================
import { isAccountAvailable, TIME_CONSTANTS } from "@ccflare/core";
import { Logger } from "@ccflare/logger";
import type {
	Account,
	LoadBalancingStrategy,
	RequestMeta,
	StrategyStore,
} from "@ccflare/types";

export class SessionStrategy implements LoadBalancingStrategy {
	private sessionDurationMs: number;
	private store: StrategyStore | null = null;
	private log = new Logger("SessionStrategy");

	constructor(
		sessionDurationMs: number = TIME_CONSTANTS.SESSION_DURATION_DEFAULT,
	) {
		this.sessionDurationMs = sessionDurationMs;
	}

	initialize(store: StrategyStore): void {
		this.store = store;
	}

	private resetSessionIfExpired(account: Account): void {
		const now = Date.now();

		if (
			!account.session_start ||
			now - account.session_start >= this.sessionDurationMs
		) {
			// Reset session
			if (this.store) {
				const wasExpired = account.session_start !== null;
				this.log.info(
					wasExpired
						? `Session expired for account ${account.name}, starting new session`
						: `Starting new session for account ${account.name}`,
				);
				this.store.resetAccountSession(account.id, now);

				// Update the account object to reflect changes
				account.session_start = now;
				account.session_request_count = 0;
			}
		}
	}

	select(accounts: Account[], _meta: RequestMeta): Account[] {
		const now = Date.now();

		// Find account with active session (most recent session_start within window)
		let activeAccount: Account | null = null;
		let mostRecentSessionStart = 0;

		for (const account of accounts) {
			if (
				account.session_start &&
				now - account.session_start < this.sessionDurationMs &&
				account.session_start > mostRecentSessionStart
			) {
				activeAccount = account;
				mostRecentSessionStart = account.session_start;
			}
		}

		// If we have an active account and it's available, use it exclusively
		if (activeAccount && isAccountAvailable(activeAccount, now)) {
			// Reset session if expired (shouldn't happen but just in case)
			this.resetSessionIfExpired(activeAccount);
			this.log.info(
				`Continuing session for account ${activeAccount.name} (${activeAccount.session_request_count} requests in session)`,
			);
			// Return active account first, then others as fallback
			const others = accounts.filter(
				(a) => a.id !== activeAccount.id && isAccountAvailable(a, now),
			);
			return [activeAccount, ...others];
		}

		// No active session or active account is rate limited
		// Filter available accounts
		const available = accounts.filter((a) => isAccountAvailable(a, now));

		if (available.length === 0) return [];

		// Pick the first available account and start a new session with it
		const chosenAccount = available[0];
		this.resetSessionIfExpired(chosenAccount);

		// Return chosen account first, then others as fallback
		const others = available.filter((a) => a.id !== chosenAccount.id);
		return [chosenAccount, ...others];
	}
}

================
File: packages/http-common/package.json
================
{
	"name": "@ccflare/http-common",
	"private": true,
	"version": "0.0.0",
	"type": "module",
	"exports": {
		".": "./src/index.ts",
		"./*": "./src/*.ts"
	},
	"scripts": {
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/types": "workspace:*",
		"@ccflare/errors": "workspace:*"
	},
	"devDependencies": {
		"@types/node": "^22.10.2",
		"typescript": "^5.7.2"
	}
}

================
File: packages/http-common/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"rootDir": "./src",
		"outDir": "./dist"
	},
	"include": ["src/**/*"]
}

================
File: packages/http-common/src/headers.ts
================
/**
 * Sanitizes proxy headers by removing hop-by-hop headers that should not be forwarded
 * after Bun has automatically decompressed the response body.
 *
 * Removes: content-encoding, content-length, transfer-encoding
 */
export function sanitizeProxyHeaders(original: Headers): Headers {
	const sanitized = new Headers(original);

	// Remove headers that are invalidated by automatic decompression
	sanitized.delete("content-encoding");
	sanitized.delete("content-length");
	sanitized.delete("transfer-encoding");

	return sanitized;
}

/**
 * Removes hop-by-hop + compression negotiation headers from the ORIGINAL
 * client request before it is persisted for analytics. Does **not** add /
 * remove auth headers.
 *
 * Removes: accept-encoding, content-encoding, transfer-encoding, content-length
 */
export function sanitizeRequestHeaders(original: Headers): Headers {
	const h = new Headers(original);
	h.delete("accept-encoding");
	h.delete("content-encoding");
	h.delete("content-length");
	h.delete("transfer-encoding");
	return h;
}

/**
 * Return a new Response with hop-by-hop / compression headers stripped.
 * Body & status are preserved.
 */
export function withSanitizedProxyHeaders(res: Response): Response {
	return new Response(res.body, {
		status: res.status,
		statusText: res.statusText,
		headers: sanitizeProxyHeaders(res.headers),
	});
}

================
File: packages/http-common/src/errors.ts
================
// Re-export HTTP errors from the unified errors package
export {
	BadGateway,
	BadRequest,
	Conflict,
	Forbidden,
	GatewayTimeout,
	HttpError,
	InternalServerError,
	NotFound,
	ServiceUnavailable,
	TooManyRequests,
	Unauthorized,
	UnprocessableEntity,
} from "@ccflare/errors";

================
File: packages/http-common/src/client.ts
================
import { HttpError, parseHttpError } from "@ccflare/errors";

export interface RequestOptions extends RequestInit {
	timeout?: number;
	retries?: number;
	retryDelay?: number;
	baseUrl?: string;
}

export interface ClientOptions {
	baseUrl?: string;
	defaultHeaders?: HeadersInit;
	timeout?: number;
	retries?: number;
	retryDelay?: number;
}

/**
 * Base HTTP client with common functionality
 */
export class HttpClient {
	private options: Required<ClientOptions>;

	constructor(options: ClientOptions = {}) {
		this.options = {
			baseUrl: options.baseUrl || "",
			defaultHeaders: options.defaultHeaders || {},
			timeout: options.timeout || 30000,
			retries: options.retries || 0,
			retryDelay: options.retryDelay || 1000,
		};
	}

	/**
	 * Make an HTTP request with retries and timeout
	 */
	async request<T = unknown>(
		url: string,
		options: RequestOptions = {},
	): Promise<T> {
		const {
			timeout = this.options.timeout,
			retries = this.options.retries,
			retryDelay = this.options.retryDelay,
			baseUrl = this.options.baseUrl,
			...fetchOptions
		} = options;

		const fullUrl = baseUrl ? new URL(url, baseUrl).toString() : url;
		const headers = {
			...this.options.defaultHeaders,
			...fetchOptions.headers,
		};

		let lastError: Error | null = null;

		for (let attempt = 0; attempt <= retries; attempt++) {
			try {
				const controller = new AbortController();
				const timeoutId = setTimeout(() => controller.abort(), timeout);

				const response = await fetch(fullUrl, {
					...fetchOptions,
					headers,
					signal: controller.signal,
				});

				clearTimeout(timeoutId);

				if (!response.ok) {
					const error = await parseHttpError(response);
					throw error;
				}

				const contentType = response.headers.get("content-type");
				if (contentType?.includes("application/json")) {
					return await response.json();
				}

				return (await response.text()) as T;
			} catch (error) {
				lastError = error as Error;

				// Don't retry on client errors (4xx)
				if (error instanceof HttpError && error.status < 500) {
					throw error;
				}

				// Don't retry on abort
				if (error instanceof Error && error.name === "AbortError") {
					throw new HttpError(408, "Request timeout");
				}

				// Retry if we have attempts left
				if (attempt < retries) {
					await this.delay(retryDelay * (attempt + 1));
				}
			}
		}

		throw lastError || new Error("Unknown error");
	}

	/**
	 * Convenience methods
	 */
	get<T = unknown>(url: string, options?: RequestOptions): Promise<T> {
		return this.request<T>(url, { ...options, method: "GET" });
	}

	post<T = unknown>(
		url: string,
		body?: unknown,
		options?: RequestOptions,
	): Promise<T> {
		return this.request<T>(url, {
			...options,
			method: "POST",
			body: body ? JSON.stringify(body) : undefined,
			headers: {
				"Content-Type": "application/json",
				...options?.headers,
			},
		});
	}

	put<T = unknown>(
		url: string,
		body?: unknown,
		options?: RequestOptions,
	): Promise<T> {
		return this.request<T>(url, {
			...options,
			method: "PUT",
			body: body ? JSON.stringify(body) : undefined,
			headers: {
				"Content-Type": "application/json",
				...options?.headers,
			},
		});
	}

	patch<T = unknown>(
		url: string,
		body?: unknown,
		options?: RequestOptions,
	): Promise<T> {
		return this.request<T>(url, {
			...options,
			method: "PATCH",
			body: body ? JSON.stringify(body) : undefined,
			headers: {
				"Content-Type": "application/json",
				...options?.headers,
			},
		});
	}

	delete<T = unknown>(url: string, options?: RequestOptions): Promise<T> {
		return this.request<T>(url, { ...options, method: "DELETE" });
	}

	/**
	 * Delay helper for retries
	 */
	private delay(ms: number): Promise<void> {
		return new Promise((resolve) => setTimeout(resolve, ms));
	}
}

================
File: packages/http-common/src/index.ts
================
// Export error handling utilities

// Export HTTP client
export * from "./client";
export * from "./errors";
// Export header utilities
export * from "./headers";
// Export response utilities
export * from "./responses";

================
File: packages/http-common/src/responses.ts
================
import { HttpError } from "./errors";

/**
 * Create a JSON response with proper headers
 */
export function jsonResponse(
	data: unknown,
	status = 200,
	headers?: HeadersInit,
): Response {
	return new Response(JSON.stringify(data), {
		status,
		headers: {
			"Content-Type": "application/json",
			...headers,
		},
	});
}

/**
 * Create an error response from any error type
 */
export function errorResponse(error: unknown): Response {
	if (error instanceof HttpError) {
		const body: { error: string; details?: unknown } = {
			error: error.message,
		};
		if (error.details !== undefined) {
			body.details = error.details;
		}
		return jsonResponse(body, error.status);
	}

	// Handle generic errors
	const message =
		error instanceof Error ? error.message : "Internal server error";
	const status = 500;

	// In browser context, we can't log to files
	// Server-side code should handle logging before calling errorResponse
	if (typeof console !== "undefined" && console.error) {
		console.error("Unhandled error:", error);
	}

	return jsonResponse({ error: message }, status);
}

/**
 * Create a success response with optional data
 */
export function successResponse(
	data?: unknown,
	message = "Success",
	status = 200,
): Response {
	return jsonResponse({ message, data }, status);
}

/**
 * Create a paginated response
 */
export function paginatedResponse<T>(
	items: T[],
	page: number,
	perPage: number,
	total: number,
	headers?: HeadersInit,
): Response {
	const totalPages = Math.ceil(total / perPage);

	return jsonResponse(
		{
			items,
			pagination: {
				page,
				perPage,
				total,
				totalPages,
				hasNext: page < totalPages,
				hasPrev: page > 1,
			},
		},
		200,
		headers,
	);
}

/**
 * Create a streaming response for Server-Sent Events
 */
export function sseResponse(
	stream: ReadableStream,
	headers?: HeadersInit,
): Response {
	return new Response(stream, {
		headers: {
			"Content-Type": "text/event-stream",
			"Cache-Control": "no-cache",
			Connection: "keep-alive",
			...headers,
		},
	});
}

================
File: packages/dashboard-web/bunfig.toml
================
[serve.static]
plugins = ["bun-plugin-tailwind"]
env = "BUN_PUBLIC_*"

================
File: packages/dashboard-web/package.json
================
{
	"name": "@ccflare/dashboard-web",
	"version": "1.0.0",
	"private": true,
	"type": "module",
	"scripts": {
		"dev": "bun --hot src/index.tsx",
		"build": "bun run build.ts",
		"typecheck": "tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/errors": "workspace:*",
		"@ccflare/ui-common": "workspace:*",
		"@ccflare/ui-constants": "workspace:*",
		"@radix-ui/react-dialog": "^1.1.14",
		"@radix-ui/react-dropdown-menu": "^2.1.15",
		"@radix-ui/react-label": "^2.1.0",
		"@radix-ui/react-popover": "^1.1.14",
		"@radix-ui/react-progress": "^1.1.7",
		"@radix-ui/react-select": "^2.1.2",
		"@radix-ui/react-separator": "^1.1.7",
		"@radix-ui/react-slot": "^1.1.0",
		"@radix-ui/react-switch": "^1.2.5",
		"@radix-ui/react-tabs": "^1.1.1",
		"@radix-ui/react-tooltip": "^1.2.7",
		"@tanstack/react-query": "^5.83.0",
		"@types/react-router-dom": "^5.3.3",
		"bun-plugin-tailwind": "^0.0.15",
		"class-variance-authority": "^0.7.1",
		"clsx": "^2.1.1",
		"cmdk": "^1.1.1",
		"date-fns": "^4.1.0",
		"framer-motion": "^12.23.9",
		"lucide-react": "^0.525.0",
		"react": "^19.0.0",
		"react-dom": "^19.0.0",
		"react-router-dom": "^7.8.1",
		"recharts": "^3.1.0",
		"tailwind-merge": "^2.6.0",
		"tailwindcss": "^4.0.0",
		"tailwindcss-animate": "^1.0.7"
	},
	"devDependencies": {
		"@types/react": "^19.0.0",
		"@types/react-dom": "^19.0.0",
		"@types/bun": "latest"
	}
}

================
File: packages/dashboard-web/components.json
================
{
	"$schema": "https://ui.shadcn.com/schema.json",
	"style": "new-york",
	"rsc": false,
	"tsx": true,
	"tailwind": {
		"config": "",
		"css": "styles/globals.css",
		"baseColor": "zinc",
		"cssVariables": true,
		"prefix": ""
	},
	"aliases": {
		"components": "@/components",
		"utils": "@/lib/utils",
		"ui": "@/components/ui",
		"lib": "@/lib",
		"hooks": "@/hooks"
	},
	"iconLibrary": "lucide"
}

================
File: packages/dashboard-web/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"lib": ["ESNext", "DOM", "DOM.Iterable"],
		"target": "ESNext",
		"module": "ESNext",
		"moduleDetection": "force",
		"jsx": "react-jsx",
		"allowJs": true,
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"verbatimModuleSyntax": true,
		"noEmit": true,
		"strict": true,
		"skipLibCheck": true,
		"noFallthroughCasesInSwitch": true,
		"baseUrl": ".",
		"paths": {
			"@/*": ["./src/*"]
		}
	},
	"include": ["src/**/*"],
	"exclude": ["dist", "node_modules"]
}

================
File: packages/dashboard-web/build.ts
================
#!/usr/bin/env bun
import { existsSync } from "node:fs";
import { rm, writeFile } from "node:fs/promises";
import path from "node:path";
import plugin from "bun-plugin-tailwind";

console.log("\n🚀 Building dashboard...\n");

const outdir = path.join(process.cwd(), "dist");

if (existsSync(outdir)) {
	console.log(`🗑️ Cleaning previous build at ${outdir}`);
	await rm(outdir, { recursive: true, force: true });
}

const start = performance.now();

const entrypoints = ["src/index.html"];
console.log(`📄 Building dashboard from ${entrypoints[0]}\n`);

const result = await Bun.build({
	entrypoints,
	outdir,
	plugins: [plugin],
	minify: true,
	target: "browser",
	sourcemap: "linked",
	splitting: true,
	define: {
		"process.env.NODE_ENV": JSON.stringify("production"),
	},
});

// Generate manifest.json with asset mappings
const manifest: Record<string, string> = {};
for (const output of result.outputs) {
	const relativePath = path.relative(outdir, output.path);
	const publicPath = `/${relativePath}`;
	manifest[publicPath] = publicPath;
}

await writeFile(
	path.join(outdir, "manifest.json"),
	JSON.stringify(manifest, null, 2),
);

const end = performance.now();
const buildTime = (end - start).toFixed(2);

console.log(`✅ Dashboard build completed in ${buildTime}ms\n`);
console.log(`📦 Output files:`);
result.outputs.forEach((output) => {
	console.log(`   - ${path.relative(process.cwd(), output.path)}`);
});

================
File: packages/dashboard-web/styles/globals.css
================
@import "tailwindcss";

@plugin "tailwindcss-animate";

@custom-variant dark (&:is(.dark *));

:root {
	--background: hsl(0 0% 100%);
	--foreground: hsl(240 10% 3.9%);
	--card: hsl(0 0% 100%);
	--card-foreground: hsl(240 10% 3.9%);
	--popover: hsl(0 0% 100%);
	--popover-foreground: hsl(240 10% 3.9%);
	--primary: hsl(24 89% 56%); /* ccflare Orange #F38020 */
	--primary-foreground: hsl(0 0% 100%);
	--secondary: hsl(240 4.8% 95.9%);
	--secondary-foreground: hsl(240 5.9% 10%);
	--muted: hsl(240 4.8% 95.9%);
	--muted-foreground: hsl(240 3.8% 46.1%);
	--accent: hsl(24 89% 56%); /* ccflare Orange */
	--accent-foreground: hsl(0 0% 100%);
	--destructive: hsl(0 84.2% 60.2%);
	--destructive-foreground: hsl(0 0% 98%);
	--border: hsl(240 5.9% 90%);
	--input: hsl(240 5.9% 90%);
	--ring: hsl(24 89% 56%); /* ccflare Orange */
	--radius: 0.375rem;
	--cf-orange: #f38020;
}

.dark {
	--background: hsl(220 13% 8%); /* Dark background like ccflare */
	--foreground: hsl(0 0% 95%);
	--card: hsl(220 13% 12%);
	--card-foreground: hsl(0 0% 95%);
	--popover: hsl(220 13% 12%);
	--popover-foreground: hsl(0 0% 95%);
	--primary: hsl(24 89% 56%); /* ccflare Orange */
	--primary-foreground: hsl(0 0% 100%);
	--secondary: hsl(220 13% 18%);
	--secondary-foreground: hsl(0 0% 95%);
	--muted: hsl(220 13% 18%);
	--muted-foreground: hsl(220 9% 55%);
	--accent: hsl(24 89% 56%); /* ccflare Orange */
	--accent-foreground: hsl(0 0% 100%);
	--destructive: hsl(0 84.2% 60.2%);
	--destructive-foreground: hsl(0 0% 98%);
	--border: hsl(220 13% 20%);
	--input: hsl(220 13% 18%);
	--ring: hsl(24 89% 56%); /* ccflare Orange */
	--cf-orange: #f38020;
}

@theme inline {
	--color-background: var(--background);
	--color-foreground: var(--foreground);
	--color-card: var(--card);
	--color-card-foreground: var(--card-foreground);
	--color-popover: var(--popover);
	--color-popover-foreground: var(--popover-foreground);
	--color-primary: var(--primary);
	--color-primary-foreground: var(--primary-foreground);
	--color-secondary: var(--secondary);
	--color-secondary-foreground: var(--secondary-foreground);
	--color-muted: var(--muted);
	--color-muted-foreground: var(--muted-foreground);
	--color-accent: var(--accent);
	--color-accent-foreground: var(--accent-foreground);
	--color-destructive: var(--destructive);
	--color-destructive-foreground: var(--destructive-foreground);
	--color-border: var(--border);
	--color-input: var(--input);
	--color-ring: var(--ring);
	--radius-sm: calc(var(--radius) - 4px);
	--radius-md: calc(var(--radius) - 2px);
	--radius-lg: var(--radius);
	--radius-xl: calc(var(--radius) + 4px);
	--animate-accordion-down: accordion-down 0.2s ease-out;
	--animate-accordion-up: accordion-up 0.2s ease-out;

	@keyframes accordion-down {
		from {
			height: 0;
		}
		to {
			height: var(--radix-accordion-content-height);
		}
	}

	@keyframes accordion-up {
		from {
			height: var(--radix-accordion-content-height);
		}
		to {
			height: 0;
		}
	}
}

@layer base {
	* {
		@apply border-border outline-ring/50;
	}
	body {
		@apply bg-background text-foreground antialiased;
		font-feature-settings:
			"rlig" 1,
			"calt" 1;
	}

	/* Custom scrollbar */
	::-webkit-scrollbar {
		width: 10px;
		height: 10px;
	}

	::-webkit-scrollbar-track {
		@apply bg-background;
	}

	::-webkit-scrollbar-thumb {
		@apply bg-muted-foreground/20 rounded-md;
	}

	::-webkit-scrollbar-thumb:hover {
		@apply bg-muted-foreground/30;
	}

	/* Charts custom styling */
	.recharts-surface {
		overflow: visible;
	}

	/* Smooth transitions for theme switching */
	* {
		transition:
			background-color 0.2s ease-in-out,
			border-color 0.2s ease-in-out;
	}

	/* Glass morphism effects */
	.glass {
		@apply bg-background/80 backdrop-blur-md;
	}

	/* Gradient text */
	.gradient-text {
		background: linear-gradient(135deg, var(--cf-orange) 0%, #f97316 100%);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	/* Card hover effects */
	.card-hover {
		@apply transition-all duration-200 hover:shadow-lg hover:scale-[1.02];
	}

	/* Success/Error/Warning colors */
	.text-success {
		@apply text-green-600 dark:text-green-400;
	}

	.text-warning {
		@apply text-yellow-600 dark:text-yellow-400;
	}

	.bg-success {
		@apply bg-green-100 dark:bg-green-900/20;
	}

	.bg-warning {
		@apply bg-yellow-100 dark:bg-yellow-900/20;
	}
}

================
File: packages/dashboard-web/src/App.tsx
================
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { Navigate, Route, Routes, useLocation } from "react-router-dom";
import { AccountsTab } from "./components/AccountsTab";
import { AgentsTab } from "./components/AgentsTab";
import { AnalyticsTab } from "./components/AnalyticsTab";
import { LogsTab } from "./components/LogsTab";
import { Navigation } from "./components/navigation";
import { OverviewTab } from "./components/OverviewTab";
import { RequestsTab } from "./components/RequestsTab";
import { ToolsTab } from "./components/ToolsTab";
import { QUERY_CONFIG, REFRESH_INTERVALS } from "./constants";
import { ThemeProvider } from "./contexts/theme-context";
import "./index.css";

const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			refetchInterval: REFRESH_INTERVALS.default, // Refetch every 30 seconds
			staleTime: QUERY_CONFIG.staleTime, // Consider data stale after 10 seconds
		},
	},
});

const routes = [
	{
		path: "/",
		element: <OverviewTab />,
		title: "Dashboard Overview",
		subtitle: "Monitor your ccflare performance and usage",
	},
	{
		path: "/analytics",
		element: <AnalyticsTab />,
		title: "Analytics",
		subtitle: "Deep dive into your usage patterns and trends",
	},
	{
		path: "/requests",
		element: <RequestsTab />,
		title: "Request History",
		subtitle: "View detailed request and response data",
	},
	{
		path: "/accounts",
		element: <AccountsTab />,
		title: "Account Management",
		subtitle: "Manage your OAuth accounts and settings",
	},
	{
		path: "/agents",
		element: <AgentsTab />,
		title: "Agent Management",
		subtitle: "Discover and manage Claude Code agents",
	},
	{
		path: "/tools",
		element: <ToolsTab />,
		title: "Tools",
		subtitle: "Configure and manage system tools and interceptors",
	},
	{
		path: "/logs",
		element: <LogsTab />,
		title: "System Logs",
		subtitle: "Real-time system logs and debugging information",
	},
];

export function App() {
	const location = useLocation();
	const currentRoute =
		routes.find((route) => route.path === location.pathname) || routes[0];

	return (
		<QueryClientProvider client={queryClient}>
			<ThemeProvider>
				<div className="min-h-screen bg-background">
					<Navigation />

					{/* Main Content */}
					<main className="lg:pl-64">
						{/* Mobile spacer */}
						<div className="h-16 lg:hidden" />

						{/* Page Content */}
						<div className="p-4 md:p-6 lg:p-8 max-w-[1600px] mx-auto">
							{/* Page Header */}
							<div className="mb-8">
								<h1 className="text-3xl font-bold gradient-text">
									{currentRoute.title}
								</h1>
								<p className="text-muted-foreground mt-2">
									{currentRoute.subtitle}
								</p>
							</div>

							{/* Tab Content */}
							<div className="animate-in fade-in-0 duration-200">
								<Routes>
									{routes.map((route) => (
										<Route
											key={route.path}
											path={route.path}
											element={route.element}
										/>
									))}
									<Route path="*" element={<Navigate to="/" replace />} />
								</Routes>
							</div>
						</div>
					</main>
				</div>
			</ThemeProvider>
		</QueryClientProvider>
	);
}

================
File: packages/dashboard-web/src/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="./favicon.svg" />
    <title>ccflare Dashboard</title>
    <script type="module" src="./frontend.tsx" async></script>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>

================
File: packages/dashboard-web/src/index.css
================
@import "../styles/globals.css";

@layer base {
	:root {
		@apply font-sans;
	}

	body {
		@apply min-w-[320px] min-h-screen relative m-0 bg-background text-foreground;
	}
}

================
File: packages/dashboard-web/src/api.ts
================
import { HttpClient, HttpError } from "@ccflare/http-common";
import type {
	AccountResponse,
	Agent,
	AgentUpdatePayload,
	AgentWorkspace,
	AnalyticsResponse,
	LogEvent,
	RequestPayload,
	RequestResponse,
	StatsWithAccounts,
} from "@ccflare/types";
import { API_LIMITS, API_TIMEOUT } from "./constants";

// Re-export types with dashboard-specific aliases for backward compatibility
export type Account = AccountResponse;
export type Stats = StatsWithAccounts;
export type LogEntry = LogEvent;
export type RequestSummary = RequestResponse;

// Re-export types directly
export type {
	Agent,
	AgentWorkspace,
	RequestPayload,
	RequestResponse,
} from "@ccflare/types";

// Agent response interface
export interface AgentsResponse {
	agents: Agent[];
	globalAgents: Agent[];
	workspaceAgents: Agent[];
	workspaces: AgentWorkspace[];
}

/**
 * Configuration for the system prompt interceptor feature
 * Controls how system prompts are intercepted and modified
 */
export interface SystemPromptConfig {
	/** Whether the system prompt interceptor is enabled */
	isEnabled: boolean;
	/** The target prompt to look for and replace */
	targetPrompt: string;
	/** The replacement prompt with {{env_block}} placeholder for environment variables */
	replacementPrompt: string;
	/** Whether tools are enabled in the intercepted system prompt */
	toolsEnabled: boolean;
}

class API extends HttpClient {
	constructor() {
		super({
			baseUrl: "",
			defaultHeaders: {
				"Content-Type": "application/json",
			},
			timeout: API_TIMEOUT,
			retries: 1,
		});
	}

	async getStats(): Promise<Stats> {
		return this.get<Stats>("/api/stats");
	}

	async getAccounts(): Promise<Account[]> {
		return this.get<Account[]>("/api/accounts");
	}

	async initAddAccount(data: {
		name: string;
		mode: "max" | "console";
		tier: number;
	}): Promise<{ authUrl: string; sessionId: string }> {
		try {
			return await this.post<{ authUrl: string; sessionId: string }>(
				"/api/oauth/init",
				data,
			);
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async completeAddAccount(data: {
		sessionId: string;
		code: string;
	}): Promise<{ message: string; mode: string; tier: number }> {
		try {
			return await this.post<{ message: string; mode: string; tier: number }>(
				"/api/oauth/callback",
				data,
			);
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async removeAccount(name: string, confirm: string): Promise<void> {
		try {
			await this.delete(`/api/accounts/${name}`, {
				body: JSON.stringify({ confirm }),
			});
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async resetStats(): Promise<void> {
		await this.post("/api/stats/reset");
	}

	async getLogHistory(): Promise<LogEntry[]> {
		return this.get<LogEntry[]>("/api/logs/history");
	}

	// SSE streaming requires special handling, keep as-is
	streamLogs(onLog: (log: LogEntry) => void): EventSource {
		const eventSource = new EventSource(`/api/logs/stream`);
		eventSource.addEventListener("message", (event) => {
			try {
				const data = JSON.parse(event.data);
				// Skip non-log messages (like the initial "connected" message)
				if (data.ts && data.level && data.msg) {
					onLog(data as LogEntry);
				}
			} catch (e) {
				console.error("Error parsing log event:", e);
			}
		});
		return eventSource;
	}

	async getRequestsDetail(
		limit: number = API_LIMITS.requestsDetail,
	): Promise<RequestPayload[]> {
		return this.get<RequestPayload[]>(`/api/requests/detail?limit=${limit}`);
	}

	async getRequestsSummary(
		limit: number = API_LIMITS.requestsSummary,
	): Promise<RequestSummary[]> {
		return this.get<RequestSummary[]>(`/api/requests?limit=${limit}`);
	}

	async getAnalytics(
		range = "24h",
		filters?: {
			accounts?: string[];
			models?: string[];
			status?: "all" | "success" | "error";
		},
		mode: "normal" | "cumulative" = "normal",
		modelBreakdown?: boolean,
	): Promise<AnalyticsResponse> {
		const params = new URLSearchParams({ range });

		if (filters?.accounts?.length) {
			params.append("accounts", filters.accounts.join(","));
		}
		if (filters?.models?.length) {
			params.append("models", filters.models.join(","));
		}
		if (filters?.status && filters.status !== "all") {
			params.append("status", filters.status);
		}
		if (mode === "cumulative") {
			params.append("mode", "cumulative");
		}
		if (modelBreakdown) {
			params.append("modelBreakdown", "true");
		}

		return this.get<AnalyticsResponse>(`/api/analytics?${params}`);
	}

	async pauseAccount(accountId: string): Promise<void> {
		try {
			await this.post(`/api/accounts/${accountId}/pause`);
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async resumeAccount(accountId: string): Promise<void> {
		try {
			await this.post(`/api/accounts/${accountId}/resume`);
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async renameAccount(
		accountId: string,
		newName: string,
	): Promise<{ newName: string }> {
		try {
			const response = await this.post<{
				success: boolean;
				message: string;
				newName: string;
			}>(`/api/accounts/${accountId}/rename`, { name: newName });
			return { newName: response.newName };
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async getStrategy(): Promise<string> {
		const data = await this.get<{ strategy: string }>("/api/config/strategy");
		return data.strategy;
	}

	async listStrategies(): Promise<string[]> {
		return this.get<string[]>("/api/strategies");
	}

	async setStrategy(strategy: string): Promise<void> {
		try {
			await this.post("/api/config/strategy", { strategy });
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async getAgents(): Promise<AgentsResponse> {
		return await this.get<AgentsResponse>("/api/agents");
	}

	async updateAgentPreference(agentId: string, model: string): Promise<void> {
		try {
			await this.post(`/api/agents/${agentId}/preference`, { model });
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async updateAgent(
		agentId: string,
		payload: AgentUpdatePayload,
	): Promise<Agent> {
		try {
			const response = await this.patch<{ success: boolean; agent: Agent }>(
				`/api/agents/${agentId}`,
				payload,
			);
			return response.agent;
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async getDefaultAgentModel(): Promise<string> {
		const data = await this.get<{ model: string }>("/api/config/model");
		return data.model;
	}

	async setDefaultAgentModel(model: string): Promise<void> {
		try {
			await this.post("/api/config/model", { model });
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	async setBulkAgentPreferences(
		model: string,
	): Promise<{ updatedCount: number }> {
		try {
			const response = await this.post<{
				success: boolean;
				updatedCount: number;
				model: string;
			}>("/api/agents/bulk-preference", { model });
			return { updatedCount: response.updatedCount };
		} catch (error) {
			if (error instanceof HttpError) {
				throw new Error(error.message);
			}
			throw error;
		}
	}

	// Retention settings
	async getRetention(): Promise<{ payloadDays: number; requestDays: number }> {
		return this.get<{ payloadDays: number; requestDays: number }>(
			"/api/config/retention",
		);
	}

	async setRetention(partial: {
		payloadDays?: number;
		requestDays?: number;
	}): Promise<void> {
		await this.post("/api/config/retention", partial);
	}

	async cleanupNow(): Promise<{
		removedRequests: number;
		removedPayloads: number;
		cutoffIso: string;
	}> {
		return this.post<{
			removedRequests: number;
			removedPayloads: number;
			cutoffIso: string;
		}>("/api/maintenance/cleanup");
	}

	async compactDb(): Promise<{ ok: boolean }> {
		return this.post<{ ok: boolean }>("/api/maintenance/compact");
	}

	// System prompt interceptor
	async getSystemPromptOverride(): Promise<{
		isEnabled: boolean;
		targetPrompt: string;
		replacementPrompt: string;
		toolsEnabled: boolean;
	}> {
		return this.get<{
			isEnabled: boolean;
			targetPrompt: string;
			replacementPrompt: string;
			toolsEnabled: boolean;
		}>("/api/tools/interceptors/system-prompt");
	}

	async setSystemPromptOverride(data: {
		isEnabled: boolean;
		targetPrompt: string;
		replacementPrompt: string;
		toolsEnabled: boolean;
	}): Promise<{
		success: boolean;
		isEnabled: boolean;
		targetPrompt: string;
		replacementPrompt: string;
		toolsEnabled: boolean;
	}> {
		return this.post<{
			success: boolean;
			isEnabled: boolean;
			targetPrompt: string;
			replacementPrompt: string;
			toolsEnabled: boolean;
		}>("/api/tools/interceptors/system-prompt", data);
	}

	async resetSystemPromptOverride(): Promise<void> {
		await this.delete("/api/tools/interceptors/system-prompt");
	}
}

export const api = new API();

================
File: packages/dashboard-web/src/global.d.ts
================
/// <reference lib="dom" />
/// <reference lib="dom.iterable" />

declare global {
	interface Window {
		EventSource: typeof EventSource;
	}
}

export {};

================
File: packages/dashboard-web/src/frontend.tsx
================
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { App } from "./App";

const elem =
	typeof document !== "undefined" ? document.getElementById("root") : null;
if (!elem) {
	throw new Error("Root element not found");
}
const app = (
	<StrictMode>
		<BrowserRouter>
			<App />
		</BrowserRouter>
	</StrictMode>
);

if (import.meta.hot) {
	// With hot module reloading, `import.meta.hot.data` is persisted.
	if (!import.meta.hot.data.root) {
		import.meta.hot.data.root = createRoot(elem);
	}
	const root = import.meta.hot.data.root;
	root.render(app);
} else {
	// The hot module reloading API is not available in production.
	createRoot(elem).render(app);
}

================
File: packages/dashboard-web/src/favicon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <defs>
    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:1" />
    </linearGradient>
  </defs>
  <rect width="100" height="100" rx="20" fill="url(#gradient)"/>
  <text x="50" y="65" font-family="system-ui, -apple-system, sans-serif" font-size="48" font-weight="bold" text-anchor="middle" fill="white">CF</text>
</svg>

================
File: packages/dashboard-web/src/contexts/theme-context.tsx
================
import type React from "react";
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "dark" | "light" | "system";

type ThemeContextType = {
	theme: Theme;
	setTheme: (theme: Theme) => void;
};

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
	const [theme, setTheme] = useState<Theme>(() => {
		const stored = localStorage.getItem("theme") as Theme;
		return stored || "system";
	});

	useEffect(() => {
		const root = window.document.documentElement;
		root.classList.remove("light", "dark");

		let effectiveTheme = theme;
		if (theme === "system") {
			effectiveTheme = window.matchMedia("(prefers-color-scheme: dark)").matches
				? "dark"
				: "light";
		}

		root.classList.add(effectiveTheme);
		localStorage.setItem("theme", theme);
	}, [theme]);

	useEffect(() => {
		if (theme === "system") {
			const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
			const handleChange = () => {
				const root = window.document.documentElement;
				root.classList.remove("light", "dark");
				root.classList.add(mediaQuery.matches ? "dark" : "light");
			};

			mediaQuery.addEventListener("change", handleChange);
			return () => mediaQuery.removeEventListener("change", handleChange);
		}
	}, [theme]);

	return (
		<ThemeContext.Provider value={{ theme, setTheme }}>
			{children}
		</ThemeContext.Provider>
	);
}

export function useTheme() {
	const context = useContext(ThemeContext);
	if (!context) {
		throw new Error("useTheme must be used within a ThemeProvider");
	}
	return context;
}

================
File: packages/dashboard-web/src/constants/index.ts
================
// Re-export all shared constants from ui-constants

// Re-export agent constants from types
export { TOOL_PRESETS } from "@ccflare/types";
export {
	API_LIMITS,
	API_TIMEOUT,
	CHART_COLORS,
	CHART_HEIGHTS,
	CHART_PROPS,
	CHART_TOOLTIP_STYLE,
	COLORS,
	QUERY_CONFIG,
	REFRESH_INTERVALS,
	TIME_RANGES,
	type TimeRange,
} from "@ccflare/ui-constants";

================
File: packages/dashboard-web/src/components/OverviewTab.tsx
================
import {
	formatCost,
	formatNumber,
	formatPercentage,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import { format } from "date-fns";
import { Activity, CheckCircle, Clock, DollarSign, Zap } from "lucide-react";
import { useMemo, useState } from "react";
import { REFRESH_INTERVALS } from "../constants";
import { useAccounts, useAnalytics, useStats } from "../hooks/queries";
import { ChartsSection } from "./overview/ChartsSection";
import { DataRetentionCard } from "./overview/DataRetentionCard";
import { LoadingSkeleton } from "./overview/LoadingSkeleton";
import { MetricCard } from "./overview/MetricCard";
import { RateLimitInfo } from "./overview/RateLimitInfo";
import { SystemStatus } from "./overview/SystemStatus";
import { TimeRangeSelector } from "./overview/TimeRangeSelector";
import { StrategyCard } from "./StrategyCard";

export function OverviewTab() {
	// Fetch all data using React Query hooks
	const { data: stats, isLoading: statsLoading } = useStats(
		REFRESH_INTERVALS.default,
	);
	const [timeRange, setTimeRange] = useState("24h");
	const { data: analytics, isLoading: analyticsLoading } = useAnalytics(
		timeRange,
		{ accounts: [], models: [], status: "all" },
		"normal",
	);
	const { data: accounts, isLoading: accountsLoading } = useAccounts();

	const loading = statsLoading || analyticsLoading || accountsLoading;
	const combinedData =
		stats && analytics && accounts ? { stats, analytics, accounts } : null;

	// Transform time series data
	const timeSeriesData = useMemo(() => {
		if (!analytics) return [];
		return analytics.timeSeries.map((point) => ({
			time: format(new Date(point.ts), "HH:mm"),
			requests: point.requests,
			successRate: point.successRate,
			responseTime: Math.round(point.avgResponseTime),
			cost: point.costUsd.toFixed(2),
			tokensPerSecond: point.avgTokensPerSecond || 0,
		}));
	}, [analytics]);

	if (loading && !combinedData) {
		return <LoadingSkeleton />;
	}

	// Helper function to calculate percentage change
	function pctChange(current: number, previous: number): number | null {
		if (previous === 0) return null; // avoid division by zero
		return ((current - previous) / previous) * 100;
	}

	// Get trend period description based on time range
	function getTrendPeriod(range: string): string {
		switch (range) {
			case "1h":
				return "previous minute";
			case "6h":
				return "previous 5 minutes";
			case "24h":
				return "previous hour";
			case "7d":
				return "previous hour";
			case "30d":
				return "previous day";
			default:
				return "previous period";
		}
	}

	const trendPeriod = getTrendPeriod(timeRange);

	// Calculate percentage changes from time series data
	let deltaRequests: number | null = null;
	let deltaSuccessRate: number | null = null;
	let deltaResponseTime: number | null = null;
	let deltaCost: number | null = null;
	let deltaOutputSpeed: number | null = null;
	let trendRequests: "up" | "down" | "flat" = "flat";
	let trendSuccessRate: "up" | "down" | "flat" = "flat";
	let trendResponseTime: "up" | "down" | "flat" = "flat";
	let trendCost: "up" | "down" | "flat" = "flat";
	let trendOutputSpeed: "up" | "down" | "flat" = "flat";

	if (timeSeriesData.length >= 2) {
		const lastBucket = timeSeriesData[timeSeriesData.length - 1];
		const prevBucket = timeSeriesData[timeSeriesData.length - 2];

		// Calculate deltas
		deltaRequests = pctChange(lastBucket.requests, prevBucket.requests);
		deltaSuccessRate = pctChange(
			lastBucket.successRate,
			prevBucket.successRate,
		);
		// For response time, calculate normal percentage change
		deltaResponseTime = pctChange(
			lastBucket.responseTime,
			prevBucket.responseTime,
		);
		deltaCost = pctChange(
			Number.parseFloat(lastBucket.cost),
			Number.parseFloat(prevBucket.cost),
		);
		deltaOutputSpeed = pctChange(
			lastBucket.tokensPerSecond,
			prevBucket.tokensPerSecond,
		);

		// Determine trends
		trendRequests =
			deltaRequests !== null ? (deltaRequests >= 0 ? "up" : "down") : "flat";
		trendSuccessRate =
			deltaSuccessRate !== null
				? deltaSuccessRate >= 0
					? "up"
					: "down"
				: "flat";
		// For response time, higher is worse (positive change is bad)
		trendResponseTime =
			deltaResponseTime !== null
				? deltaResponseTime >= 0
					? "down"
					: "up"
				: "flat";
		// For cost, higher is bad (positive change is bad)
		trendCost = deltaCost !== null ? (deltaCost >= 0 ? "down" : "up") : "flat";
		// For output speed, higher is better
		trendOutputSpeed =
			deltaOutputSpeed !== null
				? deltaOutputSpeed >= 0
					? "up"
					: "down"
				: "flat";
	}

	// Use analytics data for model distribution
	const modelData =
		analytics?.modelDistribution?.map((model) => ({
			name: model.model || "Unknown",
			value: model.count,
		})) || [];

	// Use analytics data for account health
	const accountHealthData = analytics?.accountPerformance || [];

	return (
		<div className="space-y-6">
			{/* Header with Time Range Selector */}
			<div className="flex justify-between items-center">
				<h2 className="text-2xl font-semibold">Overview</h2>
				<TimeRangeSelector value={timeRange} onChange={setTimeRange} />
			</div>

			{/* Metrics Grid */}
			<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
				<MetricCard
					title="Total Requests"
					value={formatNumber(analytics?.totals.requests || 0)}
					change={deltaRequests !== null ? deltaRequests : undefined}
					trend={trendRequests}
					trendPeriod={trendPeriod}
					icon={Activity}
				/>
				<MetricCard
					title="Success Rate"
					value={formatPercentage(analytics?.totals.successRate || 0, 0)}
					change={deltaSuccessRate !== null ? deltaSuccessRate : undefined}
					trend={trendSuccessRate}
					trendPeriod={trendPeriod}
					icon={CheckCircle}
				/>
				<MetricCard
					title="Avg Response Time"
					value={`${Math.round(analytics?.totals.avgResponseTime || 0)}ms`}
					change={deltaResponseTime !== null ? deltaResponseTime : undefined}
					trend={trendResponseTime}
					trendPeriod={trendPeriod}
					icon={Clock}
				/>
				<MetricCard
					title="Total Cost"
					value={
						analytics?.totals.totalCostUsd
							? formatCost(analytics.totals.totalCostUsd)
							: "$0.0000"
					}
					change={deltaCost !== null ? deltaCost : undefined}
					trend={trendCost}
					trendPeriod={trendPeriod}
					icon={DollarSign}
				/>
				<MetricCard
					title="Output Speed"
					value={formatTokensPerSecond(analytics?.totals.avgTokensPerSecond)}
					change={deltaOutputSpeed !== null ? deltaOutputSpeed : undefined}
					trend={trendOutputSpeed}
					trendPeriod={trendPeriod}
					icon={Zap}
				/>
			</div>

			<ChartsSection
				timeSeriesData={timeSeriesData}
				modelData={modelData}
				accountHealthData={accountHealthData}
				loading={loading}
			/>

			<SystemStatus recentErrors={stats?.recentErrors} />

			{accounts && <RateLimitInfo accounts={accounts} />}

			{/* Configuration Row */}
			<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
				<StrategyCard />
				<DataRetentionCard />
			</div>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/TokenUsageDisplay.tsx
================
import { processTokenUsage } from "@ccflare/ui-common";
import type { RequestSummary } from "../api";

interface TokenUsageDisplayProps {
	summary: RequestSummary | undefined;
}

export function TokenUsageDisplay({ summary }: TokenUsageDisplayProps) {
	// Convert RequestSummary to TokenUsageData format, handling null -> undefined conversion
	const tokenData = summary
		? {
				inputTokens: summary.inputTokens,
				outputTokens: summary.outputTokens,
				cacheReadInputTokens: summary.cacheReadInputTokens,
				cacheCreationInputTokens: summary.cacheCreationInputTokens,
				totalTokens: summary.totalTokens,
				costUsd: summary.costUsd,
				responseTimeMs: summary.responseTimeMs ?? undefined,
				tokensPerSecond: summary.tokensPerSecond,
			}
		: undefined;

	const usage = processTokenUsage(tokenData);

	if (!usage.hasData) {
		return (
			<div className="text-center text-muted-foreground py-8">
				<p>No token usage data available</p>
			</div>
		);
	}

	const { sections } = usage;

	return (
		<div className="space-y-4">
			<div className="grid grid-cols-2 gap-4">
				{sections.inputTokens && (
					<div className="bg-muted p-4 rounded-lg">
						<h4 className="font-semibold mb-2">{sections.inputTokens.label}</h4>
						<p className="text-2xl font-mono">{sections.inputTokens.value}</p>
					</div>
				)}

				{sections.outputTokens && (
					<div className="bg-muted p-4 rounded-lg">
						<h4 className="font-semibold mb-2">
							{sections.outputTokens.label}
						</h4>
						<p className="text-2xl font-mono">{sections.outputTokens.value}</p>
					</div>
				)}

				{sections.cacheReadTokens && (
					<div className="bg-muted p-4 rounded-lg">
						<h4 className="font-semibold mb-2">
							{sections.cacheReadTokens.label}
						</h4>
						<p className="text-2xl font-mono">
							{sections.cacheReadTokens.value}
						</p>
					</div>
				)}

				{sections.cacheCreationTokens && (
					<div className="bg-muted p-4 rounded-lg">
						<h4 className="font-semibold mb-2">
							{sections.cacheCreationTokens.label}
						</h4>
						<p className="text-2xl font-mono">
							{sections.cacheCreationTokens.value}
						</p>
					</div>
				)}
			</div>

			{sections.totalTokens && (
				<div className="bg-primary/10 p-4 rounded-lg">
					<h4 className="font-semibold mb-2">{sections.totalTokens.label}</h4>
					<p className="text-3xl font-mono font-bold">
						{sections.totalTokens.value}
					</p>
					{sections.cost && (
						<p className="mt-2 text-lg text-muted-foreground">
							{sections.cost.label}: {sections.cost.value}
						</p>
					)}
				</div>
			)}

			{sections.responseTime && (
				<div className="bg-muted p-4 rounded-lg">
					<h4 className="font-semibold mb-2">{sections.responseTime.label}</h4>
					<p className="text-2xl font-mono">{sections.responseTime.value}</p>
				</div>
			)}

			{sections.tokensPerSecond && (
				<div className="bg-muted p-4 rounded-lg">
					<h4 className="font-semibold mb-2">
						{sections.tokensPerSecond.label}
					</h4>
					<p className="text-2xl font-mono">{sections.tokensPerSecond.value}</p>
				</div>
			)}
		</div>
	);
}

================
File: packages/dashboard-web/src/components/ToolsTab.tsx
================
import { SystemPromptInterceptorCard } from "./tools/SystemPromptInterceptorCard";

export function ToolsTab() {
	return (
		<div className="container mx-auto p-6">
			<SystemPromptInterceptorCard />
		</div>
	);
}

================
File: packages/dashboard-web/src/components/RequestsTab.tsx
================
import {
	formatCost,
	formatDuration,
	formatTokens,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import {
	Bot,
	Calendar,
	ChevronDown,
	ChevronRight,
	Clock,
	Eye,
	Filter,
	Hash,
	RefreshCw,
	User,
	X,
} from "lucide-react";
import { useState } from "react";
import type { RequestPayload, RequestSummary } from "../api";
import { useRequests } from "../hooks/queries";
import { useRequestStream } from "../hooks/useRequestStream";
import { CopyButton } from "./CopyButton";
import { RequestDetailsModal } from "./RequestDetailsModal";
import { TokenUsageDisplay } from "./TokenUsageDisplay";
import { Badge } from "./ui/badge";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuTrigger,
} from "./ui/dropdown-menu";
import { Input } from "./ui/input";
import { Label } from "./ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "./ui/select";

export function RequestsTab() {
	const [expandedRequests, setExpandedRequests] = useState<Set<string>>(
		new Set(),
	);
	const [modalRequest, setModalRequest] = useState<RequestPayload | null>(null);
	const [accountFilter, setAccountFilter] = useState<string>("all");
	const [agentFilter, setAgentFilter] = useState<string>("all");
	const [dateFrom, setDateFrom] = useState<string>("");
	const [dateTo, setDateTo] = useState<string>("");
	const [showFilters, setShowFilters] = useState(false);
	const [statusCodeFilters, setStatusCodeFilters] = useState<Set<string>>(
		new Set(),
	);

	const {
		data: requestsData,
		isLoading: loading,
		error,
		refetch: loadRequests,
	} = useRequests(200);

	// Enable real-time updates
	useRequestStream(200);

	// Transform the data to match the expected structure
	const data = requestsData
		? {
				requests: requestsData.requests,
				summaries: new Map(
					requestsData.detailsMap instanceof Map
						? requestsData.detailsMap
						: requestsData.detailsMap.map(
								(s: RequestSummary) => [s.id, s] as [string, RequestSummary],
							),
				),
			}
		: null;

	// Extract unique accounts for filter dropdown
	const uniqueAccounts = data
		? Array.from(
				new Set(
					data.requests
						.map((r) => r.meta.accountName || r.meta.accountId)
						.filter(Boolean),
				),
			).sort()
		: [];

	// Extract unique status codes for filter
	const uniqueStatusCodes = data
		? Array.from(
				new Set(
					data.requests
						.map((r) => r.response?.status)
						.filter((status): status is number => status !== undefined),
				),
			).sort((a, b) => a - b)
		: [];

	// Extract unique agents for filter
	const uniqueAgents = data
		? Array.from(
				new Set(
					data.requests
						.map((r) => {
							const summary = data.summaries.get(r.id);
							return summary?.agentUsed || r.meta.agentUsed;
						})
						.filter(Boolean),
				),
			).sort()
		: [];

	// Filter requests based on selected filters
	const filteredRequests = data
		? data.requests.filter((request) => {
				// Account filter
				if (accountFilter !== "all") {
					const requestAccount =
						request.meta.accountName || request.meta.accountId;
					if (requestAccount !== accountFilter) return false;
				}

				// Agent filter
				if (agentFilter !== "all") {
					const summary = data.summaries.get(request.id);
					const requestAgent = summary?.agentUsed || request.meta.agentUsed;
					if (requestAgent !== agentFilter) return false;
				}

				// Status code filter
				if (statusCodeFilters.size > 0 && request.response?.status) {
					if (!statusCodeFilters.has(request.response.status.toString())) {
						return false;
					}
				}

				// Date range filter
				const requestDate = new Date(request.meta.timestamp);
				if (dateFrom) {
					const fromDate = new Date(dateFrom);
					fromDate.setHours(0, 0, 0, 0);
					if (requestDate < fromDate) return false;
				}
				if (dateTo) {
					const toDate = new Date(dateTo);
					toDate.setHours(23, 59, 59, 999);
					if (requestDate > toDate) return false;
				}

				return true;
			})
		: [];

	const toggleExpanded = (id: string) => {
		setExpandedRequests((prev) => {
			const next = new Set(prev);
			if (next.has(id)) {
				next.delete(id);
			} else {
				next.add(id);
			}
			return next;
		});
	};

	// Date preset helpers
	const applyDatePreset = (preset: string) => {
		const now = new Date();
		const toDate = now.toISOString().slice(0, 16);

		switch (preset) {
			case "1h": {
				const fromDate = new Date(now.getTime() - 60 * 60 * 1000);
				setDateFrom(fromDate.toISOString().slice(0, 16));
				setDateTo(toDate);
				break;
			}
			case "24h": {
				const fromDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
				setDateFrom(fromDate.toISOString().slice(0, 16));
				setDateTo(toDate);
				break;
			}
			case "7d": {
				const fromDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
				setDateFrom(fromDate.toISOString().slice(0, 16));
				setDateTo(toDate);
				break;
			}
			case "30d": {
				const fromDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
				setDateFrom(fromDate.toISOString().slice(0, 16));
				setDateTo(toDate);
				break;
			}
		}
	};

	const toggleStatusCode = (code: string) => {
		setStatusCodeFilters((prev) => {
			const next = new Set(prev);
			if (next.has(code)) {
				next.delete(code);
			} else {
				next.add(code);
			}
			return next;
		});
	};

	const getStatusCodeColor = (code: number) => {
		if (code >= 200 && code < 300) return "text-green-600";
		if (code >= 400 && code < 500) return "text-yellow-600";
		if (code >= 500) return "text-red-600";
		return "text-gray-600";
	};

	const clearAllFilters = () => {
		setAccountFilter("all");
		setAgentFilter("all");
		setDateFrom("");
		setDateTo("");
		setStatusCodeFilters(new Set());
	};

	const hasActiveFilters =
		accountFilter !== "all" ||
		agentFilter !== "all" ||
		dateFrom ||
		dateTo ||
		statusCodeFilters.size > 0;

	const decodeBase64 = (str: string | null): string => {
		if (!str) return "No data";
		try {
			// Handle edge cases like "[streamed]" from older data
			if (str === "[streamed]") {
				return "[Streaming data not captured]";
			}
			return atob(str);
		} catch (error) {
			console.error("Failed to decode base64:", error, "Input:", str);
			return `Failed to decode: ${str}`;
		}
	};

	/**
	 * Copy the given request to the clipboard as pretty-printed JSON, with
	 * any base64-encoded bodies already decoded for easier debugging.
	 */
	// copyRequest helper removed â€“ handled inline by CopyButton

	if (loading) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-muted-foreground">Loading requests...</p>
				</CardContent>
			</Card>
		);
	}

	if (error) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-destructive">
						Error: {error instanceof Error ? error.message : String(error)}
					</p>
					<Button
						onClick={() => loadRequests()}
						variant="outline"
						size="sm"
						className="mt-2"
					>
						<RefreshCw className="mr-2 h-4 w-4" />
						Retry
					</Button>
				</CardContent>
			</Card>
		);
	}

	return (
		<Card>
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle>Request History</CardTitle>
						<CardDescription>
							Detailed request and response data (last 200)
						</CardDescription>
					</div>
					<div className="flex gap-2">
						<Button
							onClick={() => setShowFilters(!showFilters)}
							variant={showFilters ? "default" : "outline"}
							size="sm"
							className="relative"
						>
							<Filter className="h-4 w-4 mr-2" />
							Filters
							{hasActiveFilters && !showFilters && (
								<span className="absolute -top-1 -right-1 h-2 w-2 bg-primary rounded-full animate-pulse" />
							)}
						</Button>
						<Button onClick={() => loadRequests()} variant="ghost" size="icon">
							<RefreshCw className="h-4 w-4" />
						</Button>
					</div>
				</div>
			</CardHeader>
			<CardContent>
				{/* Active Filters Display */}
				{hasActiveFilters && (
					<div className="mb-4 p-3 bg-muted/50 rounded-lg">
						<div className="flex flex-wrap items-center gap-2">
							{accountFilter !== "all" && (
								<Badge variant="outline" className="gap-1.5 pr-1">
									<User className="h-3 w-3" />
									{accountFilter}
									<button
										type="button"
										onClick={() => setAccountFilter("all")}
										className="ml-1 p-0.5 hover:bg-destructive/20 rounded"
									>
										<X className="h-3 w-3" />
									</button>
								</Badge>
							)}
							{agentFilter !== "all" && (
								<Badge variant="outline" className="gap-1.5 pr-1">
									<Bot className="h-3 w-3" />
									{agentFilter}
									<button
										type="button"
										onClick={() => setAgentFilter("all")}
										className="ml-1 p-0.5 hover:bg-destructive/20 rounded"
									>
										<X className="h-3 w-3" />
									</button>
								</Badge>
							)}
							{statusCodeFilters.size > 0 && (
								<Badge variant="outline" className="gap-1.5 pr-1">
									<Hash className="h-3 w-3" />
									{Array.from(statusCodeFilters).join(", ")}
									<button
										type="button"
										onClick={() => setStatusCodeFilters(new Set())}
										className="ml-1 p-0.5 hover:bg-destructive/20 rounded"
									>
										<X className="h-3 w-3" />
									</button>
								</Badge>
							)}
							{(dateFrom || dateTo) && (
								<Badge variant="outline" className="gap-1.5 pr-1">
									<Calendar className="h-3 w-3" />
									{dateFrom && dateTo
										? "Custom range"
										: dateFrom
											? `From ${new Date(dateFrom).toLocaleDateString()}`
											: `Until ${new Date(dateTo).toLocaleDateString()}`}
									<button
										type="button"
										onClick={() => {
											setDateFrom("");
											setDateTo("");
										}}
										className="ml-1 p-0.5 hover:bg-destructive/20 rounded"
									>
										<X className="h-3 w-3" />
									</button>
								</Badge>
							)}
							<div className="ml-auto flex items-center gap-2">
								<span className="text-xs text-muted-foreground">
									{filteredRequests.length} of {data?.requests.length || 0}{" "}
									requests
								</span>
								<Button
									variant="ghost"
									size="sm"
									onClick={clearAllFilters}
									className="h-7 text-xs"
								>
									Clear all
								</Button>
							</div>
						</div>
					</div>
				)}

				{/* Filters Panel */}
				{showFilters && (
					<div className="mb-6 border rounded-lg bg-card">
						<div className="p-4 border-b">
							<div className="flex items-center justify-between">
								<h3 className="font-medium">Filters</h3>
								<Button
									variant="ghost"
									size="sm"
									onClick={() => setShowFilters(false)}
									className="h-8 w-8 p-0"
								>
									<X className="h-4 w-4" />
								</Button>
							</div>
						</div>

						<div className="p-4 space-y-4">
							{/* Time Range Section */}
							<div>
								<h4 className="text-sm font-medium mb-3 flex items-center gap-2">
									<Clock className="h-4 w-4" />
									Time Range
								</h4>
								<div className="flex flex-wrap gap-2 mb-3">
									<Button
										variant={dateFrom || dateTo ? "outline" : "secondary"}
										size="sm"
										onClick={() => applyDatePreset("1h")}
									>
										Last hour
									</Button>
									<Button
										variant={dateFrom || dateTo ? "outline" : "secondary"}
										size="sm"
										onClick={() => applyDatePreset("24h")}
									>
										Last 24h
									</Button>
									<Button
										variant={dateFrom || dateTo ? "outline" : "secondary"}
										size="sm"
										onClick={() => applyDatePreset("7d")}
									>
										Last 7 days
									</Button>
									<Button
										variant={dateFrom || dateTo ? "outline" : "secondary"}
										size="sm"
										onClick={() => applyDatePreset("30d")}
									>
										Last 30 days
									</Button>
								</div>
								<div className="grid grid-cols-2 gap-3">
									<div>
										<Label htmlFor="date-from" className="text-xs">
											From
										</Label>
										<Input
											id="date-from"
											type="datetime-local"
											value={dateFrom}
											onChange={(e) => setDateFrom(e.target.value)}
											className="h-9 text-sm"
										/>
									</div>
									<div>
										<Label htmlFor="date-to" className="text-xs">
											To
										</Label>
										<Input
											id="date-to"
											type="datetime-local"
											value={dateTo}
											onChange={(e) => setDateTo(e.target.value)}
											className="h-9 text-sm"
										/>
									</div>
								</div>
							</div>

							<div className="h-px bg-border" />

							{/* Resource Filters */}
							<div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
								{/* Account Filter */}
								<div>
									<Label className="text-xs flex items-center gap-1 mb-2">
										<User className="h-3 w-3" />
										Account
									</Label>
									<Select
										value={accountFilter}
										onValueChange={setAccountFilter}
									>
										<SelectTrigger className="h-9">
											<SelectValue placeholder="All accounts" />
										</SelectTrigger>
										<SelectContent>
											<SelectItem value="all">All accounts</SelectItem>
											{uniqueAccounts.map((account) => (
												<SelectItem key={account} value={account || ""}>
													{account}
												</SelectItem>
											))}
										</SelectContent>
									</Select>
								</div>

								{/* Agent Filter */}
								<div>
									<Label className="text-xs flex items-center gap-1 mb-2">
										<Bot className="h-3 w-3" />
										Agent
									</Label>
									<Select value={agentFilter} onValueChange={setAgentFilter}>
										<SelectTrigger className="h-9">
											<SelectValue placeholder="All agents" />
										</SelectTrigger>
										<SelectContent>
											<SelectItem value="all">All agents</SelectItem>
											{uniqueAgents.map((agent) => (
												<SelectItem key={agent} value={agent || ""}>
													{agent}
												</SelectItem>
											))}
										</SelectContent>
									</Select>
								</div>

								{/* Status Code Filter */}
								<div>
									<Label className="text-xs flex items-center gap-1 mb-2">
										<Hash className="h-3 w-3" />
										Status Code
									</Label>
									<DropdownMenu>
										<DropdownMenuTrigger asChild>
											<Button
												variant="outline"
												className="h-9 w-full justify-between font-normal"
											>
												{statusCodeFilters.size > 0
													? `${statusCodeFilters.size} selected`
													: "All codes"}
												<ChevronDown className="h-4 w-4 opacity-50" />
											</Button>
										</DropdownMenuTrigger>
										<DropdownMenuContent className="w-56 max-h-64 overflow-y-auto">
											<div className="p-2">
												<div className="text-xs font-medium text-muted-foreground mb-2">
													Select status codes
												</div>
												{uniqueStatusCodes.map((code) => (
													<button
														key={code}
														type="button"
														className="flex items-center gap-2 p-2 hover:bg-accent rounded cursor-pointer w-full text-left"
														onClick={() => toggleStatusCode(code.toString())}
													>
														<div
															className={`w-4 h-4 border rounded-sm flex items-center justify-center ${
																statusCodeFilters.has(code.toString())
																	? "bg-primary border-primary"
																	: "border-input"
															}`}
														>
															{statusCodeFilters.has(code.toString()) && (
																<svg
																	className="w-3 h-3 text-primary-foreground"
																	fill="none"
																	viewBox="0 0 24 24"
																	stroke="currentColor"
																	aria-label="Selected"
																>
																	<title>Selected</title>
																	<path
																		strokeLinecap="round"
																		strokeLinejoin="round"
																		strokeWidth={3}
																		d="M5 13l4 4L19 7"
																	/>
																</svg>
															)}
														</div>
														<span
															className={`text-sm font-medium ${getStatusCodeColor(code)}`}
														>
															{code}
														</span>
													</button>
												))}
											</div>
										</DropdownMenuContent>
									</DropdownMenu>
								</div>
							</div>
						</div>
					</div>
				)}

				{!data ? (
					<p className="text-muted-foreground">No requests found</p>
				) : filteredRequests.length === 0 ? (
					<p className="text-muted-foreground">
						No requests match the selected filters
					</p>
				) : (
					<div className="space-y-2">
						{filteredRequests.map((request) => {
							const isExpanded = expandedRequests.has(request.id);
							const isError = request.error || !request.meta.success;
							const statusCode = request.response?.status;
							const summary = data.summaries.get(request.id);

							return (
								<div
									key={request.id}
									className={`border rounded-lg p-3 transition-all duration-300 ${
										isError ? "border-destructive/50" : "border-border"
									} ${request.meta.pending ? "animate-pulse opacity-70" : "opacity-100"}`}
								>
									<button
										type="button"
										className="flex items-center justify-between cursor-pointer w-full text-left"
										onClick={() => toggleExpanded(request.id)}
									>
										<div className="flex items-center gap-2 flex-wrap">
											{isExpanded ? (
												<ChevronDown className="h-4 w-4" />
											) : (
												<ChevronRight className="h-4 w-4" />
											)}
											<span className="text-sm font-mono">
												{new Date(request.meta.timestamp).toLocaleTimeString()}
											</span>
											{(request.meta.method || summary?.method) && (
												<span className="text-sm font-medium">
													{request.meta.method || summary?.method}
												</span>
											)}
											{(request.meta.path || summary?.path) && (
												<span className="text-sm text-muted-foreground font-mono">
													{request.meta.path || summary?.path}
												</span>
											)}
											{statusCode && (
												<span
													className={`text-sm font-medium ${
														statusCode >= 200 && statusCode < 300
															? "text-green-600"
															: statusCode >= 400 && statusCode < 500
																? "text-yellow-600"
																: "text-red-600"
													}`}
												>
													{statusCode}
												</span>
											)}
											{summary?.model && (
												<Badge variant="secondary" className="text-xs">
													{summary.model}
												</Badge>
											)}
											{(summary?.agentUsed || request.meta.agentUsed) && (
												<Badge variant="secondary" className="text-xs">
													Agent: {summary?.agentUsed || request.meta.agentUsed}
												</Badge>
											)}
											{(summary?.totalTokens || request.meta.pending) && (
												<Badge variant="outline" className="text-xs">
													{summary?.totalTokens
														? formatTokens(summary.totalTokens)
														: "--"}{" "}
													tokens
												</Badge>
											)}
											{(summary?.costUsd || request.meta.pending) && (
												<Badge variant="default" className="text-xs">
													{summary?.costUsd && summary.costUsd > 0
														? formatCost(summary.costUsd)
														: "--"}
												</Badge>
											)}
											{summary?.tokensPerSecond &&
												summary.tokensPerSecond > 0 && (
													<Badge variant="secondary" className="text-xs">
														{formatTokensPerSecond(summary.tokensPerSecond)}
													</Badge>
												)}
											{(request.meta.accountName || request.meta.accountId) && (
												<span className="text-sm text-muted-foreground">
													via{" "}
													{request.meta.accountName ||
														`${request.meta.accountId?.slice(0, 8)}...`}
												</span>
											)}
											{request.meta.rateLimited && (
												<Badge variant="warning" className="text-xs">
													Rate Limited
												</Badge>
											)}
											{request.error && (
												<span className="text-sm text-destructive">
													Error: {request.error}
												</span>
											)}
										</div>
										<div className="text-sm text-muted-foreground flex items-center gap-2">
											{(summary?.responseTimeMs || request.meta.pending) && (
												<span>
													{summary?.responseTimeMs
														? formatDuration(summary.responseTimeMs)
														: "--"}
												</span>
											)}
											{request.meta.retry !== undefined &&
												request.meta.retry > 0 && (
													<span>Retry {request.meta.retry}</span>
												)}
											<span>ID: {request.id.slice(0, 8)}...</span>
										</div>
									</button>

									{/* Action buttons */}
									<div className="flex justify-end gap-2 mt-2">
										<Button
											variant="ghost"
											size="icon"
											onClick={() => setModalRequest(request)}
											title="View Details"
										>
											<Eye className="h-4 w-4" />
										</Button>
										<CopyButton
											variant="ghost"
											size="icon"
											title="Copy as JSON"
											getValue={() => {
												const decoded: RequestPayload & { decoded?: true } = {
													...request,
													request: {
														...request.request,
														body: request.request.body
															? decodeBase64(request.request.body)
															: null,
													},
													response: request.response
														? {
																...request.response,
																body: request.response.body
																	? decodeBase64(request.response.body)
																	: null,
															}
														: null,
													decoded: true,
												};
												return JSON.stringify(decoded, null, 2);
											}}
										/>
									</div>

									{isExpanded && (
										<div className="mt-3 space-y-3">
											<TokenUsageDisplay summary={summary} />
											<Button
												variant="outline"
												size="sm"
												onClick={() => setModalRequest(request)}
												className="w-full"
											>
												<Eye className="h-4 w-4 mr-2" />
												View More Details
											</Button>
										</div>
									)}
								</div>
							);
						})}
					</div>
				)}
			</CardContent>

			{modalRequest && (
				<RequestDetailsModal
					request={modalRequest}
					summary={data?.summaries.get(modalRequest.id)}
					isOpen={true}
					onClose={() => setModalRequest(null)}
				/>
			)}
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/StrategyCard.tsx
================
import { RefreshCw, Settings } from "lucide-react";
import { useCallback, useEffect, useState } from "react";
import { api } from "../api";
import { Badge } from "./ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "./ui/select";
import { Skeleton } from "./ui/skeleton";

export function StrategyCard() {
	const [currentStrategy, setCurrentStrategy] = useState<string>("");
	const [strategies, setStrategies] = useState<string[]>([]);
	const [loading, setLoading] = useState(true);
	const [changing, setChanging] = useState(false);
	const [error, setError] = useState<string | null>(null);
	const [success, setSuccess] = useState(false);

	const loadData = useCallback(async () => {
		try {
			setLoading(true);
			setError(null);
			const [current, list] = await Promise.all([
				api.getStrategy(),
				api.listStrategies(),
			]);
			setCurrentStrategy(current);
			setStrategies(list);
		} catch (err) {
			setError(err instanceof Error ? err.message : "Failed to load data");
		} finally {
			setLoading(false);
		}
	}, []);

	useEffect(() => {
		loadData();
	}, [loadData]);

	const handleStrategyChange = async (newStrategy: string) => {
		if (newStrategy === currentStrategy) return;

		try {
			setChanging(true);
			setError(null);
			setSuccess(false);
			await api.setStrategy(newStrategy);
			setCurrentStrategy(newStrategy);
			setSuccess(true);
			setTimeout(() => setSuccess(false), 3000);
		} catch (err) {
			setError(
				err instanceof Error ? err.message : "Failed to update strategy",
			);
		} finally {
			setChanging(false);
		}
	};

	if (loading) {
		return (
			<Card>
				<CardHeader>
					<CardTitle>Load Balancer Strategy</CardTitle>
					<CardDescription>
						Configure how requests are distributed across accounts
					</CardDescription>
				</CardHeader>
				<CardContent>
					<Skeleton className="h-10 w-full" />
				</CardContent>
			</Card>
		);
	}

	return (
		<Card className="card-hover">
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle className="flex items-center gap-2">
							<Settings className="h-5 w-5" />
							Load Balancer Strategy
						</CardTitle>
						<CardDescription>
							Configure how requests are distributed across accounts
						</CardDescription>
					</div>
					{success && (
						<Badge variant="default" className="bg-success">
							Updated
						</Badge>
					)}
				</div>
			</CardHeader>
			<CardContent>
				<div className="space-y-4">
					<div>
						<p className="text-sm font-medium mb-2">Current Strategy</p>
						<Select
							value={currentStrategy}
							onValueChange={handleStrategyChange}
							disabled={changing}
						>
							<SelectTrigger className="w-full">
								<SelectValue placeholder="Select a strategy" />
							</SelectTrigger>
							<SelectContent>
								{strategies.map((strategy) => (
									<SelectItem key={strategy} value={strategy}>
										{strategy}
									</SelectItem>
								))}
							</SelectContent>
						</Select>
					</div>

					{changing && (
						<div className="flex items-center gap-2 text-sm text-muted-foreground">
							<RefreshCw className="h-4 w-4 animate-spin" />
							Updating strategy...
						</div>
					)}

					{error && (
						<div className="text-sm text-destructive">Error: {error}</div>
					)}

					<div className="text-xs text-muted-foreground">
						<p>
							<strong>session:</strong> Maintains 5-hour sessions with a single
							account to minimize rate limits
						</p>
					</div>
				</div>
			</CardContent>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/LogsTab.tsx
================
import { Pause, Play, Trash2 } from "lucide-react";
import { useCallback, useEffect, useRef, useState } from "react";
import { api, type LogEntry } from "../api";
import { useLogHistory } from "../hooks/queries";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";

export function LogsTab() {
	const [logs, setLogs] = useState<LogEntry[]>([]);
	const [paused, setPaused] = useState(false);
	const [autoScroll, setAutoScroll] = useState(true);
	const eventSourceRef = useRef<EventSource | null>(null);
	const logsEndRef = useRef<HTMLDivElement>(null);

	const startStreaming = useCallback(() => {
		eventSourceRef.current = api.streamLogs((log: LogEntry) => {
			setLogs((prev) => [...prev.slice(-999), log]); // Keep last 1000 logs
			// Auto-scroll to bottom when new log arrives
			if (autoScroll && logsEndRef.current) {
				setTimeout(() => {
					logsEndRef.current?.scrollIntoView({ behavior: "smooth" });
				}, 0);
			}
		});
	}, [autoScroll]);

	const stopStreaming = useCallback(() => {
		if (eventSourceRef.current) {
			eventSourceRef.current.close();
			eventSourceRef.current = null;
		}
	}, []);

	// Load historical logs on mount
	const { data: history, isLoading: loading, error } = useLogHistory();

	useEffect(() => {
		if (history) {
			setLogs(history);
			// Auto-scroll to bottom after loading history
			if (autoScroll && logsEndRef.current) {
				setTimeout(() => {
					logsEndRef.current?.scrollIntoView({ behavior: "smooth" });
				}, 0);
			}
		}
	}, [history, autoScroll]);

	useEffect(() => {
		if (!paused && !loading) {
			startStreaming();
		}

		return () => {
			stopStreaming();
		};
	}, [paused, loading, startStreaming, stopStreaming]);

	useEffect(() => {
		if (autoScroll && logsEndRef.current) {
			logsEndRef.current.scrollIntoView({ behavior: "smooth" });
		}
	}, [autoScroll]);

	const clearLogs = () => {
		setLogs([]);
	};

	const togglePause = () => {
		setPaused(!paused);
	};

	const getLogColor = (level: string | undefined) => {
		if (!level) return "";
		switch (level.toUpperCase()) {
			case "ERROR":
				return "text-destructive";
			case "WARN":
				return "text-yellow-600";
			case "INFO":
				return "text-green-600";
			case "DEBUG":
				return "text-muted-foreground";
			default:
				return "";
		}
	};

	const formatTimestamp = (ts: number) => {
		return new Date(ts).toLocaleTimeString();
	};

	return (
		<Card>
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle>Live Logs</CardTitle>
						<CardDescription>
							Real-time log stream {paused && "(Paused)"}
						</CardDescription>
					</div>
					<div className="flex gap-2">
						<Button onClick={togglePause} variant="outline" size="sm">
							{paused ? (
								<>
									<Play className="mr-2 h-4 w-4" />
									Resume
								</>
							) : (
								<>
									<Pause className="mr-2 h-4 w-4" />
									Pause
								</>
							)}
						</Button>
						<Button onClick={clearLogs} variant="outline" size="sm">
							<Trash2 className="mr-2 h-4 w-4" />
							Clear
						</Button>
					</div>
				</div>
			</CardHeader>
			<CardContent>
				<div className="space-y-1 max-h-[500px] overflow-y-auto font-mono text-sm">
					{loading ? (
						<p className="text-muted-foreground">Loading logs...</p>
					) : error ? (
						<p className="text-destructive">
							Error: {error instanceof Error ? error.message : String(error)}
						</p>
					) : logs.length === 0 ? (
						<p className="text-muted-foreground">No logs yet...</p>
					) : (
						logs.map((log, i) => (
							<div key={`${log.ts}-${i}`} className="flex gap-2">
								<span className="text-muted-foreground">
									{formatTimestamp(log.ts)}
								</span>
								<span className={`font-medium ${getLogColor(log.level)}`}>
									[{log.level || "LOG"}]
								</span>
								<span className="flex-1">{log.msg}</span>
							</div>
						))
					)}
					<div ref={logsEndRef} />
				</div>
				<div className="mt-4 flex items-center gap-2">
					<input
						type="checkbox"
						id="autoscroll"
						checked={autoScroll}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
							setAutoScroll((e.target as HTMLInputElement).checked)
						}
						className="rounded border-gray-300"
					/>
					<label htmlFor="autoscroll" className="text-sm text-muted-foreground">
						Auto-scroll to bottom
					</label>
				</div>
			</CardContent>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/AnalyticsTab.tsx
================
import { format } from "date-fns";
import { useMemo, useState } from "react";
import type { TimeRange } from "../constants";
import { useAnalytics } from "../hooks/queries";
import {
	AnalyticsControls,
	CumulativeGrowthChart,
	CumulativeTokenComposition,
	type FilterState,
	MainMetricsChart,
	ModelAnalytics,
	PerformanceIndicatorsChart,
	TokenSpeedAnalytics,
	TokenUsageBreakdown,
} from "./analytics";

export function AnalyticsTab() {
	const [timeRange, setTimeRange] = useState<TimeRange>("1h");
	const [selectedMetric, setSelectedMetric] = useState("requests");
	const [filterOpen, setFilterOpen] = useState(false);
	const [viewMode, setViewMode] = useState<"normal" | "cumulative">("normal");
	const [modelBreakdown, setModelBreakdown] = useState(false);
	const [filters, setFilters] = useState<FilterState>({
		accounts: [],
		models: [],
		status: "all",
	});

	// Fetch analytics data with automatic refetch on dependency changes
	const { data: analytics, isLoading: loading } = useAnalytics(
		timeRange,
		filters,
		viewMode,
		modelBreakdown,
	);

	// Get unique accounts and models from analytics data
	const availableAccounts = useMemo(
		() => analytics?.accountPerformance?.map((a) => a.name) || [],
		[analytics],
	);
	const availableModels = useMemo(
		() => analytics?.modelDistribution?.map((m) => m.model) || [],
		[analytics],
	);

	// Apply filters to data
	const filterData = <T extends { errorRate?: number | string }>(
		data: T[],
	): T[] => {
		if (!analytics) return data;

		return data.filter((point) => {
			// Status filter
			if (filters.status !== "all") {
				const errorRate =
					typeof point.errorRate === "string"
						? parseFloat(point.errorRate)
						: point.errorRate || 0;
				if (filters.status === "success" && errorRate > 50) return false;
				if (filters.status === "error" && errorRate <= 50) return false;
			}

			// For time series data, we can't filter by specific accounts/models
			// Those filters will be applied to the other charts
			return true;
		});
	};

	// Transform time series data for charts
	const data = filterData(
		analytics?.timeSeries.map((point) => ({
			time:
				timeRange === "30d"
					? format(new Date(point.ts), "MMM d")
					: format(new Date(point.ts), "HH:mm"),
			requests: point.requests,
			tokens: point.tokens,
			cost: parseFloat(point.costUsd.toFixed(2)),
			responseTime: Math.round(point.avgResponseTime),
			errorRate: parseFloat(point.errorRate.toFixed(1)),
			cacheHitRate: parseFloat(point.cacheHitRate.toFixed(1)),
			avgTokensPerSecond: point.avgTokensPerSecond || 0,
		})) || [],
	);

	// Calculate token usage breakdown
	const tokenBreakdown = analytics?.tokenBreakdown
		? [
				{
					type: "Input Tokens",
					value: analytics.tokenBreakdown.inputTokens,
					percentage: 0,
				},
				{
					type: "Cache Read",
					value: analytics.tokenBreakdown.cacheReadInputTokens,
					percentage: 0,
				},
				{
					type: "Cache Creation",
					value: analytics.tokenBreakdown.cacheCreationInputTokens,
					percentage: 0,
				},
				{
					type: "Output Tokens",
					value: analytics.tokenBreakdown.outputTokens,
					percentage: 0,
				},
			].map((item) => {
				const total = analytics.totals.totalTokens || 1;
				return { ...item, percentage: Math.round((item.value / total) * 100) };
			})
		: [];

	// Use real model performance data from backend with filters
	const _modelPerformance =
		analytics?.modelPerformance
			?.filter(
				(perf) =>
					filters.models.length === 0 || filters.models.includes(perf.model),
			)
			?.map((perf) => ({
				model: perf.model,
				avgTime: Math.round(perf.avgResponseTime),
				p95Time: Math.round(perf.p95ResponseTime),
				errorRate: parseFloat(perf.errorRate.toFixed(1)),
			})) || [];

	// Use real cost by model data with filters
	const costByModel =
		analytics?.costByModel
			?.filter(
				(model) =>
					filters.models.length === 0 || filters.models.includes(model.model),
			)
			?.slice(0, 4) || [];

	// Count active filters
	const activeFilterCount =
		filters.accounts.length +
		filters.models.length +
		(filters.status !== "all" ? 1 : 0);

	return (
		<div className="space-y-6">
			{/* Controls */}
			<AnalyticsControls
				timeRange={timeRange}
				setTimeRange={setTimeRange}
				viewMode={viewMode}
				setViewMode={(mode) => {
					setViewMode(mode);
					// Disable per-model breakdown when switching to cumulative
					if (mode === "cumulative") {
						setModelBreakdown(false);
					}
				}}
				filters={filters}
				setFilters={setFilters}
				availableAccounts={availableAccounts}
				availableModels={availableModels}
				activeFilterCount={activeFilterCount}
				filterOpen={filterOpen}
				setFilterOpen={setFilterOpen}
				loading={loading}
				onRefresh={() => setTimeRange(timeRange)}
			/>

			{/* Cumulative View - Show cumulative charts first */}
			{viewMode === "cumulative" && analytics && (
				<>
					{/* Beautiful Cumulative Chart */}
					<CumulativeGrowthChart data={data} />

					{/* Cumulative Token Breakdown Ribbon Chart */}
					{tokenBreakdown.length > 0 && (
						<CumulativeTokenComposition tokenBreakdown={tokenBreakdown} />
					)}
				</>
			)}

			{/* Main Metrics Chart */}
			<MainMetricsChart
				data={data}
				rawTimeSeries={analytics?.timeSeries}
				loading={loading}
				viewMode={viewMode}
				timeRange={timeRange}
				selectedMetric={selectedMetric}
				setSelectedMetric={setSelectedMetric}
				modelBreakdown={modelBreakdown}
				onModelBreakdownChange={setModelBreakdown}
			/>

			{/* Normal View Charts - Only show in normal mode */}
			{viewMode === "normal" && (
				<>
					{/* Secondary Charts Row */}
					<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
						<PerformanceIndicatorsChart
							data={data}
							loading={loading}
							modelBreakdown={modelBreakdown}
							rawTimeSeries={analytics?.timeSeries}
							timeRange={timeRange}
						/>
						<TokenUsageBreakdown
							tokenBreakdown={tokenBreakdown}
							timeRange={timeRange}
						/>
					</div>

					{/* Enhanced Model Analytics */}
					<ModelAnalytics
						modelPerformance={analytics?.modelPerformance || []}
						costByModel={costByModel}
						loading={loading}
						timeRange={timeRange}
					/>

					{/* Token Speed Analytics */}
					<TokenSpeedAnalytics
						timeSeriesData={data}
						modelPerformance={analytics?.modelPerformance || []}
						loading={loading}
						timeRange={timeRange}
					/>
				</>
			)}
		</div>
	);
}

================
File: packages/dashboard-web/src/components/StatsTab.tsx
================
import { formatPercentage } from "@ccflare/ui-common";
import { RefreshCw } from "lucide-react";
import { useResetStats, useStats } from "../hooks/queries";
import { useApiError } from "../hooks/useApiError";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";

export function StatsTab() {
	const { formatError } = useApiError();
	const {
		data: stats,
		isLoading: loading,
		error,
		refetch: loadStats,
	} = useStats();
	const resetStatsMutation = useResetStats();

	const handleResetStats = async () => {
		if (!confirm("Are you sure you want to reset all statistics?")) return;

		try {
			await resetStatsMutation.mutateAsync();
		} catch (err) {
			// Since we can't set error directly, we'll just alert the user
			alert(formatError(err));
		}
	};

	if (loading) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-muted-foreground">Loading statistics...</p>
				</CardContent>
			</Card>
		);
	}

	if (error) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-destructive">Error: {formatError(error)}</p>
					<Button
						onClick={() => loadStats()}
						variant="outline"
						size="sm"
						className="mt-2"
					>
						<RefreshCw className="mr-2 h-4 w-4" />
						Retry
					</Button>
				</CardContent>
			</Card>
		);
	}

	return (
		<div className="space-y-4">
			<Card>
				<CardHeader>
					<div className="flex items-center justify-between">
						<CardTitle>Account Performance</CardTitle>
						<Button onClick={() => loadStats()} variant="ghost" size="sm">
							<RefreshCw className="h-4 w-4" />
						</Button>
					</div>
				</CardHeader>
				<CardContent>
					{stats?.accounts && stats.accounts.length > 0 ? (
						<div className="space-y-4">
							{stats.accounts.map(
								(account: {
									name: string;
									requestCount: number;
									successRate: number;
								}) => (
									<div key={account.name} className="space-y-2">
										<div className="flex items-center justify-between">
											<span className="font-medium">{account.name}</span>
											<span className="text-sm text-muted-foreground">
												{account.requestCount} requests
											</span>
										</div>
										<div className="w-full bg-secondary rounded-full h-2">
											<div
												className="bg-primary h-2 rounded-full transition-all"
												style={{ width: `${account.successRate}%` }}
											/>
										</div>
										<div className="flex items-center justify-between text-sm">
											<span className="text-muted-foreground">
												Success rate
											</span>
											<span
												className={
													account.successRate >= 95
														? "text-green-600"
														: account.successRate >= 80
															? "text-yellow-600"
															: "text-red-600"
												}
											>
												{formatPercentage(account.successRate)}
											</span>
										</div>
									</div>
								),
							)}
						</div>
					) : (
						<p className="text-muted-foreground">No account data available</p>
					)}
				</CardContent>
			</Card>

			{stats?.recentErrors && stats.recentErrors.length > 0 && (
				<Card>
					<CardHeader>
						<CardTitle>Recent Errors</CardTitle>
						<CardDescription>Last 10 errors from all accounts</CardDescription>
					</CardHeader>
					<CardContent>
						<div className="space-y-2">
							{stats.recentErrors.map((error: string, i: number) => (
								<div
									key={`error-${i}-${error.substring(0, 10)}`}
									className="text-sm p-2 bg-destructive/10 rounded-md"
								>
									<p className="text-destructive">{error}</p>
								</div>
							))}
						</div>
					</CardContent>
				</Card>
			)}

			<Card>
				<CardHeader>
					<CardTitle>Actions</CardTitle>
				</CardHeader>
				<CardContent>
					<Button
						onClick={handleResetStats}
						variant="destructive"
						disabled={resetStatsMutation.isPending}
					>
						Reset All Statistics
					</Button>
				</CardContent>
			</Card>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/AccountsTab.tsx
================
import { AlertCircle, Plus } from "lucide-react";
import { useState } from "react";
import { type Account, api } from "../api";
import { useAccounts, useRenameAccount } from "../hooks/queries";
import { useApiError } from "../hooks/useApiError";
import {
	AccountAddForm,
	AccountList,
	DeleteConfirmationDialog,
	RenameAccountDialog,
} from "./accounts";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";

export function AccountsTab() {
	const { formatError } = useApiError();
	const {
		data: accounts,
		isLoading: loading,
		error,
		refetch: loadAccounts,
	} = useAccounts();
	const renameAccount = useRenameAccount();

	const [adding, setAdding] = useState(false);
	const [confirmDelete, setConfirmDelete] = useState<{
		show: boolean;
		accountName: string;
		confirmInput: string;
	}>({
		show: false,
		accountName: "",
		confirmInput: "",
	});
	const [renameDialog, setRenameDialog] = useState<{
		isOpen: boolean;
		account: Account | null;
	}>({
		isOpen: false,
		account: null,
	});
	const [actionError, setActionError] = useState<string | null>(null);

	const handleAddAccount = async (params: {
		name: string;
		mode: "max" | "console";
		tier: number;
	}) => {
		try {
			const result = await api.initAddAccount(params);
			setActionError(null);
			return result;
		} catch (err) {
			setActionError(formatError(err));
			throw err;
		}
	};

	const handleCompleteAccount = async (params: {
		sessionId: string;
		code: string;
	}) => {
		try {
			await api.completeAddAccount(params);
			await loadAccounts();
			setAdding(false);
			setActionError(null);
		} catch (err) {
			setActionError(formatError(err));
			throw err;
		}
	};

	const handleRemoveAccount = (name: string) => {
		setConfirmDelete({ show: true, accountName: name, confirmInput: "" });
	};

	const handleConfirmDelete = async () => {
		if (confirmDelete.confirmInput !== confirmDelete.accountName) {
			setActionError(
				"Account name does not match. Please type the exact account name.",
			);
			return;
		}

		try {
			await api.removeAccount(
				confirmDelete.accountName,
				confirmDelete.confirmInput,
			);
			await loadAccounts();
			setConfirmDelete({ show: false, accountName: "", confirmInput: "" });
			setActionError(null);
		} catch (err) {
			setActionError(formatError(err));
		}
	};

	const handleRename = (account: Account) => {
		setRenameDialog({ isOpen: true, account });
	};

	const handleConfirmRename = async (newName: string) => {
		if (!renameDialog.account) return;

		try {
			await renameAccount.mutateAsync({
				accountId: renameDialog.account.id,
				newName,
			});
			setRenameDialog({ isOpen: false, account: null });
			setActionError(null);
		} catch (err) {
			setActionError(formatError(err));
		}
	};

	const handlePauseToggle = async (account: Account) => {
		try {
			if (account.paused) {
				await api.resumeAccount(account.id);
			} else {
				await api.pauseAccount(account.id);
			}
			await loadAccounts();
		} catch (err) {
			setActionError(formatError(err));
		}
	};

	if (loading) {
		return (
			<Card>
				<CardContent className="pt-6">
					<p className="text-muted-foreground">Loading accounts...</p>
				</CardContent>
			</Card>
		);
	}

	const displayError = error ? formatError(error) : actionError;

	return (
		<div className="space-y-4">
			{displayError && (
				<Card className="border-destructive">
					<CardContent className="pt-6">
						<div className="flex items-center gap-2">
							<AlertCircle className="h-4 w-4 text-destructive" />
							<p className="text-destructive">{displayError}</p>
						</div>
					</CardContent>
				</Card>
			)}

			<Card>
				<CardHeader>
					<div className="flex items-center justify-between">
						<div>
							<CardTitle>Accounts</CardTitle>
							<CardDescription>Manage your Claude accounts</CardDescription>
						</div>
						{!adding && (
							<Button onClick={() => setAdding(true)} size="sm">
								<Plus className="mr-2 h-4 w-4" />
								Add Account
							</Button>
						)}
					</div>
				</CardHeader>
				<CardContent>
					{adding && (
						<AccountAddForm
							onAddAccount={handleAddAccount}
							onCompleteAccount={handleCompleteAccount}
							onCancel={() => {
								setAdding(false);
								setActionError(null);
							}}
							onSuccess={() => {
								setAdding(false);
							}}
							onError={setActionError}
						/>
					)}

					<AccountList
						accounts={accounts}
						onPauseToggle={handlePauseToggle}
						onRemove={handleRemoveAccount}
						onRename={handleRename}
					/>
				</CardContent>
			</Card>

			{confirmDelete.show && (
				<DeleteConfirmationDialog
					accountName={confirmDelete.accountName}
					confirmInput={confirmDelete.confirmInput}
					onConfirmInputChange={(value) =>
						setConfirmDelete({
							...confirmDelete,
							confirmInput: value,
						})
					}
					onConfirm={handleConfirmDelete}
					onCancel={() => {
						setConfirmDelete({
							show: false,
							accountName: "",
							confirmInput: "",
						});
						setActionError(null);
					}}
				/>
			)}

			{renameDialog.isOpen && renameDialog.account && (
				<RenameAccountDialog
					isOpen={renameDialog.isOpen}
					currentName={renameDialog.account.name}
					onClose={() => setRenameDialog({ isOpen: false, account: null })}
					onRename={handleConfirmRename}
					isLoading={renameAccount.isPending}
				/>
			)}
		</div>
	);
}

================
File: packages/dashboard-web/src/components/CopyButton.tsx
================
import { Check, Copy } from "lucide-react";
import { type ComponentProps, useRef, useState } from "react";
import { cn } from "../lib/utils";
import { Button } from "./ui/button";

interface CopyButtonProps {
	/**
	 * String or function returning the string to copy.
	 */
	value?: string;
	getValue?: () => string;
	/**
	 * Forwarded props to underlying Button
	 */
	variant?: ComponentProps<typeof Button>["variant"];
	size?: ComponentProps<typeof Button>["size"];
	className?: string;
	/**
	 * Children to render inside the button. If provided, an icon will be shown to the left.
	 */
	children?: React.ReactNode;
	/**
	 * Optional title attribute for accessibility.
	 */
	title?: string;
}

/**
 * A small wrapper around the standard Button that copies supplied text to the
 * clipboard and temporarily shows a "Copied!" label with a subtle animation.
 */
export function CopyButton({
	value,
	getValue,
	variant = "ghost",
	size = "sm",
	className,
	children,
	title,
}: CopyButtonProps) {
	const [copied, setCopied] = useState(false);
	const timeoutRef = useRef<number | null>(null);

	const handleCopy = () => {
		const text = typeof getValue === "function" ? getValue() : (value ?? "");
		if (!text) return;

		navigator.clipboard
			.writeText(text)
			.then(() => {
				setCopied(true);
				// Reset after 1.5s
				if (timeoutRef.current) {
					window.clearTimeout(timeoutRef.current);
				}
				timeoutRef.current = window.setTimeout(() => setCopied(false), 1500);
			})
			.catch((err) => console.error("Failed to copy", err));
	};

	return (
		<Button
			variant={variant}
			size={size}
			onClick={handleCopy}
			title={title}
			className={cn("relative overflow-hidden", className)}
		>
			{copied ? (
				<span className="animate-pulse">
					<Check className="h-4 w-4" />
				</span>
			) : children ? (
				<>
					<Copy className="h-4 w-4 mr-1" />
					{children}
				</>
			) : (
				<Copy className="h-4 w-4" />
			)}
		</Button>
	);
}

================
File: packages/dashboard-web/src/components/ConversationView.tsx
================
import type { MessageData } from "@ccflare/types";
import {
	cleanLineNumbers,
	genMessageKey,
	parseAssistantMessage,
	parseRequestMessages,
} from "@ccflare/ui-common";
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { Message } from "./conversation";

interface ConversationViewProps {
	requestBody: string | null;
	responseBody: string | null;
}

function ConversationViewComponent({
	requestBody,
	responseBody,
}: ConversationViewProps) {
	const [messages, setMessages] = useState<MessageData[]>([]);

	// Create stable cleanLineNumbers function
	const cleanLineNumbersCallback = useCallback(cleanLineNumbers, []);

	// Parse request body to extract conversation messages
	const requestMessages = useMemo(
		() => parseRequestMessages(requestBody),
		[requestBody],
	);

	// Parse streaming response to extract assistant message
	const assistantMessage = useMemo(
		() => parseAssistantMessage(responseBody),
		[responseBody],
	);

	// Combine messages
	useEffect(() => {
		const allMessages: MessageData[] = [...requestMessages];
		if (assistantMessage) {
			allMessages.push(assistantMessage);
		}
		setMessages(allMessages);
	}, [requestMessages, assistantMessage]);

	if (messages.length === 0) {
		return (
			<div className="flex items-center justify-center h-32">
				<p className="text-muted-foreground">No conversation data available</p>
			</div>
		);
	}

	return (
		<div className="h-[calc(65vh-10rem)] w-full overflow-hidden">
			<div className="h-full w-full overflow-y-auto overflow-x-hidden px-4 py-3 space-y-3">
				{messages.map((message, index) => (
					<Message
						key={genMessageKey(message, index)}
						role={message.role}
						content={message.content}
						contentBlocks={message.contentBlocks}
						tools={message.tools}
						toolResults={message.toolResults}
						cleanLineNumbers={cleanLineNumbersCallback}
					/>
				))}
			</div>
		</div>
	);
}

export const ConversationView = React.memo(ConversationViewComponent);

================
File: packages/dashboard-web/src/components/AgentsTab.tsx
================
import { DEFAULT_AGENT_MODEL, getModelDisplayName } from "@ccflare/core";
import { ALLOWED_MODELS } from "@ccflare/types";
import {
	AlertCircle,
	Bot,
	Folder,
	FolderOpen,
	Globe,
	Info,
	Package,
	RefreshCw,
	Settings,
} from "lucide-react";
import { useState } from "react";
import {
	useAgents,
	useBulkUpdateAgentPreferences,
	useDefaultAgentModel,
	useSetDefaultAgentModel,
	useUpdateAgentPreference,
} from "../hooks/queries";
import { AgentCard, WorkspaceCard } from "./agents";
import { Badge } from "./ui/badge";
import { Button } from "./ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "./ui/card";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
	DialogTrigger,
} from "./ui/dialog";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "./ui/select";
import { Separator } from "./ui/separator";
import { Skeleton } from "./ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/tabs";

export function AgentsTab() {
	const { data: response, isLoading, error, refetch } = useAgents();
	const updatePreference = useUpdateAgentPreference();
	const { data: defaultModel, isLoading: isLoadingDefaultModel } =
		useDefaultAgentModel();
	const setDefaultModel = useSetDefaultAgentModel();
	const bulkUpdatePreferences = useBulkUpdateAgentPreferences();
	const [selectedWorkspace, setSelectedWorkspace] = useState<string | null>(
		null,
	);
	const [bulkUpdateDialogOpen, setBulkUpdateDialogOpen] = useState(false);
	const [bulkUpdateModel, setBulkUpdateModel] =
		useState<string>(DEFAULT_AGENT_MODEL);

	const handleModelChange = (agentId: string, model: string) => {
		updatePreference.mutate({ agentId, model });
	};

	const handleDefaultModelChange = (model: string) => {
		setDefaultModel.mutate(model);
	};

	const handleBulkUpdate = () => {
		bulkUpdatePreferences.mutate(bulkUpdateModel, {
			onSuccess: (_data) => {
				setBulkUpdateDialogOpen(false);
				// You could add a toast notification here
			},
		});
	};

	if (isLoading) {
		return (
			<div className="space-y-8">
				<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
					{[...Array(6)].map((_, i) => (
						// biome-ignore lint/suspicious/noArrayIndexKey: Static skeleton elements
						<Card key={i}>
							<CardHeader>
								<Skeleton className="h-6 w-32" />
								<Skeleton className="h-4 w-full mt-2" />
								<Skeleton className="h-4 w-3/4" />
							</CardHeader>
							<CardContent>
								<Skeleton className="h-4 w-24" />
							</CardContent>
						</Card>
					))}
				</div>
			</div>
		);
	}

	if (error) {
		return (
			<Card>
				<CardHeader>
					<CardTitle className="flex items-center gap-2 text-destructive">
						<AlertCircle className="h-5 w-5" />
						Error Loading Agents
					</CardTitle>
					<CardDescription>
						{error instanceof Error ? error.message : "Failed to load agents"}
					</CardDescription>
				</CardHeader>
				<CardContent>
					<Button onClick={() => refetch()} variant="outline" size="sm">
						<RefreshCw className="mr-2 h-4 w-4" />
						Retry
					</Button>
				</CardContent>
			</Card>
		);
	}

	if (!response || response.agents.length === 0) {
		return (
			<Card>
				<CardHeader>
					<CardTitle className="flex items-center gap-2">
						<Bot className="h-5 w-5" />
						No Agents Found
					</CardTitle>
					<CardDescription>
						No agent definition files found in ~/.claude/agents/ or workspace
						directories
					</CardDescription>
				</CardHeader>
				<CardContent className="space-y-4">
					<div>
						<h4 className="font-medium mb-2">Global Agents</h4>
						<p className="text-sm text-muted-foreground">
							To add global agents, create markdown files in the
							~/.claude/agents/ directory.
						</p>
					</div>
					<Separator />
					<div>
						<h4 className="font-medium mb-2">Workspace Agents</h4>
						<p className="text-sm text-muted-foreground">
							To add workspace-specific agents, create markdown files in your
							project's .claude/agents/ directory. They should be able to
							discover local project agents after you send a message from within
							that directory.
						</p>
					</div>
					<Separator />
					<div>
						<h4 className="font-medium mb-2">Agent Format</h4>
						<pre className="mt-2 p-4 bg-muted rounded-lg text-xs overflow-x-auto">
							{`---
name: My Agent
description: Description of what this agent does
color: blue
model: ${DEFAULT_AGENT_MODEL}
---

Your system prompt content here...`}
						</pre>
					</div>
				</CardContent>
			</Card>
		);
	}

	const { globalAgents, workspaceAgents, workspaces } = response;
	const filteredWorkspaceAgents = selectedWorkspace
		? workspaceAgents.filter((agent) => agent.workspace === selectedWorkspace)
		: workspaceAgents;

	// Add agent counts to workspaces
	const workspacesWithCounts = workspaces.map((workspace) => ({
		...workspace,
		agentCount: workspaceAgents.filter((a) => a.workspace === workspace.path)
			.length,
	}));

	return (
		<div className="space-y-6">
			{/* Header */}
			<div className="space-y-4">
				<div className="flex items-center justify-between">
					<div>
						<h2 className="text-2xl font-bold flex items-center gap-3">
							<div className="p-2 bg-primary/10 rounded-lg">
								<Bot className="h-6 w-6 text-primary" />
							</div>
							AI Agents
						</h2>
						<p className="text-muted-foreground mt-1">
							Manage your AI agents and their model preferences
						</p>
					</div>
					<div className="flex items-center gap-4">
						<div className="flex items-center gap-2">
							<Badge variant="secondary" className="gap-1.5">
								<Globe className="h-3.5 w-3.5" />
								{globalAgents.length} Global
							</Badge>
							<Badge variant="secondary" className="gap-1.5">
								<Folder className="h-3.5 w-3.5" />
								{workspaceAgents.length} Workspace
							</Badge>
						</div>
					</div>
				</div>

				{/* Default Model Settings */}
				<Card>
					<CardHeader>
						<CardTitle className="text-base flex items-center gap-2">
							<Settings className="h-4 w-4" />
							Default Agent Model
						</CardTitle>
						<CardDescription>
							Set the default model for all agents. Individual agent preferences
							will override this setting.
						</CardDescription>
					</CardHeader>
					<CardContent>
						<div className="space-y-4">
							<div className="flex items-center gap-4">
								<div className="flex-1">
									<Select
										value={defaultModel || DEFAULT_AGENT_MODEL}
										onValueChange={handleDefaultModelChange}
										disabled={
											isLoadingDefaultModel || setDefaultModel.isPending
										}
									>
										<SelectTrigger className="w-full max-w-xs">
											<SelectValue placeholder="Select a model" />
										</SelectTrigger>
										<SelectContent>
											{ALLOWED_MODELS.map((model) => (
												<SelectItem key={model} value={model}>
													{getModelDisplayName(model)}
												</SelectItem>
											))}
										</SelectContent>
									</Select>
								</div>
								{setDefaultModel.isPending && (
									<span className="text-sm text-muted-foreground">
										Updating...
									</span>
								)}
							</div>

							<Separator />

							<div className="space-y-2">
								<p className="text-sm font-medium">Force Update All Agents</p>
								<p className="text-sm text-muted-foreground">
									Override all individual agent preferences with a specific
									model.
								</p>
								<Dialog
									open={bulkUpdateDialogOpen}
									onOpenChange={setBulkUpdateDialogOpen}
								>
									<DialogTrigger asChild>
										<Button variant="outline" size="sm">
											Force Update All
										</Button>
									</DialogTrigger>
									<DialogContent>
										<DialogHeader>
											<DialogTitle>Update All Agent Models</DialogTitle>
											<DialogDescription>
												This will override all individual agent preferences and
												set them to the selected model. This action cannot be
												undone.
											</DialogDescription>
										</DialogHeader>
										<div className="py-4">
											<Select
												value={bulkUpdateModel}
												onValueChange={setBulkUpdateModel}
											>
												<SelectTrigger>
													<SelectValue />
												</SelectTrigger>
												<SelectContent>
													{ALLOWED_MODELS.map((model) => (
														<SelectItem key={model} value={model}>
															{getModelDisplayName(model)}
														</SelectItem>
													))}
												</SelectContent>
											</Select>
										</div>
										<DialogFooter>
											<Button
												variant="outline"
												onClick={() => setBulkUpdateDialogOpen(false)}
											>
												Cancel
											</Button>
											<Button
												onClick={handleBulkUpdate}
												disabled={bulkUpdatePreferences.isPending}
											>
												{bulkUpdatePreferences.isPending
													? "Updating..."
													: `Update ${response?.agents.length || 0} Agents`}
											</Button>
										</DialogFooter>
									</DialogContent>
								</Dialog>
							</div>
						</div>
					</CardContent>
				</Card>

				{/* Workspaces Section */}
				{workspacesWithCounts.length > 0 && (
					<Card className="border-dashed">
						<CardHeader>
							<CardTitle className="text-base flex items-center gap-2">
								<FolderOpen className="h-4 w-4" />
								Active Workspaces
							</CardTitle>
						</CardHeader>
						<CardContent>
							<div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
								{workspacesWithCounts.map((workspace) => (
									<button
										type="button"
										key={workspace.path}
										onClick={() =>
											setSelectedWorkspace(
												selectedWorkspace === workspace.path
													? null
													: workspace.path,
											)
										}
										className="text-left w-full"
									>
										<WorkspaceCard
											workspace={workspace}
											isActive={selectedWorkspace === workspace.path}
										/>
									</button>
								))}
							</div>
						</CardContent>
					</Card>
				)}
			</div>

			{/* Agents Tabs */}
			<Tabs defaultValue="all" className="space-y-4">
				<TabsList className="grid w-full max-w-md grid-cols-3">
					<TabsTrigger value="all" className="gap-1.5">
						<Package className="h-4 w-4" />
						All Agents
					</TabsTrigger>
					<TabsTrigger value="global" className="gap-1.5">
						<Globe className="h-4 w-4" />
						Global
					</TabsTrigger>
					<TabsTrigger value="workspace" className="gap-1.5">
						<Folder className="h-4 w-4" />
						Workspace
					</TabsTrigger>
				</TabsList>

				<TabsContent value="all" className="space-y-6">
					{globalAgents.length > 0 && (
						<div className="space-y-4">
							<div className="flex items-center gap-2">
								<h3 className="text-lg font-semibold">Global Agents</h3>
								<Badge variant="outline">{globalAgents.length}</Badge>
							</div>
							<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
								{globalAgents.map((agent) => (
									<AgentCard
										key={agent.id}
										agent={agent}
										onModelChange={handleModelChange}
										isUpdating={updatePreference.isPending}
									/>
								))}
							</div>
						</div>
					)}

					{workspaceAgents.length > 0 && (
						<div className="space-y-4">
							<div className="flex items-center gap-2">
								<h3 className="text-lg font-semibold">Workspace Agents</h3>
								<Badge variant="outline">
									{filteredWorkspaceAgents.length}
								</Badge>
								{selectedWorkspace && (
									<Button
										variant="ghost"
										size="sm"
										onClick={() => setSelectedWorkspace(null)}
									>
										Clear filter
									</Button>
								)}
							</div>
							<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
								{filteredWorkspaceAgents.map((agent) => (
									<AgentCard
										key={agent.id}
										agent={agent}
										onModelChange={handleModelChange}
										isUpdating={updatePreference.isPending}
									/>
								))}
							</div>
						</div>
					)}
				</TabsContent>

				<TabsContent value="global" className="space-y-4">
					{globalAgents.length === 0 ? (
						<Card>
							<CardHeader>
								<CardTitle className="flex items-center gap-2">
									<Info className="h-5 w-5" />
									No Global Agents
								</CardTitle>
								<CardDescription>
									Create agent files in ~/.claude/agents/ to add global agents
								</CardDescription>
							</CardHeader>
						</Card>
					) : (
						<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
							{globalAgents.map((agent) => (
								<AgentCard
									key={agent.id}
									agent={agent}
									onModelChange={handleModelChange}
									isUpdating={updatePreference.isPending}
								/>
							))}
						</div>
					)}
				</TabsContent>

				<TabsContent value="workspace" className="space-y-4">
					{workspaceAgents.length === 0 ? (
						<Card>
							<CardHeader>
								<CardTitle className="flex items-center gap-2">
									<Info className="h-5 w-5" />
									No Workspace Agents
								</CardTitle>
								<CardDescription>
									Workspace agents are automatically discovered from your
									project directories. They should be able to discover local
									project agents after you send a message from within that
									directory.
								</CardDescription>
							</CardHeader>
						</Card>
					) : (
						<>
							{selectedWorkspace && (
								<div className="flex items-center gap-2 p-3 bg-muted rounded-lg">
									<Folder className="h-4 w-4" />
									<span className="text-sm">
										Showing agents from:{" "}
										<strong>{selectedWorkspace.split("/").pop()}</strong>
									</span>
									<Button
										variant="ghost"
										size="sm"
										className="ml-auto"
										onClick={() => setSelectedWorkspace(null)}
									>
										Clear filter
									</Button>
								</div>
							)}
							<div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
								{filteredWorkspaceAgents.map((agent) => (
									<AgentCard
										key={agent.id}
										agent={agent}
										onModelChange={handleModelChange}
										isUpdating={updatePreference.isPending}
									/>
								))}
							</div>
						</>
					)}
				</TabsContent>
			</Tabs>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/navigation.tsx
================
import {
	Activity,
	BarChart3,
	Bot,
	FileText,
	GitBranch,
	LayoutDashboard,
	Menu,
	Shield,
	Users,
	Wrench,
	X,
	Zap,
} from "lucide-react";
import { useState } from "react";
import { Link, useLocation } from "react-router-dom";
import { cn } from "../lib/utils";
import { ThemeToggle } from "./theme-toggle";
import { Button } from "./ui/button";
import { Separator } from "./ui/separator";

interface NavItem {
	label: string;
	icon: React.ComponentType<{ className?: string }>;
	path: string;
	badge?: string;
}

const navItems: NavItem[] = [
	{ label: "Overview", icon: LayoutDashboard, path: "/" },
	{ label: "Analytics", icon: BarChart3, path: "/analytics" },
	{ label: "Requests", icon: Activity, path: "/requests" },
	{ label: "Accounts", icon: Users, path: "/accounts" },
	{ label: "Agents", icon: Bot, path: "/agents" },
	{ label: "Tools", icon: Wrench, path: "/tools" },
	{ label: "Logs", icon: FileText, path: "/logs" },
];

export function Navigation() {
	const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
	const location = useLocation();

	return (
		<>
			{/* Mobile header */}
			<div className="lg:hidden fixed top-0 left-0 right-0 z-50 h-16 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b px-4 flex items-center justify-between">
				<div className="flex items-center gap-3">
					<Shield className="h-6 w-6 text-primary" />
					<span className="font-semibold text-lg">ccflare</span>
				</div>
				<div className="flex items-center gap-2">
					<ThemeToggle />
					<Button
						variant="ghost"
						size="sm"
						onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
					>
						{isMobileMenuOpen ? (
							<X className="h-5 w-5" />
						) : (
							<Menu className="h-5 w-5" />
						)}
					</Button>
				</div>
			</div>

			{/* Mobile menu overlay */}
			{isMobileMenuOpen && (
				<button
					type="button"
					className="lg:hidden fixed inset-0 z-40 bg-background/80 backdrop-blur-sm cursor-default"
					onClick={() => setIsMobileMenuOpen(false)}
					aria-label="Close menu"
				/>
			)}

			{/* Sidebar */}
			<aside
				className={cn(
					"fixed left-0 top-0 z-40 h-screen w-64 bg-card border-r transition-transform duration-300 lg:translate-x-0",
					isMobileMenuOpen
						? "translate-x-0"
						: "-translate-x-full lg:translate-x-0",
				)}
			>
				<div className="flex h-full flex-col">
					{/* Logo */}
					<div className="p-6 pb-4">
						<div className="flex items-center gap-3">
							<div className="flex h-10 w-10 items-center justify-center rounded-lg bg-primary/10">
								<Shield className="h-6 w-6 text-primary" />
							</div>
							<div>
								<h1 className="font-semibold text-lg">ccflare</h1>
								<p className="text-xs text-muted-foreground">
									Powerful proxy for Claude Code
								</p>
							</div>
						</div>
					</div>

					<Separator />

					{/* Navigation */}
					<nav className="flex-1 space-y-1 p-4">
						{navItems.map((item) => {
							const Icon = item.icon;
							const isActive = location.pathname === item.path;
							return (
								<Link
									key={item.path}
									to={item.path}
									onClick={() => setIsMobileMenuOpen(false)}
								>
									<Button
										variant={isActive ? "secondary" : "ghost"}
										className={cn(
											"w-full justify-start gap-3 transition-all",
											isActive &&
												"bg-primary/10 text-primary hover:bg-primary/20",
										)}
									>
										<Icon className="h-4 w-4" />
										{item.label}
										{item.badge && (
											<span className="ml-auto rounded-full bg-primary/20 px-2 py-0.5 text-xs font-medium">
												{item.badge}
											</span>
										)}
									</Button>
								</Link>
							);
						})}
					</nav>

					<Separator />

					{/* Footer */}
					<div className="p-4 space-y-4">
						<div className="rounded-lg bg-muted/50 p-3">
							<div className="flex items-center gap-2 text-sm">
								<Zap className="h-4 w-4 text-primary" />
								<span className="font-medium">Status</span>
							</div>
							<p className="mt-1 text-xs text-muted-foreground">
								All systems operational
							</p>
						</div>

						<div className="hidden lg:flex items-center justify-between">
							<div className="flex items-center gap-2 text-xs text-muted-foreground">
								<GitBranch className="h-3 w-3" />
								<span>v1.0.0</span>
							</div>
							<ThemeToggle />
						</div>
					</div>
				</div>
			</aside>
		</>
	);
}

================
File: packages/dashboard-web/src/components/theme-toggle.tsx
================
import { Monitor, Moon, Sun } from "lucide-react";
import { useTheme } from "../contexts/theme-context";
import { Button } from "./ui/button";
import {
	DropdownMenu,
	DropdownMenuContent,
	DropdownMenuItem,
	DropdownMenuTrigger,
} from "./ui/dropdown-menu";

export function ThemeToggle() {
	const { setTheme } = useTheme();

	return (
		<DropdownMenu>
			<DropdownMenuTrigger asChild>
				<Button variant="ghost" size="sm" className="w-9 px-0">
					<Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
					<Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
					<span className="sr-only">Toggle theme</span>
				</Button>
			</DropdownMenuTrigger>
			<DropdownMenuContent align="end">
				<DropdownMenuItem onClick={() => setTheme("light")}>
					<Sun className="mr-2 h-4 w-4" />
					<span>Light</span>
				</DropdownMenuItem>
				<DropdownMenuItem onClick={() => setTheme("dark")}>
					<Moon className="mr-2 h-4 w-4" />
					<span>Dark</span>
				</DropdownMenuItem>
				<DropdownMenuItem onClick={() => setTheme("system")}>
					<Monitor className="mr-2 h-4 w-4" />
					<span>System</span>
				</DropdownMenuItem>
			</DropdownMenuContent>
		</DropdownMenu>
	);
}

================
File: packages/dashboard-web/src/components/RequestDetailsModal.tsx
================
import { formatCost, formatTimestamp, formatTokens } from "@ccflare/ui-common";
import { Eye } from "lucide-react";
import { useState } from "react";
import type { RequestPayload, RequestSummary } from "../api";
import { ConversationView } from "./ConversationView";
import { CopyButton } from "./CopyButton";
import { TokenUsageDisplay } from "./TokenUsageDisplay";
import { Badge } from "./ui/badge";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogHeader,
	DialogTitle,
} from "./ui/dialog";
import { Label } from "./ui/label";
import { Switch } from "./ui/switch";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/tabs";

interface RequestDetailsModalProps {
	request: RequestPayload;
	summary: RequestSummary | undefined;
	isOpen: boolean;
	onClose: () => void;
}

export function RequestDetailsModal({
	request,
	summary,
	isOpen,
	onClose,
}: RequestDetailsModalProps) {
	const [beautifyMode, setBeautifyMode] = useState(true);

	const decodeBase64 = (str: string | null): string => {
		if (!str) return "No data";
		try {
			if (str === "[streamed]") {
				return "[Streaming data not captured]";
			}
			return atob(str);
		} catch (error) {
			console.error("Failed to decode base64:", error, "Input:", str);
			return `Failed to decode: ${str}`;
		}
	};

	const formatJson = (str: string): string => {
		try {
			const parsed = JSON.parse(str);
			return JSON.stringify(parsed, null, 2);
		} catch {
			// If it's not valid JSON, return as-is
			return str;
		}
	};

	const formatHeaders = (headers: Record<string, string>): string => {
		if (!beautifyMode) {
			return Object.entries(headers)
				.map(([key, value]) => `${key}: ${value}`)
				.join("\n");
		}
		return JSON.stringify(headers, null, 2);
	};

	const formatBody = (body: string | null): string => {
		const decoded = decodeBase64(body);
		if (!beautifyMode) return decoded;
		return formatJson(decoded);
	};

	const _isError = request.error || !request.meta.success;
	const statusCode = request.response?.status;

	return (
		<Dialog open={isOpen} onOpenChange={onClose}>
			<DialogContent className="max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
				<DialogHeader>
					<DialogTitle className="flex items-center gap-2">
						<Eye className="h-5 w-5" />
						Request Details
					</DialogTitle>
					<DialogDescription className="flex items-center justify-between">
						<div className="flex items-center gap-2 flex-wrap">
							<span className="font-mono text-sm">
								{formatTimestamp(request.meta.timestamp)}
							</span>
							{statusCode && (
								<Badge
									variant={
										statusCode >= 200 && statusCode < 300
											? "success"
											: statusCode >= 400 && statusCode < 500
												? "warning"
												: "destructive"
									}
								>
									{statusCode}
								</Badge>
							)}
							{summary?.model && (
								<Badge variant="secondary">{summary.model}</Badge>
							)}
							{summary?.agentUsed && (
								<Badge variant="secondary">Agent: {summary.agentUsed}</Badge>
							)}
							{summary?.totalTokens && (
								<Badge variant="outline">
									{formatTokens(summary.totalTokens)} tokens
								</Badge>
							)}
							{summary?.costUsd && summary.costUsd > 0 && (
								<Badge variant="default">{formatCost(summary.costUsd)}</Badge>
							)}
							{request.meta.rateLimited && (
								<Badge variant="warning">Rate Limited</Badge>
							)}
						</div>
						<div className="flex items-center gap-2">
							<Label htmlFor="beautify-mode" className="text-sm">
								Beautify
							</Label>
							<Switch
								id="beautify-mode"
								checked={beautifyMode}
								onCheckedChange={setBeautifyMode}
							/>
						</div>
					</DialogDescription>
				</DialogHeader>

				<Tabs defaultValue="conversation" className="flex-1 overflow-hidden">
					<TabsList className="grid w-full grid-cols-5">
						<TabsTrigger value="conversation">Conversation</TabsTrigger>
						<TabsTrigger value="request">Request</TabsTrigger>
						<TabsTrigger value="response">Response</TabsTrigger>
						<TabsTrigger value="metadata">Metadata</TabsTrigger>
						<TabsTrigger value="tokens">Token Usage</TabsTrigger>
					</TabsList>

					<TabsContent value="conversation" className="mt-4 flex-1 min-h-0">
						<ConversationView
							requestBody={decodeBase64(request.request.body)}
							responseBody={decodeBase64(request.response?.body || null)}
						/>
					</TabsContent>

					<TabsContent
						value="request"
						className="mt-4 space-y-4 overflow-y-auto max-h-[60vh]"
					>
						<div>
							<div className="flex items-center justify-between mb-2">
								<h3 className="font-semibold">Headers</h3>
								<CopyButton
									variant="ghost"
									size="sm"
									getValue={() => formatHeaders(request.request.headers)}
								>
									Copy
								</CopyButton>
							</div>
							<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
								{formatHeaders(request.request.headers)}
							</pre>
						</div>

						{request.request.body && (
							<div>
								<div className="flex items-center justify-between mb-2">
									<h3 className="font-semibold">Body</h3>
									<CopyButton
										variant="ghost"
										size="sm"
										getValue={() => formatBody(request.request.body)}
									>
										Copy
									</CopyButton>
								</div>
								<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
									{formatBody(request.request.body)}
								</pre>
							</div>
						)}
					</TabsContent>

					<TabsContent
						value="response"
						className="mt-4 space-y-4 overflow-y-auto max-h-[60vh]"
					>
						{request.response ? (
							<>
								<div>
									<div className="flex items-center justify-between mb-2">
										<h3 className="font-semibold">Headers</h3>
										<CopyButton
											variant="ghost"
											size="sm"
											getValue={() =>
												request.response
													? formatHeaders(request.response.headers)
													: ""
											}
										>
											Copy
										</CopyButton>
									</div>
									<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
										{formatHeaders(request.response.headers)}
									</pre>
								</div>

								{request.response.body && (
									<div>
										<div className="flex items-center justify-between mb-2">
											<h3 className="font-semibold">Body</h3>
											<CopyButton
												variant="ghost"
												size="sm"
												getValue={() =>
													request.response
														? formatBody(request.response.body)
														: ""
												}
											>
												Copy
											</CopyButton>
										</div>
										<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
											{formatBody(request.response.body)}
										</pre>
									</div>
								)}
							</>
						) : (
							<div className="text-center text-muted-foreground py-8">
								{request.error ? (
									<>
										<p className="text-destructive font-medium">
											Error: {request.error}
										</p>
										<p className="mt-2">No response data available</p>
									</>
								) : (
									<p>No response data available</p>
								)}
							</div>
						)}
					</TabsContent>

					<TabsContent
						value="metadata"
						className="mt-4 overflow-y-auto max-h-[60vh]"
					>
						<div>
							<div className="flex items-center justify-between mb-2">
								<h3 className="font-semibold">Request Metadata</h3>
								<CopyButton
									variant="ghost"
									size="sm"
									getValue={() =>
										beautifyMode
											? JSON.stringify(request.meta, null, 2)
											: JSON.stringify(request.meta)
									}
								>
									Copy
								</CopyButton>
							</div>
							<pre className="bg-muted p-4 rounded-lg overflow-x-auto text-sm font-mono">
								{beautifyMode
									? JSON.stringify(request.meta, null, 2)
									: JSON.stringify(request.meta)}
							</pre>
						</div>
					</TabsContent>

					<TabsContent
						value="tokens"
						className="mt-4 overflow-y-auto max-h-[60vh]"
					>
						<TokenUsageDisplay summary={summary} />
					</TabsContent>
				</Tabs>
			</DialogContent>
		</Dialog>
	);
}

================
File: packages/dashboard-web/src/components/ui/tabs.tsx
================
import * as TabsPrimitive from "@radix-ui/react-tabs";
import * as React from "react";

import { cn } from "../../lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
	React.ElementRef<typeof TabsPrimitive.List>,
	React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
	<TabsPrimitive.List
		ref={ref}
		className={cn(
			"inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
			className,
		)}
		{...props}
	/>
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
	React.ElementRef<typeof TabsPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
	<TabsPrimitive.Trigger
		ref={ref}
		className={cn(
			"inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
			className,
		)}
		{...props}
	/>
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
	React.ElementRef<typeof TabsPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
	<TabsPrimitive.Content
		ref={ref}
		className={cn(
			"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
			className,
		)}
		{...props}
	/>
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

================
File: packages/dashboard-web/src/components/ui/card.tsx
================
import * as React from "react";

import { cn } from "../../lib/utils";

const Card = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn(
			"rounded-lg border bg-card text-card-foreground shadow-sm hover:shadow-md transition-shadow duration-200",
			className,
		)}
		{...props}
	/>
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn("flex flex-col space-y-1.5 p-6", className)}
		{...props}
	/>
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
	HTMLParagraphElement,
	React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
	<h3
		ref={ref}
		className={cn("font-semibold leading-none tracking-tight", className)}
		{...props}
	/>
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
	HTMLParagraphElement,
	React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
	<p
		ref={ref}
		className={cn("text-sm text-muted-foreground", className)}
		{...props}
	/>
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
	HTMLDivElement,
	React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
	<div
		ref={ref}
		className={cn("flex items-center p-6 pt-0", className)}
		{...props}
	/>
));
CardFooter.displayName = "CardFooter";

export {
	Card,
	CardHeader,
	CardTitle,
	CardDescription,
	CardContent,
	CardFooter,
};

================
File: packages/dashboard-web/src/components/ui/popover.tsx
================
import * as PopoverPrimitive from "@radix-ui/react-popover";
import * as React from "react";

import { cn } from "../../lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
	React.ElementRef<typeof PopoverPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
	<PopoverPrimitive.Portal>
		<PopoverPrimitive.Content
			ref={ref}
			align={align}
			sideOffset={sideOffset}
			className={cn(
				"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				className,
			)}
			{...props}
		/>
	</PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };

================
File: packages/dashboard-web/src/components/ui/progress.tsx
================
import * as ProgressPrimitive from "@radix-ui/react-progress";
import * as React from "react";
import { cn } from "../../lib/utils";

const Progress = React.forwardRef<
	React.ElementRef<typeof ProgressPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
	<ProgressPrimitive.Root
		ref={ref}
		className={cn(
			"relative h-2 w-full overflow-hidden rounded-full bg-secondary",
			className,
		)}
		{...props}
	>
		<ProgressPrimitive.Indicator
			className="h-full w-full flex-1 bg-primary transition-all duration-700 ease-out"
			style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
		/>
	</ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };

================
File: packages/dashboard-web/src/components/ui/label.tsx
================
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "../../lib/utils";

const labelVariants = cva(
	"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
	React.ElementRef<typeof LabelPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
		VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
	<LabelPrimitive.Root
		ref={ref}
		className={cn(labelVariants(), className)}
		{...props}
	/>
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

================
File: packages/dashboard-web/src/components/ui/switch.tsx
================
import * as SwitchPrimitives from "@radix-ui/react-switch";
import * as React from "react";

import { cn } from "../../lib/utils";

const Switch = React.forwardRef<
	React.ElementRef<typeof SwitchPrimitives.Root>,
	React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
	<SwitchPrimitives.Root
		className={cn(
			"peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
			className,
		)}
		{...props}
		ref={ref}
	>
		<SwitchPrimitives.Thumb
			className={cn(
				"pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0",
			)}
		/>
	</SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

================
File: packages/dashboard-web/src/components/ui/dialog.tsx
================
import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "../../lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const _DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Overlay>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
	<DialogPrimitive.Overlay
		ref={ref}
		className={cn(
			"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
			className,
		)}
		{...props}
	/>
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
	<DialogPortal>
		<DialogOverlay />
		<DialogPrimitive.Content
			ref={ref}
			className={cn(
				"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
				className,
			)}
			{...props}
		>
			{children}
			<DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
				<X className="h-4 w-4" />
				<span className="sr-only">Close</span>
			</DialogPrimitive.Close>
		</DialogPrimitive.Content>
	</DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
	className,
	...props
}: React.HTMLAttributes<HTMLDivElement>) => (
	<div
		className={cn(
			"flex flex-col space-y-1.5 text-center sm:text-left",
			className,
		)}
		{...props}
	/>
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
	className,
	...props
}: React.HTMLAttributes<HTMLDivElement>) => (
	<div
		className={cn(
			"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
			className,
		)}
		{...props}
	/>
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Title>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
	<DialogPrimitive.Title
		ref={ref}
		className={cn(
			"text-lg font-semibold leading-none tracking-tight",
			className,
		)}
		{...props}
	/>
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
	React.ElementRef<typeof DialogPrimitive.Description>,
	React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
	<DialogPrimitive.Description
		ref={ref}
		className={cn("text-sm text-muted-foreground", className)}
		{...props}
	/>
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
	Dialog,
	DialogTrigger,
	DialogContent,
	DialogHeader,
	DialogFooter,
	DialogTitle,
	DialogDescription,
};

================
File: packages/dashboard-web/src/components/ui/badge.tsx
================
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";

import { cn } from "../../lib/utils";

const badgeVariants = cva(
	"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
	{
		variants: {
			variant: {
				default:
					"border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
				secondary:
					"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
				destructive:
					"border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
				outline: "text-foreground",
				success:
					"border-transparent bg-green-500 text-white shadow hover:bg-green-500/80",
				warning:
					"border-transparent bg-yellow-500 text-white shadow hover:bg-yellow-500/80",
			},
		},
		defaultVariants: {
			variant: "default",
		},
	},
);

interface BadgeProps
	extends React.HTMLAttributes<HTMLDivElement>,
		VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
	return (
		<div className={cn(badgeVariants({ variant }), className)} {...props} />
	);
}

export { Badge };

================
File: packages/dashboard-web/src/components/ui/separator.tsx
================
import * as SeparatorPrimitive from "@radix-ui/react-separator";
import * as React from "react";

import { cn } from "../../lib/utils";

const Separator = React.forwardRef<
	React.ElementRef<typeof SeparatorPrimitive.Root>,
	React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
	(
		{ className, orientation = "horizontal", decorative = true, ...props },
		ref,
	) => (
		<SeparatorPrimitive.Root
			ref={ref}
			decorative={decorative}
			orientation={orientation}
			className={cn(
				"shrink-0 bg-border",
				orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
				className,
			)}
			{...props}
		/>
	),
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };

================
File: packages/dashboard-web/src/components/ui/button.tsx
================
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "../../lib/utils";

const buttonVariants = cva(
	"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
	{
		variants: {
			variant: {
				default:
					"bg-primary text-primary-foreground shadow-sm hover:bg-primary/90 hover:shadow-md hover:-translate-y-0.5",
				destructive:
					"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
				outline:
					"border-2 border-border bg-background shadow-sm hover:bg-accent hover:text-accent-foreground hover:border-primary/50",
				secondary:
					"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
				ghost: "hover:bg-accent hover:text-accent-foreground",
				link: "text-primary underline-offset-4 hover:underline",
			},
			size: {
				default: "h-10 px-5 py-2",
				sm: "h-8 rounded-md px-3 text-xs",
				lg: "h-12 rounded-md px-8",
				icon: "h-10 w-10",
			},
		},
		defaultVariants: {
			variant: "default",
			size: "default",
		},
	},
);

interface ButtonProps
	extends React.ButtonHTMLAttributes<HTMLButtonElement>,
		VariantProps<typeof buttonVariants> {
	asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
	({ className, variant, size, asChild = false, ...props }, ref) => {
		const Comp = asChild ? Slot : "button";
		return (
			<Comp
				className={cn(buttonVariants({ variant, size, className }))}
				ref={ref}
				{...props}
			/>
		);
	},
);
Button.displayName = "Button";

export { Button };

================
File: packages/dashboard-web/src/components/ui/dropdown-menu.tsx
================
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";
import * as React from "react";

import { cn } from "../../lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const _DropdownMenuGroup = DropdownMenuPrimitive.Group;

const _DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const _DropdownMenuSub = DropdownMenuPrimitive.Sub;

const _DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
		inset?: boolean;
	}
>(({ className, inset, children, ...props }, ref) => (
	<DropdownMenuPrimitive.SubTrigger
		ref={ref}
		className={cn(
			"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
			inset && "pl-8",
			className,
		)}
		{...props}
	>
		{children}
		<ChevronRight className="ml-auto h-4 w-4" />
	</DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
	DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
	<DropdownMenuPrimitive.SubContent
		ref={ref}
		className={cn(
			"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
			className,
		)}
		{...props}
	/>
));
DropdownMenuSubContent.displayName =
	DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
	<DropdownMenuPrimitive.Portal>
		<DropdownMenuPrimitive.Content
			ref={ref}
			sideOffset={sideOffset}
			className={cn(
				"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
				"data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				className,
			)}
			{...props}
		/>
	</DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
		inset?: boolean;
	}
>(({ className, inset, ...props }, ref) => (
	<DropdownMenuPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			inset && "pl-8",
			className,
		)}
		{...props}
	/>
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
	<DropdownMenuPrimitive.CheckboxItem
		ref={ref}
		className={cn(
			"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		checked={checked}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<DropdownMenuPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</DropdownMenuPrimitive.ItemIndicator>
		</span>
		{children}
	</DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
	DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
	<DropdownMenuPrimitive.RadioItem
		ref={ref}
		className={cn(
			"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
			<DropdownMenuPrimitive.ItemIndicator>
				<Circle className="h-2 w-2 fill-current" />
			</DropdownMenuPrimitive.ItemIndicator>
		</span>
		{children}
	</DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
		inset?: boolean;
	}
>(({ className, inset, ...props }, ref) => (
	<DropdownMenuPrimitive.Label
		ref={ref}
		className={cn(
			"px-2 py-1.5 text-sm font-semibold",
			inset && "pl-8",
			className,
		)}
		{...props}
	/>
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
	React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<DropdownMenuPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
	className,
	...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
	return (
		<span
			className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
			{...props}
		/>
	);
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
	DropdownMenu,
	DropdownMenuTrigger,
	DropdownMenuContent,
	DropdownMenuItem,
};

================
File: packages/dashboard-web/src/components/ui/select.tsx
================
import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown } from "lucide-react";
import * as React from "react";

import { cn } from "../../lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Trigger>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Trigger
		ref={ref}
		className={cn(
			"flex h-9 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
			className,
		)}
		{...props}
	>
		{children}
		<SelectPrimitive.Icon asChild>
			<ChevronDown className="h-4 w-4 opacity-50" />
		</SelectPrimitive.Icon>
	</SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectContent = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Content>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
	<SelectPrimitive.Portal>
		<SelectPrimitive.Content
			ref={ref}
			className={cn(
				"relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
				position === "popper" &&
					"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
				className,
			)}
			position={position}
			{...props}
		>
			<SelectPrimitive.Viewport
				className={cn(
					"p-1",
					position === "popper" &&
						"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
				)}
			>
				{children}
			</SelectPrimitive.Viewport>
		</SelectPrimitive.Content>
	</SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Label>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Label
		ref={ref}
		className={cn("px-2 py-1.5 text-sm font-semibold", className)}
		{...props}
	/>
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Item>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
	<SelectPrimitive.Item
		ref={ref}
		className={cn(
			"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
			className,
		)}
		{...props}
	>
		<span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
			<SelectPrimitive.ItemIndicator>
				<Check className="h-4 w-4" />
			</SelectPrimitive.ItemIndicator>
		</span>
		<SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
	</SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
	React.ElementRef<typeof SelectPrimitive.Separator>,
	React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
	<SelectPrimitive.Separator
		ref={ref}
		className={cn("-mx-1 my-1 h-px bg-muted", className)}
		{...props}
	/>
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
	Select,
	SelectGroup,
	SelectValue,
	SelectTrigger,
	SelectContent,
	SelectLabel,
	SelectItem,
	SelectSeparator,
};

================
File: packages/dashboard-web/src/components/ui/textarea.tsx
================
import * as React from "react";

import { cn } from "../../lib/utils";

export interface TextareaProps
	extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
	({ className, ...props }, ref) => {
		return (
			<textarea
				className={cn(
					"flex min-h-[80px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Textarea.displayName = "Textarea";

export { Textarea };

================
File: packages/dashboard-web/src/components/ui/input.tsx
================
import * as React from "react";

import { cn } from "../../lib/utils";

export interface InputProps
	extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
	({ className, type, ...props }, ref) => {
		return (
			<input
				type={type}
				className={cn(
					"flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
					className,
				)}
				ref={ref}
				{...props}
			/>
		);
	},
);
Input.displayName = "Input";

export { Input };

================
File: packages/dashboard-web/src/components/ui/skeleton.tsx
================
import { cn } from "../../lib/utils";

function Skeleton({
	className,
	...props
}: React.HTMLAttributes<HTMLDivElement>) {
	return (
		<div
			className={cn("animate-pulse rounded-md bg-muted", className)}
			{...props}
		/>
	);
}

export { Skeleton };

================
File: packages/dashboard-web/src/components/tools/SystemPromptInterceptorCard.tsx
================
import { useEffect, useState } from "react";
import {
	useResetSystemPromptOverride,
	useSetSystemPromptOverride,
	useSystemPromptOverride,
} from "../../hooks/queries";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardFooter,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Label } from "../ui/label";
import { Switch } from "../ui/switch";
import { Textarea } from "../ui/textarea";

export function SystemPromptInterceptorCard() {
	const { data, isLoading } = useSystemPromptOverride();
	const { mutate, isPending, isSuccess } = useSetSystemPromptOverride();
	const { mutate: resetMutate } = useResetSystemPromptOverride();

	// Local form state
	const [isEnabled, setIsEnabled] = useState(false);
	const [targetPrompt, setTargetPrompt] = useState("");
	const [replacementPrompt, setReplacementPrompt] = useState("");
	const [toolsEnabled, setToolsEnabled] = useState(true);

	// Sync server data to local state
	useEffect(() => {
		if (data) {
			setIsEnabled(data.isEnabled);
			setTargetPrompt(data.targetPrompt);
			setReplacementPrompt(data.replacementPrompt);
			setToolsEnabled(data.toolsEnabled);
		}
	}, [data]);

	const handleSave = () => {
		mutate({
			isEnabled,
			targetPrompt,
			replacementPrompt,
			toolsEnabled,
		});
	};

	if (isLoading) {
		return (
			<Card>
				<CardHeader>
					<CardTitle>System Prompt Interceptor</CardTitle>
					<CardDescription>Loading configuration...</CardDescription>
				</CardHeader>
			</Card>
		);
	}

	return (
		<Card>
			<CardHeader>
				<CardTitle>System Prompt Interceptor</CardTitle>
				<CardDescription>
					Configure a custom system prompt to override the default Claude
					behavior
				</CardDescription>
			</CardHeader>
			<CardContent className="space-y-6">
				<div className="flex items-center justify-between">
					<div className="space-y-0.5">
						<Label htmlFor="enable-interceptor">Enable Interceptor</Label>
						<p className="text-sm text-muted-foreground">
							When enabled, your custom prompt will be used
						</p>
					</div>
					<Switch
						id="enable-interceptor"
						checked={isEnabled}
						onCheckedChange={setIsEnabled}
					/>
				</div>

				<div className="space-y-2">
					<Label htmlFor="target-prompt">Target Prompt</Label>
					<Textarea
						id="target-prompt"
						placeholder="The prompt to look for and replace..."
						value={targetPrompt}
						onChange={(e) => setTargetPrompt(e.target.value)}
						className="min-h-[150px]"
					/>
					<p className="text-sm text-muted-foreground">
						This is the prompt that will be detected and replaced. After reset,
						this shows the last-seen system prompt.
					</p>
				</div>

				<div className="space-y-2">
					<Label htmlFor="replacement-prompt">Replacement Prompt</Label>
					<Textarea
						id="replacement-prompt"
						placeholder="Your custom replacement prompt here..."
						value={replacementPrompt}
						onChange={(e) => setReplacementPrompt(e.target.value)}
						className="min-h-[200px]"
					/>
					<p className="text-sm text-muted-foreground">
						Use{" "}
						<code className="bg-muted px-1 py-0.5 rounded">
							{"{{env_block}}"}
						</code>{" "}
						to preserve the dynamic environment details from the original
						prompt.
					</p>
				</div>

				<div className="flex items-center justify-between">
					<div className="space-y-0.5">
						<Label htmlFor="enable-tools">Enable Tools</Label>
						<p className="text-sm text-muted-foreground">
							Allow Claude to use tools when this interceptor is active
						</p>
					</div>
					<Switch
						id="enable-tools"
						checked={toolsEnabled}
						onCheckedChange={setToolsEnabled}
					/>
				</div>
			</CardContent>
			<CardFooter className="flex gap-2">
				<Button onClick={handleSave} disabled={isPending}>
					{isPending ? "Saving..." : isSuccess ? "Saved!" : "Save"}
				</Button>
				<Button variant="outline" onClick={() => resetMutate()}>
					Reset to Default
				</Button>
			</CardFooter>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/charts/ChartContainer.tsx
================
import { RefreshCw } from "lucide-react";
import type { ReactNode } from "react";
import { CHART_HEIGHTS } from "../../constants";

interface ChartContainerProps {
	children: ReactNode;
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	className?: string;
	error?: Error | null;
	emptyState?: ReactNode;
	isEmpty?: boolean;
}

export function ChartContainer({
	children,
	loading = false,
	height = "medium",
	className = "",
	error = null,
	emptyState,
	isEmpty = false,
}: ChartContainerProps) {
	const chartHeight =
		typeof height === "number" ? height : CHART_HEIGHTS[height];

	if (error) {
		return (
			<div
				className={`flex items-center justify-center ${className}`}
				style={{ height: chartHeight }}
			>
				<div className="text-center space-y-2">
					<p className="text-sm text-destructive">Error loading chart data</p>
					<p className="text-xs text-muted-foreground">{error.message}</p>
				</div>
			</div>
		);
	}

	if (loading) {
		return (
			<div
				className={`flex items-center justify-center ${className}`}
				style={{ height: chartHeight }}
			>
				<RefreshCw className="h-8 w-8 animate-spin text-muted-foreground" />
			</div>
		);
	}

	if (isEmpty && emptyState) {
		return (
			<div
				className={`flex items-center justify-center ${className}`}
				style={{ height: chartHeight }}
			>
				{emptyState}
			</div>
		);
	}

	return <div className={className}>{children}</div>;
}

================
File: packages/dashboard-web/src/components/charts/BaseAreaChart.tsx
================
import type { ReactNode } from "react";
import {
	Area,
	AreaChart,
	CartesianGrid,
	Legend,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import {
	type CommonChartProps,
	getChartHeight,
	getTooltipStyles,
	isChartEmpty,
} from "./chart-utils";

interface BaseAreaChartProps extends CommonChartProps {
	dataKey: string;
	color?: string;
	gradientId?: string;
	customGradient?: ReactNode;
	strokeWidth?: number;
	fillOpacity?: number;
}

export function BaseAreaChart({
	data,
	dataKey,
	xAxisKey = "time",
	loading = false,
	height = "medium",
	color = COLORS.primary,
	gradientId = "colorGradient",
	customGradient,
	strokeWidth = 2,
	fillOpacity = 1,
	xAxisAngle = 0,
	xAxisTextAnchor = "middle",
	xAxisHeight = 30,
	xAxisTickFormatter,
	yAxisDomain,
	yAxisTickFormatter,
	tooltipFormatter,
	tooltipLabelFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	showLegend = false,
	legendHeight = 36,
	margin,
	className = "",
	error = null,
	emptyState,
	onChartClick,
}: BaseAreaChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = isChartEmpty(data);
	const tooltipStyles = getTooltipStyles(tooltipStyle);

	const defaultGradient = (
		<linearGradient id={gradientId} x1="0" y1="0" x2="0" y2="1">
			<stop offset="5%" stopColor={color} stopOpacity={0.8} />
			<stop offset="95%" stopColor={color} stopOpacity={0.1} />
		</linearGradient>
	);

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<AreaChart data={data} margin={margin} onClick={onChartClick}>
					<defs>{customGradient || defaultGradient}</defs>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						className={CHART_PROPS.gridClassName}
					/>
					<XAxis
						dataKey={xAxisKey}
						className="text-xs"
						angle={xAxisAngle}
						textAnchor={xAxisTextAnchor}
						height={xAxisHeight}
						tickFormatter={xAxisTickFormatter}
					/>
					<YAxis
						className="text-xs"
						domain={yAxisDomain}
						tickFormatter={yAxisTickFormatter}
					/>
					<Tooltip
						contentStyle={tooltipStyles}
						formatter={tooltipFormatter}
						labelFormatter={tooltipLabelFormatter}
					/>
					{showLegend && <Legend height={legendHeight} />}
					<Area
						type="monotone"
						dataKey={dataKey}
						stroke={color}
						strokeWidth={strokeWidth}
						fillOpacity={fillOpacity}
						fill={`url(#${gradientId})`}
						animationDuration={animationDuration}
					/>
				</AreaChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}

================
File: packages/dashboard-web/src/components/charts/TokenSpeedChart.tsx
================
import { formatTokensPerSecond } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";

interface TokenSpeedChartProps {
	data: Array<{
		time: string;
		avgTokensPerSecond: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	timeRange?: string;
}

export function TokenSpeedChart({
	data,
	loading = false,
	height = 400,
	timeRange = "24h",
}: TokenSpeedChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	// Filter out null values for better chart display
	const filteredData = data.map((point) => ({
		...point,
		avgTokensPerSecond: point.avgTokensPerSecond || 0,
	}));

	const gradient = (
		<linearGradient id="colorSpeed" x1="0" y1="0" x2="0" y2="1">
			<stop offset="0%" stopColor={COLORS.purple} stopOpacity={0.9} />
			<stop offset="100%" stopColor={COLORS.purple} stopOpacity={0.1} />
		</linearGradient>
	);

	return (
		<BaseAreaChart
			data={filteredData}
			dataKey="avgTokensPerSecond"
			loading={loading}
			height={height}
			color={COLORS.purple}
			gradientId="colorSpeed"
			customGradient={gradient}
			strokeWidth={2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			yAxisTickFormatter={formatCompactNumber}
			tooltipFormatter={(value) => [
				formatTokensPerSecond(value as number),
				"Output Speed",
			]}
			animationDuration={1000}
		/>
	);
}

================
File: packages/dashboard-web/src/components/charts/BasePieChart.tsx
================
import type { ReactNode } from "react";
import {
	Cell,
	Legend,
	Pie,
	PieChart,
	ResponsiveContainer,
	Tooltip,
} from "recharts";
import {
	CHART_COLORS,
	type CHART_HEIGHTS,
	type CHART_TOOLTIP_STYLE,
} from "../../constants";
import { ChartContainer } from "./ChartContainer";
import { getChartHeight, getTooltipStyles } from "./chart-utils";
import type { ChartClickHandler, TooltipFormatterFunction } from "./types";

interface BasePieChartProps {
	data: Array<{ name: string; value: number; [key: string]: string | number }>;
	dataKey?: string;
	nameKey?: string;
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	innerRadius?: number;
	outerRadius?: number;
	paddingAngle?: number;
	cx?: string | number;
	cy?: string | number;
	colors?: string[];
	tooltipFormatter?: TooltipFormatterFunction;
	tooltipStyle?: keyof typeof CHART_TOOLTIP_STYLE | object;
	animationDuration?: number;
	showLegend?: boolean;
	legendLayout?: "horizontal" | "vertical";
	legendAlign?: "left" | "center" | "right";
	legendVerticalAlign?: "top" | "middle" | "bottom";
	renderLabel?: boolean;
	className?: string;
	error?: Error | null;
	emptyState?: ReactNode;
	onPieClick?: ChartClickHandler;
}

export function BasePieChart({
	data,
	dataKey = "value",
	nameKey = "name",
	loading = false,
	height = "medium",
	innerRadius = 0,
	outerRadius = 80,
	paddingAngle = 0,
	cx = "50%",
	cy = "50%",
	colors = [...CHART_COLORS],
	tooltipFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	showLegend = false,
	legendLayout = "horizontal",
	legendAlign = "center",
	legendVerticalAlign = "bottom",
	renderLabel = false,
	className = "",
	error = null,
	emptyState,
	onPieClick,
}: BasePieChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = !data || data.length === 0;
	const tooltipStyles = getTooltipStyles(tooltipStyle);

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<PieChart>
					<Pie
						data={data}
						cx={cx}
						cy={cy}
						innerRadius={innerRadius}
						outerRadius={outerRadius}
						paddingAngle={paddingAngle}
						dataKey={dataKey}
						nameKey={nameKey}
						animationDuration={animationDuration}
						label={renderLabel}
						onClick={onPieClick}
					>
						{data.map((entry, index) => (
							<Cell
								key={`cell-${entry[nameKey]}`}
								fill={colors[index % colors.length]}
							/>
						))}
					</Pie>
					<Tooltip contentStyle={tooltipStyles} formatter={tooltipFormatter} />
					{showLegend && (
						<Legend
							layout={legendLayout}
							align={legendAlign}
							verticalAlign={legendVerticalAlign}
						/>
					)}
				</PieChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}

================
File: packages/dashboard-web/src/components/charts/ModelPerformanceComparison.tsx
================
import { getModelShortName } from "@ccflare/core";
import { formatCost, formatTokensPerSecond } from "@ccflare/ui-common";
import {
	Area,
	AreaChart,
	Bar,
	CartesianGrid,
	ComposedChart,
	Legend,
	Line,
	ResponsiveContainer,
	Scatter,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_HEIGHTS, CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import { getTooltipStyles } from "./chart-utils";

interface ModelComparisonData {
	model: string;
	avgTokensPerSecond: number | null;
	costPer1kTokens: number;
	avgResponseTime: number;
	errorRate: number;
	totalRequests: number;
}

interface ModelPerformanceComparisonProps {
	data: ModelComparisonData[];
	loading?: boolean;
	height?: number;
	viewMode?: "speed-cost" | "performance" | "efficiency";
}

// Model-based color palette
const MODEL_COLORS: Record<string, string> = {
	"claude-3.5-sonnet": COLORS.purple,
	"claude-3.5-haiku": COLORS.success,
	"claude-3-opus": COLORS.blue,
	"claude-opus-4": COLORS.pink,
};

function getModelColor(model: string): string {
	// Try to find color by short name first
	const shortName = getModelShortName(model);
	if (MODEL_COLORS[shortName]) return MODEL_COLORS[shortName];

	// Check for exact match
	if (MODEL_COLORS[model]) return MODEL_COLORS[model];

	// Check for partial matches
	for (const [key, color] of Object.entries(MODEL_COLORS)) {
		if (model.includes(key) || key.includes(model)) {
			return color;
		}
	}

	return COLORS.primary;
}

export function ModelPerformanceComparison({
	data,
	loading = false,
	height = CHART_HEIGHTS.large,
	viewMode = "speed-cost",
}: ModelPerformanceComparisonProps) {
	// Filter and prepare data
	const chartData = data
		.filter((d) => d.avgTokensPerSecond !== null && d.avgTokensPerSecond > 0)
		.sort((a, b) => (b.avgTokensPerSecond || 0) - (a.avgTokensPerSecond || 0));

	if (viewMode === "speed-cost") {
		return (
			<ChartContainer
				loading={loading}
				height={height}
				isEmpty={chartData.length === 0}
				emptyState={
					<div className="text-muted-foreground">
						No model performance data available
					</div>
				}
			>
				<ResponsiveContainer width="100%" height={height}>
					<ComposedChart
						data={chartData}
						margin={{ top: 20, right: 30, left: 20, bottom: 80 }}
					>
						<defs>
							<linearGradient id="speedGradient" x1="0" y1="0" x2="0" y2="1">
								<stop offset="0%" stopColor={COLORS.purple} stopOpacity={0.9} />
								<stop
									offset="100%"
									stopColor={COLORS.purple}
									stopOpacity={0.3}
								/>
							</linearGradient>
							<linearGradient id="costGradient" x1="0" y1="0" x2="0" y2="1">
								<stop
									offset="0%"
									stopColor={COLORS.warning}
									stopOpacity={0.9}
								/>
								<stop
									offset="100%"
									stopColor={COLORS.warning}
									stopOpacity={0.3}
								/>
							</linearGradient>
							<filter id="glow">
								<feGaussianBlur stdDeviation="3" result="coloredBlur" />
								<feMerge>
									<feMergeNode in="coloredBlur" />
									<feMergeNode in="SourceGraphic" />
								</feMerge>
							</filter>
						</defs>
						<CartesianGrid
							strokeDasharray={CHART_PROPS.strokeDasharray}
							stroke="rgba(255,255,255,0.1)"
						/>
						<XAxis
							dataKey="model"
							angle={-45}
							textAnchor="end"
							height={80}
							interval={0}
							fontSize={12}
							stroke="rgba(255,255,255,0.5)"
						/>
						<YAxis
							yAxisId="speed"
							orientation="left"
							stroke={COLORS.purple}
							fontSize={12}
							label={{
								value: "Tokens/Second",
								angle: -90,
								position: "insideLeft",
								style: { textAnchor: "middle", fill: COLORS.purple },
							}}
						/>
						<YAxis
							yAxisId="cost"
							orientation="right"
							stroke={COLORS.warning}
							fontSize={12}
							label={{
								value: "Cost per 1K Tokens ($)",
								angle: 90,
								position: "insideRight",
								style: { textAnchor: "middle", fill: COLORS.warning },
							}}
						/>
						<Tooltip
							contentStyle={{
								backgroundColor: "rgba(0,0,0,0.8)",
								border: "1px solid rgba(255,255,255,0.2)",
								borderRadius: "8px",
								backdropFilter: "blur(8px)",
							}}
							formatter={(value: number, name: string) => {
								if (name === "Speed")
									return [formatTokensPerSecond(value), name];
								if (name === "Cost/1K") return [formatCost(value), name];
								return [value, name];
							}}
						/>
						<Legend
							verticalAlign="top"
							height={36}
							iconType="rect"
							wrapperStyle={{ paddingBottom: "10px" }}
						/>
						<Bar
							yAxisId="speed"
							dataKey="avgTokensPerSecond"
							name="Speed"
							fill="url(#speedGradient)"
							filter="url(#glow)"
						/>
						<Line
							yAxisId="cost"
							type="monotone"
							dataKey="costPer1kTokens"
							name="Cost/1K"
							stroke={COLORS.warning}
							strokeWidth={3}
							dot={{ fill: COLORS.warning, r: 4 }}
							filter="url(#glow)"
						/>
					</ComposedChart>
				</ResponsiveContainer>
			</ChartContainer>
		);
	}

	if (viewMode === "performance") {
		return (
			<ChartContainer
				loading={loading}
				height={height}
				isEmpty={chartData.length === 0}
				emptyState={
					<div className="text-muted-foreground">
						No model performance data available
					</div>
				}
			>
				<ResponsiveContainer width="100%" height={height}>
					<ComposedChart
						data={chartData}
						margin={{ top: 20, right: 30, left: 20, bottom: 80 }}
					>
						<defs>
							<linearGradient id="responseGradient" x1="0" y1="0" x2="0" y2="1">
								<stop offset="0%" stopColor={COLORS.blue} stopOpacity={0.9} />
								<stop offset="100%" stopColor={COLORS.blue} stopOpacity={0.3} />
							</linearGradient>
						</defs>
						<CartesianGrid
							strokeDasharray={CHART_PROPS.strokeDasharray}
							className={CHART_PROPS.gridClassName}
						/>
						<XAxis
							dataKey="model"
							angle={-45}
							textAnchor="end"
							height={80}
							interval={0}
							fontSize={12}
						/>
						<YAxis
							yAxisId="time"
							orientation="left"
							fontSize={12}
							label={{
								value: "Response Time (ms)",
								angle: -90,
								position: "insideLeft",
								style: { textAnchor: "middle" },
							}}
						/>
						<YAxis
							yAxisId="error"
							orientation="right"
							fontSize={12}
							label={{
								value: "Error Rate (%)",
								angle: 90,
								position: "insideRight",
								style: { textAnchor: "middle" },
							}}
						/>
						<Tooltip
							contentStyle={getTooltipStyles("dark")}
							formatter={(value: number, name: string) => {
								if (name === "Response Time") return [`${value}ms`, name];
								if (name === "Error Rate") return [`${value}%`, name];
								return [value, name];
							}}
						/>
						<Legend verticalAlign="top" height={36} iconType="rect" />
						<Bar
							yAxisId="time"
							dataKey="avgResponseTime"
							name="Response Time"
							fill="url(#responseGradient)"
						/>
						<Scatter
							yAxisId="error"
							dataKey="errorRate"
							name="Error Rate"
							fill={COLORS.error}
						/>
					</ComposedChart>
				</ResponsiveContainer>
			</ChartContainer>
		);
	}

	// Efficiency view: Speed vs Cost scatter plot
	return (
		<ChartContainer
			loading={loading}
			height={height}
			isEmpty={chartData.length === 0}
			emptyState={
				<div className="text-muted-foreground">
					No model efficiency data available
				</div>
			}
		>
			<ResponsiveContainer width="100%" height={height}>
				<AreaChart
					data={chartData}
					margin={{ top: 20, right: 30, left: 60, bottom: 80 }}
				>
					<defs>
						{chartData.map((model, index) => (
							<linearGradient
								key={model.model}
								id={`gradient-${index}`}
								x1="0"
								y1="0"
								x2="0"
								y2="1"
							>
								<stop
									offset="0%"
									stopColor={getModelColor(model.model)}
									stopOpacity={0.9}
								/>
								<stop
									offset="100%"
									stopColor={getModelColor(model.model)}
									stopOpacity={0.1}
								/>
							</linearGradient>
						))}
					</defs>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						stroke="rgba(255,255,255,0.1)"
					/>
					<XAxis
						dataKey="model"
						angle={-45}
						textAnchor="end"
						height={80}
						interval={0}
						fontSize={12}
					/>
					<YAxis
						fontSize={12}
						label={{
							value: "Efficiency Score",
							angle: -90,
							position: "insideLeft",
							style: { textAnchor: "middle" },
						}}
					/>
					<Tooltip
						contentStyle={{
							backgroundColor: "rgba(0,0,0,0.8)",
							border: "1px solid rgba(255,255,255,0.2)",
							borderRadius: "8px",
							backdropFilter: "blur(8px)",
						}}
						content={({ active, payload }) => {
							if (!active || !payload?.[0]) return null;
							const data = payload[0].payload;
							return (
								<div className="p-3 space-y-1">
									<p className="font-semibold">{data.model}</p>
									<p className="text-sm">
										Speed: {formatTokensPerSecond(data.avgTokensPerSecond)}
									</p>
									<p className="text-sm">
										Cost/1K: {formatCost(data.costPer1kTokens)}
									</p>
									<p className="text-sm">
										Efficiency:{" "}
										{(
											(data.avgTokensPerSecond || 0) / data.costPer1kTokens
										).toFixed(2)}
									</p>
								</div>
							);
						}}
					/>
					<Area
						type="monotone"
						dataKey={(data: ModelComparisonData) =>
							(data.avgTokensPerSecond || 0) / data.costPer1kTokens
						}
						stroke={COLORS.primary}
						strokeWidth={2}
						fill="url(#gradient-0)"
						name="Efficiency Score"
					/>
				</AreaChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}

================
File: packages/dashboard-web/src/components/charts/BaseLineChart.tsx
================
import {
	CartesianGrid,
	Legend,
	Line,
	LineChart,
	ReferenceLine,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import {
	type CommonChartProps,
	getChartHeight,
	getTooltipStyles,
	isChartEmpty,
} from "./chart-utils";

interface LineConfig {
	dataKey: string;
	stroke?: string;
	strokeWidth?: number;
	dot?: boolean;
	name?: string;
}

interface ReferenceLineConfig {
	y: number;
	stroke?: string;
	strokeDasharray?: string;
	label?: string;
}

interface BaseLineChartProps extends CommonChartProps {
	lines: LineConfig | LineConfig[];
	referenceLines?: ReferenceLineConfig[];
}

export function BaseLineChart({
	data,
	lines,
	xAxisKey = "time",
	loading = false,
	height = "medium",
	xAxisAngle = 0,
	xAxisTextAnchor = "middle",
	xAxisHeight = 30,
	xAxisTickFormatter,
	yAxisDomain,
	yAxisTickFormatter,
	tooltipFormatter,
	tooltipLabelFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	showLegend = false,
	legendHeight = 36,
	referenceLines = [],
	margin,
	className = "",
	error = null,
	emptyState,
	onChartClick,
}: BaseLineChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = isChartEmpty(data);
	const tooltipStyles = getTooltipStyles(tooltipStyle);
	const lineConfigs = Array.isArray(lines) ? lines : [lines];

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<LineChart data={data} margin={margin} onClick={onChartClick}>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						className={CHART_PROPS.gridClassName}
					/>
					<XAxis
						dataKey={xAxisKey}
						className="text-xs"
						angle={xAxisAngle}
						textAnchor={xAxisTextAnchor}
						height={xAxisHeight}
						tickFormatter={xAxisTickFormatter}
					/>
					<YAxis
						className="text-xs"
						domain={yAxisDomain}
						tickFormatter={yAxisTickFormatter}
					/>
					<Tooltip
						contentStyle={tooltipStyles}
						formatter={tooltipFormatter}
						labelFormatter={tooltipLabelFormatter}
					/>
					{showLegend && <Legend height={legendHeight} />}
					{lineConfigs.map((lineConfig, _index) => (
						<Line
							key={lineConfig.dataKey}
							type="monotone"
							dataKey={lineConfig.dataKey}
							stroke={lineConfig.stroke || COLORS.primary}
							strokeWidth={lineConfig.strokeWidth || 2}
							dot={lineConfig.dot ?? false}
							name={lineConfig.name || lineConfig.dataKey}
							animationDuration={animationDuration}
						/>
					))}
					{referenceLines.map((refLine) => (
						<ReferenceLine
							key={`ref-line-${refLine.y}`}
							y={refLine.y}
							stroke={refLine.stroke || COLORS.primary}
							strokeDasharray={
								refLine.strokeDasharray || CHART_PROPS.strokeDasharray
							}
							label={refLine.label}
						/>
					))}
				</LineChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}

================
File: packages/dashboard-web/src/components/charts/ResponseTimeChart.tsx
================
import { COLORS } from "../../constants";
import { BaseAreaChart } from "./BaseAreaChart";

interface ResponseTimeChartProps {
	data: Array<{
		time: string;
		responseTime: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}

export function ResponseTimeChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: ResponseTimeChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	return (
		<BaseAreaChart
			data={data}
			dataKey="responseTime"
			loading={loading}
			height={height}
			color={viewMode === "cumulative" ? COLORS.purple : COLORS.primary}
			strokeWidth={viewMode === "cumulative" ? 3 : 2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			tooltipFormatter={(value) => [`${value}ms`, "Response Time"]}
			tooltipLabelFormatter={(label) =>
				viewMode === "cumulative" ? `Cumulative at ${label}` : label
			}
			animationDuration={1000}
		/>
	);
}

================
File: packages/dashboard-web/src/components/charts/RequestVolumeChart.tsx
================
import { formatNumber } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";

interface RequestVolumeChartProps {
	data: Array<{
		time: string;
		requests: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}

export function RequestVolumeChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: RequestVolumeChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	const gradient =
		viewMode === "cumulative" ? (
			<linearGradient id="colorRequests" x1="0" y1="0" x2="0" y2="1">
				<stop offset="0%" stopColor={COLORS.purple} stopOpacity={0.9} />
				<stop offset="50%" stopColor={COLORS.primary} stopOpacity={0.7} />
				<stop offset="100%" stopColor={COLORS.blue} stopOpacity={0.3} />
			</linearGradient>
		) : undefined;

	return (
		<BaseAreaChart
			data={data}
			dataKey="requests"
			loading={loading}
			height={height}
			color={viewMode === "cumulative" ? COLORS.purple : COLORS.primary}
			gradientId="colorRequests"
			customGradient={gradient}
			strokeWidth={viewMode === "cumulative" ? 3 : 2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			yAxisTickFormatter={formatCompactNumber}
			tooltipFormatter={(value) => [formatNumber(value as number), "Requests"]}
			tooltipLabelFormatter={(label) =>
				viewMode === "cumulative" ? `Cumulative at ${label}` : label
			}
			animationDuration={1000}
		/>
	);
}

================
File: packages/dashboard-web/src/components/charts/CostChart.tsx
================
import { formatCost } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactCurrency } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";

interface CostChartProps {
	data: Array<{
		time: string;
		cost: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}

export function CostChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: CostChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	const gradient = (
		<linearGradient id="colorCost" x1="0" y1="0" x2="0" y2="1">
			<stop
				offset="0%"
				stopColor={viewMode === "cumulative" ? COLORS.warning : COLORS.primary}
				stopOpacity={0.9}
			/>
			<stop
				offset="100%"
				stopColor={viewMode === "cumulative" ? COLORS.warning : COLORS.primary}
				stopOpacity={0.1}
			/>
		</linearGradient>
	);

	return (
		<BaseAreaChart
			data={data}
			dataKey="cost"
			loading={loading}
			height={height}
			color={viewMode === "cumulative" ? COLORS.warning : COLORS.primary}
			gradientId="colorCost"
			customGradient={gradient}
			strokeWidth={viewMode === "cumulative" ? 3 : 2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			yAxisTickFormatter={formatCompactCurrency}
			tooltipFormatter={(value) => [formatCost(Number(value)), "Cost"]}
			tooltipLabelFormatter={(label) =>
				viewMode === "cumulative" ? `Cumulative at ${label}` : label
			}
			animationDuration={1000}
		/>
	);
}

================
File: packages/dashboard-web/src/components/charts/TokenUsageChart.tsx
================
import { formatTokens } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseAreaChart } from "./BaseAreaChart";

interface TokenUsageChartProps {
	data: Array<{
		time: string;
		tokens: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
	timeRange?: string;
}

export function TokenUsageChart({
	data,
	loading = false,
	height = 400,
	viewMode = "normal",
	timeRange = "24h",
}: TokenUsageChartProps) {
	const isLongRange = timeRange === "7d" || timeRange === "30d";

	const gradient = (
		<linearGradient id="colorTokens" x1="0" y1="0" x2="0" y2="1">
			<stop
				offset="0%"
				stopColor={viewMode === "cumulative" ? COLORS.blue : COLORS.primary}
				stopOpacity={0.9}
			/>
			<stop
				offset="100%"
				stopColor={viewMode === "cumulative" ? COLORS.blue : COLORS.primary}
				stopOpacity={0.1}
			/>
		</linearGradient>
	);

	return (
		<BaseAreaChart
			data={data}
			dataKey="tokens"
			loading={loading}
			height={height}
			color={viewMode === "cumulative" ? COLORS.blue : COLORS.primary}
			gradientId="colorTokens"
			customGradient={gradient}
			strokeWidth={viewMode === "cumulative" ? 3 : 2}
			xAxisAngle={isLongRange ? -45 : 0}
			xAxisTextAnchor={isLongRange ? "end" : "middle"}
			xAxisHeight={isLongRange ? 60 : 30}
			yAxisTickFormatter={formatCompactNumber}
			tooltipFormatter={(value) => [formatTokens(value as number), "Tokens"]}
			tooltipLabelFormatter={(label) =>
				viewMode === "cumulative" ? `Cumulative at ${label}` : label
			}
			animationDuration={1000}
		/>
	);
}

================
File: packages/dashboard-web/src/components/charts/ChartTooltip.tsx
================
import { CHART_TOOLTIP_STYLE } from "../../constants";
import type { TooltipFormatterValue } from "./types";

interface PayloadItem {
	dataKey: string;
	value: TooltipFormatterValue;
	name?: string;
	color?: string;
}

interface ChartTooltipProps {
	active?: boolean;
	payload?: PayloadItem[];
	label?: string;
	formatters?: Record<string, (value: TooltipFormatterValue) => string>;
	labelFormatter?: (label: string) => string;
	style?: keyof typeof CHART_TOOLTIP_STYLE | object;
}

export function ChartTooltip({
	active,
	payload,
	label,
	formatters = {},
	labelFormatter,
	style = "default",
}: ChartTooltipProps) {
	if (!active || !payload || !payload.length) {
		return null;
	}

	const tooltipStyle =
		typeof style === "string" ? CHART_TOOLTIP_STYLE[style] : style;

	const formattedLabel =
		labelFormatter && label ? labelFormatter(label) : label;

	return (
		<div className="p-3 rounded-md shadow-lg" style={tooltipStyle}>
			{formattedLabel && <p className="font-medium mb-2">{formattedLabel}</p>}
			<div className="space-y-1">
				{payload.map((entry, index) => {
					const formatter = formatters[entry.dataKey] || formatters.default;
					const value = formatter ? formatter(entry.value) : entry.value;

					return (
						<div
							key={`${entry.dataKey}-${index}`}
							className="flex items-center gap-2"
						>
							<div
								className="w-3 h-3 rounded-full"
								style={{ backgroundColor: entry.color }}
							/>
							<span className="text-sm">
								{entry.name}: <strong>{value}</strong>
							</span>
						</div>
					);
				})}
			</div>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/charts/BaseScatterChart.tsx
================
import type { ReactNode } from "react";
import {
	CartesianGrid,
	ResponsiveContainer,
	Scatter,
	ScatterChart,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import {
	type CHART_HEIGHTS,
	CHART_PROPS,
	type CHART_TOOLTIP_STYLE,
	COLORS,
} from "../../constants";
import { ChartContainer } from "./ChartContainer";
import { getChartHeight, getTooltipStyles, isChartEmpty } from "./chart-utils";
import type {
	ChartClickHandler,
	ChartDataPoint,
	TooltipFormatterFunction,
} from "./types";

interface BaseScatterChartProps {
	data: ChartDataPoint[];
	xKey: string;
	yKey: string;
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	fill?: string;
	xAxisLabel?: string;
	yAxisLabel?: string;
	xAxisDomain?: [number | "auto", number | "auto"];
	xAxisTickFormatter?: (value: number | string) => string;
	yAxisDomain?: [number | "auto", number | "auto"];
	yAxisTickFormatter?: (value: number | string) => string;
	tooltipFormatter?: TooltipFormatterFunction;
	tooltipStyle?: keyof typeof CHART_TOOLTIP_STYLE | object;
	animationDuration?: number;
	margin?: { top?: number; right?: number; bottom?: number; left?: number };
	className?: string;
	error?: Error | null;
	emptyState?: ReactNode;
	onDotClick?: ChartClickHandler;
	renderLabel?: (entry: ChartDataPoint) => ReactNode;
}

export function BaseScatterChart({
	data,
	xKey,
	yKey,
	loading = false,
	height = "medium",
	fill = COLORS.primary,
	xAxisLabel,
	yAxisLabel,
	xAxisDomain,
	xAxisTickFormatter,
	yAxisDomain,
	yAxisTickFormatter,
	tooltipFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	margin,
	className = "",
	error = null,
	emptyState,
	onDotClick,
	renderLabel,
}: BaseScatterChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = isChartEmpty(data);
	const tooltipStyles = getTooltipStyles(tooltipStyle);

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<ScatterChart margin={margin}>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						className={CHART_PROPS.gridClassName}
					/>
					<XAxis
						dataKey={xKey}
						name={xAxisLabel || xKey}
						className="text-xs"
						domain={xAxisDomain}
						tickFormatter={xAxisTickFormatter}
						label={
							xAxisLabel
								? {
										value: xAxisLabel,
										position: "insideBottom",
										offset: -5,
									}
								: undefined
						}
					/>
					<YAxis
						dataKey={yKey}
						name={yAxisLabel || yKey}
						className="text-xs"
						domain={yAxisDomain}
						tickFormatter={yAxisTickFormatter}
						label={
							yAxisLabel
								? {
										value: yAxisLabel,
										angle: -90,
										position: "insideLeft",
									}
								: undefined
						}
					/>
					<Tooltip contentStyle={tooltipStyles} formatter={tooltipFormatter} />
					<Scatter
						name="Data"
						data={data}
						fill={fill}
						animationDuration={animationDuration}
						onClick={onDotClick}
					>
						{renderLabel &&
							data.map((entry) => (
								<text
									key={`label-${entry[xKey]}-${entry[yKey]}`}
									x={entry[xKey]}
									y={entry[yKey]}
									dy={-10}
									textAnchor="middle"
									className="text-xs fill-foreground"
								>
									{renderLabel(entry)}
								</text>
							))}
					</Scatter>
				</ScatterChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}

================
File: packages/dashboard-web/src/components/charts/types.ts
================
// Common types for chart components
export type ChartDataPoint = Record<string, string | number>;

export type TooltipFormatterValue = string | number | [number, number];

export type TooltipFormatterFunction = (
	value: TooltipFormatterValue,
	name?: string,
) => [string, string] | string;

// Use any for chart click handlers to match recharts types
// biome-ignore lint/suspicious/noExplicitAny: recharts types require any
export type ChartClickHandler = (data: any) => void;

================
File: packages/dashboard-web/src/components/charts/ModelTokenSpeedChart.tsx
================
import { getModelShortName } from "@ccflare/core";
import { formatTokensPerSecond } from "@ccflare/ui-common";
import {
	Bar,
	BarChart,
	CartesianGrid,
	Cell,
	ErrorBar,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { getTooltipStyles } from "./chart-utils";

interface ModelTokenSpeedData {
	model: string;
	avgTokensPerSecond: number | null;
	minTokensPerSecond: number | null;
	maxTokensPerSecond: number | null;
}

interface ModelTokenSpeedChartProps {
	data: ModelTokenSpeedData[];
	loading?: boolean;
	height?: number;
}

// Model-based color palette
const MODEL_COLORS: Record<string, string> = {
	"claude-3.5-sonnet": COLORS.purple,
	"claude-3.5-haiku": COLORS.success,
	"claude-3-opus": COLORS.blue,
	"claude-opus-4": COLORS.pink,
	// Add more models as needed
};

function getModelColor(model: string): string {
	// Try to find color by short name first
	const shortName = getModelShortName(model);
	if (MODEL_COLORS[shortName]) return MODEL_COLORS[shortName];

	// Check for exact match
	if (MODEL_COLORS[model]) return MODEL_COLORS[model];

	// Check for partial matches
	for (const [key, color] of Object.entries(MODEL_COLORS)) {
		if (model.includes(key) || key.includes(model)) {
			return color;
		}
	}

	// Default color
	return COLORS.primary;
}

export function ModelTokenSpeedChart({
	data,
	loading = false,
	height = 300,
}: ModelTokenSpeedChartProps) {
	if (loading) {
		return (
			<div className="flex items-center justify-center" style={{ height }}>
				<div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" />
			</div>
		);
	}

	// Filter out models without token speed data and prepare chart data
	const chartData = data
		.filter((d) => d.avgTokensPerSecond !== null && d.avgTokensPerSecond > 0)
		.map((d) => ({
			model: d.model,
			avgSpeed: d.avgTokensPerSecond || 0,
			minSpeed: d.minTokensPerSecond || 0,
			maxSpeed: d.maxTokensPerSecond || 0,
			// Calculate error bars (distance from avg to min/max)
			errorLower: (d.avgTokensPerSecond || 0) - (d.minTokensPerSecond || 0),
			errorUpper: (d.maxTokensPerSecond || 0) - (d.avgTokensPerSecond || 0),
		}))
		.sort((a, b) => b.avgSpeed - a.avgSpeed); // Sort by average speed

	if (chartData.length === 0) {
		return (
			<div
				className="flex items-center justify-center text-muted-foreground"
				style={{ height }}
			>
				No token speed data available
			</div>
		);
	}

	return (
		<ResponsiveContainer width="100%" height={height}>
			<BarChart
				data={chartData}
				margin={{ top: 20, right: 30, left: 60, bottom: 80 }}
			>
				<CartesianGrid
					strokeDasharray={CHART_PROPS.strokeDasharray}
					className={CHART_PROPS.gridClassName}
				/>
				<XAxis
					dataKey="model"
					fontSize={12}
					angle={-45}
					textAnchor="end"
					height={80}
					interval={0}
				/>
				<YAxis
					fontSize={12}
					tickFormatter={formatCompactNumber}
					label={{
						value: "Tokens/Second",
						angle: -90,
						position: "insideLeft",
						style: {
							textAnchor: "middle",
							fontSize: 12,
						},
					}}
				/>
				<Tooltip
					contentStyle={getTooltipStyles("default")}
					formatter={(value: number, name: string) => {
						if (name === "avgSpeed") {
							return [formatTokensPerSecond(value), "Avg Speed"];
						}
						return [value, name];
					}}
					labelFormatter={(label) => `Model: ${label}`}
				/>
				<Bar dataKey="avgSpeed" name="Average Speed">
					{chartData.map((entry) => (
						<Cell
							key={`cell-${entry.model}`}
							fill={getModelColor(entry.model)}
						/>
					))}
					<ErrorBar
						dataKey="errorLower"
						width={4}
						strokeOpacity={0.5}
						direction="y"
					/>
				</Bar>
			</BarChart>
		</ResponsiveContainer>
	);
}

================
File: packages/dashboard-web/src/components/charts/MultiModelChart.tsx
================
import { getModelShortName } from "@ccflare/core";
import {
	formatCost,
	formatNumber,
	formatTokens,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import {
	CartesianGrid,
	Legend,
	Line,
	LineChart,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import {
	CHART_COLORS,
	CHART_HEIGHTS,
	CHART_PROPS,
	COLORS,
} from "../../constants";
import {
	formatCompactCurrency,
	formatCompactNumber,
} from "../../lib/chart-utils";
import { ChartContainer } from "./ChartContainer";
import { getTooltipStyles } from "./chart-utils";

interface MultiModelChartProps {
	data: Array<{
		time: string;
		[model: string]: string | number;
	}>;
	models: string[];
	metric:
		| "requests"
		| "tokens"
		| "cost"
		| "responseTime"
		| "tokensPerSecond"
		| "errorRate"
		| "cacheHitRate";
	loading?: boolean;
	height?: number;
	viewMode?: "normal" | "cumulative";
}

// Model-based color palette
const MODEL_COLORS: Record<string, string> = {
	"claude-3.5-sonnet": COLORS.purple,
	"claude-3.5-haiku": COLORS.success,
	"claude-3-opus": COLORS.blue,
	"claude-opus-4": COLORS.pink,
};

function getModelColor(model: string, index: number): string {
	// Try to find color by short name first
	const shortName = getModelShortName(model);
	if (MODEL_COLORS[shortName]) return MODEL_COLORS[shortName];

	// Check for exact match
	if (MODEL_COLORS[model]) return MODEL_COLORS[model];

	// Check for partial matches
	for (const [key, color] of Object.entries(MODEL_COLORS)) {
		if (model.includes(key) || key.includes(model)) {
			return color;
		}
	}

	// Use chart colors array as fallback
	return CHART_COLORS[index % CHART_COLORS.length];
}

function getMetricLabel(metric: string): string {
	switch (metric) {
		case "requests":
			return "Requests";
		case "tokens":
			return "Tokens";
		case "cost":
			return "Cost ($)";
		case "responseTime":
			return "Response Time (ms)";
		case "tokensPerSecond":
			return "Tokens/Second";
		case "errorRate":
			return "Error Rate (%)";
		case "cacheHitRate":
			return "Cache Hit Rate (%)";
		default:
			return metric;
	}
}

function formatValue(value: number, metric: string): string {
	switch (metric) {
		case "cost":
			return formatCost(value);
		case "tokens":
			return formatTokens(value);
		case "tokensPerSecond":
			return formatTokensPerSecond(value);
		case "responseTime":
			return `${value.toFixed(0)}ms`;
		case "errorRate":
		case "cacheHitRate":
			return `${value.toFixed(1)}%`;
		default:
			return formatNumber(value);
	}
}

function formatAxisValue(value: number, metric: string): string {
	switch (metric) {
		case "cost":
			return formatCompactCurrency(value);
		case "tokens":
		case "requests":
			return formatCompactNumber(value);
		case "tokensPerSecond":
			return formatCompactNumber(value);
		case "responseTime":
			return formatCompactNumber(value);
		case "errorRate":
		case "cacheHitRate":
			return `${value.toFixed(0)}%`;
		default:
			return formatCompactNumber(value);
	}
}

export function MultiModelChart({
	data,
	models,
	metric,
	loading = false,
	height = CHART_HEIGHTS.large,
	viewMode = "normal",
}: MultiModelChartProps) {
	if (loading || !data || data.length === 0) {
		return (
			<ChartContainer
				loading={loading}
				height={height}
				isEmpty={!loading && (!data || data.length === 0)}
				emptyState={
					<div className="text-muted-foreground">No data available</div>
				}
			>
				<div />
			</ChartContainer>
		);
	}

	return (
		<ResponsiveContainer width="100%" height={height}>
			<LineChart
				data={data}
				margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
			>
				<defs>
					{models.map((model, index) => (
						<linearGradient
							key={model}
							id={`gradient-${model}`}
							x1="0"
							y1="0"
							x2="0"
							y2="1"
						>
							<stop
								offset="0%"
								stopColor={getModelColor(model, index)}
								stopOpacity={0.9}
							/>
							<stop
								offset="100%"
								stopColor={getModelColor(model, index)}
								stopOpacity={0.3}
							/>
						</linearGradient>
					))}
					<filter id="glow">
						<feGaussianBlur stdDeviation="2" result="coloredBlur" />
						<feMerge>
							<feMergeNode in="coloredBlur" />
							<feMergeNode in="SourceGraphic" />
						</feMerge>
					</filter>
				</defs>
				<CartesianGrid
					strokeDasharray={CHART_PROPS.strokeDasharray}
					className={CHART_PROPS.gridClassName}
				/>
				<XAxis
					dataKey="time"
					fontSize={12}
					angle={data.length > 10 ? -45 : 0}
					textAnchor={data.length > 10 ? "end" : "middle"}
					height={data.length > 10 ? 60 : 30}
				/>
				<YAxis
					fontSize={12}
					tickFormatter={(value) => formatAxisValue(value, metric)}
					label={{
						value: getMetricLabel(metric),
						angle: -90,
						position: "insideLeft",
						style: { textAnchor: "middle", fontSize: 12 },
					}}
				/>
				<Tooltip
					contentStyle={getTooltipStyles("dark")}
					formatter={(value: number) => formatValue(value, metric)}
					labelFormatter={(label) =>
						viewMode === "cumulative" ? `Cumulative at ${label}` : label
					}
				/>
				<Legend
					verticalAlign="top"
					height={36}
					wrapperStyle={{ paddingTop: "10px" }}
				/>
				{models.map((model, index) => (
					<Line
						key={model}
						type="monotone"
						dataKey={model}
						name={model}
						stroke={getModelColor(model, index)}
						strokeWidth={viewMode === "cumulative" ? 3 : 2}
						dot={false}
						activeDot={{ r: 6 }}
						filter={viewMode === "cumulative" ? "url(#glow)" : undefined}
						connectNulls={true}
					/>
				))}
			</LineChart>
		</ResponsiveContainer>
	);
}

================
File: packages/dashboard-web/src/components/charts/chart-utils.ts
================
import { CHART_HEIGHTS, CHART_TOOLTIP_STYLE } from "../../constants";
import type { ChartClickHandler, ChartDataPoint } from "./types";

/**
 * Calculate chart height from height prop
 */
export function getChartHeight(
	height: keyof typeof CHART_HEIGHTS | number,
): number {
	return typeof height === "number" ? height : CHART_HEIGHTS[height];
}

/**
 * Check if chart data is empty
 */
export function isChartEmpty(data: ChartDataPoint[] | undefined): boolean {
	return !data || data.length === 0;
}

/**
 * Get tooltip styles from prop
 */
export function getTooltipStyles(
	tooltipStyle: keyof typeof CHART_TOOLTIP_STYLE | object,
): object {
	return typeof tooltipStyle === "string"
		? CHART_TOOLTIP_STYLE[tooltipStyle]
		: tooltipStyle;
}

/**
 * Common chart axis props
 */
export interface CommonAxisProps {
	xAxisKey?: string;
	xAxisAngle?: number;
	xAxisTextAnchor?: "start" | "middle" | "end";
	xAxisHeight?: number;
	xAxisTickFormatter?: (value: number | string) => string;
	yAxisDomain?: [number | "auto", number | "auto"];
	yAxisTickFormatter?: (value: number | string) => string;
}

/**
 * Common chart props shared across all chart types
 */
export interface CommonChartProps extends CommonAxisProps {
	data: ChartDataPoint[];
	loading?: boolean;
	height?: keyof typeof CHART_HEIGHTS | number;
	className?: string;
	error?: Error | null;
	emptyState?: React.ReactNode;
	margin?: { top?: number; right?: number; bottom?: number; left?: number };
	showLegend?: boolean;
	legendHeight?: number;
	tooltipFormatter?: (value: number, name: string) => [string, string];
	tooltipLabelFormatter?: (label: string) => string;
	tooltipStyle?: keyof typeof CHART_TOOLTIP_STYLE | object;
	animationDuration?: number;
	onChartClick?: ChartClickHandler;
}

================
File: packages/dashboard-web/src/components/charts/index.ts
================
export { BaseAreaChart } from "./BaseAreaChart";
export { BaseBarChart } from "./BaseBarChart";
export { BaseLineChart } from "./BaseLineChart";
export { BasePieChart } from "./BasePieChart";
export { BaseScatterChart } from "./BaseScatterChart";
export { ChartContainer } from "./ChartContainer";
export { ChartTooltip } from "./ChartTooltip";
export { CostChart } from "./CostChart";
export { ModelPerformanceChart } from "./ModelPerformanceChart";
export { ModelPerformanceComparison } from "./ModelPerformanceComparison";
export { ModelTokenSpeedChart } from "./ModelTokenSpeedChart";
export { MultiModelChart } from "./MultiModelChart";
export { RequestVolumeChart } from "./RequestVolumeChart";
export { ResponseTimeChart } from "./ResponseTimeChart";
export { TokenSpeedChart } from "./TokenSpeedChart";
export { TokenUsageChart } from "./TokenUsageChart";

================
File: packages/dashboard-web/src/components/charts/ModelPerformanceChart.tsx
================
import { formatPercentage } from "@ccflare/ui-common";
import { COLORS } from "../../constants";
import { formatCompactNumber } from "../../lib/chart-utils";
import { BaseScatterChart } from "./BaseScatterChart";

interface ModelPerformanceChartProps {
	data: Array<{
		model: string;
		avgTime: number;
		errorRate: number;
		[key: string]: string | number;
	}>;
	loading?: boolean;
	height?: number;
}

export function ModelPerformanceChart({
	data,
	loading = false,
	height = 300,
}: ModelPerformanceChartProps) {
	return (
		<BaseScatterChart
			data={data}
			xKey="avgTime"
			yKey="errorRate"
			loading={loading}
			height={height}
			fill={COLORS.primary}
			xAxisLabel="Avg Response Time (ms)"
			xAxisTickFormatter={formatCompactNumber}
			yAxisLabel="Error Rate %"
			tooltipFormatter={(value, name) => {
				if (name === "avgTime") return [`${value}ms`, "Avg Time"];
				if (name === "errorRate")
					return [formatPercentage(Number(value)), "Error Rate"];
				return [`${value}`, name || ""];
			}}
			tooltipStyle={{
				backgroundColor: COLORS.success,
				border: `1px solid ${COLORS.success}`,
				borderRadius: "var(--radius)",
				color: "#fff",
			}}
			renderLabel={(entry) => entry.model}
		/>
	);
}

================
File: packages/dashboard-web/src/components/charts/BaseBarChart.tsx
================
import {
	Bar,
	BarChart,
	CartesianGrid,
	Legend,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import { CHART_PROPS, COLORS } from "../../constants";
import { ChartContainer } from "./ChartContainer";
import {
	type CommonChartProps,
	getChartHeight,
	getTooltipStyles,
	isChartEmpty,
} from "./chart-utils";

interface BarConfig {
	dataKey: string;
	fill?: string;
	name?: string;
	yAxisId?: string;
	radius?: [number, number, number, number];
}

interface BaseBarChartProps extends CommonChartProps {
	bars: BarConfig | BarConfig[];
	layout?: "horizontal" | "vertical";
	xAxisType?: "number" | "category";
	yAxisType?: "number" | "category";
	yAxisWidth?: number;
	yAxisOrientation?: "left" | "right";
	secondaryYAxis?: boolean;
}

export function BaseBarChart({
	data,
	bars,
	xAxisKey = "name",
	loading = false,
	height = "medium",
	layout = "horizontal",
	xAxisAngle = 0,
	xAxisTextAnchor = "middle",
	xAxisHeight = 30,
	xAxisTickFormatter,
	xAxisType = layout === "vertical" ? "number" : "category",
	yAxisType = layout === "vertical" ? "category" : "number",
	yAxisWidth,
	yAxisDomain,
	yAxisTickFormatter,
	yAxisOrientation = "left",
	secondaryYAxis = false,
	tooltipFormatter,
	tooltipLabelFormatter,
	tooltipStyle = "default",
	animationDuration = 1000,
	showLegend = false,
	legendHeight = 36,
	margin,
	className = "",
	error = null,
	emptyState,
	onChartClick,
}: BaseBarChartProps) {
	const chartHeight = getChartHeight(height);
	const isEmpty = isChartEmpty(data);
	const tooltipStyles = getTooltipStyles(tooltipStyle);
	const barConfigs = Array.isArray(bars) ? bars : [bars];

	return (
		<ChartContainer
			loading={loading}
			height={height}
			className={className}
			error={error}
			isEmpty={isEmpty}
			emptyState={emptyState}
		>
			<ResponsiveContainer width="100%" height={chartHeight}>
				<BarChart
					data={data}
					layout={layout}
					margin={margin}
					onClick={onChartClick}
				>
					<CartesianGrid
						strokeDasharray={CHART_PROPS.strokeDasharray}
						className={CHART_PROPS.gridClassName}
					/>
					{layout === "vertical" ? (
						<>
							<XAxis
								type={xAxisType as "number"}
								className="text-xs"
								tickFormatter={xAxisTickFormatter}
							/>
							<YAxis
								dataKey={xAxisKey}
								type={yAxisType as "category"}
								className="text-xs"
								width={yAxisWidth}
								tickFormatter={yAxisTickFormatter}
							/>
						</>
					) : (
						<>
							<XAxis
								dataKey={xAxisKey}
								type={xAxisType as "category"}
								className="text-xs"
								angle={xAxisAngle}
								textAnchor={xAxisTextAnchor}
								height={xAxisHeight}
								tickFormatter={xAxisTickFormatter}
							/>
							<YAxis
								yAxisId={secondaryYAxis ? "left" : undefined}
								type={yAxisType as "number"}
								className="text-xs"
								domain={yAxisDomain}
								orientation={yAxisOrientation}
								tickFormatter={yAxisTickFormatter}
							/>
							{secondaryYAxis && (
								<YAxis
									yAxisId="right"
									orientation="right"
									className="text-xs"
									tickFormatter={yAxisTickFormatter}
								/>
							)}
						</>
					)}
					<Tooltip
						contentStyle={tooltipStyles}
						formatter={tooltipFormatter}
						labelFormatter={tooltipLabelFormatter}
					/>
					{showLegend && <Legend height={legendHeight} />}
					{barConfigs.map((barConfig) => (
						<Bar
							key={barConfig.dataKey}
							dataKey={barConfig.dataKey}
							fill={barConfig.fill || COLORS.primary}
							name={barConfig.name || barConfig.dataKey}
							yAxisId={barConfig.yAxisId}
							radius={barConfig.radius}
							animationDuration={animationDuration}
						/>
					))}
				</BarChart>
			</ResponsiveContainer>
		</ChartContainer>
	);
}

================
File: packages/dashboard-web/src/components/agents/AgentCard.tsx
================
import { getModelDisplayName } from "@ccflare/core";
import type { Agent } from "@ccflare/types";
import { ALLOWED_MODELS } from "@ccflare/types";
import { Bot, Cpu, Edit3, Folder, Globe, Sparkles } from "lucide-react";
import { useState } from "react";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { AgentEditDialog } from "./AgentEditDialog";

interface AgentCardProps {
	agent: Agent;
	onModelChange?: (agentId: string, model: string) => void;
	isUpdating?: boolean;
}

export function AgentCard({
	agent,
	onModelChange,
	isUpdating,
}: AgentCardProps) {
	const [editDialogOpen, setEditDialogOpen] = useState(false);

	// Map color names to more sophisticated gradient classes
	const colorMap: Record<string, { border: string; bg: string; icon: string }> =
		{
			gray: {
				border: "border-gray-300 dark:border-gray-700",
				bg: "bg-gray-50 dark:bg-gray-900/50",
				icon: "text-gray-600 dark:text-gray-400",
			},
			blue: {
				border: "border-blue-300 dark:border-blue-700",
				bg: "bg-blue-50 dark:bg-blue-900/20",
				icon: "text-blue-600 dark:text-blue-400",
			},
			green: {
				border: "border-green-300 dark:border-green-700",
				bg: "bg-green-50 dark:bg-green-900/20",
				icon: "text-green-600 dark:text-green-400",
			},
			yellow: {
				border: "border-yellow-300 dark:border-yellow-700",
				bg: "bg-yellow-50 dark:bg-yellow-900/20",
				icon: "text-yellow-600 dark:text-yellow-400",
			},
			orange: {
				border: "border-orange-300 dark:border-orange-700",
				bg: "bg-orange-50 dark:bg-orange-900/20",
				icon: "text-orange-600 dark:text-orange-400",
			},
			red: {
				border: "border-red-300 dark:border-red-700",
				bg: "bg-red-50 dark:bg-red-900/20",
				icon: "text-red-600 dark:text-red-400",
			},
			purple: {
				border: "border-purple-300 dark:border-purple-700",
				bg: "bg-purple-50 dark:bg-purple-900/20",
				icon: "text-purple-600 dark:text-purple-400",
			},
			pink: {
				border: "border-pink-300 dark:border-pink-700",
				bg: "bg-pink-50 dark:bg-pink-900/20",
				icon: "text-pink-600 dark:text-pink-400",
			},
			indigo: {
				border: "border-indigo-300 dark:border-indigo-700",
				bg: "bg-indigo-50 dark:bg-indigo-900/20",
				icon: "text-indigo-600 dark:text-indigo-400",
			},
			cyan: {
				border: "border-cyan-300 dark:border-cyan-700",
				bg: "bg-cyan-50 dark:bg-cyan-900/20",
				icon: "text-cyan-600 dark:text-cyan-400",
			},
		};

	const colors = colorMap[agent.color] || colorMap.gray;
	const isWorkspaceAgent = agent.source === "workspace";
	const SourceIcon = isWorkspaceAgent ? Folder : Globe;

	// Get clean agent name (remove workspace prefix for workspace agents)
	const displayName =
		isWorkspaceAgent && agent.id.includes(":") ? agent.name : agent.name;

	// Get workspace name from ID if it's a workspace agent
	const workspaceName =
		isWorkspaceAgent && agent.id.includes(":") ? agent.id.split(":")[0] : null;

	return (
		<Card
			className={`group relative overflow-hidden transition-all hover:shadow-lg ${colors.border} border-2`}
		>
			{/* Gradient background overlay */}
			<div className={`absolute inset-0 ${colors.bg} opacity-50`} />

			<CardHeader className="relative">
				<div className="space-y-3">
					<div className="flex items-start justify-between">
						<div className="flex items-center gap-3">
							<div
								className={`p-2.5 rounded-xl ${colors.bg} ${colors.border} border backdrop-blur-sm`}
							>
								<Bot className={`h-5 w-5 ${colors.icon}`} />
							</div>
							<div className="flex-1">
								<CardTitle className="text-lg font-semibold flex items-center gap-2">
									{displayName}
									{agent.model.includes("opus") && (
										<Sparkles className="h-4 w-4 text-yellow-500" />
									)}
								</CardTitle>
								<div className="flex items-center gap-2 mt-1">
									<Badge variant="outline" className="text-xs gap-1">
										<SourceIcon className="h-3 w-3" />
										{isWorkspaceAgent ? workspaceName : "Global"}
									</Badge>
									{agent.model.includes("opus") && (
										<Badge variant="secondary" className="text-xs gap-1">
											<Cpu className="h-3 w-3" />
											Advanced
										</Badge>
									)}
								</div>
							</div>
						</div>
						<Button
							variant="ghost"
							size="sm"
							onClick={() => setEditDialogOpen(true)}
							className="opacity-0 group-hover:opacity-100 transition-opacity"
						>
							<Edit3 className="h-4 w-4" />
						</Button>
					</div>
					<CardDescription className="text-sm leading-relaxed line-clamp-3 whitespace-pre-wrap">
						{agent.description.replace(/\\n/g, "\n")}
					</CardDescription>
				</div>
			</CardHeader>

			<CardContent className="relative space-y-4">
				<div className="space-y-2">
					<Label className="text-muted-foreground">Model Preference</Label>
					<Select
						value={agent.model}
						onValueChange={(value) => onModelChange?.(agent.id, value)}
						disabled={isUpdating}
					>
						<SelectTrigger className="w-full bg-background/60 backdrop-blur-sm">
							<SelectValue />
						</SelectTrigger>
						<SelectContent>
							{ALLOWED_MODELS.map((model) => (
								<SelectItem
									key={model}
									value={model}
									className="flex items-center"
								>
									<span className="flex items-center gap-2">
										{getModelDisplayName(model)}
										{model.includes("opus") && (
											<Badge variant="secondary" className="text-xs">
												Premium
											</Badge>
										)}
									</span>
								</SelectItem>
							))}
						</SelectContent>
					</Select>
				</div>

				<div className="pt-2 border-t">
					<p className="text-xs text-muted-foreground font-mono">{agent.id}</p>
				</div>
			</CardContent>

			<AgentEditDialog
				agent={agent}
				open={editDialogOpen}
				onOpenChange={setEditDialogOpen}
			/>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/agents/AgentEditDialog.tsx
================
import { getModelDisplayName } from "@ccflare/core";
import type {
	Agent,
	AgentTool,
	AgentUpdatePayload,
	AllowedModel,
} from "@ccflare/types";
import { ALL_TOOLS, ALLOWED_MODELS } from "@ccflare/types";
import { Cpu, Edit3, FileText, Palette, Save, Shield, X } from "lucide-react";
import { useMemo, useState } from "react";
import { TOOL_PRESETS } from "../../constants";
import { useUpdateAgent } from "../../hooks/queries";
import { cn } from "../../lib/utils";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "../ui/dialog";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../ui/tabs";

interface AgentEditDialogProps {
	agent: Agent;
	open: boolean;
	onOpenChange: (open: boolean) => void;
}

type ToolPresetMode = keyof typeof TOOL_PRESETS;

// Helper function to get all combinations of array elements
function getCombinations<T>(arr: T[], size: number): T[][] {
	if (size === 0) return [[]];
	if (size > arr.length) return [];

	const result: T[][] = [];

	function combine(start: number, combo: T[]) {
		if (combo.length === size) {
			result.push([...combo]);
			return;
		}

		for (let i = start; i < arr.length; i++) {
			combo.push(arr[i]);
			combine(i + 1, combo);
			combo.pop();
		}
	}

	combine(0, []);
	return result;
}

const COLORS = [
	{ name: "gray", class: "bg-gray-500" },
	{ name: "blue", class: "bg-blue-500" },
	{ name: "green", class: "bg-green-500" },
	{ name: "yellow", class: "bg-yellow-500" },
	{ name: "orange", class: "bg-orange-500" },
	{ name: "red", class: "bg-red-500" },
	{ name: "purple", class: "bg-purple-500" },
	{ name: "pink", class: "bg-pink-500" },
	{ name: "indigo", class: "bg-indigo-500" },
	{ name: "cyan", class: "bg-cyan-500" },
];

const TOOL_MODE_INFO = {
	all: {
		label: "All Tools",
		description: "Full access to all available tools",
		icon: "üöÄ",
	},
	edit: {
		label: "Edit Mode",
		description: "File modification tools only",
		icon: "‚úèÔ∏è",
	},
	"read-only": {
		label: "Read Only",
		description: "File reading and search tools",
		icon: "üëÅÔ∏è",
	},
	execution: {
		label: "Execution",
		description: "Command execution tools only",
		icon: "‚ö°",
	},
};

export function AgentEditDialog({
	agent,
	open,
	onOpenChange,
}: AgentEditDialogProps) {
	const updateAgent = useUpdateAgent();

	const [description, setDescription] = useState(
		agent.description.replace(/\\n/g, "\n"),
	);
	const [model, setModel] = useState<AllowedModel>(agent.model);
	const [color, setColor] = useState(agent.color);
	const [systemPrompt, setSystemPrompt] = useState(agent.systemPrompt);

	// Initialize selected modes based on current tools
	const [selectedModes, setSelectedModes] = useState<Set<ToolPresetMode>>(
		() => {
			if (!agent.tools || agent.tools.length === 0) {
				return new Set(["all"]);
			}

			const toolsSet = new Set(agent.tools);
			const matchingModes = new Set<ToolPresetMode>();

			// First, try to find exact matches with single presets
			for (const [mode, presetTools] of Object.entries(TOOL_PRESETS)) {
				if (mode === "all") continue;
				const presetSet = new Set(presetTools);
				if (
					toolsSet.size === presetSet.size &&
					[...toolsSet].every((tool) => presetSet.has(tool))
				) {
					matchingModes.add(mode as ToolPresetMode);
				}
			}

			// If we found exact single preset matches, return them
			if (matchingModes.size > 0) {
				return matchingModes;
			}

			// Otherwise, find the combination of presets that exactly matches our tools
			const presetModes = Object.keys(TOOL_PRESETS).filter(
				(m) => m !== "all",
			) as ToolPresetMode[];

			// Try all combinations of presets to find exact matches
			for (let i = 1; i <= presetModes.length; i++) {
				const combinations = getCombinations(presetModes, i);
				for (const combo of combinations) {
					const comboTools = new Set<AgentTool>();
					for (const mode of combo) {
						TOOL_PRESETS[mode].forEach((tool) => comboTools.add(tool));
					}
					// Check if this combination exactly matches our tools
					if (
						comboTools.size === toolsSet.size &&
						[...toolsSet].every((tool) => comboTools.has(tool))
					) {
						return new Set(combo);
					}
				}
			}

			// If no exact combination found, return empty set (will trigger custom mode)
			return new Set<ToolPresetMode>();
		},
	);

	const [customTools, setCustomTools] = useState<AgentTool[]>(
		agent.tools || [],
	);

	const [isCustomMode, setIsCustomMode] = useState(() => {
		// Start in custom mode if:
		// 1. No modes are selected (tools don't match any preset combination)
		// 2. Or if we have the "all" preset selected and there are tools
		if (selectedModes.size === 0) {
			return true;
		}
		if (selectedModes.has("all") && agent.tools && agent.tools.length > 0) {
			return true;
		}
		return false;
	});

	// Compute effective tools based on selected modes
	const effectiveTools = useMemo(() => {
		if (isCustomMode) {
			return customTools;
		}

		if (selectedModes.has("all")) {
			return [];
		}

		const toolSet = new Set<AgentTool>();
		for (const mode of selectedModes) {
			if (mode !== "all") {
				TOOL_PRESETS[mode].forEach((tool) => toolSet.add(tool));
			}
		}
		return Array.from(toolSet);
	}, [selectedModes, customTools, isCustomMode]);

	const handleModeToggle = (mode: ToolPresetMode) => {
		const newModes = new Set(selectedModes);

		if (mode === "all") {
			// If selecting "all", clear other selections
			if (newModes.has("all")) {
				newModes.delete("all");
			} else {
				newModes.clear();
				newModes.add("all");
			}
		} else {
			// Toggle the mode
			if (newModes.has(mode)) {
				newModes.delete(mode);
			} else {
				newModes.add(mode);
				// Remove "all" if selecting specific modes
				newModes.delete("all");
			}
		}

		setSelectedModes(newModes);

		// Calculate the tools from the new preset selection
		const newToolSet = new Set<AgentTool>();
		for (const m of newModes) {
			if (m !== "all") {
				TOOL_PRESETS[m].forEach((tool) => newToolSet.add(tool));
			}
		}

		// Check if custom tools match the new preset selection
		const customToolSet = new Set(customTools);
		const hasExtraTools = [...customToolSet].some(
			(tool) => !newToolSet.has(tool),
		);
		const _missingTools = [...newToolSet].some(
			(tool) => !customToolSet.has(tool),
		);

		// Only stay in custom mode if we have extra tools that aren't in the presets
		if (isCustomMode && hasExtraTools && newModes.size > 0) {
			// Stay in custom mode but update the selection
			setIsCustomMode(true);
		} else {
			// Switch to preset mode
			setIsCustomMode(false);
			setCustomTools(Array.from(newToolSet));
		}
	};

	const handleCustomModeToggle = () => {
		if (!isCustomMode) {
			// Entering custom mode - keep current tools
			setCustomTools(effectiveTools);
			setIsCustomMode(true);
		} else {
			// Exiting custom mode - try to find matching presets
			const toolSet = new Set(customTools);

			// Try to find matching preset combinations
			const presetModes = Object.keys(TOOL_PRESETS).filter(
				(m) => m !== "all",
			) as ToolPresetMode[];

			for (let i = 1; i <= presetModes.length; i++) {
				const combinations = getCombinations(presetModes, i);
				for (const combo of combinations) {
					const comboTools = new Set<AgentTool>();
					for (const mode of combo) {
						TOOL_PRESETS[mode].forEach((tool) => comboTools.add(tool));
					}
					// Check if this combination exactly matches our tools
					if (
						comboTools.size === toolSet.size &&
						[...toolSet].every((tool) => comboTools.has(tool))
					) {
						// Found a matching preset combination
						setSelectedModes(new Set(combo));
						setIsCustomMode(false);
						return;
					}
				}
			}

			// If no exact match found, just exit custom mode with empty selection
			setSelectedModes(new Set());
			setIsCustomMode(false);
		}
	};

	const handleSave = async () => {
		try {
			const tools = effectiveTools;

			// Determine mode for API - only send if it's a single exact match
			let mode: string | undefined;
			if (!isCustomMode && selectedModes.size === 1) {
				const [selectedMode] = selectedModes;
				if (selectedMode === "all" && tools.length === 0) {
					mode = "all";
				} else if (selectedMode !== "all") {
					const presetTools = TOOL_PRESETS[selectedMode];
					if (
						tools.length === presetTools.length &&
						tools.every((t) => presetTools.includes(t))
					) {
						mode = selectedMode;
					}
				}
			}

			await updateAgent.mutateAsync({
				id: agent.id,
				payload: {
					description: description.replace(/\n/g, "\\n"),
					model,
					color,
					systemPrompt,
					mode: mode as AgentUpdatePayload["mode"],
					tools: mode ? undefined : tools,
				},
			});

			onOpenChange(false);
		} catch (error) {
			console.error("Failed to update agent:", error);
		}
	};

	const handleToolToggle = (tool: AgentTool) => {
		const newTools = customTools.includes(tool)
			? customTools.filter((t) => t !== tool)
			: [...customTools, tool];

		setCustomTools(newTools);

		// Check if the new tool selection matches any preset combination
		const newToolSet = new Set(newTools);

		// Try to find matching preset combinations
		const presetModes = Object.keys(TOOL_PRESETS).filter(
			(m) => m !== "all",
		) as ToolPresetMode[];

		for (let i = 1; i <= presetModes.length; i++) {
			const combinations = getCombinations(presetModes, i);
			for (const combo of combinations) {
				const comboTools = new Set<AgentTool>();
				for (const mode of combo) {
					TOOL_PRESETS[mode].forEach((tool) => comboTools.add(tool));
				}
				// Check if this combination exactly matches our tools
				if (
					comboTools.size === newToolSet.size &&
					[...newToolSet].every((tool) => comboTools.has(tool))
				) {
					// Found a matching preset combination
					setSelectedModes(new Set(combo));
					setIsCustomMode(false);
					return;
				}
			}
		}

		// No matching preset combination found, stay in custom mode
		setIsCustomMode(true);
	};

	return (
		<Dialog open={open} onOpenChange={onOpenChange}>
			<DialogContent className="max-w-3xl max-h-[90vh] overflow-hidden flex flex-col">
				<DialogHeader className="space-y-4 pb-6 border-b">
					<DialogTitle className="flex items-center gap-3 text-xl">
						<div className="p-2 bg-primary/10 rounded-lg">
							<Edit3 className="h-5 w-5 text-primary" />
						</div>
						<span>Edit Agent Configuration</span>
					</DialogTitle>
					<DialogDescription className="flex items-center gap-2">
						<Badge variant="secondary" className="gap-1.5">
							{agent.name}
						</Badge>
						<span className="text-muted-foreground">
							Customize how this agent behaves and what it can access
						</span>
					</DialogDescription>
				</DialogHeader>

				<Tabs defaultValue="general" className="flex-1 overflow-y-auto">
					<TabsList className="grid w-full grid-cols-4">
						<TabsTrigger value="general" className="gap-2">
							<FileText className="h-4 w-4" />
							General
						</TabsTrigger>
						<TabsTrigger value="description" className="gap-2">
							<Edit3 className="h-4 w-4" />
							Description
						</TabsTrigger>
						<TabsTrigger value="tools" className="gap-2">
							<Shield className="h-4 w-4" />
							Tools
						</TabsTrigger>
						<TabsTrigger value="prompt" className="gap-2">
							<Cpu className="h-4 w-4" />
							Prompt
						</TabsTrigger>
					</TabsList>

					<div className="overflow-y-auto flex-1 px-1">
						<TabsContent value="general" className="mt-6 space-y-6">
							{/* Model */}
							<div className="space-y-3">
								<Label className="text-base font-medium">Language Model</Label>
								<Select
									value={model}
									onValueChange={(value) => setModel(value as AllowedModel)}
								>
									<SelectTrigger className="w-full">
										<SelectValue />
									</SelectTrigger>
									<SelectContent>
										{ALLOWED_MODELS.map((m) => (
											<SelectItem key={m} value={m}>
												<div className="flex items-center gap-2">
													<Cpu className="h-4 w-4" />
													{getModelDisplayName(m)}
													{m.includes("opus") && (
														<Badge variant="secondary" className="ml-2 text-xs">
															Advanced
														</Badge>
													)}
												</div>
											</SelectItem>
										))}
									</SelectContent>
								</Select>
							</div>

							{/* Color */}
							<div className="space-y-3">
								<Label className="text-base font-medium flex items-center gap-2">
									<Palette className="h-4 w-4" />
									Theme Color
								</Label>
								<div className="grid grid-cols-5 gap-3">
									{COLORS.map(({ name, class: colorClass }) => (
										<button
											key={name}
											type="button"
											onClick={() => setColor(name)}
											className={cn(
												"relative h-12 rounded-lg border-2 transition-all",
												"hover:scale-105 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
												color === name
													? "border-primary shadow-lg"
													: "border-transparent",
											)}
										>
											<div
												className={cn(
													"h-full w-full rounded-md",
													colorClass,
													"opacity-90",
												)}
											/>
											{color === name && (
												<div className="absolute inset-0 flex items-center justify-center">
													<div className="h-3 w-3 rounded-full bg-white shadow-sm" />
												</div>
											)}
										</button>
									))}
								</div>
							</div>
						</TabsContent>

						<TabsContent value="description" className="mt-6 space-y-4">
							<div className="space-y-3">
								<Label htmlFor="description" className="text-base font-medium">
									Agent Description
								</Label>
								<textarea
									id="description"
									value={description}
									onChange={(e) => setDescription(e.target.value)}
									rows={12}
									className="flex min-h-[300px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 resize-none font-mono"
									placeholder="Describe what this agent does and when to use it..."
								/>
								<p className="text-xs text-muted-foreground">
									This description helps users understand when to use this agent
								</p>
							</div>
						</TabsContent>

						<TabsContent value="tools" className="mt-6 space-y-6">
							<div className="space-y-6">
								<div className="space-y-4">
									<div className="flex items-center justify-between">
										<Label className="text-base font-medium">
											Tool Access Presets
										</Label>
										<Badge variant="outline" className="gap-1.5">
											{effectiveTools.length === 0
												? "All tools"
												: `${effectiveTools.length} tools selected`}
										</Badge>
									</div>

									<p className="text-sm text-muted-foreground">
										Select one or more presets to combine their tool sets, or
										use custom selection for fine-grained control.
									</p>

									<div className="grid gap-3">
										{(
											Object.keys(TOOL_MODE_INFO) as Array<
												keyof typeof TOOL_MODE_INFO
											>
										).map((mode) => {
											const info = TOOL_MODE_INFO[mode];
											const isSelected = selectedModes.has(mode);
											const toolCount = TOOL_PRESETS[mode]?.length || 0;

											return (
												<button
													key={mode}
													type="button"
													onClick={() => handleModeToggle(mode)}
													disabled={isCustomMode}
													className={cn(
														"relative flex items-start gap-4 rounded-lg border p-4 text-left transition-all",
														"hover:bg-accent/50",
														isSelected && !isCustomMode
															? "border-primary bg-primary/5"
															: "border-border",
														isCustomMode && "opacity-50 cursor-not-allowed",
													)}
												>
													<input
														type="checkbox"
														checked={isSelected && !isCustomMode}
														onChange={() => {}}
														className="mt-0.5 h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
														disabled={isCustomMode}
													/>
													<div className="text-2xl">{info.icon}</div>
													<div className="flex-1 space-y-1">
														<div className="font-medium">{info.label}</div>
														<div className="text-sm text-muted-foreground">
															{info.description}
														</div>
														<Badge variant="secondary" className="mt-2">
															{mode === "all"
																? "All tools"
																: `${toolCount} tools`}
														</Badge>
													</div>
												</button>
											);
										})}
									</div>
								</div>

								{/* Custom Mode Toggle */}
								<div className="border-t pt-6">
									<button
										type="button"
										onClick={handleCustomModeToggle}
										className={cn(
											"relative flex items-start gap-4 rounded-lg border p-4 text-left transition-all w-full",
											"hover:bg-accent/50",
											isCustomMode
												? "border-primary bg-primary/5"
												: "border-border",
										)}
									>
										<input
											type="checkbox"
											checked={isCustomMode}
											onChange={() => {}}
											className="mt-0.5 h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
										/>
										<div className="text-2xl">‚öôÔ∏è</div>
										<div className="flex-1 space-y-1">
											<div className="font-medium">Custom Selection</div>
											<div className="text-sm text-muted-foreground">
												Manually select specific tools
											</div>
										</div>
									</button>

									{/* Custom Tools Selection */}
									{isCustomMode && (
										<div className="mt-4 space-y-3">
											<div className="flex items-center justify-between">
												<Label className="text-sm font-medium">
													Select Tools ({customTools.length} selected)
												</Label>
												<div className="flex gap-2">
													<Button
														type="button"
														variant="ghost"
														size="sm"
														onClick={() => setCustomTools(ALL_TOOLS)}
													>
														Select All
													</Button>
													<Button
														type="button"
														variant="ghost"
														size="sm"
														onClick={() => setCustomTools([])}
													>
														Clear
													</Button>
												</div>
											</div>
											<div className="grid grid-cols-2 gap-2 rounded-lg border p-4 max-h-64 overflow-y-auto">
												{ALL_TOOLS.map((tool) => (
													<label
														key={tool}
														className="flex items-center gap-3 p-2 rounded-md hover:bg-accent cursor-pointer"
													>
														<input
															type="checkbox"
															checked={customTools.includes(tool)}
															onChange={() => handleToolToggle(tool)}
															className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary"
														/>
														<span className="text-sm">{tool}</span>
													</label>
												))}
											</div>
										</div>
									)}
								</div>
							</div>
						</TabsContent>

						<TabsContent value="prompt" className="mt-6 space-y-4">
							<div className="space-y-3">
								<Label htmlFor="systemPrompt" className="text-base font-medium">
									System Prompt
								</Label>
								<textarea
									id="systemPrompt"
									value={systemPrompt}
									onChange={(e) => setSystemPrompt(e.target.value)}
									rows={12}
									className="flex min-h-[300px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 resize-none font-mono"
									placeholder="Enter the system prompt that defines this agent's behavior..."
								/>
								<p className="text-xs text-muted-foreground">
									This prompt will be used to initialize the agent's behavior
									and capabilities
								</p>
							</div>
						</TabsContent>
					</div>
				</Tabs>

				<DialogFooter className="border-t pt-6">
					<Button
						variant="outline"
						onClick={() => onOpenChange(false)}
						disabled={updateAgent.isPending}
					>
						<X className="h-4 w-4 mr-2" />
						Cancel
					</Button>
					<Button onClick={handleSave} disabled={updateAgent.isPending}>
						<Save className="h-4 w-4 mr-2" />
						{updateAgent.isPending ? "Saving..." : "Save Changes"}
					</Button>
				</DialogFooter>
			</DialogContent>
		</Dialog>
	);
}

================
File: packages/dashboard-web/src/components/agents/index.ts
================
export { AgentCard } from "./AgentCard";
export { AgentEditDialog } from "./AgentEditDialog";
export { WorkspaceCard } from "./WorkspaceCard";

================
File: packages/dashboard-web/src/components/agents/WorkspaceCard.tsx
================
import type { AgentWorkspace } from "@ccflare/types";
import { formatDistanceToNow } from "date-fns";
import { Folder, FolderOpen, Package } from "lucide-react";
import { Badge } from "../ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";

interface WorkspaceCardProps {
	workspace: AgentWorkspace & { agentCount?: number };
	isActive?: boolean;
}

export function WorkspaceCard({ workspace, isActive }: WorkspaceCardProps) {
	const Icon = isActive ? FolderOpen : Folder;

	return (
		<Card
			className={`transition-all ${isActive ? "ring-2 ring-primary shadow-lg" : "hover:shadow-md"}`}
		>
			<CardHeader>
				<div className="flex items-start justify-between">
					<div className="flex items-center gap-3">
						<div
							className={`p-2 rounded-lg ${isActive ? "bg-primary/10" : "bg-muted"}`}
						>
							<Icon
								className={`h-5 w-5 ${isActive ? "text-primary" : "text-muted-foreground"}`}
							/>
						</div>
						<div>
							<CardTitle className="text-lg font-semibold">
								{workspace.name}
							</CardTitle>
							<CardDescription className="text-xs mt-1">
								{workspace.path}
							</CardDescription>
						</div>
					</div>
					{workspace.agentCount !== undefined && workspace.agentCount > 0 && (
						<Badge variant="secondary" className="gap-1">
							<Package className="h-3 w-3" />
							{workspace.agentCount}
						</Badge>
					)}
				</div>
			</CardHeader>
			<CardContent>
				<p className="text-sm text-muted-foreground">
					Last seen{" "}
					{formatDistanceToNow(new Date(workspace.lastSeen), {
						addSuffix: true,
					})}
				</p>
			</CardContent>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/accounts/AccountAddForm.tsx
================
import { useState } from "react";
import { Button } from "../ui/button";
import { Input } from "../ui/input";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";

interface AccountAddFormProps {
	onAddAccount: (params: {
		name: string;
		mode: "max" | "console";
		tier: number;
	}) => Promise<{ authUrl: string; sessionId: string }>;
	onCompleteAccount: (params: {
		sessionId: string;
		code: string;
	}) => Promise<void>;
	onCancel: () => void;
	onSuccess: () => void;
	onError: (error: string) => void;
}

export function AccountAddForm({
	onAddAccount,
	onCompleteAccount,
	onCancel,
	onSuccess,
	onError,
}: AccountAddFormProps) {
	const [authStep, setAuthStep] = useState<"form" | "code">("form");
	const [authCode, setAuthCode] = useState("");
	const [sessionId, setSessionId] = useState("");
	const [newAccount, setNewAccount] = useState({
		name: "",
		mode: "max" as "max" | "console",
		tier: 1,
	});

	const handleAddAccount = async () => {
		if (!newAccount.name) {
			onError("Account name is required");
			return;
		}
		// Step 1: Initialize OAuth flow
		const { authUrl, sessionId } = await onAddAccount(newAccount);
		setSessionId(sessionId);

		// Open auth URL in new tab
		if (typeof window !== "undefined") {
			window.open(authUrl, "_blank");
		}

		// Move to code entry step
		setAuthStep("code");
	};

	const handleCodeSubmit = async () => {
		if (!authCode) {
			onError("Authorization code is required");
			return;
		}
		// Step 2: Complete OAuth flow
		await onCompleteAccount({
			sessionId,
			code: authCode,
		});

		// Success! Reset form
		setAuthStep("form");
		setAuthCode("");
		setSessionId("");
		setNewAccount({ name: "", mode: "max", tier: 1 });
		onSuccess();
	};

	const handleCancel = () => {
		setAuthStep("form");
		setAuthCode("");
		setSessionId("");
		setNewAccount({ name: "", mode: "max", tier: 1 });
		onCancel();
	};

	return (
		<div className="space-y-4 mb-6 p-4 border rounded-lg">
			<h4 className="font-medium">
				{authStep === "form" ? "Add New Account" : "Enter Authorization Code"}
			</h4>
			{authStep === "form" && (
				<>
					<div className="space-y-2">
						<Label htmlFor="name">Account Name</Label>
						<Input
							id="name"
							value={newAccount.name}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
								setNewAccount({
									...newAccount,
									name: (e.target as HTMLInputElement).value,
								})
							}
							placeholder="e.g., work-account or user@example.com"
						/>
					</div>
					<div className="space-y-2">
						<Label htmlFor="mode">Mode</Label>
						<Select
							value={newAccount.mode}
							onValueChange={(value: "max" | "console") =>
								setNewAccount({ ...newAccount, mode: value })
							}
						>
							<SelectTrigger id="mode">
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="max">Max (Recommended)</SelectItem>
								<SelectItem value="console">Console</SelectItem>
							</SelectContent>
						</Select>
					</div>
					<div className="space-y-2">
						<Label htmlFor="tier">Tier</Label>
						<Select
							value={String(newAccount.tier)}
							onValueChange={(value: string) =>
								setNewAccount({ ...newAccount, tier: parseInt(value) })
							}
						>
							<SelectTrigger id="tier">
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="1">Tier 1 (Default)</SelectItem>
								<SelectItem value="5">Tier 5</SelectItem>
								<SelectItem value="20">Tier 20</SelectItem>
							</SelectContent>
						</Select>
					</div>
				</>
			)}
			{authStep === "form" ? (
				<div className="flex gap-2">
					<Button onClick={handleAddAccount}>Continue</Button>
					<Button variant="outline" onClick={handleCancel}>
						Cancel
					</Button>
				</div>
			) : (
				<>
					<div className="space-y-2">
						<p className="text-sm text-muted-foreground">
							A new browser tab has opened for authentication. After
							authorizing, copy the code and paste it below.
						</p>
						<Label htmlFor="code">Authorization Code</Label>
						<Input
							id="code"
							value={authCode}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
								setAuthCode((e.target as HTMLInputElement).value)
							}
							placeholder="Paste authorization code here"
						/>
					</div>
					<div className="flex gap-2">
						<Button onClick={handleCodeSubmit}>Complete Setup</Button>
						<Button variant="outline" onClick={handleCancel}>
							Cancel
						</Button>
					</div>
				</>
			)}
		</div>
	);
}

================
File: packages/dashboard-web/src/components/accounts/AccountList.tsx
================
import type { Account } from "../../api";
import { AccountListItem } from "./AccountListItem";

interface AccountListProps {
	accounts: Account[] | undefined;
	onPauseToggle: (account: Account) => void;
	onRemove: (name: string) => void;
	onRename: (account: Account) => void;
}

export function AccountList({
	accounts,
	onPauseToggle,
	onRemove,
	onRename,
}: AccountListProps) {
	if (!accounts || accounts.length === 0) {
		return <p className="text-muted-foreground">No accounts configured</p>;
	}

	// Find the most recently used account
	const mostRecentAccountId = accounts.reduce(
		(mostRecent, account) => {
			if (!account.lastUsed) return mostRecent;
			if (!mostRecent) return account.id;

			const mostRecentAccount = accounts.find((a) => a.id === mostRecent);
			if (!mostRecentAccount?.lastUsed) return account.id;

			const mostRecentLastUsed = new Date(mostRecentAccount.lastUsed).getTime();
			const currentLastUsed = new Date(account.lastUsed).getTime();

			return currentLastUsed > mostRecentLastUsed ? account.id : mostRecent;
		},
		null as string | null,
	);

	return (
		<div className="space-y-2">
			{accounts.map((account) => (
				<AccountListItem
					key={account.name}
					account={account}
					isActive={account.id === mostRecentAccountId}
					onPauseToggle={onPauseToggle}
					onRemove={onRemove}
					onRename={onRename}
				/>
			))}
		</div>
	);
}

================
File: packages/dashboard-web/src/components/accounts/RateLimitProgress.tsx
================
import { useEffect, useState } from "react";
import { cn } from "../../lib/utils";
import { Progress } from "../ui/progress";

interface RateLimitProgressProps {
	resetIso: string | null;
	className?: string;
}

const WINDOW_MS = 5 * 60 * 60 * 1000; // 5 hours in milliseconds

export function RateLimitProgress({
	resetIso,
	className,
}: RateLimitProgressProps) {
	const [now, setNow] = useState(Date.now());

	useEffect(() => {
		const interval = setInterval(() => setNow(Date.now()), 10000); // Update every 10 seconds
		return () => clearInterval(interval);
	}, []);

	if (!resetIso) return null;

	const resetTime = new Date(resetIso).getTime();
	const startTime = resetTime - WINDOW_MS;
	const elapsed = now - startTime;
	const percentage = Math.min(100, Math.max(0, (elapsed / WINDOW_MS) * 100));
	const remainingMs = Math.max(0, resetTime - now);
	const remainingMinutes = Math.ceil(remainingMs / 60000);
	const remainingHours = Math.floor(remainingMinutes / 60);
	const remainingMins = remainingMinutes % 60;

	// Format time remaining
	let timeText = "";
	if (remainingMs <= 0) {
		timeText = "Ready to refresh";
	} else if (remainingHours > 0) {
		timeText = `${remainingHours}h ${remainingMins}m until refresh`;
	} else {
		timeText = `${remainingMinutes}m until refresh`;
	}

	return (
		<div className={cn("space-y-2", className)}>
			<div className="flex items-center justify-between">
				<span className="text-xs text-muted-foreground">Rate limit window</span>
				<span className="text-xs font-medium text-muted-foreground">
					{percentage.toFixed(0)}%
				</span>
			</div>
			<Progress value={percentage} className="h-2" />
			<div className="flex items-center justify-between">
				<span className="text-xs text-muted-foreground">{timeText}</span>
				{remainingMs > 0 && (
					<span className="text-xs text-muted-foreground">
						Resets at {new Date(resetTime).toLocaleTimeString()}
					</span>
				)}
			</div>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/accounts/AccountListItem.tsx
================
import { AccountPresenter } from "@ccflare/ui-common";
import {
	AlertCircle,
	CheckCircle,
	Edit2,
	Pause,
	Play,
	Trash2,
} from "lucide-react";
import type { Account } from "../../api";
import { Button } from "../ui/button";
import { RateLimitProgress } from "./RateLimitProgress";

interface AccountListItemProps {
	account: Account;
	isActive?: boolean;
	onPauseToggle: (account: Account) => void;
	onRemove: (name: string) => void;
	onRename: (account: Account) => void;
}

export function AccountListItem({
	account,
	isActive = false,
	onPauseToggle,
	onRemove,
	onRename,
}: AccountListItemProps) {
	const presenter = new AccountPresenter(account);

	return (
		<div
			key={account.name}
			className={`p-4 border rounded-lg transition-colors space-y-4 ${
				isActive
					? "border-primary bg-primary/5 shadow-sm"
					: "border-border hover:border-muted-foreground/50"
			}`}
		>
			<div className="flex items-center justify-between">
				<div className="flex items-center gap-4">
					<div>
						<div className="flex items-center gap-2">
							<p className="font-medium">{account.name}</p>
							{isActive && (
								<span className="px-2 py-0.5 text-xs font-medium bg-primary text-primary-foreground rounded-full">
									Active
								</span>
							)}
						</div>
						<p className="text-sm text-muted-foreground">
							{account.provider} â€¢ {presenter.tierDisplay}
						</p>
					</div>
					<div className="flex items-center gap-2">
						{presenter.isRateLimited ? (
							<AlertCircle className="h-4 w-4 text-yellow-600" />
						) : (
							<CheckCircle className="h-4 w-4 text-green-600" />
						)}
						<span className="text-sm">{presenter.requestCount} requests</span>
						{presenter.isPaused && (
							<span className="text-sm text-muted-foreground">Paused</span>
						)}
						{!presenter.isPaused && presenter.rateLimitStatus !== "OK" && (
							<span className="text-sm text-destructive">
								{presenter.rateLimitStatus}
							</span>
						)}
					</div>
				</div>
				<div className="flex items-center gap-2">
					<Button
						variant="ghost"
						size="sm"
						onClick={() => onRename(account)}
						title="Rename account"
					>
						<Edit2 className="h-4 w-4" />
					</Button>
					<Button
						variant="ghost"
						size="sm"
						onClick={() => onPauseToggle(account)}
						title={account.paused ? "Resume account" : "Pause account"}
					>
						{account.paused ? (
							<Play className="h-4 w-4" />
						) : (
							<Pause className="h-4 w-4" />
						)}
					</Button>
					<Button
						variant="ghost"
						size="sm"
						onClick={() => onRemove(account.name)}
					>
						<Trash2 className="h-4 w-4" />
					</Button>
				</div>
			</div>
			{account.rateLimitReset && (
				<RateLimitProgress resetIso={account.rateLimitReset} />
			)}
		</div>
	);
}

================
File: packages/dashboard-web/src/components/accounts/DeleteConfirmationDialog.tsx
================
import { AlertCircle } from "lucide-react";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Input } from "../ui/input";
import { Label } from "../ui/label";

interface DeleteConfirmationDialogProps {
	accountName: string;
	confirmInput: string;
	onConfirmInputChange: (value: string) => void;
	onConfirm: () => void;
	onCancel: () => void;
}

export function DeleteConfirmationDialog({
	accountName,
	confirmInput,
	onConfirmInputChange,
	onConfirm,
	onCancel,
}: DeleteConfirmationDialogProps) {
	return (
		<div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
			<Card className="w-full max-w-md">
				<CardHeader>
					<CardTitle>Confirm Account Removal</CardTitle>
					<CardDescription>This action cannot be undone.</CardDescription>
				</CardHeader>
				<CardContent className="space-y-4">
					<div className="p-4 bg-destructive/10 border border-destructive/20 rounded-lg">
						<div className="flex items-center gap-2 text-destructive">
							<AlertCircle className="h-5 w-5" />
							<p className="font-medium">Warning</p>
						</div>
						<p className="text-sm mt-2">
							You are about to permanently remove the account '{accountName}'.
							This will delete all associated data and cannot be recovered.
						</p>
					</div>
					<div className="space-y-2">
						<Label htmlFor="confirm-input">
							Type{" "}
							<span className="font-mono font-semibold">{accountName}</span> to
							confirm:
						</Label>
						<Input
							id="confirm-input"
							value={confirmInput}
							onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
								onConfirmInputChange((e.target as HTMLInputElement).value)
							}
							placeholder="Enter account name"
							autoComplete="off"
						/>
					</div>
					<div className="flex gap-2">
						<Button
							variant="destructive"
							onClick={onConfirm}
							disabled={confirmInput !== accountName}
						>
							Delete Account
						</Button>
						<Button variant="outline" onClick={onCancel}>
							Cancel
						</Button>
					</div>
				</CardContent>
			</Card>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/accounts/index.ts
================
export { AccountAddForm } from "./AccountAddForm";
export { AccountList } from "./AccountList";
export { AccountListItem } from "./AccountListItem";
export { DeleteConfirmationDialog } from "./DeleteConfirmationDialog";
export { RateLimitProgress } from "./RateLimitProgress";
export { RenameAccountDialog } from "./RenameAccountDialog";

================
File: packages/dashboard-web/src/components/accounts/RenameAccountDialog.tsx
================
import { useState } from "react";
import { Button } from "../ui/button";
import {
	Dialog,
	DialogContent,
	DialogDescription,
	DialogFooter,
	DialogHeader,
	DialogTitle,
} from "../ui/dialog";
import { Input } from "../ui/input";
import { Label } from "../ui/label";

interface RenameAccountDialogProps {
	isOpen: boolean;
	currentName: string;
	onClose: () => void;
	onRename: (newName: string) => void;
	isLoading?: boolean;
}

export function RenameAccountDialog({
	isOpen,
	currentName,
	onClose,
	onRename,
	isLoading = false,
}: RenameAccountDialogProps) {
	const [newName, setNewName] = useState(currentName);
	const [error, setError] = useState("");

	const handleSubmit = (e: React.FormEvent) => {
		e.preventDefault();

		// Validate new name
		const trimmedName = newName.trim();
		if (!trimmedName) {
			setError("Account name cannot be empty");
			return;
		}
		if (trimmedName === currentName) {
			setError("New name must be different from current name");
			return;
		}
		if (trimmedName.length > 100) {
			setError("Account name must be 100 characters or less");
			return;
		}

		setError("");
		onRename(trimmedName);
	};

	const handleOpenChange = (open: boolean) => {
		if (!open) {
			setNewName(currentName);
			setError("");
			onClose();
		}
	};

	return (
		<Dialog open={isOpen} onOpenChange={handleOpenChange}>
			<DialogContent>
				<form onSubmit={handleSubmit}>
					<DialogHeader>
						<DialogTitle>Rename Account</DialogTitle>
						<DialogDescription>
							Enter a new name for account "{currentName}"
						</DialogDescription>
					</DialogHeader>
					<div className="grid gap-4 py-4">
						<div className="grid gap-2">
							<Label htmlFor="new-name">New Name</Label>
							<Input
								id="new-name"
								value={newName}
								onChange={(e) => {
									setNewName(e.target.value);
									setError("");
								}}
								placeholder="Enter new account name"
								autoFocus
								disabled={isLoading}
							/>
							{error && <p className="text-sm text-destructive">{error}</p>}
						</div>
					</div>
					<DialogFooter>
						<Button
							type="button"
							variant="outline"
							onClick={() => handleOpenChange(false)}
							disabled={isLoading}
						>
							Cancel
						</Button>
						<Button type="submit" disabled={isLoading}>
							{isLoading ? "Renaming..." : "Rename"}
						</Button>
					</DialogFooter>
				</form>
			</DialogContent>
		</Dialog>
	);
}

================
File: packages/dashboard-web/src/components/overview/MetricCard.tsx
================
import { formatPercentage } from "@ccflare/ui-common";
import { Info, TrendingDown, TrendingUp } from "lucide-react";
import { Card, CardContent } from "../ui/card";
import { Popover, PopoverContent, PopoverTrigger } from "../ui/popover";

export interface MetricCardProps {
	title: string;
	value: string | number;
	change?: number;
	icon: React.ComponentType<{ className?: string }>;
	trend?: "up" | "down" | "flat";
	trendPeriod?: string;
}

export function MetricCard({
	title,
	value,
	change,
	icon: Icon,
	trend,
	trendPeriod,
}: MetricCardProps) {
	const trendElement = trend !== "flat" && change !== undefined && (
		<div
			className={`flex items-center gap-1 text-sm font-medium ${
				trend === "up" ? "text-success" : "text-destructive"
			}`}
		>
			{trend === "up" ? (
				<TrendingUp className="h-4 w-4" />
			) : (
				<TrendingDown className="h-4 w-4" />
			)}
			<span>{formatPercentage(Math.abs(change), 0)}</span>
		</div>
	);

	return (
		<Card>
			<CardContent className="p-6">
				<div className="flex items-center justify-between mb-4">
					<Icon className="h-8 w-8 text-muted-foreground/20" />
					{trendPeriod && trendElement ? (
						<Popover>
							<PopoverTrigger asChild>
								<div className="flex items-center gap-1 cursor-help">
									{trendElement}
									<Info className="h-3 w-3 text-muted-foreground" />
								</div>
							</PopoverTrigger>
							<PopoverContent className="w-auto p-2 text-xs">
								<p>Compared to {trendPeriod}</p>
							</PopoverContent>
						</Popover>
					) : (
						trendElement
					)}
				</div>
				<div className="space-y-1">
					<p className="text-sm text-muted-foreground">{title}</p>
					<p className="text-2xl font-bold">{value}</p>
				</div>
			</CardContent>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/overview/RateLimitInfo.tsx
================
import type { AccountResponse } from "@ccflare/types";
import { format } from "date-fns";
import { AlertCircle } from "lucide-react";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";

interface RateLimitInfoProps {
	accounts: AccountResponse[];
}

export function RateLimitInfo({ accounts }: RateLimitInfoProps) {
	const rateLimitedAccounts = accounts.filter((acc) => {
		const status = acc.rateLimitStatus.toLowerCase();
		return (
			status !== "ok" && status !== "paused" && !status.startsWith("allowed")
		);
	});

	if (rateLimitedAccounts.length === 0) {
		return null;
	}

	return (
		<Card>
			<CardHeader>
				<CardTitle>Rate Limit Info</CardTitle>
				<CardDescription>Rate limit information about accounts</CardDescription>
			</CardHeader>
			<CardContent>
				<div className="space-y-3">
					{rateLimitedAccounts.map((account) => {
						const resetTime = account.rateLimitReset
							? new Date(account.rateLimitReset)
							: null;
						const now = new Date();
						const timeUntilReset = resetTime
							? Math.max(0, resetTime.getTime() - now.getTime())
							: null;
						const minutesLeft = timeUntilReset
							? Math.ceil(timeUntilReset / 60000)
							: null;

						const statusLower = account.rateLimitStatus.toLowerCase();
						const isHardLimit =
							statusLower.includes("hard") ||
							(statusLower.includes("limit") &&
								!statusLower.includes("warning"));
						const bgClass = isHardLimit ? "bg-destructive/10" : "bg-warning/10";
						const iconColor = isHardLimit ? "text-destructive" : "text-warning";

						return (
							<div
								key={account.id}
								className={`flex items-center justify-between p-4 rounded-lg ${bgClass}`}
							>
								<div className="flex items-center gap-3">
									<AlertCircle className={`h-5 w-5 ${iconColor}`} />
									<div>
										<p className="font-medium">{account.name}</p>
										<p className="text-sm text-muted-foreground">
											{account.rateLimitStatus}
											{account.rateLimitRemaining !== null &&
												` â€¢ ${account.rateLimitRemaining} requests remaining`}
										</p>
									</div>
								</div>
								<div className="text-right">
									{resetTime && (
										<>
											<p className="text-sm font-medium">
												Resets in {minutesLeft}m
											</p>
											<p className="text-xs text-muted-foreground">
												{format(resetTime, "HH:mm:ss")}
											</p>
										</>
									)}
								</div>
							</div>
						);
					})}
				</div>
			</CardContent>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/overview/TimeRangeSelector.tsx
================
import { Clock } from "lucide-react";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";

interface TimeRangeSelectorProps {
	value: string;
	onChange: (value: string) => void;
}

const TIME_RANGES = [
	{ value: "1h", label: "Last hour" },
	{ value: "6h", label: "Last 6 hours" },
	{ value: "24h", label: "Last 24 hours" },
	{ value: "7d", label: "Last 7 days" },
	{ value: "30d", label: "Last 30 days" },
];

export function TimeRangeSelector({ value, onChange }: TimeRangeSelectorProps) {
	return (
		<div className="flex items-center gap-2">
			<Clock className="h-4 w-4 text-muted-foreground" />
			<Select value={value} onValueChange={onChange}>
				<SelectTrigger className="w-[150px]">
					<SelectValue />
				</SelectTrigger>
				<SelectContent>
					{TIME_RANGES.map((range) => (
						<SelectItem key={range.value} value={range.value}>
							{range.label}
						</SelectItem>
					))}
				</SelectContent>
			</Select>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/overview/LoadingSkeleton.tsx
================
import { Card, CardContent, CardHeader } from "../ui/card";
import { Skeleton } from "../ui/skeleton";

export function LoadingSkeleton() {
	return (
		<div className="space-y-6">
			<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
				{[...Array(4)].map((_, i) => (
					// biome-ignore lint/suspicious/noArrayIndexKey: Skeleton cards are temporary placeholders
					<Card key={i}>
						<CardContent className="p-6">
							<Skeleton className="h-4 w-24 mb-2" />
							<Skeleton className="h-8 w-32 mb-2" />
							<Skeleton className="h-4 w-20" />
						</CardContent>
					</Card>
				))}
			</div>
			<Card>
				<CardHeader>
					<Skeleton className="h-6 w-32" />
				</CardHeader>
				<CardContent>
					<Skeleton className="h-64 w-full" />
				</CardContent>
			</Card>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/overview/SystemStatus.tsx
================
import { CheckCircle, XCircle } from "lucide-react";
import { Badge } from "../ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";

interface SystemStatusProps {
	recentErrors?: string[];
}

export function SystemStatus({ recentErrors }: SystemStatusProps) {
	return (
		<Card>
			<CardHeader>
				<CardTitle>System Status</CardTitle>
				<CardDescription>
					Current operational status and recent events
				</CardDescription>
			</CardHeader>
			<CardContent>
				<div className="space-y-4">
					<div className="flex items-center justify-between p-4 rounded-lg bg-success/10">
						<div className="flex items-center gap-3">
							<CheckCircle className="h-5 w-5 text-success" />
							<div>
								<p className="font-medium">All Systems Operational</p>
								<p className="text-sm text-muted-foreground">
									No issues detected
								</p>
							</div>
						</div>
						<Badge variant="default" className="bg-success">
							Healthy
						</Badge>
					</div>

					{recentErrors && recentErrors.length > 0 && (
						<div className="space-y-2">
							<h4 className="text-sm font-medium text-muted-foreground">
								Recent Errors
							</h4>
							{recentErrors.slice(0, 3).map((error, i) => (
								<div
									key={`error-${error.substring(0, 20)}-${i}`}
									className="flex items-start gap-2 p-3 rounded-lg bg-destructive/10"
								>
									<XCircle className="h-4 w-4 text-destructive mt-0.5" />
									<p className="text-sm text-muted-foreground">{error}</p>
								</div>
							))}
						</div>
					)}
				</div>
			</CardContent>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/overview/ChartsSection.tsx
================
import { CHART_COLORS, COLORS } from "../../constants";
import {
	BaseAreaChart,
	BaseBarChart,
	BaseLineChart,
	BasePieChart,
} from "../charts";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";

interface ChartsSectionProps {
	timeSeriesData: Array<{
		time: string;
		requests: number;
		successRate: number;
		responseTime: number;
		cost: string;
	}>;
	modelData: Array<{ name: string; value: number }>;
	accountHealthData: Array<{
		name: string;
		requests: number;
		successRate: number;
	}>;
	loading: boolean;
}

export function ChartsSection({
	timeSeriesData,
	modelData,
	accountHealthData,
	loading,
}: ChartsSectionProps) {
	return (
		<>
			{/* Charts Row 1 */}
			<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
				{/* Request Volume Chart */}
				<Card>
					<CardHeader>
						<CardTitle>Request Volume</CardTitle>
						<CardDescription>
							Requests per hour over the last 24 hours
						</CardDescription>
					</CardHeader>
					<CardContent>
						<BaseAreaChart
							data={timeSeriesData}
							dataKey="requests"
							loading={loading}
							height="medium"
						/>
					</CardContent>
				</Card>

				{/* Success Rate Chart */}
				<Card>
					<CardHeader>
						<CardTitle>Success Rate Trend</CardTitle>
						<CardDescription>Success percentage over time</CardDescription>
					</CardHeader>
					<CardContent>
						<BaseLineChart
							data={timeSeriesData}
							lines={{ dataKey: "successRate", stroke: COLORS.success }}
							loading={loading}
							height="medium"
							yAxisDomain={[80, 100]}
						/>
					</CardContent>
				</Card>
			</div>

			{/* Charts Row 2 */}
			<div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
				{/* Model Distribution */}
				<Card>
					<CardHeader>
						<CardTitle>Model Usage</CardTitle>
						<CardDescription>
							Distribution of API calls by model
						</CardDescription>
					</CardHeader>
					<CardContent>
						<BasePieChart
							data={modelData}
							loading={loading}
							height="small"
							innerRadius={60}
							outerRadius={80}
							paddingAngle={5}
							tooltipStyle="success"
						/>
						<div className="mt-4 space-y-2">
							{modelData.map((model, index) => (
								<div
									key={model.name}
									className="flex items-center justify-between text-sm"
								>
									<div className="flex items-center gap-2">
										<div
											className="h-3 w-3 rounded-full"
											style={{
												backgroundColor:
													CHART_COLORS[index % CHART_COLORS.length],
											}}
										/>
										<span className="text-muted-foreground">{model.name}</span>
									</div>
									<span className="font-medium">{model.value}</span>
								</div>
							))}
						</div>
					</CardContent>
				</Card>

				{/* Account Health */}
				<Card className="lg:col-span-2">
					<CardHeader>
						<CardTitle>Account Performance</CardTitle>
						<CardDescription>
							Request distribution and success rates by account
						</CardDescription>
					</CardHeader>
					<CardContent>
						<BaseBarChart
							data={accountHealthData}
							bars={[
								{ dataKey: "requests", yAxisId: "left", name: "Requests" },
								{
									dataKey: "successRate",
									yAxisId: "right",
									fill: COLORS.success,
									name: "Success %",
								},
							]}
							xAxisKey="name"
							loading={loading}
							height="small"
							secondaryYAxis={true}
							showLegend={true}
						/>
					</CardContent>
				</Card>
			</div>
		</>
	);
}

================
File: packages/dashboard-web/src/components/overview/DataRetentionCard.tsx
================
import { useEffect, useState } from "react";
import {
	useCleanupNow,
	useCompactDb,
	useRetention,
	useSetRetention,
} from "../../hooks/queries";
import { Button } from "../ui/button";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Input } from "../ui/input";

export function DataRetentionCard() {
	const { data, isLoading } = useRetention();
	const setRetention = useSetRetention();
	const cleanupNow = useCleanupNow();
	const compactDb = useCompactDb();
	const [payloadDays, setPayloadDays] = useState<number>(
		data?.payloadDays ?? 7,
	);
	const [requestDays, setRequestDays] = useState<number>(
		data?.requestDays ?? 365,
	);

	useEffect(() => {
		if (typeof data?.payloadDays === "number") setPayloadDays(data.payloadDays);
		if (typeof data?.requestDays === "number") setRequestDays(data.requestDays);
	}, [data?.payloadDays, data?.requestDays]);

	const disabled = isLoading || setRetention.isPending;
	const validPayload =
		Number.isFinite(payloadDays) && payloadDays >= 1 && payloadDays <= 365;
	const validRequests =
		Number.isFinite(requestDays) && requestDays >= 1 && requestDays <= 3650;

	return (
		<Card className="card-hover">
			<CardHeader>
				<CardTitle>Payload Retention</CardTitle>
				<CardDescription>
					Automatically delete request/response payloads older than this window.
					Analytics remain intact.
				</CardDescription>
			</CardHeader>
			<CardContent className="space-y-3">
				<div className="flex items-center gap-2">
					<div className="flex items-center gap-2">
						<span className="text-sm font-medium w-28">Payloads</span>
						<Input
							type="number"
							min={1}
							max={365}
							value={payloadDays}
							onChange={(e) =>
								setPayloadDays(parseInt(e.target.value || "0", 10))
							}
							className="w-24"
						/>
						<span className="text-sm text-muted-foreground">days</span>
					</div>
					<Button
						size="sm"
						disabled={disabled || !validPayload}
						onClick={() => setRetention.mutate({ payloadDays })}
					>
						Save
					</Button>
				</div>

				<div className="flex items-center gap-2">
					{[7, 14, 30, 90].map((d) => (
						<Button
							key={d}
							variant="outline"
							size="sm"
							onClick={() => setPayloadDays(d)}
						>
							{d}d
						</Button>
					))}
				</div>

				<div className="flex items-center gap-2 pt-2">
					<div className="flex items-center gap-2">
						<span className="text-sm font-medium w-28">Requests</span>
						<Input
							type="number"
							min={1}
							max={3650}
							value={requestDays}
							onChange={(e) =>
								setRequestDays(parseInt(e.target.value || "0", 10))
							}
							className="w-24"
						/>
						<span className="text-sm text-muted-foreground">days</span>
					</div>
					<Button
						size="sm"
						disabled={disabled || !validRequests}
						onClick={() => setRetention.mutate({ requestDays })}
					>
						Save
					</Button>
				</div>

				<div className="pt-2">
					<Button
						variant="secondary"
						size="sm"
						onClick={() => cleanupNow.mutate()}
						disabled={cleanupNow.isPending}
					>
						Clean up now
					</Button>
					<Button
						variant="outline"
						size="sm"
						className="ml-2"
						onClick={() => compactDb.mutate()}
						disabled={compactDb.isPending}
					>
						Compact database
					</Button>
				</div>

				{cleanupNow.data && (
					<p className="text-xs text-muted-foreground">
						Removed {cleanupNow.data.removedRequests} requests and{" "}
						{cleanupNow.data.removedPayloads} payloads older than{" "}
						{new Date(cleanupNow.data.cutoffIso).toLocaleString()}.
					</p>
				)}

				{compactDb.isSuccess && (
					<p className="text-xs text-muted-foreground">
						Database compacted. File size should reduce on disk.
					</p>
				)}
			</CardContent>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/analytics/AnalyticsControls.tsx
================
import { CalendarDays, RefreshCw } from "lucide-react";
import type { TimeRange } from "../../constants";
import { Button } from "../ui/button";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { AnalyticsFilters, type FilterState } from "./AnalyticsFilters";

interface AnalyticsControlsProps {
	timeRange: TimeRange;
	setTimeRange: (range: TimeRange) => void;
	viewMode: "normal" | "cumulative";
	setViewMode: (mode: "normal" | "cumulative") => void;
	filters: FilterState;
	setFilters: (filters: FilterState) => void;
	availableAccounts: string[];
	availableModels: string[];
	activeFilterCount: number;
	filterOpen: boolean;
	setFilterOpen: (open: boolean) => void;
	loading: boolean;
	onRefresh: () => void;
}

export function AnalyticsControls({
	timeRange,
	setTimeRange,
	viewMode,
	setViewMode,
	filters,
	setFilters,
	availableAccounts,
	availableModels,
	activeFilterCount,
	filterOpen,
	setFilterOpen,
	loading,
	onRefresh,
}: AnalyticsControlsProps) {
	return (
		<div className="flex flex-col sm:flex-row gap-4 justify-between">
			<div className="flex flex-wrap gap-2">
				<Select
					value={timeRange}
					onValueChange={(v) => setTimeRange(v as TimeRange)}
				>
					<SelectTrigger className="w-32">
						<CalendarDays className="h-4 w-4 mr-2" />
						<SelectValue />
					</SelectTrigger>
					<SelectContent>
						<SelectItem value="1h">Last Hour</SelectItem>
						<SelectItem value="6h">Last 6 Hours</SelectItem>
						<SelectItem value="24h">Last 24 Hours</SelectItem>
						<SelectItem value="7d">Last 7 Days</SelectItem>
						<SelectItem value="30d">Last 30 Days</SelectItem>
					</SelectContent>
				</Select>

				<AnalyticsFilters
					filters={filters}
					setFilters={setFilters}
					availableAccounts={availableAccounts}
					availableModels={availableModels}
					activeFilterCount={activeFilterCount}
					filterOpen={filterOpen}
					setFilterOpen={setFilterOpen}
				/>
			</div>

			<div className="flex gap-2">
				<div className="flex gap-1 bg-muted rounded-md p-1">
					<Button
						variant={viewMode === "normal" ? "default" : "ghost"}
						size="sm"
						className="h-8 px-3"
						onClick={() => setViewMode("normal")}
					>
						Normal
					</Button>
					<Button
						variant={viewMode === "cumulative" ? "default" : "ghost"}
						size="sm"
						className="h-8 px-3"
						onClick={() => setViewMode("cumulative")}
					>
						Cumulative
					</Button>
				</div>
				<Button
					variant="outline"
					size="sm"
					onClick={onRefresh}
					disabled={loading}
				>
					<RefreshCw
						className={`h-4 w-4 mr-2 ${loading ? "animate-spin" : ""}`}
					/>
					Refresh
				</Button>
			</div>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/analytics/ModelAnalytics.tsx
================
import { Activity, BarChart3, TrendingUp, Zap } from "lucide-react";
import { useState } from "react";
import type { TimeRange } from "../../constants";
import { ModelPerformanceComparison, ModelTokenSpeedChart } from "../charts";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../ui/tabs";

interface ModelAnalyticsProps {
	modelPerformance: Array<{
		model: string;
		avgResponseTime: number;
		p95ResponseTime: number;
		errorRate: number;
		avgTokensPerSecond: number | null;
		minTokensPerSecond: number | null;
		maxTokensPerSecond: number | null;
	}>;
	costByModel: Array<{
		model: string;
		costUsd: number;
		requests: number;
		totalTokens?: number;
	}>;
	loading?: boolean;
	timeRange: TimeRange;
}

export function ModelAnalytics({
	modelPerformance,
	costByModel,
	loading = false,
}: ModelAnalyticsProps) {
	const [comparisonView, setComparisonView] = useState<
		"speed-cost" | "performance" | "efficiency"
	>("speed-cost");

	// Prepare data for the comparison chart
	const comparisonData = modelPerformance.map((perf) => {
		const costData = costByModel.find((c) => c.model === perf.model);
		const totalCost = costData?.costUsd || 0;
		const totalRequests = costData?.requests || 1;
		const totalTokens = costData?.totalTokens || 0;

		// Calculate cost per 1k tokens
		let costPer1kTokens: number;
		if (totalTokens > 0) {
			// Use actual token count for accurate calculation
			costPer1kTokens = (totalCost / totalTokens) * 1000;
		} else {
			// Fallback: estimate based on average cost per request
			const avgCostPerRequest = totalCost / totalRequests;
			const _estimatedTokensPerRequest = 1000; // Rough estimate
			costPer1kTokens = avgCostPerRequest;
		}

		return {
			model: perf.model,
			avgTokensPerSecond: perf.avgTokensPerSecond,
			costPer1kTokens,
			avgResponseTime: perf.avgResponseTime,
			errorRate: perf.errorRate,
			totalRequests,
		};
	});

	return (
		<div className="space-y-6">
			{/* Header with title and controls */}
			<div className="flex items-center justify-between">
				<div>
					<h3 className="text-lg font-semibold">Model Performance Analytics</h3>
					<p className="text-sm text-muted-foreground">
						Comprehensive analysis of model performance, cost, and efficiency
					</p>
				</div>
			</div>

			{/* Tabbed interface for different views */}
			<Tabs defaultValue="comparison" className="space-y-4">
				<TabsList className="grid w-full grid-cols-2">
					<TabsTrigger value="comparison" className="flex items-center gap-2">
						<TrendingUp className="h-4 w-4" />
						Multi-Metric Comparison
					</TabsTrigger>
					<TabsTrigger value="detailed" className="flex items-center gap-2">
						<BarChart3 className="h-4 w-4" />
						Detailed Analysis
					</TabsTrigger>
				</TabsList>

				{/* Multi-Metric Comparison Tab */}
				<TabsContent value="comparison" className="space-y-4">
					<Card className="bg-gradient-to-br from-background to-muted/10 border-muted">
						<CardHeader>
							<div className="flex items-center justify-between">
								<div className="space-y-1">
									<CardTitle className="text-2xl font-bold flex items-center gap-2">
										<Zap className="h-6 w-6 text-purple-500" />
										Model Performance Comparison
									</CardTitle>
									<CardDescription>
										{comparisonView === "speed-cost"
											? "Token generation speed vs. cost efficiency"
											: comparisonView === "performance"
												? "Response time and error rate analysis"
												: "Overall efficiency score (speed/cost ratio)"}
									</CardDescription>
								</div>
								<Select
									value={comparisonView}
									onValueChange={(v) =>
										setComparisonView(
											v as "speed-cost" | "performance" | "efficiency",
										)
									}
								>
									<SelectTrigger className="w-48">
										<SelectValue />
									</SelectTrigger>
									<SelectContent>
										<SelectItem value="speed-cost">
											<div className="flex items-center gap-2">
												<Zap className="h-4 w-4" />
												Speed vs Cost
											</div>
										</SelectItem>
										<SelectItem value="performance">
											<div className="flex items-center gap-2">
												<Activity className="h-4 w-4" />
												Performance Metrics
											</div>
										</SelectItem>
										<SelectItem value="efficiency">
											<div className="flex items-center gap-2">
												<TrendingUp className="h-4 w-4" />
												Efficiency Score
											</div>
										</SelectItem>
									</SelectContent>
								</Select>
							</div>
						</CardHeader>
						<CardContent>
							<ModelPerformanceComparison
								data={comparisonData}
								loading={loading}
								height={400}
								viewMode={comparisonView}
							/>
						</CardContent>
					</Card>
				</TabsContent>

				{/* Detailed Analysis Tab */}
				<TabsContent value="detailed" className="space-y-4">
					<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
						{/* Token Speed Chart */}
						<Card>
							<CardHeader>
								<CardTitle className="flex items-center gap-2">
									<Zap className="h-5 w-5" />
									Token Generation Speed
								</CardTitle>
								<CardDescription>
									Average, min, and max tokens per second by model
								</CardDescription>
							</CardHeader>
							<CardContent>
								<ModelTokenSpeedChart
									data={modelPerformance}
									loading={loading}
									height={350}
								/>
							</CardContent>
						</Card>

						{/* Model Stats Cards */}
						<div className="space-y-4">
							{/* Fastest Model Card */}
							<Card>
								<CardHeader className="pb-3">
									<CardTitle className="text-sm font-medium">
										Fastest Model
									</CardTitle>
								</CardHeader>
								<CardContent>
									{(() => {
										const fastest = modelPerformance
											.filter((m) => m.avgTokensPerSecond !== null)
											.sort(
												(a, b) =>
													(b.avgTokensPerSecond || 0) -
													(a.avgTokensPerSecond || 0),
											)[0];
										return fastest ? (
											<div className="space-y-2">
												<p className="text-2xl font-bold">{fastest.model}</p>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">Speed:</span>
													<span className="font-medium">
														{fastest.avgTokensPerSecond?.toFixed(1)} tok/s
													</span>
												</div>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														Response:
													</span>
													<span className="font-medium">
														{fastest.avgResponseTime.toFixed(0)}ms
													</span>
												</div>
											</div>
										) : (
											<p className="text-muted-foreground">No data</p>
										);
									})()}
								</CardContent>
							</Card>

							{/* Most Reliable Model Card */}
							<Card>
								<CardHeader className="pb-3">
									<CardTitle className="text-sm font-medium">
										Most Reliable Model
									</CardTitle>
								</CardHeader>
								<CardContent>
									{(() => {
										const reliable = modelPerformance.sort(
											(a, b) => a.errorRate - b.errorRate,
										)[0];
										return reliable ? (
											<div className="space-y-2">
												<p className="text-2xl font-bold">{reliable.model}</p>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														Error Rate:
													</span>
													<span className="font-medium text-green-600">
														{reliable.errorRate.toFixed(2)}%
													</span>
												</div>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														p95 Response:
													</span>
													<span className="font-medium">
														{reliable.p95ResponseTime.toFixed(0)}ms
													</span>
												</div>
											</div>
										) : (
											<p className="text-muted-foreground">No data</p>
										);
									})()}
								</CardContent>
							</Card>

							{/* Most Cost-Effective Model Card */}
							<Card>
								<CardHeader className="pb-3">
									<CardTitle className="text-sm font-medium">
										Most Cost-Effective
									</CardTitle>
								</CardHeader>
								<CardContent>
									{(() => {
										const costEffective = comparisonData
											.filter(
												(m) =>
													m.avgTokensPerSecond !== null &&
													m.costPer1kTokens > 0,
											)
											.sort((a, b) => {
												const efficiencyA =
													(a.avgTokensPerSecond || 0) / a.costPer1kTokens;
												const efficiencyB =
													(b.avgTokensPerSecond || 0) / b.costPer1kTokens;
												return efficiencyB - efficiencyA;
											})[0];
										return costEffective ? (
											<div className="space-y-2">
												<p className="text-2xl font-bold">
													{costEffective.model}
												</p>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														Efficiency:
													</span>
													<span className="font-medium">
														{(
															(costEffective.avgTokensPerSecond || 0) /
															costEffective.costPer1kTokens
														).toFixed(2)}{" "}
														tok/s/$
													</span>
												</div>
												<div className="flex items-center gap-4 text-sm">
													<span className="text-muted-foreground">
														Cost/1K:
													</span>
													<span className="font-medium">
														${costEffective.costPer1kTokens.toFixed(3)}
													</span>
												</div>
											</div>
										) : (
											<p className="text-muted-foreground">No data</p>
										);
									})()}
								</CardContent>
							</Card>
						</div>
					</div>
				</TabsContent>
			</Tabs>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/analytics/TokenSpeedAnalytics.tsx
================
import { formatTokensPerSecond } from "@ccflare/ui-common";
import { Activity, Zap } from "lucide-react";
import type { TimeRange } from "../../constants";
import { ModelTokenSpeedChart } from "../charts/ModelTokenSpeedChart";
import { TokenSpeedChart } from "../charts/TokenSpeedChart";
import { Card, CardContent, CardHeader, CardTitle } from "../ui/card";

interface TokenSpeedAnalyticsProps {
	timeSeriesData: Array<{
		time: string;
		avgTokensPerSecond: number;
		[key: string]: string | number;
	}>;
	modelPerformance: Array<{
		model: string;
		avgTokensPerSecond: number | null;
		minTokensPerSecond: number | null;
		maxTokensPerSecond: number | null;
	}>;
	loading?: boolean;
	timeRange: TimeRange;
}

export function TokenSpeedAnalytics({
	timeSeriesData,
	modelPerformance,
	loading = false,
	timeRange,
}: TokenSpeedAnalyticsProps) {
	// Calculate overall statistics
	const validSpeeds = timeSeriesData
		.map((d) => d.avgTokensPerSecond)
		.filter((speed) => speed > 0);

	const overallAvgSpeed =
		validSpeeds.length > 0
			? validSpeeds.reduce((sum, speed) => sum + speed, 0) / validSpeeds.length
			: 0;

	// Get the true maximum speed from model performance data
	const maxSpeed = Math.max(
		...modelPerformance
			.map((m) => m.maxTokensPerSecond || 0)
			.filter((speed) => speed > 0),
		0,
	);

	// Find fastest model by peak speed
	const fastestModel = modelPerformance
		.filter((m) => m.maxTokensPerSecond !== null && m.maxTokensPerSecond > 0)
		.sort(
			(a, b) => (b.maxTokensPerSecond || 0) - (a.maxTokensPerSecond || 0),
		)[0];

	return (
		<div className="space-y-6">
			{/* Statistics Cards */}
			<div className="grid grid-cols-1 md:grid-cols-3 gap-4">
				<Card>
					<CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
						<CardTitle className="text-sm font-medium">
							Average Output Speed
						</CardTitle>
						<Activity className="h-4 w-4 text-muted-foreground" />
					</CardHeader>
					<CardContent>
						<div className="text-2xl font-bold">
							{formatTokensPerSecond(overallAvgSpeed)}
						</div>
						<p className="text-xs text-muted-foreground">
							Across all models and requests
						</p>
					</CardContent>
				</Card>

				<Card>
					<CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
						<CardTitle className="text-sm font-medium">Peak Speed</CardTitle>
						<Zap className="h-4 w-4 text-muted-foreground" />
					</CardHeader>
					<CardContent>
						<div className="text-2xl font-bold">
							{formatTokensPerSecond(maxSpeed)}
						</div>
						<p className="text-xs text-muted-foreground">
							Maximum observed in {timeRange}
						</p>
					</CardContent>
				</Card>

				<Card>
					<CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
						<CardTitle className="text-sm font-medium">Fastest Model</CardTitle>
						<Zap className="h-4 w-4 text-muted-foreground" />
					</CardHeader>
					<CardContent>
						<div className="text-2xl font-bold">
							{fastestModel?.model || "N/A"}
						</div>
						<p className="text-xs text-muted-foreground">
							{fastestModel
								? `Peak: ${formatTokensPerSecond(fastestModel.maxTokensPerSecond || 0)}`
								: "No data"}
						</p>
					</CardContent>
				</Card>
			</div>

			{/* Charts */}
			<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
				<Card>
					<CardHeader>
						<CardTitle className="flex items-center gap-2">
							<Activity className="h-5 w-5" />
							Output Speed Over Time
						</CardTitle>
					</CardHeader>
					<CardContent>
						<TokenSpeedChart
							data={timeSeriesData}
							loading={loading}
							height={300}
							timeRange={timeRange}
						/>
					</CardContent>
				</Card>

				<Card>
					<CardHeader>
						<CardTitle className="flex items-center gap-2">
							<Zap className="h-5 w-5" />
							Speed by Model
						</CardTitle>
					</CardHeader>
					<CardContent>
						<ModelTokenSpeedChart
							data={modelPerformance}
							loading={loading}
							height={300}
						/>
					</CardContent>
				</Card>
			</div>
		</div>
	);
}

================
File: packages/dashboard-web/src/components/analytics/index.ts
================
export {
	CumulativeGrowthChart,
	CumulativeTokenComposition,
	MainMetricsChart,
	ModelComparisonCharts,
	PerformanceIndicatorsChart,
	TokenUsageBreakdown,
} from "./AnalyticsCharts";
export { AnalyticsControls } from "./AnalyticsControls";
export { AnalyticsFilters, type FilterState } from "./AnalyticsFilters";
export { ModelAnalytics } from "./ModelAnalytics";
export { TokenSpeedAnalytics } from "./TokenSpeedAnalytics";

================
File: packages/dashboard-web/src/components/analytics/AnalyticsFilters.tsx
================
import { Filter } from "lucide-react";
import { Badge } from "../ui/badge";
import { Button } from "../ui/button";
import { Label } from "../ui/label";
import { Popover, PopoverContent, PopoverTrigger } from "../ui/popover";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Separator } from "../ui/separator";

export interface FilterState {
	accounts: string[];
	models: string[];
	status: "all" | "success" | "error";
}

interface AnalyticsFiltersProps {
	filters: FilterState;
	setFilters: (filters: FilterState) => void;
	availableAccounts: string[];
	availableModels: string[];
	activeFilterCount: number;
	filterOpen: boolean;
	setFilterOpen: (open: boolean) => void;
}

export function AnalyticsFilters({
	filters,
	setFilters,
	availableAccounts,
	availableModels,
	activeFilterCount,
	filterOpen,
	setFilterOpen,
}: AnalyticsFiltersProps) {
	return (
		<Popover open={filterOpen} onOpenChange={setFilterOpen}>
			<PopoverTrigger asChild>
				<Button variant="outline" size="sm">
					<Filter className="h-4 w-4 mr-2" />
					Filters
					{activeFilterCount > 0 && (
						<Badge variant="secondary" className="ml-2 h-5 px-1">
							{activeFilterCount}
						</Badge>
					)}
				</Button>
			</PopoverTrigger>
			<PopoverContent className="w-80" align="start">
				<div className="space-y-4">
					<div className="flex items-center justify-between">
						<h4 className="font-medium leading-none">Filters</h4>
						{activeFilterCount > 0 && (
							<Button
								variant="ghost"
								size="sm"
								onClick={() =>
									setFilters({ accounts: [], models: [], status: "all" })
								}
							>
								Clear all
							</Button>
						)}
					</div>

					<Separator />

					{/* Status Filter */}
					<div className="space-y-2">
						<Label>Status</Label>
						<Select
							value={filters.status}
							onValueChange={(value) =>
								setFilters({
									...filters,
									status: value as FilterState["status"],
								})
							}
						>
							<SelectTrigger>
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="all">All Requests</SelectItem>
								<SelectItem value="success">Success Only</SelectItem>
								<SelectItem value="error">Errors Only</SelectItem>
							</SelectContent>
						</Select>
					</div>

					{/* Account Filter */}
					{availableAccounts.length > 0 && (
						<div className="space-y-2">
							<Label>Accounts ({filters.accounts.length} selected)</Label>
							<div className="border rounded-md p-2 max-h-32 overflow-y-auto space-y-1">
								{availableAccounts.map((account) => (
									<label
										key={account}
										className="flex items-center space-x-2 cursor-pointer hover:bg-muted/50 p-1 rounded"
									>
										<input
											type="checkbox"
											className="rounded border-gray-300"
											checked={filters.accounts.includes(account)}
											onChange={(e) => {
												if (e.target.checked) {
													setFilters({
														...filters,
														accounts: [...filters.accounts, account],
													});
												} else {
													setFilters({
														...filters,
														accounts: filters.accounts.filter(
															(a) => a !== account,
														),
													});
												}
											}}
										/>
										<span className="text-sm">{account}</span>
									</label>
								))}
							</div>
						</div>
					)}

					{/* Model Filter */}
					{availableModels.length > 0 && (
						<div className="space-y-2">
							<Label>Models ({filters.models.length} selected)</Label>
							<div className="border rounded-md p-2 max-h-32 overflow-y-auto space-y-1">
								{availableModels.map((model) => (
									<label
										key={model}
										className="flex items-center space-x-2 cursor-pointer hover:bg-muted/50 p-1 rounded"
									>
										<input
											type="checkbox"
											className="rounded border-gray-300"
											checked={filters.models.includes(model)}
											onChange={(e) => {
												if (e.target.checked) {
													setFilters({
														...filters,
														models: [...filters.models, model],
													});
												} else {
													setFilters({
														...filters,
														models: filters.models.filter((m) => m !== model),
													});
												}
											}}
										/>
										<span className="text-sm truncate">{model}</span>
									</label>
								))}
							</div>
						</div>
					)}

					<Separator />

					<div className="flex justify-end">
						<Button size="sm" onClick={() => setFilterOpen(false)}>
							Done
						</Button>
					</div>
				</div>
			</PopoverContent>
		</Popover>
	);
}

================
File: packages/dashboard-web/src/components/analytics/AnalyticsCharts.tsx
================
import type { TimePoint } from "@ccflare/types";
import { formatCost, formatNumber, formatTokens } from "@ccflare/ui-common";
import { useState } from "react";
import {
	Area,
	AreaChart,
	CartesianGrid,
	Legend,
	ResponsiveContainer,
	Tooltip,
	XAxis,
	YAxis,
} from "recharts";
import {
	CHART_HEIGHTS,
	CHART_PROPS,
	COLORS,
	type TimeRange,
} from "../../constants";
import {
	formatCompactCurrency,
	formatCompactNumber,
} from "../../lib/chart-utils";
import {
	BaseAreaChart,
	BaseBarChart,
	BaseLineChart,
	CostChart,
	ModelPerformanceChart,
	MultiModelChart,
	RequestVolumeChart,
	ResponseTimeChart,
	TokenSpeedChart,
	TokenUsageChart,
} from "../charts";
import { Badge } from "../ui/badge";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "../ui/card";
import { Label } from "../ui/label";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "../ui/select";
import { Switch } from "../ui/switch";

interface ChartData {
	time: string;
	requests: number;
	tokens: number;
	cost: number;
	responseTime: number;
	errorRate: number;
	cacheHitRate: number;
	avgTokensPerSecond: number;
	[key: string]: string | number;
}

interface MainMetricsChartProps {
	data: ChartData[];
	rawTimeSeries?: TimePoint[];
	loading: boolean;
	viewMode: "normal" | "cumulative";
	timeRange: TimeRange;
	selectedMetric: string;
	setSelectedMetric: (metric: string) => void;
	modelBreakdown?: boolean;
	onModelBreakdownChange?: (enabled: boolean) => void;
}

export function MainMetricsChart({
	data,
	rawTimeSeries,
	loading,
	viewMode,
	timeRange,
	selectedMetric,
	setSelectedMetric,
	modelBreakdown = false,
	onModelBreakdownChange,
}: MainMetricsChartProps) {
	// Process data for multi-model chart if model breakdown is enabled (not in cumulative mode)
	const processedMultiModelData =
		rawTimeSeries && modelBreakdown && viewMode !== "cumulative"
			? (() => {
					// Group by timestamp and pivot models
					const grouped: Record<
						string,
						{ time: string; [model: string]: string | number }
					> = {};
					const models = new Set<string>();

					// First pass: collect all time points and models
					const timePoints = new Set<string>();
					const timeToTimestamp = new Map<string, number>();

					rawTimeSeries.forEach((point) => {
						if (point.model) {
							models.add(point.model);
							const time =
								timeRange === "30d"
									? new Date(point.ts).toLocaleDateString()
									: new Date(point.ts).toLocaleTimeString([], {
											hour: "2-digit",
											minute: "2-digit",
										});
							timePoints.add(time);
							timeToTimestamp.set(time, point.ts);
						}
					});

					// Sort time points chronologically using the original timestamps
					const sortedTimes = Array.from(timePoints).sort((a, b) => {
						const tsA = timeToTimestamp.get(a) || 0;
						const tsB = timeToTimestamp.get(b) || 0;
						return tsA - tsB;
					});

					// Initialize data structure
					const modelArrays = Array.from(models).sort();

					// Process time points in order
					sortedTimes.forEach((time) => {
						grouped[time] = { time };

						// Initialize all models for this time point
						modelArrays.forEach((model) => {
							// Default to 0 for missing data points
							grouped[time][model] = 0;
						});
					});

					// Fill in actual values
					rawTimeSeries.forEach((point) => {
						if (point.model) {
							const time =
								timeRange === "30d"
									? new Date(point.ts).toLocaleDateString()
									: new Date(point.ts).toLocaleTimeString([], {
											hour: "2-digit",
											minute: "2-digit",
										});

							// Map the metric value
							let value = 0;
							switch (selectedMetric) {
								case "requests":
									value = point.requests;
									break;
								case "tokens":
									value = point.tokens;
									break;
								case "cost":
									value = point.costUsd;
									break;
								case "responseTime":
									value = point.avgResponseTime;
									break;
								case "tokensPerSecond":
									value = point.avgTokensPerSecond || 0;
									break;
							}

							grouped[time][point.model] = value;
						}
					});

					// Sort and return the data
					const finalData = sortedTimes.map((time) => grouped[time]);

					return {
						data: finalData,
						models: modelArrays,
					};
				})()
			: null;

	return (
		<Card>
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle>Traffic Analytics</CardTitle>
						<CardDescription>
							{viewMode === "cumulative"
								? "Cumulative totals showing growth over time"
								: modelBreakdown
									? "Per-model breakdown over time"
									: "Request volume and performance metrics over time"}
						</CardDescription>
					</div>
					<div className="flex items-center gap-4">
						{viewMode !== "cumulative" && (
							<div className="flex items-center gap-2">
								<Switch
									id="model-breakdown"
									checked={modelBreakdown}
									onCheckedChange={onModelBreakdownChange}
								/>
								<Label htmlFor="model-breakdown" className="text-sm">
									Per Model
								</Label>
							</div>
						)}
						<Select value={selectedMetric} onValueChange={setSelectedMetric}>
							<SelectTrigger className="w-40">
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="requests">Requests</SelectItem>
								<SelectItem value="tokens">Token Usage</SelectItem>
								<SelectItem value="cost">Cost ($)</SelectItem>
								<SelectItem value="responseTime">Response Time</SelectItem>
								<SelectItem value="tokensPerSecond">Output Speed</SelectItem>
							</SelectContent>
						</Select>
					</div>
				</div>
			</CardHeader>
			<CardContent>
				{(() => {
					// Show multi-model chart if breakdown is enabled
					if (modelBreakdown && processedMultiModelData) {
						return (
							<MultiModelChart
								data={processedMultiModelData.data}
								models={processedMultiModelData.models}
								metric={
									selectedMetric as
										| "requests"
										| "tokens"
										| "cost"
										| "responseTime"
										| "tokensPerSecond"
								}
								loading={loading}
								height={CHART_HEIGHTS.large}
								viewMode={viewMode}
							/>
						);
					}

					// Otherwise show normal charts
					const commonProps = {
						data,
						loading,
						height: CHART_HEIGHTS.large,
						viewMode,
						timeRange,
					};

					switch (selectedMetric) {
						case "tokens":
							return <TokenUsageChart {...commonProps} />;
						case "cost":
							return <CostChart {...commonProps} />;
						case "requests":
							return <RequestVolumeChart {...commonProps} />;
						case "responseTime":
							return <ResponseTimeChart {...commonProps} />;
						case "tokensPerSecond":
							return <TokenSpeedChart {...commonProps} />;
						default:
							return (
								<BaseAreaChart
									data={data}
									dataKey={selectedMetric}
									loading={loading}
									height="large"
									color={
										viewMode === "cumulative" ? COLORS.purple : COLORS.primary
									}
									strokeWidth={viewMode === "cumulative" ? 3 : 2}
									xAxisAngle={
										timeRange === "7d" || timeRange === "30d" ? -45 : 0
									}
									xAxisTextAnchor={
										timeRange === "7d" || timeRange === "30d" ? "end" : "middle"
									}
									xAxisHeight={
										timeRange === "7d" || timeRange === "30d" ? 60 : 30
									}
									tooltipLabelFormatter={(label) =>
										viewMode === "cumulative" ? `Cumulative at ${label}` : label
									}
								/>
							);
					}
				})()}
			</CardContent>
		</Card>
	);
}

interface PerformanceIndicatorsChartProps {
	data: ChartData[];
	loading: boolean;
	modelBreakdown?: boolean;
	rawTimeSeries?: TimePoint[];
	selectedMetric?: "errorRate" | "cacheHitRate";
	timeRange?: TimeRange;
}

export function PerformanceIndicatorsChart({
	data,
	loading,
	modelBreakdown = false,
	rawTimeSeries,
	selectedMetric = "cacheHitRate",
	timeRange = "24h",
}: PerformanceIndicatorsChartProps) {
	const [currentMetric, setCurrentMetric] = useState(selectedMetric);

	// Process data for multi-model chart if model breakdown is enabled
	const processedMultiModelData =
		rawTimeSeries && modelBreakdown
			? (() => {
					// Group by timestamp and pivot models
					const grouped: Record<
						string,
						{ time: string; [model: string]: string | number }
					> = {};
					const models = new Set<string>();
					const timeToTimestamp = new Map<string, number>();

					rawTimeSeries.forEach((point) => {
						if (point.model) {
							models.add(point.model);
							const time =
								timeRange === "30d"
									? new Date(point.ts).toLocaleDateString()
									: new Date(point.ts).toLocaleTimeString([], {
											hour: "2-digit",
											minute: "2-digit",
										});
							timeToTimestamp.set(time, point.ts);
						}
					});

					// Sort time points chronologically
					const sortedTimes = Array.from(new Set(timeToTimestamp.keys())).sort(
						(a, b) => {
							const tsA = timeToTimestamp.get(a) || 0;
							const tsB = timeToTimestamp.get(b) || 0;
							return tsA - tsB;
						},
					);

					const modelArrays = Array.from(models).sort();

					// Initialize all time points with all models
					sortedTimes.forEach((time) => {
						grouped[time] = { time };
						modelArrays.forEach((model) => {
							grouped[time][model] = 0;
						});
					});

					// Fill in actual values
					rawTimeSeries.forEach((point) => {
						if (point.model) {
							const time =
								timeRange === "30d"
									? new Date(point.ts).toLocaleDateString()
									: new Date(point.ts).toLocaleTimeString([], {
											hour: "2-digit",
											minute: "2-digit",
										});

							// Map the metric value
							const value =
								currentMetric === "errorRate"
									? point.errorRate
									: point.cacheHitRate;

							grouped[time][point.model] = value;
						}
					});

					const finalData = sortedTimes.map((time) => grouped[time]);

					return {
						data: finalData,
						models: modelArrays,
					};
				})()
			: null;

	return (
		<Card>
			<CardHeader>
				<div className="flex items-center justify-between">
					<div>
						<CardTitle>Performance Indicators</CardTitle>
						<CardDescription>
							{modelBreakdown
								? "Per-model error rate and cache hit rate trends"
								: "Error rate and cache hit rate trends"}
						</CardDescription>
					</div>
					{modelBreakdown && (
						<Select
							value={currentMetric}
							onValueChange={(value) =>
								setCurrentMetric(value as "errorRate" | "cacheHitRate")
							}
						>
							<SelectTrigger className="w-36">
								<SelectValue />
							</SelectTrigger>
							<SelectContent>
								<SelectItem value="cacheHitRate">Cache Hit Rate</SelectItem>
								<SelectItem value="errorRate">Error Rate</SelectItem>
							</SelectContent>
						</Select>
					)}
				</div>
			</CardHeader>
			<CardContent>
				{modelBreakdown && processedMultiModelData ? (
					<MultiModelChart
						data={processedMultiModelData.data}
						models={processedMultiModelData.models}
						metric={currentMetric}
						loading={loading}
						height={CHART_HEIGHTS.medium}
					/>
				) : (
					<BaseLineChart
						data={data}
						lines={[
							{
								dataKey: "errorRate",
								stroke: COLORS.error,
								name: "Error Rate %",
							},
							{
								dataKey: "cacheHitRate",
								stroke: COLORS.success,
								name: "Cache Hit %",
							},
						]}
						loading={loading}
						height="medium"
						showLegend={true}
						referenceLines={[
							{ y: 90, stroke: COLORS.success },
							{ y: 5, stroke: COLORS.error },
						]}
					/>
				)}
			</CardContent>
		</Card>
	);
}

interface TokenBreakdownItem {
	type: string;
	value: number;
	percentage: number;
}

interface TokenUsageBreakdownProps {
	tokenBreakdown: TokenBreakdownItem[];
	timeRange: TimeRange;
}

export function TokenUsageBreakdown({
	tokenBreakdown,
	timeRange,
}: TokenUsageBreakdownProps) {
	return (
		<Card>
			<CardHeader>
				<CardTitle>Token Usage Breakdown</CardTitle>
				<CardDescription>
					Distribution of token types in the last {timeRange}
				</CardDescription>
			</CardHeader>
			<CardContent>
				<div className="space-y-4">
					{tokenBreakdown.map((item, index) => (
						<div key={item.type}>
							<div className="flex items-center justify-between mb-2">
								<span className="text-sm font-medium">{item.type}</span>
								<div className="flex items-center gap-2">
									<span className="text-sm text-muted-foreground">
										{formatTokens(item.value)} tokens
									</span>
									<Badge variant="outline">{item.percentage}%</Badge>
								</div>
							</div>
							<div className="w-full bg-muted rounded-full h-2">
								<div
									className="h-2 rounded-full transition-all"
									style={{
										width: `${item.percentage}%`,
										backgroundColor:
											index === 0
												? COLORS.blue
												: index === 1
													? COLORS.success
													: index === 2
														? COLORS.warning
														: COLORS.purple,
									}}
								/>
							</div>
						</div>
					))}
					<div className="pt-4 border-t">
						<div className="flex items-center justify-between">
							<span className="text-sm font-medium">Total Tokens</span>
							<span className="text-lg font-bold">
								{tokenBreakdown.reduce((acc, item) => acc + item.value, 0)}
							</span>
						</div>
					</div>
				</div>
			</CardContent>
		</Card>
	);
}

interface ModelComparisonChartsProps {
	modelPerformance: Array<{
		model: string;
		avgTime: number;
		p95Time: number;
		errorRate: number;
	}>;
	costByModel: Array<{ model: string; cost: number; requests: number }>;
	loading: boolean;
	timeRange: TimeRange;
}

export function ModelComparisonCharts({
	modelPerformance,
	costByModel,
	loading,
	timeRange,
}: ModelComparisonChartsProps) {
	return (
		<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
			{/* Model Performance */}
			<Card>
				<CardHeader>
					<CardTitle>Model Performance Comparison</CardTitle>
					<CardDescription>
						Response times and error rates by model
					</CardDescription>
				</CardHeader>
				<CardContent>
					<ModelPerformanceChart
						data={modelPerformance}
						loading={loading}
						height={CHART_HEIGHTS.medium}
					/>
				</CardContent>
			</Card>

			{/* Cost by Model */}
			<Card>
				<CardHeader>
					<CardTitle>Cost Analysis by Model</CardTitle>
					<CardDescription>
						Top models by cost in the last {timeRange}
					</CardDescription>
				</CardHeader>
				<CardContent>
					<BaseBarChart
						data={costByModel}
						bars={{ dataKey: "cost", radius: [0, 4, 4, 0] }}
						xAxisKey="model"
						loading={loading}
						height="medium"
						layout="vertical"
						yAxisWidth={120}
						tooltipFormatter={(value, name) => {
							if (name === "cost") return [formatCost(Number(value)), "Cost"];
							return [formatNumber(value as number), "Requests"];
						}}
					/>
				</CardContent>
			</Card>
		</div>
	);
}

interface CumulativeGrowthChartProps {
	data: ChartData[];
}

export function CumulativeGrowthChart({ data }: CumulativeGrowthChartProps) {
	return (
		<Card className="bg-gradient-to-br from-background to-muted/10 border-muted">
			<CardHeader>
				<CardTitle className="text-2xl font-bold">
					Cumulative Growth Analysis
				</CardTitle>
				<CardDescription>
					Token usage vs. cost accumulation over time
				</CardDescription>
			</CardHeader>
			<CardContent>
				<ResponsiveContainer width="100%" height={CHART_HEIGHTS.large}>
					<AreaChart
						data={data}
						margin={{ top: 20, right: 30, left: 20, bottom: 20 }}
					>
						<defs>
							<linearGradient id="colorTokens" x1="0" y1="0" x2="0" y2="1">
								<stop offset="0%" stopColor={COLORS.blue} stopOpacity={0.9} />
								<stop offset="100%" stopColor={COLORS.blue} stopOpacity={0.1} />
							</linearGradient>
							<linearGradient id="colorCost" x1="0" y1="0" x2="0" y2="1">
								<stop
									offset="0%"
									stopColor={COLORS.warning}
									stopOpacity={0.9}
								/>
								<stop
									offset="100%"
									stopColor={COLORS.warning}
									stopOpacity={0.1}
								/>
							</linearGradient>
							<filter id="glow">
								<feGaussianBlur stdDeviation="4" result="coloredBlur" />
								<feMerge>
									<feMergeNode in="coloredBlur" />
									<feMergeNode in="SourceGraphic" />
								</feMerge>
							</filter>
						</defs>
						<CartesianGrid
							strokeDasharray={CHART_PROPS.strokeDasharray}
							stroke="rgba(255,255,255,0.1)"
						/>
						<XAxis
							dataKey="time"
							className="text-xs"
							stroke="rgba(255,255,255,0.5)"
						/>
						<YAxis
							yAxisId="tokens"
							className="text-xs"
							stroke={COLORS.blue}
							tickFormatter={formatCompactNumber}
						/>
						<YAxis
							yAxisId="cost"
							orientation="right"
							className="text-xs"
							stroke={COLORS.warning}
							tickFormatter={formatCompactCurrency}
						/>
						<Tooltip
							labelClassName="font-bold"
							contentStyle={{
								backgroundColor: "rgba(0,0,0,0.8)",
								border: "1px solid rgba(255,255,255,0.2)",
								borderRadius: "8px",
								backdropFilter: "blur(8px)",
							}}
							formatter={(value: number | string, name: string) => {
								if (name === "Total Cost")
									return [formatCost(Number(value)), "Total Cost"];
								return [formatTokens(value as number), "Total Tokens"];
							}}
						/>
						<Legend
							verticalAlign="top"
							height={36}
							iconType="rect"
							wrapperStyle={{
								paddingBottom: "20px",
							}}
						/>
						<Area
							yAxisId="tokens"
							type="monotone"
							dataKey="tokens"
							stroke={COLORS.blue}
							strokeWidth={3}
							fillOpacity={1}
							fill="url(#colorTokens)"
							filter="url(#glow)"
							name="Total Tokens"
						/>
						<Area
							yAxisId="cost"
							type="monotone"
							dataKey="cost"
							stroke={COLORS.warning}
							strokeWidth={3}
							fillOpacity={1}
							fill="url(#colorCost)"
							filter="url(#glow)"
							name="Total Cost"
						/>
					</AreaChart>
				</ResponsiveContainer>
			</CardContent>
		</Card>
	);
}

interface CumulativeTokenCompositionProps {
	tokenBreakdown: TokenBreakdownItem[];
}

export function CumulativeTokenComposition({
	tokenBreakdown,
}: CumulativeTokenCompositionProps) {
	return (
		<Card>
			<CardHeader>
				<CardTitle>Cumulative Token Composition</CardTitle>
				<CardDescription>Token type distribution over time</CardDescription>
			</CardHeader>
			<CardContent>
				<div className="space-y-6">
					<div className="relative h-24 bg-muted rounded-lg overflow-hidden">
						{(() => {
							let offset = 0;
							return tokenBreakdown.map((item, index) => {
								const width = item.percentage;
								const currentOffset = offset;
								offset += width;
								return (
									<div
										key={item.type}
										className="absolute h-full transition-all duration-1000 hover:opacity-80"
										style={{
											left: `${currentOffset}%`,
											width: `${width}%`,
											background: `linear-gradient(135deg, ${
												index === 0
													? COLORS.blue
													: index === 1
														? COLORS.success
														: index === 2
															? COLORS.warning
															: COLORS.purple
											} 0%, ${
												index === 0
													? COLORS.purple
													: index === 1
														? COLORS.blue
														: index === 2
															? COLORS.primary
															: COLORS.warning
											} 100%)`,
										}}
									>
										<div className="flex items-center justify-center h-full">
											{width > 10 && (
												<span className="text-white font-medium text-xs">
													{item.percentage}%
												</span>
											)}
										</div>
									</div>
								);
							});
						})()}
					</div>
					<div className="grid grid-cols-2 md:grid-cols-4 gap-4">
						{tokenBreakdown.map((item, index) => (
							<div key={item.type} className="flex items-center gap-2">
								<div
									className="w-3 h-3 rounded-full"
									style={{
										background:
											index === 0
												? COLORS.blue
												: index === 1
													? COLORS.success
													: index === 2
														? COLORS.warning
														: COLORS.purple,
									}}
								/>
								<div>
									<p className="text-xs text-muted-foreground">{item.type}</p>
									<p className="text-sm font-medium">
										{formatTokens(item.value)}
									</p>
								</div>
							</div>
						))}
					</div>
				</div>
			</CardContent>
		</Card>
	);
}

================
File: packages/dashboard-web/src/components/conversation/ToolResultBlock.tsx
================
import { FileText } from "lucide-react";
import React from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";

interface ToolResultBlockProps {
	content: string;
}

const MAX_CHARS_COLLAPSE = 200;

function ToolResultBlockComponent({ content }: ToolResultBlockProps) {
	const { display, isLong, isExpanded, toggle } = useCollapsible(
		content,
		MAX_CHARS_COLLAPSE,
	);

	return (
		<div className="p-3 bg-green-50 dark:bg-green-900/10 border border-green-200 dark:border-green-800 rounded-lg">
			<div className="flex items-center justify-between mb-1">
				<div className="flex items-center gap-2">
					<FileText className="w-3 h-3 text-green-600 dark:text-green-400" />
					<span className="text-xs font-medium text-green-600 dark:text-green-400">
						Tool Result
					</span>
				</div>
				{isLong && (
					<Button
						variant="ghost"
						size="sm"
						className="h-6 px-2 text-xs"
						onClick={toggle}
					>
						{isExpanded ? "Show less" : "Show more"}
					</Button>
				)}
			</div>
			<div className="text-xs bg-green-100/50 dark:bg-green-900/20 p-2 rounded mt-1 overflow-hidden">
				<pre
					className={`overflow-x-auto whitespace-pre text-left ${
						isExpanded && isLong ? "max-h-96 overflow-y-auto pr-2" : ""
					}`}
				>
					{display}
				</pre>
			</div>
		</div>
	);
}

export const ToolResultBlock = React.memo(ToolResultBlockComponent);

================
File: packages/dashboard-web/src/components/conversation/MessageBubble.tsx
================
import type { Role } from "@ccflare/types";
import React from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";

interface MessageBubbleProps {
	role: Role;
	content: string;
}

const MAX_CHARS_COLLAPSE = 300;

const ROLE_BG_COLORS: Record<Role, string> = {
	user: "bg-primary text-primary-foreground",
	assistant: "bg-muted",
	system: "bg-orange-100 dark:bg-orange-900",
};

function MessageBubbleComponent({ role, content }: MessageBubbleProps) {
	const { display, isLong, isExpanded, toggle } = useCollapsible(
		content,
		MAX_CHARS_COLLAPSE,
	);
	const bgColor = ROLE_BG_COLORS[role];

	return (
		<div>
			<div className={`rounded-lg px-4 py-2 ${bgColor}`}>
				<div
					className={`whitespace-pre text-sm overflow-x-auto text-left ${
						isExpanded && isLong ? "max-h-96 overflow-y-auto pr-2" : ""
					}`}
				>
					{display}
				</div>
			</div>
			{isLong && (
				<Button
					variant="ghost"
					size="sm"
					className="mt-1 h-6 px-2 text-xs"
					onClick={toggle}
				>
					{isExpanded ? "Show less" : "Show more"}
				</Button>
			)}
		</div>
	);
}

export const MessageBubble = React.memo(MessageBubbleComponent);

================
File: packages/dashboard-web/src/components/conversation/ThinkingBlock.tsx
================
import { MessageSquare } from "lucide-react";
import React from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";

interface ThinkingBlockProps {
	content: string;
}

const MAX_CHARS_COLLAPSE = 200;

function ThinkingBlockComponent({ content }: ThinkingBlockProps) {
	const { display, isLong, isExpanded, toggle } = useCollapsible(
		content,
		MAX_CHARS_COLLAPSE,
	);

	return (
		<div className="p-3 bg-yellow-50 dark:bg-yellow-900/10 border border-yellow-200 dark:border-yellow-800 rounded-lg">
			<div className="flex items-center justify-between mb-1">
				<div className="flex items-center gap-2">
					<MessageSquare className="w-3 h-3 text-yellow-600 dark:text-yellow-400" />
					<span className="text-xs font-medium text-yellow-600 dark:text-yellow-400">
						Thinking
					</span>
				</div>
				{isLong && (
					<Button
						variant="ghost"
						size="sm"
						className="h-5 px-2 text-xs"
						onClick={toggle}
					>
						{isExpanded ? "Show less" : "Show more"}
					</Button>
				)}
			</div>
			<div className="text-xs text-yellow-700 dark:text-yellow-300 whitespace-pre overflow-x-auto">
				{display}
			</div>
		</div>
	);
}

export const ThinkingBlock = React.memo(ThinkingBlockComponent);

================
File: packages/dashboard-web/src/components/conversation/Message.tsx
================
import {
	type ContentBlock,
	ContentBlockType,
	type Role,
	type ToolResult,
	type ToolUse,
} from "@ccflare/types";
import type { LucideIcon } from "lucide-react";
import { Bot, FileText, Terminal, User } from "lucide-react";
import React from "react";
import { Badge } from "../ui/badge";
import { MessageBubble } from "./MessageBubble";
import { ThinkingBlock } from "./ThinkingBlock";
import { ToolResultBlock } from "./ToolResultBlock";
import { ToolUsageBlock } from "./ToolUsageBlock";

interface MessageProps {
	role: Role;
	content: string;
	contentBlocks?: ContentBlock[];
	tools?: ToolUse[];
	toolResults?: ToolResult[];
	cleanLineNumbers: (content: string) => string;
}

const ROLE_STYLES: Record<Role, { bg: string; Icon: LucideIcon }> = {
	user: { bg: "bg-primary text-primary-foreground", Icon: User },
	assistant: { bg: "bg-muted", Icon: Bot },
	system: { bg: "bg-orange-100 dark:bg-orange-900", Icon: Bot },
};

function MessageComponent({
	role,
	content,
	contentBlocks,
	tools,
	toolResults,
	cleanLineNumbers,
}: MessageProps) {
	const isRightAligned = role === "user";
	const thinkingBlock = contentBlocks?.find(
		(b) => b.type === ContentBlockType.Thinking,
	);
	const thinkingText =
		typeof thinkingBlock?.thinking === "string" ? thinkingBlock.thinking : "";
	const hasThinking =
		thinkingText && cleanLineNumbers(thinkingText).trim().length > 0;
	const cleanedContent =
		typeof content === "string" ? cleanLineNumbers(content).trim() : "";
	const hasTools = tools?.length || 0;
	const hasToolResults = toolResults?.length || 0;

	const roleStyle = ROLE_STYLES[role];
	const Icon = roleStyle.Icon;

	return (
		<div
			className={`flex gap-3 w-full ${isRightAligned ? "flex-row-reverse" : "flex-row"}`}
		>
			<div
				className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center ${roleStyle.bg}`}
			>
				<Icon className="w-4 h-4" />
			</div>

			<div
				className={`flex-1 min-w-0 ${isRightAligned ? "text-right" : "text-left"}`}
			>
				<div
					className={`inline-block max-w-[85%] ${isRightAligned ? "ml-auto" : "mr-auto"}`}
				>
					<div className="flex items-center gap-2 mb-1">
						<span className="text-xs font-medium text-muted-foreground">
							{role.charAt(0).toUpperCase() + role.slice(1)}
						</span>
						{hasThinking && (
							<Badge variant="secondary" className="text-xs">
								Thinking
							</Badge>
						)}
						{hasTools > 0 && (
							<Badge variant="outline" className="text-xs">
								<Terminal className="w-3 h-3 mr-1" />
								{hasTools} tool{hasTools > 1 ? "s" : ""} used
							</Badge>
						)}
						{hasToolResults > 0 && (
							<Badge variant="secondary" className="text-xs">
								<FileText className="w-3 h-3 mr-1" />
								{hasToolResults} result{hasToolResults > 1 ? "s" : ""}
							</Badge>
						)}
					</div>

					{/* Thinking block */}
					{hasThinking && thinkingBlock && (
						<div className="mb-2">
							<ThinkingBlock content={cleanLineNumbers(thinkingText)} />
						</div>
					)}

					{/* Main content */}
					{cleanedContent.length > 0 && (
						<MessageBubble role={role} content={cleanedContent} />
					)}

					{/* Tool usage */}
					{hasTools > 0 && (
						<div className="mt-2 space-y-2">
							{tools?.map((tool, index) => (
								<ToolUsageBlock
									key={`tool-${tool.id || tool.name}-${index}`}
									toolName={tool.name}
									input={tool.input}
								/>
							))}
						</div>
					)}

					{/* Tool results */}
					{hasToolResults > 0 && (
						<div className="mt-2 space-y-2">
							{toolResults?.map((result, index) => (
								<ToolResultBlock
									key={`result-${result.tool_use_id || index}`}
									content={
										typeof result.content === "string"
											? cleanLineNumbers(result.content)
											: ""
									}
								/>
							))}
						</div>
					)}
				</div>
			</div>
		</div>
	);
}

export const Message = React.memo(MessageComponent);

================
File: packages/dashboard-web/src/components/conversation/index.ts
================
export { Message } from "./Message";
export { MessageBubble } from "./MessageBubble";
export { ThinkingBlock } from "./ThinkingBlock";
export { ToolResultBlock } from "./ToolResultBlock";
export { ToolUsageBlock } from "./ToolUsageBlock";

================
File: packages/dashboard-web/src/components/conversation/ToolUsageBlock.tsx
================
import { Terminal } from "lucide-react";
import React, { useMemo } from "react";
import { useCollapsible } from "../../hooks/useCollapsible";
import { Button } from "../ui/button";

interface ToolUsageBlockProps {
	toolName: string;
	input?: Record<string, unknown>;
}

const MAX_CHARS_COLLAPSE = 200;

function ToolUsageBlockComponent({ toolName, input }: ToolUsageBlockProps) {
	const inputStr = useMemo(
		() => (input ? JSON.stringify(input, null, 2) : ""),
		[input],
	);

	const { display, isLong, isExpanded, toggle } = useCollapsible(
		inputStr,
		MAX_CHARS_COLLAPSE,
	);
	const hasInput = input && Object.keys(input).length > 0;

	return (
		<div className="p-3 bg-blue-50 dark:bg-blue-900/10 border border-blue-200 dark:border-blue-800 rounded-lg">
			<div className="flex items-center justify-between mb-1">
				<div className="flex items-center gap-2">
					<Terminal className="w-3 h-3 text-blue-600 dark:text-blue-400" />
					<span className="text-xs font-medium text-blue-600 dark:text-blue-400">
						Tool: {toolName}
					</span>
				</div>
				{hasInput && isLong && (
					<Button
						variant="ghost"
						size="sm"
						className="h-6 px-2 text-xs"
						onClick={toggle}
					>
						{isExpanded ? "Show less" : "Show more"}
					</Button>
				)}
			</div>
			{hasInput && (
				<pre
					className={`text-xs bg-blue-100/50 dark:bg-blue-900/20 p-2 rounded mt-1 overflow-x-auto whitespace-pre text-left ${
						isExpanded && isLong ? "max-h-96 overflow-y-auto pr-2" : ""
					}`}
				>
					{display}
				</pre>
			)}
		</div>
	);
}

export const ToolUsageBlock = React.memo(ToolUsageBlockComponent);

================
File: packages/dashboard-web/src/hooks/useCollapsible.ts
================
import { useMemo, useState } from "react";

export const useCollapsible = (content: string, limit: number) => {
	const [isExpanded, setIsExpanded] = useState(false);

	const isLong = useMemo(
		() => content && content.length > limit,
		[content, limit],
	);

	const display = useMemo(() => {
		if (isExpanded || !isLong) {
			return content;
		}
		return content ? `${content.slice(0, limit)}...` : "";
	}, [content, limit, isExpanded, isLong]);

	const toggle = () => setIsExpanded((prev) => !prev);

	return {
		display,
		isLong,
		isExpanded,
		toggle,
	};
};

================
File: packages/dashboard-web/src/hooks/useApiError.ts
================
import {
	type ErrorFormatterOptions,
	type ErrorType,
	formatError as formatErrorFromPackage,
	getErrorType,
	isAuthError as isAuthErrorCheck,
	isNetworkError as isNetworkErrorCheck,
	isRateLimitError as isRateLimitErrorCheck,
} from "@ccflare/errors";
import { useCallback, useMemo } from "react";

export interface UseApiErrorOptions extends ErrorFormatterOptions {
	/**
	 * Whether to log errors to console
	 * @default false
	 */
	logErrors?: boolean;
}

export interface UseApiErrorReturn {
	/**
	 * Format an error into a user-friendly message
	 */
	formatError: (error: unknown) => string;
	/**
	 * Check if an error is a network error
	 */
	isNetworkError: (error: unknown) => boolean;
	/**
	 * Check if an error is an authentication error
	 */
	isAuthError: (error: unknown) => boolean;
	/**
	 * Check if an error is a rate limit error
	 */
	isRateLimitError: (error: unknown) => boolean;
	/**
	 * Get error type
	 */
	getErrorType: (error: unknown) => ErrorType;
}

/**
 * Hook for consistent error handling across the dashboard
 *
 * @example
 * ```tsx
 * const { formatError, isNetworkError } = useApiError({
 *   errorMap: {
 *     "Network Error": "Unable to connect to the server. Please check your connection.",
 *   }
 * });
 *
 * try {
 *   await api.getAccounts();
 * } catch (err) {
 *   const message = formatError(err);
 *   setError(message);
 * }
 * ```
 */
export function useApiError(
	options: UseApiErrorOptions = {},
): UseApiErrorReturn {
	const { logErrors = false, ...formatOptions } = options;

	// Memoize formatOptions to avoid re-creating on every render
	const memoizedFormatOptions = useMemo(
		() => ({
			...formatOptions,
			errorMap: {
				...formatOptions.errorMap,
				// Override auth error message for dashboard context
				unauthorized: "Authentication failed. Please re-add your account.",
				401: "Authentication failed. Please re-add your account.",
			},
		}),
		// biome-ignore lint/correctness/useExhaustiveDependencies: formatOptions is destructured from options
		[formatOptions],
	);

	const formatError = useCallback(
		(error: unknown): string => {
			if (logErrors) {
				console.error("[API Error]", error);
			}

			// Use the formatError from the errors package with custom auth message
			return formatErrorFromPackage(error, memoizedFormatOptions);
		},
		[logErrors, memoizedFormatOptions],
	);

	const isNetworkError = useCallback((error: unknown): boolean => {
		return isNetworkErrorCheck(error);
	}, []);

	const isAuthError = useCallback((error: unknown): boolean => {
		return isAuthErrorCheck(error);
	}, []);

	const isRateLimitError = useCallback((error: unknown): boolean => {
		return isRateLimitErrorCheck(error);
	}, []);

	const getErrorTypeWrapper = useCallback((error: unknown): ErrorType => {
		return getErrorType(error);
	}, []);

	return useMemo(
		() => ({
			formatError,
			isNetworkError,
			isAuthError,
			isRateLimitError,
			getErrorType: getErrorTypeWrapper,
		}),
		[
			formatError,
			isNetworkError,
			isAuthError,
			isRateLimitError,
			getErrorTypeWrapper,
		],
	);
}

================
File: packages/dashboard-web/src/hooks/queries.ts
================
import type { AgentUpdatePayload } from "@ccflare/types";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { api } from "../api";
import { REFRESH_INTERVALS } from "../constants";
import { queryKeys } from "../lib/query-keys";

export const useAccounts = () => {
	return useQuery({
		queryKey: queryKeys.accounts(),
		queryFn: () => api.getAccounts(),
		refetchInterval: REFRESH_INTERVALS.fast, // Refresh every 10 seconds for rate limit updates
	});
};

export const useAgents = () => {
	return useQuery({
		queryKey: queryKeys.agents(),
		queryFn: () => api.getAgents(),
		refetchInterval: 30000, // Poll every 30 seconds for new agents
		refetchIntervalInBackground: true, // Continue polling when tab is not focused
	});
};

export const useStats = (refetchInterval?: number) => {
	return useQuery({
		queryKey: queryKeys.stats(),
		queryFn: () => api.getStats(),
		refetchInterval: refetchInterval ?? REFRESH_INTERVALS.fast,
	});
};

export const useAnalytics = (
	timeRange: string,
	filters: {
		accounts?: string[];
		models?: string[];
		status?: "all" | "success" | "error";
	},
	viewMode: "normal" | "cumulative",
	modelBreakdown?: boolean,
) => {
	return useQuery({
		queryKey: queryKeys.analytics(timeRange, filters, viewMode, modelBreakdown),
		queryFn: () =>
			api.getAnalytics(timeRange, filters, viewMode, modelBreakdown),
	});
};

export const useRequests = (limit: number, refetchInterval?: number) => {
	return useQuery({
		queryKey: queryKeys.requests(limit),
		queryFn: async () => {
			const [requestsDetail, requestsSummary] = await Promise.all([
				api.getRequestsDetail(limit),
				api.getRequestsSummary(limit),
			]);
			return { requests: requestsDetail, detailsMap: requestsSummary };
		},
		refetchInterval: refetchInterval ?? REFRESH_INTERVALS.fast,
	});
};

export const useRequestDetails = (id: string) => {
	return useQuery({
		queryKey: queryKeys.requestDetails(id),
		queryFn: () =>
			api
				.getRequestsDetail(1)
				.then((requests) => requests.find((r) => r.id === id)),
		enabled: !!id,
	});
};

export const useLogHistory = () => {
	return useQuery({
		queryKey: queryKeys.logHistory(),
		queryFn: () => api.getLogHistory(),
	});
};

// Mutations
export const useRemoveAccount = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: ({
			name,
			confirmInput,
		}: {
			name: string;
			confirmInput: string;
		}) => api.removeAccount(name, confirmInput),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.accounts() });
		},
	});
};

export const useRenameAccount = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: ({
			accountId,
			newName,
		}: {
			accountId: string;
			newName: string;
		}) => api.renameAccount(accountId, newName),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.accounts() });
		},
	});
};

export const useResetStats = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: () => api.resetStats(),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.stats() });
		},
	});
};

export const useUpdateAgentPreference = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: ({ agentId, model }: { agentId: string; model: string }) =>
			api.updateAgentPreference(agentId, model),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.agents() });
		},
	});
};

export const useDefaultAgentModel = () => {
	return useQuery({
		queryKey: queryKeys.defaultAgentModel(),
		queryFn: () => api.getDefaultAgentModel(),
		refetchInterval: REFRESH_INTERVALS.slow, // Poll for config changes
		refetchIntervalInBackground: true, // Continue polling when tab is not focused
	});
};

export const useSetDefaultAgentModel = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: (model: string) => api.setDefaultAgentModel(model),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: queryKeys.defaultAgentModel(),
			});
			queryClient.invalidateQueries({ queryKey: queryKeys.agents() });
		},
	});
};

export const useBulkUpdateAgentPreferences = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: (model: string) => api.setBulkAgentPreferences(model),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.agents() });
		},
	});
};

export const useUpdateAgent = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: ({
			id,
			payload,
		}: {
			id: string;
			payload: AgentUpdatePayload;
		}) => api.updateAgent(id, payload),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: queryKeys.agents() });
		},
	});
};

// Note: Clear logs functionality appears to be removed from the API

// Retention settings
export const useRetention = () => {
	return useQuery({
		queryKey: ["retention"],
		queryFn: () => api.getRetention(),
	});
};

export const useSetRetention = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: (partial: { payloadDays?: number; requestDays?: number }) =>
			api.setRetention(partial),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ["retention"] });
		},
	});
};

export const useCleanupNow = () => {
	return useMutation({
		mutationFn: () => api.cleanupNow(),
	});
};

export const useCompactDb = () => {
	return useMutation({
		mutationFn: () => api.compactDb(),
	});
};

/**
 * Hook to fetch the current system prompt interceptor configuration
 * Polls for changes at a slow interval and continues in background
 */

export const useSystemPromptOverride = () => {
	return useQuery({
		queryKey: queryKeys.systemPromptOverride(),
		queryFn: () => api.getSystemPromptOverride(),
		refetchInterval: REFRESH_INTERVALS.slow, // Poll for config changes
	});
};

export const useSetSystemPromptOverride = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: (data: {
			isEnabled: boolean;
			targetPrompt: string;
			replacementPrompt: string;
			toolsEnabled: boolean;
		}) => api.setSystemPromptOverride(data),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: queryKeys.systemPromptOverride(),
			});
		},
	});
};

export const useResetSystemPromptOverride = () => {
	const queryClient = useQueryClient();
	return useMutation({
		mutationFn: () => api.resetSystemPromptOverride(),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: queryKeys.systemPromptOverride(),
			});
		},
	});
};

================
File: packages/dashboard-web/src/hooks/useRequestStream.ts
================
import { useQueryClient } from "@tanstack/react-query";
import { useEffect } from "react";
import type { Account, RequestPayload, RequestResponse } from "../api";
import { queryKeys } from "../lib/query-keys";

export function useRequestStream(limit = 200) {
	const queryClient = useQueryClient();

	useEffect(() => {
		let es: EventSource | null = null;
		let retries = 0;
		let reconnectTimeout: NodeJS.Timeout | null = null;

		const connect = () => {
			// Clear any existing timeout
			if (reconnectTimeout) {
				clearTimeout(reconnectTimeout);
				reconnectTimeout = null;
			}

			es = new EventSource("/api/requests/stream");

			es.addEventListener("open", () => {
				// Reset retry count on successful connection
				retries = 0;
				console.log("SSE connection established");
			});

			es.addEventListener("message", (ev) => {
				const evt = JSON.parse(ev.data) as
					| {
							type: "start";
							id: string;
							method: string;
							path: string;
							timestamp: number;
							accountId: string | null;
							statusCode: number;
							agentUsed: string | null;
					  }
					| { type: "summary"; payload: RequestResponse }
					| { type: "payload"; payload: RequestPayload };

				queryClient.setQueryData(
					queryKeys.requests(limit),
					(
						current:
							| {
									requests: RequestPayload[];
									detailsMap: Map<string, RequestResponse> | RequestResponse[];
							  }
							| undefined,
					) => {
						if (!current) return current;

						// Ensure detailsMap is a Map
						const currentDetailsMap =
							current.detailsMap instanceof Map
								? current.detailsMap
								: new Map(
										(current.detailsMap as RequestResponse[]).map((s) => [
											s.id,
											s,
										]),
									);

						if (evt.type === "start") {
							// Look up account name from cache
							const accounts = queryClient.getQueryData<Account[]>(
								queryKeys.accounts(),
							);
							const account = accounts?.find((a) => a.id === evt.accountId);

							// Create a lightweight placeholder payload
							const placeholder: RequestPayload = {
								id: evt.id,
								request: { headers: {}, body: null },
								response: {
									status: evt.statusCode,
									headers: {},
									body: null,
								},
								meta: {
									timestamp: evt.timestamp,
									path: evt.path,
									method: evt.method,
									accountId: evt.accountId || undefined,
									accountName: account?.name,
									success: false,
									pending: true,
									agentUsed: evt.agentUsed || undefined,
								},
							};

							// Check if this request already exists
							const existingIndex = current.requests.findIndex(
								(r) => r.id === evt.id,
							);
							if (existingIndex >= 0) {
								// Update existing placeholder
								const newRequests = [...current.requests];
								newRequests[existingIndex] = placeholder;
								return {
									...current,
									requests: newRequests,
									detailsMap: currentDetailsMap,
								};
							}

							// Add new placeholder at the beginning
							return {
								...current,
								requests: [placeholder, ...current.requests].slice(0, limit),
								detailsMap: currentDetailsMap,
							};
						} else if (evt.type === "payload") {
							// Replace placeholder or insert if missing
							const newRequests = [...current.requests];
							const idx = newRequests.findIndex((r) => r.id === evt.payload.id);
							if (idx >= 0) {
								newRequests[idx] = evt.payload;
							} else {
								newRequests.unshift(evt.payload);
							}
							return {
								...current,
								requests: newRequests.slice(0, limit),
								detailsMap: currentDetailsMap,
							};
						} else {
							// Update details map with summary
							const map = new Map(currentDetailsMap);
							map.set(evt.payload.id, evt.payload);

							// Update the request if it exists
							const requestIndex = current.requests.findIndex(
								(r) => r.id === evt.payload.id,
							);
							if (requestIndex >= 0) {
								const newRequests = [...current.requests];
								// Update meta to remove pending status
								if (newRequests[requestIndex].meta) {
									newRequests[requestIndex] = {
										...newRequests[requestIndex],
										meta: {
											...newRequests[requestIndex].meta,
											pending: false,
											success: evt.payload.success,
										},
									};
								}
								return { ...current, requests: newRequests, detailsMap: map };
							}

							return { ...current, detailsMap: map };
						}
					},
				);
			});

			es.addEventListener("error", (error) => {
				console.error("SSE connection error:", error);

				if (es) {
					es.close();
					es = null;
				}

				// Calculate exponential backoff delay (max 30 seconds)
				const delay = Math.min(1000 * 2 ** retries, 30000);
				retries++;

				console.log(`Reconnecting in ${delay}ms (attempt ${retries})`);
				reconnectTimeout = setTimeout(connect, delay);
			});
		};

		// Initial connection
		connect();

		// Cleanup function
		return () => {
			if (reconnectTimeout) {
				clearTimeout(reconnectTimeout);
			}
			if (es) {
				es.close();
			}
		};
	}, [limit, queryClient]);
}

================
File: packages/dashboard-web/src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

================
File: packages/dashboard-web/src/lib/query-keys.ts
================
export const queryKeys = {
	all: ["ccflare"] as const,
	accounts: () => [...queryKeys.all, "accounts"] as const,
	agents: () => [...queryKeys.all, "agents"] as const,
	stats: () => [...queryKeys.all, "stats"] as const,
	analytics: (
		timeRange?: string,
		filters?: unknown,
		viewMode?: string,
		modelBreakdown?: boolean,
	) =>
		[
			...queryKeys.all,
			"analytics",
			{ timeRange, filters, viewMode, modelBreakdown },
		] as const,
	requests: (limit?: number) =>
		[...queryKeys.all, "requests", { limit }] as const,
	requestDetails: (id: string) =>
		[...queryKeys.all, "requests", "detail", id] as const,
	logs: () => [...queryKeys.all, "logs"] as const,
	logHistory: () => [...queryKeys.all, "logs", "history"] as const,
	defaultAgentModel: () =>
		[...queryKeys.all, "config", "defaultAgentModel"] as const,
	systemPromptOverride: () =>
		[...queryKeys.all, "tools", "systemPromptOverride"] as const,
} as const;

================
File: packages/dashboard-web/src/lib/chart-utils.ts
================
/**
 * Format numbers in compact notation for chart axes
 * 1000 -> 1k
 * 1000000 -> 1M
 * 1000000000 -> 1B
 */
export function formatCompactNumber(value: number | string): string {
	const numValue = typeof value === "string" ? Number(value) : value;
	if (Number.isNaN(numValue)) return String(value);

	const absValue = Math.abs(numValue);
	const sign = numValue < 0 ? "-" : "";

	if (absValue >= 1e9) {
		return `${sign}${(absValue / 1e9).toFixed(1).replace(/\.0$/, "")}B`;
	}
	if (absValue >= 1e6) {
		return `${sign}${(absValue / 1e6).toFixed(1).replace(/\.0$/, "")}M`;
	}
	if (absValue >= 1e3) {
		return `${sign}${(absValue / 1e3).toFixed(1).replace(/\.0$/, "")}k`;
	}
	return `${sign}${absValue.toString()}`;
}

/**
 * Format currency in compact notation
 * $1234 -> $1.2k
 */
export function formatCompactCurrency(value: number | string): string {
	return `$${formatCompactNumber(value)}`;
}

================
File: packages/errors/package.json
================
{
	"name": "@ccflare/errors",
	"version": "1.0.0",
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"scripts": {
		"typecheck": "tsc --noEmit",
		"lint": "biome check --write --unsafe"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*"
	},
	"devDependencies": {
		"@types/bun": "1.1.15",
		"typescript": "5.7.2"
	}
}

================
File: packages/errors/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"baseUrl": ".",
		"outDir": "./dist",
		"rootDir": "./src"
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}

================
File: packages/errors/src/index.ts
================
// Re-export core errors that are available
export {
	OAuthError,
	ProviderError,
	RateLimitError,
	ServiceUnavailableError,
	TokenRefreshError,
	ValidationError,
} from "@ccflare/core";

// Error type constants
export const ERROR_TYPES = {
	NETWORK: "network",
	AUTH: "auth",
	RATE_LIMIT: "rate-limit",
	VALIDATION: "validation",
	SERVER: "server",
	UNKNOWN: "unknown",
} as const;

export type ErrorType = (typeof ERROR_TYPES)[keyof typeof ERROR_TYPES];

// HTTP error class for API responses
export class HttpError extends Error {
	constructor(
		public status: number,
		message: string,
		public details?: unknown,
	) {
		super(message);
		this.name = "HttpError";
	}
}

// Common HTTP error factories
export const BadRequest = (message: string, details?: unknown) =>
	new HttpError(400, message, details);

export const Unauthorized = (message: string, details?: unknown) =>
	new HttpError(401, message, details);

export const Forbidden = (message: string, details?: unknown) =>
	new HttpError(403, message, details);

export const NotFound = (message: string, details?: unknown) =>
	new HttpError(404, message, details);

export const Conflict = (message: string, details?: unknown) =>
	new HttpError(409, message, details);

export const UnprocessableEntity = (message: string, details?: unknown) =>
	new HttpError(422, message, details);

export const TooManyRequests = (message: string, details?: unknown) =>
	new HttpError(429, message, details);

export const InternalServerError = (message: string, details?: unknown) =>
	new HttpError(500, message, details);

export const BadGateway = (message: string, details?: unknown) =>
	new HttpError(502, message, details);

export const ServiceUnavailable = (message: string, details?: unknown) =>
	new HttpError(503, message, details);

export const GatewayTimeout = (message: string, details?: unknown) =>
	new HttpError(504, message, details);

// Error type detection
export function getErrorType(error: unknown): ErrorType {
	if (error instanceof HttpError) {
		if (error.status === 401) return ERROR_TYPES.AUTH;
		if (error.status === 429) return ERROR_TYPES.RATE_LIMIT;
		if (error.status >= 400 && error.status < 500)
			return ERROR_TYPES.VALIDATION;
		if (error.status >= 500) return ERROR_TYPES.SERVER;
	}

	if (error instanceof Error) {
		const message = error.message.toLowerCase();

		// Check for specific error types in message
		if (
			message.includes("network") ||
			message.includes("fetch failed") ||
			message.includes("connection") ||
			message.includes("econnrefused")
		) {
			return ERROR_TYPES.NETWORK;
		}

		if (
			message.includes("unauthorized") ||
			message.includes("authentication") ||
			message.includes("401") ||
			message.includes("token")
		) {
			return ERROR_TYPES.AUTH;
		}

		if (
			message.includes("rate limit") ||
			message.includes("too many requests") ||
			message.includes("429")
		) {
			return ERROR_TYPES.RATE_LIMIT;
		}

		if (
			message.includes("validation") ||
			message.includes("invalid") ||
			message.includes("bad request")
		) {
			return ERROR_TYPES.VALIDATION;
		}

		if (
			message.includes("server error") ||
			message.includes("500") ||
			message.includes("502") ||
			message.includes("503") ||
			message.includes("504")
		) {
			return ERROR_TYPES.SERVER;
		}
	}

	return ERROR_TYPES.UNKNOWN;
}

// Error type checkers
export const isNetworkError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.NETWORK;

export const isAuthError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.AUTH;

export const isRateLimitError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.RATE_LIMIT;

export const isValidationError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.VALIDATION;

export const isServerError = (error: unknown): boolean =>
	getErrorType(error) === ERROR_TYPES.SERVER;

// Default error messages
const DEFAULT_ERROR_MESSAGES: Record<ErrorType, string> = {
	[ERROR_TYPES.NETWORK]:
		"Network error. Please check your connection and try again.",
	[ERROR_TYPES.AUTH]: "Authentication failed. Please sign in again.",
	[ERROR_TYPES.RATE_LIMIT]: "Too many requests. Please try again later.",
	[ERROR_TYPES.VALIDATION]: "Invalid request. Please check your input.",
	[ERROR_TYPES.SERVER]: "Server error. Please try again later.",
	[ERROR_TYPES.UNKNOWN]: "An unexpected error occurred.",
};

// Error formatting options
export interface ErrorFormatterOptions {
	defaultMessage?: string;
	errorMap?: Record<string, string>;
	includeDetails?: boolean;
}

// Format error for user display
export function formatError(
	error: unknown,
	options: ErrorFormatterOptions = {},
): string {
	const {
		defaultMessage = DEFAULT_ERROR_MESSAGES[ERROR_TYPES.UNKNOWN],
		errorMap = {},
		includeDetails = false,
	} = options;

	// Handle null/undefined
	if (error == null) {
		return defaultMessage;
	}

	// Handle Error instances
	if (error instanceof Error) {
		const message = error.message;

		// Check error map for custom messages
		for (const [key, value] of Object.entries(errorMap)) {
			if (message.includes(key)) {
				return value;
			}
		}

		// Get error type and use default message if appropriate
		const errorType = getErrorType(error);
		const defaultTypeMessage = DEFAULT_ERROR_MESSAGES[errorType];

		// For known error types, prefer the default message unless includeDetails is true
		if (errorType !== ERROR_TYPES.UNKNOWN && !includeDetails) {
			return defaultTypeMessage;
		}

		// Return the actual error message
		return message;
	}

	// Handle string errors
	if (typeof error === "string") {
		return error;
	}

	// Handle objects with message property
	if (typeof error === "object" && error !== null && "message" in error) {
		return String(error.message);
	}

	// Fallback
	return defaultMessage;
}

// Parse HTTP response error
export async function parseHttpError(response: Response): Promise<HttpError> {
	let message = `HTTP ${response.status}: ${response.statusText}`;
	let details: unknown;

	try {
		const contentType = response.headers.get("content-type");
		if (contentType?.includes("application/json")) {
			const data = await response.json();
			if (data.error) {
				message =
					typeof data.error === "string"
						? data.error
						: data.error.message || message;
				details = data.error;
			} else if (data.message) {
				message = data.message;
				details = data;
			}
		} else {
			const text = await response.text();
			if (text) {
				message = text;
			}
		}
	} catch {
		// Ignore parsing errors
	}

	return new HttpError(response.status, message, details);
}

================
File: packages/cli-commands/package.json
================
{
	"name": "@ccflare/cli-commands",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"exports": {
		".": "./src/index.ts"
	},
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/core-di": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/oauth-flow": "workspace:*",
		"open": "^10.0.0"
	}
}

================
File: packages/cli-commands/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: packages/cli-commands/src/index.ts
================
// Export all commands
export * from "./commands/account";
export * from "./commands/analyze";
export * from "./commands/help";
export * from "./commands/stats";

// Export prompts
export * from "./prompts/index";
// Export main CLI runner
export { runCli } from "./runner";
// Export utilities
export * from "./utils/browser";

================
File: packages/cli-commands/src/runner.ts
================
import { parseArgs } from "node:util";
import { Config } from "@ccflare/config";
import { shutdown } from "@ccflare/core";
import { container, SERVICE_KEYS } from "@ccflare/core-di";
import { DatabaseFactory } from "@ccflare/database";
import {
	addAccount,
	getAccountsList,
	pauseAccount,
	removeAccountWithConfirmation,
	resumeAccount,
} from "./commands/account";
import { analyzePerformance } from "./commands/analyze";
import { getHelpText } from "./commands/help";
import { clearRequestHistory, resetAllStats } from "./commands/stats";

/**
 * Main CLI runner
 */
export async function runCli(argv: string[]): Promise<void> {
	// Initialize DI container and services
	container.registerInstance(SERVICE_KEYS.Config, new Config());
	const config = container.resolve<Config>(SERVICE_KEYS.Config);
	DatabaseFactory.initialize();
	const dbOps = DatabaseFactory.getInstance();
	container.registerInstance(SERVICE_KEYS.Database, dbOps);

	try {
		// Parse command line arguments
		const { positionals, values } = parseArgs({
			args: argv.slice(2),
			strict: false,
			options: {
				mode: { type: "string" },
				tier: { type: "string" },
				force: { type: "boolean" },
			},
		});

		const command = positionals[0];

		switch (command) {
			case "add": {
				const name = positionals[1];
				if (!name) {
					console.error("Error: Account name is required");
					console.log(
						"Usage: ccflare-cli add <name> [--mode <max|console>] [--tier <1|5|20>]",
					);
					process.exit(1);
				}

				// Parse options
				const mode = values.mode as "max" | "console" | undefined;
				const tierValue = values.tier
					? parseInt(values.tier as string)
					: undefined;
				const tier =
					tierValue === 1 || tierValue === 5 || tierValue === 20
						? tierValue
						: undefined;

				await addAccount(dbOps, config, { name, mode, tier });
				break;
			}

			case "list": {
				const accounts = getAccountsList(dbOps);

				if (accounts.length === 0) {
					console.log("No accounts found");
				} else {
					console.log(`\nAccounts (${accounts.length}):`);
					console.log("─".repeat(100));

					// Header
					console.log(
						"Name".padEnd(20) +
							"Type".padEnd(10) +
							"Tier".padEnd(6) +
							"Requests".padEnd(12) +
							"Token".padEnd(10) +
							"Status".padEnd(20) +
							"Session",
					);
					console.log("─".repeat(100));

					// Rows
					for (const account of accounts) {
						console.log(
							account.name.padEnd(20) +
								account.provider.padEnd(10) +
								account.tierDisplay.padEnd(6) +
								`${account.requestCount}/${account.totalRequests}`.padEnd(12) +
								account.tokenStatus.padEnd(10) +
								account.rateLimitStatus.padEnd(20) +
								account.sessionInfo,
						);
					}
				}
				break;
			}

			case "remove": {
				const name = positionals[1];
				if (!name) {
					console.error("Error: Account name is required");
					console.log("Usage: ccflare-cli remove <name> [--force]");
					process.exit(1);
				}

				const result = await removeAccountWithConfirmation(
					dbOps,
					name,
					values.force === true,
				);
				console.log(result.message);
				if (!result.success) {
					process.exit(1);
				}
				break;
			}

			case "reset-stats": {
				const db = dbOps.getDatabase();
				resetAllStats(db);
				console.log("Account statistics reset successfully");
				break;
			}

			case "clear-history": {
				const db = dbOps.getDatabase();
				const result = clearRequestHistory(db);
				console.log(`Cleared ${result.count} request records`);
				break;
			}

			case "pause": {
				const name = positionals[1];
				if (!name) {
					console.error("Error: Account name is required");
					console.log("Usage: ccflare-cli pause <name>");
					process.exit(1);
				}

				const result = pauseAccount(dbOps, name);
				console.log(result.message);
				if (!result.success) {
					process.exit(1);
				}
				break;
			}

			case "resume": {
				const name = positionals[1];
				if (!name) {
					console.error("Error: Account name is required");
					console.log("Usage: ccflare-cli resume <name>");
					process.exit(1);
				}

				const result = resumeAccount(dbOps, name);
				console.log(result.message);
				if (!result.success) {
					process.exit(1);
				}
				break;
			}

			case "analyze": {
				const db = dbOps.getDatabase();
				analyzePerformance(db);
				break;
			}

			default: {
				console.log(getHelpText());
				if (command && command !== "help") {
					console.error(`\nError: Unknown command '${command}'`);
					process.exit(1);
				}
				break;
			}
		}
	} catch (error) {
		console.error(`Error: ${error instanceof Error ? error.message : error}`);
		process.exit(1);
	} finally {
		// Always shutdown resources
		await shutdown();
	}
}

================
File: packages/cli-commands/src/utils/browser.ts
================
import { spawn } from "node:child_process";
import open from "open";

/**
 * Try to open the user's default browser with the given URL.
 * Returns true on success, false otherwise.
 */
export async function openBrowser(url: string): Promise<boolean> {
	try {
		await open(url, { wait: false });
		return true;
	} catch (_err) {
		// Fallback â€“ Windows quoting is critical!
		try {
			if (process.platform === "win32") {
				// Use powershell -Command Start-Process 'url'
				spawn(
					"powershell.exe",
					["-NoProfile", "-Command", "Start-Process", `'${url}'`],
					{
						detached: true,
						stdio: "ignore",
					},
				).unref();
			} else if (process.platform === "darwin") {
				spawn("open", [url], { detached: true, stdio: "ignore" }).unref();
			} else {
				// Linux generic fallback
				spawn("xdg-open", [url], { detached: true, stdio: "ignore" }).unref();
			}
			return true;
		} catch {
			return false;
		}
	}
}

================
File: packages/cli-commands/src/prompts/std-adapter.ts
================
import type { PromptAdapter } from "./adapter";

/**
 * Standard prompt adapter using blocking prompt() calls
 */
export class StdPromptAdapter implements PromptAdapter {
	async select<T extends string | number>(
		question: string,
		options: Array<{ label: string; value: T }>,
	): Promise<T> {
		console.log(question);
		options.forEach((option, index) => {
			console.log(`${index + 1}) ${option.label}`);
		});

		const choice = prompt(`Enter your choice (${1}-${options.length}): `);
		const index = parseInt(choice || "", 10) - 1;

		if (index < 0 || index >= options.length || Number.isNaN(index)) {
			throw new Error(
				`Invalid choice. Please enter a number between 1 and ${options.length}.`,
			);
		}

		return options[index].value;
	}

	async input(question: string, _mask?: boolean): Promise<string> {
		// Note: Bun's prompt() doesn't support masking, so we ignore the mask parameter
		const answer = prompt(question);
		if (!answer) {
			throw new Error("Input is required");
		}
		return answer;
	}

	async confirm(question: string): Promise<boolean> {
		const answer = prompt(`${question} (y/n): `);
		return answer?.toLowerCase().startsWith("y") || false;
	}
}

// Export singleton instance
export const stdPromptAdapter = new StdPromptAdapter();

================
File: packages/cli-commands/src/prompts/adapter.ts
================
/**
 * Prompt adapter interface for abstracting user input collection
 */
export interface PromptAdapter {
	/**
	 * Present a selection menu to the user
	 * @param question The question to ask
	 * @param options Array of options with label and value
	 * @returns Promise resolving to the selected value
	 */
	select<T extends string | number>(
		question: string,
		options: Array<{ label: string; value: T }>,
	): Promise<T>;

	/**
	 * Get text input from the user
	 * @param question The question to ask
	 * @param mask Whether to mask the input (for passwords)
	 * @returns Promise resolving to the entered text
	 */
	input(question: string, mask?: boolean): Promise<string>;

	/**
	 * Get a yes/no confirmation from the user
	 * @param question The question to ask
	 * @returns Promise resolving to true if confirmed, false otherwise
	 */
	confirm(question: string): Promise<boolean>;
}

================
File: packages/cli-commands/src/prompts/index.ts
================
import { stdPromptAdapter } from "./std-adapter";

// Re-export adapter types
export type { PromptAdapter } from "./adapter";
export { StdPromptAdapter, stdPromptAdapter } from "./std-adapter";

/**
 * Prompt user to select account mode
 */
export async function promptAccountMode(): Promise<"max" | "console"> {
	return stdPromptAdapter.select(
		"What type of account would you like to add?",
		[
			{ label: "Claude Max account", value: "max" },
			{ label: "Claude Console account", value: "console" },
		],
	);
}

/**
 * Prompt user to select account tier
 */
export async function promptAccountTier(): Promise<1 | 5 | 20> {
	return stdPromptAdapter.select(
		"Select the tier for this account (used for weighted load balancing):",
		[
			{ label: "1x tier (default free account)", value: 1 },
			{ label: "5x tier (paid account)", value: 5 },
			{ label: "20x tier (enterprise account)", value: 20 },
		],
	);
}

/**
 * Prompt user to enter authorization code
 */
export async function promptAuthorizationCode(): Promise<string> {
	return stdPromptAdapter.input("\nEnter the authorization code: ");
}

/**
 * Prompt user to confirm account removal
 */
export async function promptAccountRemovalConfirmation(
	accountName: string,
): Promise<boolean> {
	console.log(
		`\n⚠️  WARNING: You are about to remove the account '${accountName}'`,
	);
	console.log("This action cannot be undone.");
	console.log("\nTo confirm, please type the account name exactly:");

	const confirmation = prompt(`Type '${accountName}' to confirm deletion: `);

	if (!confirmation) {
		return false;
	}

	return confirmation === accountName;
}

================
File: packages/cli-commands/src/commands/account.ts
================
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import { createOAuthFlow } from "@ccflare/oauth-flow";
import type { AccountListItem } from "@ccflare/types";
import {
	type PromptAdapter,
	promptAccountRemovalConfirmation,
	stdPromptAdapter,
} from "../prompts/index";
import { openBrowser } from "../utils/browser";

// Re-export types with adapter extension for CLI-specific options
export interface AddAccountOptions {
	name: string;
	mode?: "max" | "console";
	tier?: 1 | 5 | 20;
	adapter?: PromptAdapter;
}

// Re-export AccountListItem from types for backward compatibility
export type { AccountListItem } from "@ccflare/types";

// Add mode property to AccountListItem for CLI display
export interface AccountListItemWithMode extends AccountListItem {
	mode: "max" | "console";
}

/**
 * Add a new account using OAuth flow
 */
export async function addAccount(
	dbOps: DatabaseOperations,
	config: Config,
	options: AddAccountOptions,
): Promise<void> {
	const {
		name,
		mode: providedMode,
		tier: providedTier,
		adapter = stdPromptAdapter,
	} = options;

	// Create OAuth flow instance
	const oauthFlow = await createOAuthFlow(dbOps, config);

	// Prompt for mode if not provided
	const mode =
		providedMode ||
		(await adapter.select("What type of account would you like to add?", [
			{ label: "Claude Max account", value: "max" },
			{ label: "Claude Console account", value: "console" },
		]));

	// Begin OAuth flow
	const flowResult = await oauthFlow.begin({
		name,
		mode: mode as "max" | "console",
	});
	const { authUrl, sessionId } = flowResult;

	// Open browser and prompt for code
	console.log(`\nOpening browser to authenticate...`);
	console.log(`URL: ${authUrl}`);
	const browserOpened = await openBrowser(authUrl);
	if (!browserOpened) {
		console.log(
			`\nFailed to open browser automatically. Please manually open the URL above.`,
		);
	}

	// Get authorization code
	const code = await adapter.input("\nEnter the authorization code: ");

	// Get tier for Max accounts
	const tier =
		mode === "max"
			? providedTier ||
				(await adapter.select(
					"Select the tier for this account (used for weighted load balancing):",
					[
						{ label: "1x tier (default free account)", value: 1 },
						{ label: "5x tier (paid account)", value: 5 },
						{ label: "20x tier (enterprise account)", value: 20 },
					],
				))
			: 1;

	// Complete OAuth flow
	console.log("\nExchanging code for tokens...");
	const _account = await oauthFlow.complete(
		{ sessionId, code, tier, name },
		flowResult,
	);

	console.log(`\nAccount '${name}' added successfully!`);
	console.log(`Type: ${mode === "max" ? "Claude Max" : "Claude Console"}`);
	console.log(`Tier: ${tier}x`);
}

/**
 * Get list of all accounts with formatted information
 */
export function getAccountsList(dbOps: DatabaseOperations): AccountListItem[] {
	const accounts = dbOps.getAllAccounts();
	const now = Date.now();

	return accounts.map((account) => {
		const tierDisplay = `${account.account_tier}x`;
		const tokenStatus =
			account.expires_at && account.expires_at > now ? "valid" : "expired";

		let rateLimitStatus = "OK";
		if (account.paused) {
			rateLimitStatus = "Paused";
		} else if (account.rate_limited_until && account.rate_limited_until > now) {
			const minutesLeft = Math.ceil((account.rate_limited_until - now) / 60000);
			rateLimitStatus = `Rate limited (${minutesLeft}m)`;
		}

		let sessionInfo = "-";
		if (account.session_start) {
			const sessionAge = Math.floor((now - account.session_start) / 60000);
			sessionInfo = `${account.session_request_count} reqs, ${sessionAge}m ago`;
		}

		return {
			id: account.id,
			name: account.name,
			provider: account.provider,
			tierDisplay,
			created: new Date(account.created_at),
			lastUsed: account.last_used ? new Date(account.last_used) : null,
			requestCount: account.request_count,
			totalRequests: account.total_requests,
			paused: account.paused,
			tokenStatus,
			rateLimitStatus,
			sessionInfo,
			tier: account.account_tier || 1,
			mode: account.account_tier > 1 ? "max" : "console",
		};
	});
}

/**
 * Remove an account by name
 */
export function removeAccount(
	dbOps: DatabaseOperations,
	name: string,
): { success: boolean; message: string } {
	const db = dbOps.getDatabase();
	const result = db.run("DELETE FROM accounts WHERE name = ?", [name]);

	if (result.changes === 0) {
		return {
			success: false,
			message: `Account '${name}' not found`,
		};
	}

	return {
		success: true,
		message: `Account '${name}' removed successfully`,
	};
}

/**
 * Remove an account by name with confirmation prompt (for CLI)
 */
export async function removeAccountWithConfirmation(
	dbOps: DatabaseOperations,
	name: string,
	force?: boolean,
): Promise<{ success: boolean; message: string }> {
	// Check if account exists first
	const accounts = dbOps.getAllAccounts();
	const exists = accounts.some((a) => a.name === name);

	if (!exists) {
		return {
			success: false,
			message: `Account '${name}' not found`,
		};
	}

	// Skip confirmation if force flag is set
	if (!force) {
		const confirmed = await promptAccountRemovalConfirmation(name);
		if (!confirmed) {
			return {
				success: false,
				message: "Account removal cancelled",
			};
		}
	}

	return removeAccount(dbOps, name);
}

/**
 * Toggle account pause state (shared logic for pause/resume)
 */
function toggleAccountPause(
	dbOps: DatabaseOperations,
	name: string,
	shouldPause: boolean,
): { success: boolean; message: string } {
	const db = dbOps.getDatabase();

	// Get account ID by name
	const account = db
		.query<{ id: string; paused: 0 | 1 }, [string]>(
			"SELECT id, COALESCE(paused, 0) as paused FROM accounts WHERE name = ?",
		)
		.get(name);

	if (!account) {
		return {
			success: false,
			message: `Account '${name}' not found`,
		};
	}

	const isPaused = account.paused === 1;
	const _action = shouldPause ? "pause" : "resume";
	const actionPast = shouldPause ? "paused" : "resumed";

	if (isPaused === shouldPause) {
		return {
			success: false,
			message: `Account '${name}' is already ${actionPast}`,
		};
	}

	if (shouldPause) {
		dbOps.pauseAccount(account.id);
	} else {
		dbOps.resumeAccount(account.id);
	}

	return {
		success: true,
		message: `Account '${name}' ${actionPast} successfully`,
	};
}

/**
 * Pause an account by name
 */
export function pauseAccount(
	dbOps: DatabaseOperations,
	name: string,
): { success: boolean; message: string } {
	return toggleAccountPause(dbOps, name, true);
}

/**
 * Resume a paused account by name
 */
export function resumeAccount(
	dbOps: DatabaseOperations,
	name: string,
): { success: boolean; message: string } {
	return toggleAccountPause(dbOps, name, false);
}

================
File: packages/cli-commands/src/commands/analyze.ts
================
import type { Database } from "bun:sqlite";
import { TIME_CONSTANTS } from "@ccflare/core";
import { analyzeIndexUsage } from "@ccflare/database";

/**
 * Analyze query performance and index usage
 */
export function analyzePerformance(db: Database): void {
	console.log("\n=== Database Performance Analysis ===\n");

	// Basic index usage analysis
	analyzeIndexUsage(db);

	// Show detailed query performance for common patterns
	console.log("\n=== Query Performance Metrics ===\n");

	const performanceQueries = [
		{
			name: "Recent requests (last 24h)",
			query: `
				SELECT COUNT(*) as count 
				FROM requests 
				WHERE timestamp > ?
			`,
			params: [Date.now() - TIME_CONSTANTS.DAY],
		},
		{
			name: "Active accounts",
			query: `
				SELECT COUNT(*) as count 
				FROM accounts 
				WHERE paused = 0
			`,
			params: [],
		},
		{
			name: "Model usage distribution",
			query: `
				SELECT model, COUNT(*) as count 
				FROM requests 
				WHERE model IS NOT NULL AND timestamp > ? 
				GROUP BY model 
				ORDER BY count DESC 
				LIMIT 5
			`,
			params: [Date.now() - TIME_CONSTANTS.DAY],
		},
	];

	for (const test of performanceQueries) {
		try {
			const start = performance.now();
			const stmt = db.prepare(test.query);
			const result = stmt.all(...test.params);
			const duration = performance.now() - start;

			console.log(`${test.name}:`);
			console.log(`  Time: ${duration.toFixed(2)}ms`);
			console.log(`  Results: ${JSON.stringify(result)}\n`);
		} catch (error) {
			console.error(`${test.name}: Error - ${error}`);
		}
	}

	// Check if statistics need updating
	console.log("=== Index Optimization Status ===\n");

	// Get last ANALYZE time
	const lastAnalyze = db
		.prepare(`
		SELECT * FROM sqlite_stat1 LIMIT 1
	`)
		.get();

	if (!lastAnalyze) {
		console.log("⚠️  No index statistics found. Running ANALYZE...");
		db.exec("ANALYZE");
		console.log("✓ Index statistics updated");
	} else {
		console.log("✓ Index statistics are available");
	}

	// Show index coverage
	const indexedColumns = db
		.prepare(`
		SELECT 
			m.tbl_name as table_name,
			COUNT(DISTINCT m.name) as index_count
		FROM sqlite_master m
		WHERE m.type = 'index' 
			AND m.name NOT LIKE 'sqlite_%'
			AND m.sql IS NOT NULL
		GROUP BY m.tbl_name
	`)
		.all() as Array<{ table_name: string; index_count: number }>;

	console.log("\n=== Index Coverage ===\n");
	for (const table of indexedColumns) {
		console.log(`${table.table_name}: ${table.index_count} indexes`);
	}

	console.log("\n✓ Analysis complete");
}

================
File: packages/cli-commands/src/commands/help.ts
================
/**
 * Get help text for CLI commands
 */
export function getHelpText(): string {
	return `
Usage: ccflare-cli <command> [options]

Commands:
  add <name> [--mode <max|console>] [--tier <1|5|20>]
    Add a new account using OAuth
    --mode: Account type (optional, will prompt if not provided)
    --tier: Account tier (1, 5, or 20) (optional, will prompt for Max accounts)

  list
    List all accounts with their details

  remove <name> [--force]
    Remove an account
    --force: Skip confirmation prompt

  pause <name>
    Pause an account to exclude it from load balancing

  resume <name>
    Resume a paused account to include it in load balancing

  reset-stats
    Reset request counts for all accounts

  clear-history
    Clear request history

  analyze
    Analyze database performance and index usage

  help
    Show this help message

Examples:
  ccflare-cli add myaccount --mode max --tier 5
  ccflare-cli list
  ccflare-cli remove myaccount
  ccflare-cli pause myaccount
  ccflare-cli resume myaccount
`;
}

================
File: packages/cli-commands/src/commands/stats.ts
================
import type { Database } from "bun:sqlite";

/**
 * Reset all account statistics
 */
export function resetAllStats(db: Database): void {
	db.run(
		"UPDATE accounts SET request_count = 0, session_start = NULL, session_request_count = 0",
	);
}

/**
 * Clear all request history
 */
export function clearRequestHistory(db: Database): { count: number } {
	const result = db.run("DELETE FROM requests");
	return { count: result.changes };
}

================
File: packages/oauth-flow/package.json
================
{
	"name": "@ccflare/oauth-flow",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/index.ts",
	"scripts": {
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/config": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/providers": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}

================
File: packages/oauth-flow/src/index.ts
================
import type { Config } from "@ccflare/config";
import type { DatabaseOperations } from "@ccflare/database";
import {
	generatePKCE,
	getOAuthProvider,
	type OAuthProviderConfig,
	type OAuthTokens,
	type PKCEChallenge,
} from "@ccflare/providers";
import type { AccountTier } from "@ccflare/types";

export interface BeginOptions {
	name: string;
	mode: "max" | "console";
}

export interface BeginResult {
	sessionId: string;
	authUrl: string;
	pkce: PKCEChallenge;
	oauthConfig: OAuthProviderConfig;
	mode: "max" | "console"; // Track mode to handle differently in complete()
}

export interface CompleteOptions {
	sessionId: string;
	code: string;
	tier?: AccountTier;
	name: string; // Required to properly create the account
}

export interface AccountCreated {
	id: string;
	name: string;
	tier: number;
	provider: "anthropic";
	authType: "oauth" | "api_key"; // Track authentication type
}

export interface OAuthFlowResult {
	success: boolean;
	message: string;
	data?: AccountCreated;
}

/**
 * Handles the Anthropic OAuth flow for both "max" and "console" authentication modes.
 *
 * - "max" mode: Standard OAuth with refresh tokens for Claude Max accounts
 * - "console" mode: OAuth flow that creates a static API key
 *
 * This class does not persist session data. The caller must handle storage
 * between {@link begin} and {@link complete} calls.
 */
export class OAuthFlow {
	constructor(
		private dbOps: DatabaseOperations,
		private config: Config,
	) {}

	/**
	 * Starts an Anthropic OAuth flow.
	 *
	 * The caller MUST persist the returned `sessionId`, `pkce.verifier`,
	 * `mode`, and `tier` so that {@link complete} can validate the callback.
	 *
	 * @param opts - OAuth flow options
	 * @param opts.name - Unique account name
	 * @param opts.mode - Authentication mode ("max" for Claude Max, "console" for API key)
	 * @returns OAuth flow data including auth URL and session info
	 * @throws {Error} If account name already exists
	 */
	async begin(opts: BeginOptions): Promise<BeginResult> {
		const { name, mode } = opts;

		// Check if account already exists
		const existingAccounts = this.dbOps.getAllAccounts();
		if (existingAccounts.some((a) => a.name === name)) {
			throw new Error(`Account with name '${name}' already exists`);
		}

		// Get OAuth provider
		const oauthProvider = getOAuthProvider("anthropic");
		if (!oauthProvider) {
			throw new Error("Anthropic OAuth provider not found");
		}

		// Generate PKCE challenge
		const pkce = await generatePKCE();

		// Get OAuth config with runtime client ID
		const runtime = this.config.getRuntime();
		const oauthConfig = oauthProvider.getOAuthConfig(mode);
		oauthConfig.clientId = runtime.clientId;

		// Generate auth URL
		const authUrl = oauthProvider.generateAuthUrl(oauthConfig, pkce);

		// Create session ID for this OAuth flow
		const sessionId = crypto.randomUUID();

		// NOTE: OAuthFlow itself does not persist the session.
		//       The caller (HTTP-API oauth-init handler) must
		//       store {sessionId, verifier, mode, tier} â€“ typically
		//       via DatabaseOperations.createOAuthSession().

		return {
			sessionId,
			authUrl,
			pkce,
			oauthConfig,
			mode,
		};
	}

	/**
	 * Completes the Anthropic OAuth flow after user authorization.
	 *
	 * Exchanges the authorization code for tokens and creates the account.
	 * For "console" mode, creates an API key instead of storing OAuth tokens.
	 *
	 * @param opts - Completion options
	 * @param opts.sessionId - Session ID from {@link begin}
	 * @param opts.code - Authorization code from OAuth callback
	 * @param opts.tier - Account tier (1, 5, or 20)
	 * @param opts.name - Account name (must match the one from begin)
	 * @param flowData - Flow data returned from {@link begin}
	 * @returns Created account information
	 * @throws {Error} If OAuth provider not found or token exchange fails
	 */
	async complete(
		opts: CompleteOptions,
		flowData: BeginResult,
	): Promise<AccountCreated> {
		const { code, tier = 1, name } = opts;

		// Get OAuth provider
		const oauthProvider = getOAuthProvider("anthropic");
		if (!oauthProvider) {
			throw new Error("Anthropic OAuth provider not found");
		}

		// Exchange authorization code for tokens
		const tokens = await oauthProvider.exchangeCode(
			code,
			flowData.pkce.verifier,
			flowData.oauthConfig,
		);

		const accountId = crypto.randomUUID();

		// Handle console mode - create API key
		if (flowData.mode === "console" || !tokens.refreshToken) {
			const apiKey = await this.createAnthropicApiKey(tokens.accessToken);
			return this.createAccountWithApiKey(accountId, name, apiKey, tier);
		}

		// Handle max mode - standard OAuth flow
		return this.createAccountWithOAuth(accountId, name, tokens, tier);
	}

	/**
	 * Creates an API key using the Anthropic console endpoint.
	 *
	 * This is used for "console" mode accounts where users want a static API key
	 * instead of OAuth tokens that need refreshing.
	 *
	 * @param accessToken - Temporary access token from OAuth flow
	 * @returns The newly created API key
	 * @throws {Error} If API key creation fails
	 */
	private async createAnthropicApiKey(accessToken: string): Promise<string> {
		const response = await fetch(
			"https://api.anthropic.com/api/oauth/claude_cli/create_api_key",
			{
				method: "POST",
				headers: {
					Authorization: `Bearer ${accessToken}`,
					"Content-Type": "application/x-www-form-urlencoded",
					Accept: "application/json, text/plain, */*",
				},
			},
		);

		if (!response.ok) {
			throw new Error(`Failed to create API key: ${response.statusText}`);
		}

		const json = (await response.json()) as { raw_key: string };
		return json.raw_key;
	}

	/**
	 * Creates an account with OAuth tokens (max mode).
	 *
	 * Stores refresh token, access token, and expiration for automatic token refresh.
	 *
	 * @param id - Unique account ID
	 * @param name - Account name
	 * @param tokens - OAuth tokens from token exchange
	 * @param tier - Account tier (1, 5, or 20)
	 * @returns Created account information
	 */
	private createAccountWithOAuth(
		id: string,
		name: string,
		tokens: OAuthTokens,
		tier: AccountTier,
	): AccountCreated {
		const db = this.dbOps.getDatabase();

		db.run(
			`
			INSERT INTO accounts (
				id, name, provider, api_key, refresh_token, access_token, expires_at, 
				created_at, request_count, total_requests, account_tier
			) VALUES (?, ?, ?, NULL, ?, ?, ?, ?, 0, 0, ?)
			`,
			[
				id,
				name,
				"anthropic",
				tokens.refreshToken || "",
				tokens.accessToken,
				tokens.expiresAt,
				Date.now(),
				tier,
			],
		);

		return {
			id,
			name,
			tier,
			provider: "anthropic",
			authType: "oauth",
		};
	}

	/**
	 * Creates an account with API key (console mode).
	 *
	 * Stores only the API key, no OAuth tokens. These accounts don't require
	 * token refresh but cannot be refreshed if the API key is revoked.
	 *
	 * @param id - Unique account ID
	 * @param name - Account name
	 * @param apiKey - API key from Anthropic console
	 * @param tier - Account tier (1, 5, or 20)
	 * @returns Created account information
	 */
	private createAccountWithApiKey(
		id: string,
		name: string,
		apiKey: string,
		tier: AccountTier,
	): AccountCreated {
		const db = this.dbOps.getDatabase();

		db.run(
			`
			INSERT INTO accounts (
				id, name, provider, api_key, refresh_token, access_token, expires_at, 
				created_at, request_count, total_requests, account_tier
			) VALUES (?, ?, ?, ?, NULL, NULL, NULL, ?, 0, 0, ?)
			`,
			[id, name, "anthropic", apiKey, Date.now(), tier],
		);

		return {
			id,
			name,
			tier,
			provider: "anthropic",
			authType: "api_key",
		};
	}
}

// Helper function for simpler usage
export async function createOAuthFlow(
	dbOps: DatabaseOperations,
	config: Config,
): Promise<OAuthFlow> {
	return new OAuthFlow(dbOps, config);
}

================
File: apps/lander/package.json
================
{
	"name": "@ccflare/lander",
	"version": "1.0.0",
	"description": "Landing page for ccflare - The ultimate Claude Code proxy for power users",
	"private": true,
	"scripts": {
		"build": "mkdir -p dist && cp -r src/* dist/",
		"preview": "bunx serve src"
	},
	"keywords": [
		"ccflare",
		"landing-page",
		"static-site"
	],
	"author": "snipeship",
	"license": "MIT"
}

================
File: apps/lander/src/index.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ccflare - The Ultimate Claude Code Proxy for Power Users</title>
    <meta name="description" content="Track every request. Go low-level. Never hit rate limits again. The ultimate Claude Code proxy with full visibility and control over your API usage.">
    
    <!-- SEO Meta Tags -->
    <meta name="keywords" content="Claude API proxy, Claude rate limit, Claude load balancer, Anthropic API proxy, Claude API analytics, Claude token tracking, Claude cost monitoring, Claude failover, Claude API monitoring, Claude request tracking, Claude debugging, Claude API management, Claude multiple accounts, Claude API gateway, Claude proxy server">
    <meta name="author" content="ccflare">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="revisit-after" content="7 days">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ccflare.com/">
    <meta property="og:title" content="ccflare - Never Hit Claude API Rate Limits Again">
    <meta property="og:description" content="The ultimate Claude API proxy with intelligent load balancing, request-level analytics, and real-time monitoring. Track every token, analyze costs, debug everything.">
    <meta property="og:image" content="https://ccflare.com/screenshot-analytics.png">
    <meta property="og:site_name" content="ccflare">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ccflare.com/">
    <meta name="twitter:title" content="ccflare - Never Hit Claude API Rate Limits Again">
    <meta name="twitter:description" content="The ultimate Claude API proxy with intelligent load balancing, request-level analytics, and real-time monitoring.">
    <meta name="twitter:image" content="https://ccflare.com/screenshot-analytics.png">
    
    <!-- Additional SEO -->
    <link rel="canonical" href="https://ccflare.com/">
    <meta name="theme-color" content="#F38020">
    
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "ccflare",
        "applicationCategory": "DeveloperApplication",
        "operatingSystem": "Windows, macOS, Linux",
        "description": "Claude API proxy with intelligent load balancing, request-level analytics, and rate limit management",
        "url": "https://ccflare.com",
        "author": {
            "@type": "Organization",
            "name": "ccflare"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "5",
            "ratingCount": "100"
        },
        "keywords": "Claude API proxy, rate limiting, load balancer, API analytics, token tracking"
    }
    </script>
</head>
<body>
    <div class="grain"></div>
    
    <header class="header">
        <nav class="nav-container">
            <div class="logo-wrapper">
                <div class="logo-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L3 7V12C3 16.55 6.84 20.74 12 22C17.16 20.74 21 16.55 21 12V7L12 2Z" fill="#F38020"/>
                    </svg>
                </div>
                <span class="logo-text">ccflare</span>
            </div>
            <div class="nav-links">
                <a href="#features">Features</a>
                <a href="#performance">Performance</a>
                <a href="#pricing">Pricing</a>
                <a href="https://github.com/snipeship/ccflare" target="_blank" class="github-link">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z"/>
                    </svg>
                    <span>GitHub</span>
                </a>
            </div>
        </nav>
    </header>

    <main>
        <section class="hero">
            <div class="hero-background"></div>
            <div class="hero-container">
                <div class="hero-content">
                    <div class="hero-badge">For Power Users</div>
                    <h1 class="hero-title">
                        Track Every Request.<br>
                        <span class="gradient-text">Go Low-Level.</span>
                    </h1>
                    <p class="hero-subtitle">
                        Never hit Claude API rate limits again. One command gives you a full Anthropic API proxy server, 
                        real-time token analytics, and intelligent load balancing across multiple accounts. It's really that simple.
                    </p>
                    <div class="hero-actions">
                        <a href="#get-started" class="btn btn-primary">
                            <span>Get Started</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                        </a>
                        <a href="https://github.com/snipeship/ccflare" class="btn btn-secondary" target="_blank">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.603-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z"/>
                            </svg>
                            <span>Star on GitHub</span>
                        </a>
                    </div>
                    <div class="hero-stats">
                        <div class="stat">
                            <span class="stat-value">99.9%</span>
                            <span class="stat-label">Uptime</span>
                        </div>
                        <div class="stat-divider"></div>
                        <div class="stat">
                            <span class="stat-value">&lt;10ms</span>
                            <span class="stat-label">Overhead</span>
                        </div>
                        <div class="stat-divider"></div>
                        <div class="stat">
                            <span class="stat-value">‚àû</span>
                            <span class="stat-label">Scale</span>
                        </div>
                    </div>
                </div>
                <div class="hero-screenshot">
                    <div class="hero-screenshot-wrapper">
                        <img src="screenshot-analytics.png" alt="Claude API analytics dashboard - real-time token usage tracking, cost monitoring, and request analytics for Anthropic API" loading="eager">
                        <div class="hero-screenshot-glow"></div>
                    </div>
                </div>
            </div>
        </section>

        <section id="features" class="features">
            <div class="container">
                <div class="section-header">
                    <h2>Built for Power Users</h2>
                    <p>Everything you need to take control of your Claude API usage</p>
                </div>
                <div class="features-grid">
                    <div class="feature-card featured">
                        <div class="feature-icon">
                            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 12h-4l-3 9L9 3l-3 9H2"/>
                            </svg>
                        </div>
                        <h3>Request-Level Claude API Tracking</h3>
                        <p>Monitor every Anthropic API call with millisecond precision. Track Claude token usage, API costs, latency, and success rates in real-time.</p>
                        <div class="feature-stats">
                            <div class="feature-stat">
                                <span class="stat-number">< 10ms</span>
                                <span class="stat-label">Overhead</span>
                            </div>
                            <div class="feature-stat">
                                <span class="stat-number">100%</span>
                                <span class="stat-label">Coverage</span>
                            </div>
                        </div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="2" y="3" width="20" height="14" rx="2" ry="2"/>
                                <line x1="8" y1="21" x2="16" y2="21"/>
                                <line x1="12" y1="17" x2="12" y2="21"/>
                            </svg>
                        </div>
                        <h3>Real-time Dashboard</h3>
                        <p>Live analytics with account health, rate limit status, and usage patterns at your fingertips.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
                            </svg>
                        </div>
                        <h3>Deep Debugging</h3>
                        <p>Full request/response logging, error traces, and diagnostics. Know exactly what's happening.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 20v-6m0 0v-6m0 6h6m-6 0H6"/>
                                <circle cx="12" cy="12" r="10"/>
                            </svg>
                        </div>
                        <h3>Fine-grained Control</h3>
                        <p>Set custom rate limits, quotas, and priorities per account. Control every aspect.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/>
                            </svg>
                        </div>
                        <h3>Smart Routing</h3>
                        <p>Multiple load balancing strategies. Automatic failover. Your proxy, your rules.</p>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                            </svg>
                        </div>
                        <h3>Zero Downtime</h3>
                        <p>Seamless account failover. Never lose a request. Track everything that happens.</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="screenshots" class="screenshots">
            <div class="container-wide">
                <div class="section-header">
                    <h2>See It In Action</h2>
                    <p>Powerful analytics and monitoring at your fingertips</p>
                </div>
                
                <!-- Main Featured Screenshot -->
                <div class="screenshot-hero">
                    <div class="screenshot-hero-content">
                        <div class="screenshot-hero-text">
                            <h3>Powerful Analytics at Your Fingertips</h3>
                            <p>Track every request, monitor token usage, and analyze costs in real-time. Get deep insights into your API usage patterns with beautiful, actionable analytics.</p>
                            <div class="screenshot-features">
                                <div class="screenshot-feature">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span>Token usage tracking</span>
                                </div>
                                <div class="screenshot-feature">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span>Cost analysis per model</span>
                                </div>
                                <div class="screenshot-feature">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="20 6 9 17 4 12"/>
                                    </svg>
                                    <span>Response time metrics</span>
                                </div>
                            </div>
                        </div>
                        <div class="screenshot-hero-image">
                            <img src="screenshot-analytics.png" alt="Claude API analytics - token usage, cost tracking, and request monitoring for Anthropic Claude" loading="lazy">
                        </div>
                    </div>
                </div>

                <!-- Secondary Screenshots Grid -->
                <div class="screenshots-secondary">
                    <div class="screenshot-card-large">
                        <div class="screenshot-card-header">
                            <h3>Real-time Dashboard</h3>
                            <p>Monitor all accounts, request rates, and system health in one unified view</p>
                        </div>
                        <div class="screenshot-wrapper-large">
                            <img src="screenshot-dashboard.png" alt="Claude API proxy dashboard - monitor multiple accounts, rate limits, and API health in real-time" loading="lazy">
                        </div>
                    </div>
                    <div class="screenshot-card-large">
                        <div class="screenshot-card-header">
                            <h3>Debug Console</h3>
                            <p>Full request/response logging with error traces and diagnostics</p>
                        </div>
                        <div class="screenshot-wrapper-large">
                            <img src="screenshot-logs.png" alt="Claude API debug console - request/response logs, error tracking, and API diagnostics" loading="lazy">
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="performance" class="performance">
            <div class="container">
                <div class="section-header">
                    <h2>Track Everything. Miss Nothing.</h2>
                    <p>Real-time insights into your Claude API usage</p>
                </div>
                <div class="performance-grid">
                    <div class="performance-card">
                        <div class="performance-metric">
                            <span class="metric-value">10M+</span>
                            <span class="metric-label">Requests Handled</span>
                        </div>
                        <div class="performance-chart">
                            <div class="chart-bar" style="height: 40%"></div>
                            <div class="chart-bar" style="height: 60%"></div>
                            <div class="chart-bar" style="height: 80%"></div>
                            <div class="chart-bar" style="height: 100%"></div>
                            <div class="chart-bar" style="height: 90%"></div>
                        </div>
                    </div>
                    <div class="performance-card">
                        <div class="performance-metric">
                            <span class="metric-value">0</span>
                            <span class="metric-label">Rate Limit Errors</span>
                        </div>
                        <div class="performance-icon success">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                        </div>
                    </div>
                    <div class="performance-card">
                        <div class="performance-metric">
                            <span class="metric-value">99.99%</span>
                            <span class="metric-label">API Availability</span>
                        </div>
                        <div class="uptime-indicator">
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                            <div class="uptime-bar"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="get-started" class="get-started">
            <div class="container">
                <div class="section-header">
                    <h2>One Command. Everything You Need.</h2>
                    <p>Seriously, it's this simple</p>
                </div>
                <div class="hero-code-block">
                    <div class="code-block large">
                        <pre><code># Clone, install, and run - that's it!
git clone https://github.com/snipeship/ccflare
cd ccflare
bun install
<span class="highlight">bun run ccflare</span></code></pre>
                    </div>
                    <div class="command-benefits">
                        <h3>That single command gives you:</h3>
                        <ul>
                            <li>‚úÖ Full proxy server on port 8080</li>
                            <li>‚úÖ Interactive TUI for monitoring</li>
                            <li>‚úÖ Web dashboard at http://localhost:8080/dashboard</li>
                            <li>‚úÖ Real-time analytics and request logs</li>
                            <li>‚úÖ Automatic rate limit handling</li>
                        </ul>
                    </div>
                </div>
                <div class="steps-grid">
                    <div class="step-card">
                        <div class="step-number">01</div>
                        <h3>Add Your Accounts</h3>
                        <div class="code-block">
                            <pre><code># In another terminal
bun cli add work-account
bun cli add personal-account</code></pre>
                        </div>
                    </div>
                    <div class="step-card">
                        <div class="step-number">02</div>
                        <h3>Configure Claude</h3>
                        <div class="code-block">
                            <pre><code># Point Claude to your proxy
export ANTHROPIC_BASE_URL=http://localhost:8080</code></pre>
                        </div>
                    </div>
                    <div class="step-card">
                        <div class="step-number">03</div>
                        <h3>Never Hit Rate Limits</h3>
                        <div class="code-block">
                            <pre><code># Just use Claude normally
# ccflare handles the rest! üöÄ</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section id="pricing" class="pricing">
            <div class="container">
                <div class="section-header">
                    <h2>Open Source. Full Control.</h2>
                    <p>Run it yourself. Modify it. Own your infrastructure.</p>
                </div>
                <div class="pricing-card">
                    <div class="pricing-header">
                        <h3>No Bullshit Edition</h3>
                        <div class="price">
                            <span class="currency">$</span>
                            <span class="amount">0</span>
                            <span class="period">/forever</span>
                        </div>
                    </div>
                    <ul class="pricing-features">
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Unlimited accounts</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Request-level tracking and analytics</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Low-level debugging and monitoring tools</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Full source code access. MIT licensed. No strings attached.</span>
                        </li>
                        <li>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            <span>Claude support (why do you need customer support when you can fix it yourself?)</span>
                        </li>
                    </ul>
                    <a href="https://github.com/snipeship/ccflare" class="btn btn-primary btn-block" target="_blank">
                        Get Started Now
                    </a>
                </div>
            </div>
        </section>

        <section class="cta">
            <div class="container">
                <div class="cta-content">
                    <h2>Take Control of Your Claude API Usage</h2>
                    <p>Track every Anthropic API request. Monitor rate limits. Never get blocked again with intelligent load balancing.</p>
                    <div class="cta-actions">
                        <a href="https://github.com/snipeship/ccflare" class="btn btn-primary" target="_blank">
                            <span>Get ccflare</span>
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <div class="logo-wrapper">
                        <div class="logo-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 2L3 7V12C3 16.55 6.84 20.74 12 22C17.16 20.74 21 16.55 21 12V7L12 2Z" fill="#F38020"/>
                            </svg>
                        </div>
                        <span class="logo-text">ccflare</span>
                    </div>
                    <p class="footer-tagline">The open-source Claude API proxy for rate limit management and request analytics.</p>
                </div>
                <div class="footer-links">
                    <a href="https://github.com/snipeship/ccflare" target="_blank">GitHub</a>
                    <a href="https://github.com/snipeship/ccflare/issues" target="_blank">Issues</a>
                    <a href="https://github.com/snipeship/ccflare/blob/main/LICENSE" target="_blank">License</a>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 ccflare. Built with ‚ù§Ô∏è for developers who ship.</p>
            </div>
        </div>
    </footer>
</body>
</html>

================
File: apps/lander/src/styles.css
================
:root {
	--cf-orange: #f38020;
	--background: hsl(220 13% 8%);
	--foreground: hsl(0 0% 95%);
	--card: hsl(220 13% 12%);
	--card-foreground: hsl(0 0% 95%);
	--secondary: hsl(220 13% 18%);
	--muted: hsl(220 13% 18%);
	--muted-foreground: hsl(220 9% 55%);
	--border: hsl(220 13% 20%);
	--radius: 0.5rem;
}

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

body {
	font-family:
		"Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
		Ubuntu, sans-serif;
	background-color: var(--background);
	color: var(--foreground);
	line-height: 1.6;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
	overflow-x: hidden;
}

/* Grain overlay */
.grain {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
	opacity: 0.03;
	z-index: 1;
	background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
}

/* Header */
.header {
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	z-index: 50;
	background: rgba(17, 18, 23, 0.8);
	backdrop-filter: blur(10px);
	border-bottom: 1px solid var(--border);
}

.nav-container {
	max-width: 1200px;
	margin: 0 auto;
	padding: 1rem 2rem;
	display: flex;
	justify-content: space-between;
	align-items: center;
}

.logo-wrapper {
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

.logo-icon {
	display: flex;
	align-items: center;
	justify-content: center;
}

.logo-text {
	font-size: 1.25rem;
	font-weight: 600;
	letter-spacing: -0.02em;
}

.nav-links {
	display: flex;
	align-items: center;
	gap: 2rem;
}

.nav-links a {
	color: var(--muted-foreground);
	text-decoration: none;
	font-size: 0.875rem;
	font-weight: 500;
	transition: color 0.2s;
}

.nav-links a:hover {
	color: var(--foreground);
}

.github-link {
	display: flex;
	align-items: center;
	gap: 0.5rem;
	padding: 0.5rem 1rem;
	border: 1px solid var(--border);
	border-radius: var(--radius);
	transition: all 0.2s;
}

.github-link:hover {
	border-color: var(--cf-orange);
	color: var(--cf-orange) !important;
}

/* Hero Section */
.hero {
	position: relative;
	min-height: 100vh;
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 6rem 2rem 4rem;
}

.hero-background {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: radial-gradient(
		ellipse at top,
		rgba(243, 128, 32, 0.1) 0%,
		transparent 50%
	);
	pointer-events: none;
}

.hero-container {
	max-width: 1400px;
	width: 100%;
	display: grid;
	grid-template-columns: 1fr 1.2fr;
	gap: 4rem;
	align-items: center;
	z-index: 2;
	margin: 0 auto;
}

.hero-content {
	text-align: left;
}

/* Hero Screenshot */
.hero-screenshot {
	position: relative;
	width: 100%;
}

.hero-screenshot-wrapper {
	position: relative;
	width: 100%;
	border-radius: var(--radius);
	overflow: hidden;
	box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
	transition: transform 0.3s ease;
	border: 2px solid var(--border);
}

.hero-screenshot-wrapper:hover {
	transform: translateY(-4px) scale(1.02);
	border-color: rgba(243, 128, 32, 0.3);
	box-shadow: 0 30px 60px -15px rgba(0, 0, 0, 0.6);
}

.hero-screenshot-wrapper img {
	width: 100%;
	height: auto;
	display: block;
}

.hero-screenshot-glow {
	position: absolute;
	inset: -50%;
	background: radial-gradient(
		circle,
		rgba(243, 128, 32, 0.4) 0%,
		transparent 70%
	);
	opacity: 0.3;
	pointer-events: none;
	animation: pulse 4s ease-in-out infinite;
}

@keyframes pulse {
	0%,
	100% {
		opacity: 0.2;
		transform: scale(0.8);
	}
	50% {
		opacity: 0.4;
		transform: scale(1);
	}
}

.hero-badge {
	display: inline-block;
	padding: 0.25rem 0.75rem;
	background: rgba(243, 128, 32, 0.2);
	border: 1px solid rgba(243, 128, 32, 0.3);
	border-radius: 9999px;
	font-size: 0.75rem;
	font-weight: 500;
	color: var(--cf-orange);
	margin-bottom: 1.5rem;
}

.hero-title {
	font-size: clamp(3rem, 8vw, 5rem);
	font-weight: 700;
	line-height: 1.1;
	letter-spacing: -0.03em;
	margin-bottom: 1.5rem;
}

.gradient-text {
	background: linear-gradient(135deg, var(--cf-orange) 0%, #f97316 100%);
	-webkit-background-clip: text;
	-webkit-text-fill-color: transparent;
	background-clip: text;
}

.hero-subtitle {
	font-size: 1.25rem;
	color: var(--muted-foreground);
	max-width: 600px;
	margin: 0 0 2.5rem;
	line-height: 1.7;
}

.hero-actions {
	display: flex;
	gap: 1rem;
	justify-content: flex-start;
	margin-bottom: 3rem;
	flex-wrap: wrap;
}

/* Buttons */
.btn {
	display: inline-flex;
	align-items: center;
	gap: 0.5rem;
	padding: 0.75rem 1.5rem;
	border-radius: var(--radius);
	font-weight: 500;
	font-size: 0.875rem;
	text-decoration: none;
	transition: all 0.2s;
	cursor: pointer;
	border: none;
}

.btn-primary {
	background: var(--cf-orange);
	color: white;
}

.btn-primary:hover {
	background: #e67119;
	transform: translateY(-2px);
	box-shadow: 0 10px 20px rgba(243, 128, 32, 0.3);
}

.btn-secondary {
	background: var(--secondary);
	color: var(--foreground);
}

.btn-secondary:hover {
	background: var(--muted);
}

.btn-block {
	width: 100%;
	justify-content: center;
}

/* Hero Stats */
.hero-stats {
	display: flex;
	gap: 3rem;
	justify-content: flex-start;
	align-items: center;
}

.stat {
	text-align: center;
}

.stat-value {
	display: block;
	font-size: 2rem;
	font-weight: 700;
	color: var(--foreground);
	letter-spacing: -0.02em;
}

.stat-label {
	display: block;
	font-size: 0.875rem;
	color: var(--muted-foreground);
	margin-top: 0.25rem;
}

.stat-divider {
	width: 1px;
	height: 40px;
	background: var(--border);
}

/* Container */
.container {
	max-width: 1200px;
	margin: 0 auto;
	padding: 0 2rem;
}

/* Section Header */
.section-header {
	text-align: center;
	margin-bottom: 4rem;
}

.section-header h2 {
	font-size: 2.5rem;
	font-weight: 700;
	margin-bottom: 1rem;
	letter-spacing: -0.02em;
}

.section-header p {
	font-size: 1.125rem;
	color: var(--muted-foreground);
}

/* Features Section */
.features {
	padding: 6rem 0;
}

.features-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
	gap: 2rem;
}

.feature-card {
	background: var(--card);
	padding: 2rem;
	border-radius: var(--radius);
	border: 1px solid var(--border);
	transition: all 0.2s;
}

.feature-card:hover {
	transform: translateY(-4px);
	border-color: rgba(243, 128, 32, 0.3);
	box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
}

.feature-icon {
	width: 48px;
	height: 48px;
	background: rgba(243, 128, 32, 0.1);
	border-radius: var(--radius);
	display: flex;
	align-items: center;
	justify-content: center;
	margin-bottom: 1.5rem;
	color: var(--cf-orange);
}

.feature-card h3 {
	font-size: 1.25rem;
	font-weight: 600;
	margin-bottom: 0.75rem;
}

.feature-card p {
	color: var(--muted-foreground);
	line-height: 1.6;
}

/* Featured Feature Card */
.feature-card.featured {
	grid-column: span 2;
	background: linear-gradient(
		135deg,
		rgba(243, 128, 32, 0.1) 0%,
		rgba(243, 128, 32, 0.05) 100%
	);
	border: 2px solid rgba(243, 128, 32, 0.2);
	position: relative;
	overflow: hidden;
}

.feature-card.featured::before {
	content: "";
	position: absolute;
	top: -2px;
	left: -2px;
	right: -2px;
	bottom: -2px;
	background: linear-gradient(135deg, var(--cf-orange), transparent);
	opacity: 0;
	transition: opacity 0.3s;
	z-index: -1;
}

.feature-card.featured:hover::before {
	opacity: 0.1;
}

.feature-card.featured .feature-icon {
	width: 64px;
	height: 64px;
	background: rgba(243, 128, 32, 0.2);
}

.feature-stats {
	display: flex;
	gap: 2rem;
	margin-top: 1.5rem;
	padding-top: 1.5rem;
	border-top: 1px solid var(--border);
}

.feature-stat {
	display: flex;
	flex-direction: column;
	gap: 0.25rem;
}

.stat-number {
	font-size: 1.5rem;
	font-weight: 700;
	color: var(--cf-orange);
}

.stat-label {
	font-size: 0.875rem;
	color: var(--muted-foreground);
}

/* Screenshots Section */
.screenshots {
	padding: 6rem 0;
	background: rgba(243, 128, 32, 0.03);
}

.container-wide {
	max-width: 1400px;
	margin: 0 auto;
	padding: 0 2rem;
}

/* Featured Screenshot Hero */
.screenshot-hero {
	margin-top: 3rem;
	margin-bottom: 4rem;
}

.screenshot-hero-content {
	display: grid;
	grid-template-columns: 1fr 2fr;
	gap: 4rem;
	align-items: center;
}

.screenshot-hero-text h3 {
	font-size: 2rem;
	font-weight: 700;
	margin-bottom: 1rem;
	color: var(--foreground);
}

.screenshot-hero-text p {
	font-size: 1.125rem;
	color: var(--muted-foreground);
	line-height: 1.8;
	margin-bottom: 2rem;
}

.screenshot-features {
	display: flex;
	flex-direction: column;
	gap: 1rem;
}

.screenshot-feature {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	color: var(--muted-foreground);
}

.screenshot-feature svg {
	color: var(--primary);
	flex-shrink: 0;
}

.screenshot-hero-image {
	position: relative;
	background: var(--card);
	border: 2px solid var(--border);
	border-radius: var(--radius);
	overflow: hidden;
	box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
	transition: all 0.3s ease;
}

.screenshot-hero-image:hover {
	transform: translateY(-4px);
	border-color: rgba(243, 128, 32, 0.3);
	box-shadow: 0 30px 60px -15px rgba(0, 0, 0, 0.6);
}

.screenshot-hero-image img {
	width: 100%;
	height: auto;
	display: block;
}

/* Secondary Screenshots */
.screenshots-secondary {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
	gap: 3rem;
}

.screenshot-card-large {
	background: var(--card);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	overflow: hidden;
	transition: all 0.3s ease;
}

.screenshot-card-large:hover {
	transform: translateY(-4px);
	border-color: rgba(243, 128, 32, 0.3);
	box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
}

.screenshot-card-header {
	padding: 2rem;
	background: rgba(243, 128, 32, 0.05);
	border-bottom: 1px solid var(--border);
}

.screenshot-card-header h3 {
	font-size: 1.5rem;
	font-weight: 600;
	margin-bottom: 0.5rem;
}

.screenshot-card-header p {
	color: var(--muted-foreground);
	font-size: 1rem;
	margin: 0;
}

.screenshot-wrapper-large {
	position: relative;
	background: var(--secondary);
	overflow: hidden;
}

.screenshot-wrapper-large img {
	width: 100%;
	height: auto;
	display: block;
	object-fit: cover;
}

/* Legacy styles for compatibility */
.screenshots-grid {
	display: none;
}

/* Performance Section */
.performance {
	padding: 6rem 0;
}

.performance-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
	gap: 2rem;
}

.performance-card {
	background: var(--card);
	padding: 2.5rem;
	border-radius: var(--radius);
	border: 1px solid var(--border);
	text-align: center;
}

.performance-metric {
	margin-bottom: 2rem;
}

.metric-value {
	display: block;
	font-size: 3rem;
	font-weight: 700;
	color: var(--cf-orange);
	letter-spacing: -0.02em;
}

.metric-label {
	display: block;
	font-size: 0.875rem;
	color: var(--muted-foreground);
	margin-top: 0.5rem;
}

.performance-chart {
	display: flex;
	gap: 0.5rem;
	align-items: flex-end;
	justify-content: center;
	height: 80px;
}

.chart-bar {
	width: 20px;
	background: var(--cf-orange);
	border-radius: 4px 4px 0 0;
	opacity: 0.8;
}

.performance-icon {
	display: flex;
	justify-content: center;
}

.performance-icon.success {
	color: #10b981;
}

.uptime-indicator {
	display: flex;
	gap: 0.25rem;
	justify-content: center;
}

.uptime-bar {
	width: 8px;
	height: 40px;
	background: #10b981;
	border-radius: 2px;
}

/* Get Started Section */
.get-started {
	padding: 6rem 0;
}

.steps-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
	gap: 2rem;
}

.step-card {
	position: relative;
	padding: 2rem;
}

.step-number {
	font-size: 4rem;
	font-weight: 700;
	color: rgba(243, 128, 32, 0.2);
	line-height: 1;
	margin-bottom: 1rem;
}

.step-card h3 {
	font-size: 1.25rem;
	font-weight: 600;
	margin-bottom: 1rem;
}

.code-block {
	background: var(--card);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: 1rem;
	overflow-x: auto;
}

.code-block pre {
	margin: 0;
	font-family: "SF Mono", "Monaco", "Inconsolata", "Fira Code", monospace;
	font-size: 0.875rem;
	line-height: 1.5;
	color: var(--foreground);
}

/* Pricing Section */
.pricing {
	padding: 6rem 0;
	background: rgba(243, 128, 32, 0.03);
}

.pricing-card {
	max-width: 480px;
	margin: 0 auto;
	background: var(--card);
	border: 1px solid var(--border);
	border-radius: var(--radius);
	padding: 3rem;
	text-align: center;
}

.pricing-header {
	margin-bottom: 2rem;
}

.pricing-header h3 {
	font-size: 1.5rem;
	font-weight: 600;
	margin-bottom: 1.5rem;
}

.price {
	display: flex;
	align-items: baseline;
	justify-content: center;
	gap: 0.25rem;
}

.pricing-tagline {
	text-align: center;
	color: var(--muted-foreground);
	font-size: 1.125rem;
	font-weight: 500;
	margin-top: 0.75rem;
	letter-spacing: -0.01em;
}

.currency {
	font-size: 1.5rem;
	color: var(--muted-foreground);
}

.amount {
	font-size: 4rem;
	font-weight: 700;
	letter-spacing: -0.02em;
}

.period {
	font-size: 1.125rem;
	color: var(--muted-foreground);
}

.pricing-features {
	list-style: none;
	margin: 2rem 0;
	text-align: left;
}

.pricing-features li {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border);
}

.pricing-features li:last-child {
	border-bottom: none;
}

.pricing-features svg {
	color: #10b981;
	flex-shrink: 0;
}

/* CTA Section */
.cta {
	padding: 6rem 0;
	background: linear-gradient(
		135deg,
		rgba(243, 128, 32, 0.1) 0%,
		transparent 100%
	);
}

.cta-content {
	text-align: center;
	max-width: 600px;
	margin: 0 auto;
}

.cta-content h2 {
	font-size: 2.5rem;
	font-weight: 700;
	margin-bottom: 1rem;
	letter-spacing: -0.02em;
}

.cta-content p {
	font-size: 1.125rem;
	color: var(--muted-foreground);
	margin-bottom: 2rem;
}

.cta-actions {
	display: flex;
	gap: 1rem;
	justify-content: center;
}

/* Footer */
.footer {
	background: var(--card);
	border-top: 1px solid var(--border);
	padding: 3rem 0 2rem;
}

.footer-content {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 2rem;
}

.footer-brand {
	display: flex;
	flex-direction: column;
	gap: 0.5rem;
}

.footer-tagline {
	color: var(--muted-foreground);
	font-size: 0.875rem;
}

.footer-links {
	display: flex;
	gap: 2rem;
}

.footer-links a {
	color: var(--muted-foreground);
	text-decoration: none;
	font-size: 0.875rem;
	transition: color 0.2s;
}

.footer-links a:hover {
	color: var(--foreground);
}

.footer-bottom {
	text-align: center;
	padding-top: 2rem;
	border-top: 1px solid var(--border);
	color: var(--muted-foreground);
	font-size: 0.875rem;
}

/* Hero Code Block */
.hero-code-block {
	display: grid;
	grid-template-columns: 1.5fr 1fr;
	gap: 3rem;
	margin: 3rem 0;
	align-items: start;
}

.code-block.large {
	background: rgba(243, 128, 32, 0.05);
	border: 2px solid rgba(243, 128, 32, 0.2);
	box-shadow: 0 0 40px rgba(243, 128, 32, 0.1);
}

.code-block.large pre {
	font-size: 1rem;
	line-height: 1.8;
}

.code-block .highlight {
	color: var(--primary);
	font-weight: 600;
	text-shadow: 0 0 20px rgba(243, 128, 32, 0.5);
}

.command-benefits {
	padding: 1.5rem 0;
}

.command-benefits h3 {
	font-size: 1.25rem;
	margin-bottom: 1rem;
	color: var(--foreground);
}

.command-benefits ul {
	list-style: none;
	padding: 0;
	margin: 0;
}

.command-benefits li {
	padding: 0.75rem 0;
	font-size: 1rem;
	color: var(--muted-foreground);
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

/* Responsive */
@media (max-width: 1024px) {
	.hero-container {
		grid-template-columns: 1fr;
		gap: 3rem;
	}

	.hero-content {
		text-align: center;
		max-width: 800px;
		margin: 0 auto;
	}

	.hero-subtitle {
		margin: 0 auto 2.5rem;
	}

	.hero-actions {
		justify-content: center;
	}

	.hero-stats {
		justify-content: center;
	}

	.hero-screenshot-wrapper {
		max-width: 600px;
		margin: 0 auto;
	}

	.screenshot-hero-content {
		grid-template-columns: 1fr;
		gap: 3rem;
	}

	.screenshot-hero-text {
		text-align: center;
	}

	.screenshots-secondary {
		grid-template-columns: 1fr;
		gap: 2rem;
	}
}

@media (max-width: 768px) {
	.hero-code-block {
		grid-template-columns: 1fr;
		gap: 2rem;
	}

	.container-wide {
		padding: 0 1rem;
	}

	.screenshot-hero {
		margin-top: 2rem;
		margin-bottom: 3rem;
	}

	.screenshot-hero-text h3 {
		font-size: 1.5rem;
	}

	.screenshot-hero-text p {
		font-size: 1rem;
	}

	.screenshot-card-header {
		padding: 1.5rem;
	}

	.screenshot-card-header h3 {
		font-size: 1.25rem;
	}

	.feature-card.featured {
		grid-column: 1;
	}

	.feature-stats {
		flex-direction: row;
		justify-content: space-around;
	}

	.stat-number {
		font-size: 1.25rem;
	}

	.nav-links {
		gap: 1rem;
	}

	.nav-links a:not(.github-link) {
		display: none;
	}

	.hero-title {
		font-size: 3rem;
	}

	.hero-stats {
		gap: 1.5rem;
	}

	.stat-value {
		font-size: 1.5rem;
	}

	.footer-content {
		flex-direction: column;
		gap: 2rem;
		text-align: center;
	}

	.footer-links {
		justify-content: center;
	}
}

================
File: apps/lander/src/_redirects
================
# Redirects for Cloudflare Pages
# Add any redirects here as needed
# Example: /old-path /new-path 301

================
File: apps/lander/src/_headers
================
/*
  X-Frame-Options: DENY
  X-Content-Type-Options: nosniff
  X-XSS-Protection: 1; mode=block
  Referrer-Policy: strict-origin-when-cross-origin
  Permissions-Policy: accelerometer=(), camera=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()
  Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https:; connect-src 'self'

/*.css
  Cache-Control: public, max-age=31536000, immutable

/*.js
  Cache-Control: public, max-age=31536000, immutable

/*.woff2
  Cache-Control: public, max-age=31536000, immutable

/index.html
  Cache-Control: public, max-age=0, must-revalidate

================
File: apps/tui/package.json
================
{
	"name": "ccflare",
	"version": "1.0.0",
	"description": "TUI for ccflare load balancer",
	"bin": {
		"ccflare": "./dist/ccflare"
	},
	"type": "module",
	"scripts": {
		"dev": "bun run src/main.ts",
		"build": "bun build src/main.ts --compile --outfile dist/ccflare --target=bun",
		"prepublishOnly": "bun run build",
		"postpublish": "chmod +x dist/ccflare"
	},
	"dependencies": {
		"@ccflare/tui-core": "workspace:*",
		"@ccflare/ui-common": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/core-di": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/server": "workspace:*",
		"ink": "^6.0.0",
		"ink-select-input": "^6.0.0",
		"ink-spinner": "^5.0.0",
		"ink-text-input": "^6.0.0",
		"react": "^19.0.0"
	},
	"devDependencies": {
		"@types/react": "^19.0.0",
		"@types/node": "^20.0.0",
		"react-devtools-core": "^5.0.0"
	},
	"files": [
		"dist"
	],
	"keywords": [
		"ccflare",
		"load-balancer",
		"tui",
		"cli"
	],
	"publishConfig": {
		"access": "public"
	}
}

================
File: apps/tui/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"compilerOptions": {
		"jsx": "react-jsx",
		"module": "ESNext",
		"target": "ESNext",
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"types": ["react", "node"]
	},
	"include": ["src/**/*"],
	"exclude": ["node_modules", "dist"]
}

================
File: apps/tui/src/App.tsx
================
import { Box, Text, useApp } from "ink";
import SelectInput from "ink-select-input";
import { useState } from "react";
import { AccountsScreen } from "./components/AccountsScreen";
import { AnalyticsScreen } from "./components/AnalyticsScreen";
import { LogsScreen } from "./components/LogsScreen";
import { RequestsScreen } from "./components/RequestsScreen";
import { ServerScreen } from "./components/ServerScreen";
import { StatsScreen } from "./components/StatsScreen";
import { StrategyScreen } from "./components/StrategyScreen";

type Screen =
	| "home"
	| "server"
	| "accounts"
	| "stats"
	| "analytics"
	| "requests"
	| "logs"
	| "strategy";

export function App() {
	const [screen, setScreen] = useState<Screen>("home");
	const { exit } = useApp();

	const items = [
		{ label: "🚀 Server", value: "server" },
		{ label: "👥 Manage Accounts", value: "accounts" },
		{ label: "📊 View Statistics", value: "stats" },
		{ label: "📈 Analytics Dashboard", value: "analytics" },
		{ label: "📜 View Requests", value: "requests" },
		{ label: "📋 View Logs", value: "logs" },
		{ label: "⚖️  Load Balancer", value: "strategy" },
		{ label: "❌ Exit", value: "exit" },
	];

	const handleSelect = (item: { value: string }) => {
		if (item.value === "exit") {
			exit();
		} else {
			setScreen(item.value as Screen);
		}
	};

	const handleBack = () => {
		setScreen("home");
	};

	if (screen === "home") {
		return (
			<Box flexDirection="column" padding={1}>
				<Box marginBottom={1}>
					<Text color="cyan" bold>
						🎯 ccflare TUI
					</Text>
				</Box>
				<Text dimColor>Select an option:</Text>
				<Box marginTop={1}>
					<SelectInput items={items} onSelect={handleSelect} />
				</Box>
			</Box>
		);
	}

	return (
		<Box flexDirection="column" height="100%">
			{screen === "server" && <ServerScreen onBack={handleBack} />}
			{screen === "accounts" && <AccountsScreen onBack={handleBack} />}
			{screen === "stats" && <StatsScreen onBack={handleBack} />}
			{screen === "analytics" && <AnalyticsScreen onBack={handleBack} />}
			{screen === "requests" && <RequestsScreen onBack={handleBack} />}
			{screen === "logs" && <LogsScreen onBack={handleBack} />}
			{screen === "strategy" && <StrategyScreen onBack={handleBack} />}
		</Box>
	);
}

================
File: apps/tui/src/main.ts
================
#!/usr/bin/env bun
import { Config } from "@ccflare/config";
import { CLAUDE_MODEL_IDS, NETWORK, shutdown } from "@ccflare/core";
import { container, SERVICE_KEYS } from "@ccflare/core-di";
import { DatabaseFactory } from "@ccflare/database";
import { Logger } from "@ccflare/logger";
// Import server
import startServer from "@ccflare/server";
import * as tuiCore from "@ccflare/tui-core";
import { parseArgs } from "@ccflare/tui-core";
import { render } from "ink";
import React from "react";
import { App } from "./App";

// Global singleton for auto-started server
let runningServer: ReturnType<typeof startServer> | null = null;

async function ensureServer(port: number) {
	if (!runningServer) {
		runningServer = startServer({ port, withDashboard: true });
	}
	return runningServer;
}

async function main() {
	// Initialize DI container and services
	container.registerInstance(SERVICE_KEYS.Config, new Config());
	container.registerInstance(SERVICE_KEYS.Logger, new Logger("TUI"));

	// Initialize database factory
	DatabaseFactory.initialize();
	const dbOps = DatabaseFactory.getInstance();
	container.registerInstance(SERVICE_KEYS.Database, dbOps);

	const args = process.argv.slice(2);
	const parsed = parseArgs(args);

	// Handle help
	if (parsed.help) {
		console.log(`
🎯 ccflare - Load Balancer for Claude

Usage: ccflare [options]

Options:
  --serve              Start API server with dashboard
  --port <number>      Server port (default: 8080, or PORT env var)
  --logs [N]           Stream latest N lines then follow
  --stats              Show statistics (JSON output)
  --add-account <name> Add a new account
    --mode <max|console>  Account mode (default: max)
    --tier <1|5|20>       Account tier (default: 1)
  --list               List all accounts
  --remove <name>      Remove an account
  --pause <name>       Pause an account
  --resume <name>      Resume an account
  --analyze            Analyze database performance
  --reset-stats        Reset usage statistics
  --clear-history      Clear request history
  --get-model          Show current default agent model
  --set-model <model>  Set default agent model (opus-4 or sonnet-4)
  --help, -h           Show this help message

Interactive Mode:
  ccflare          Launch interactive TUI (default)

Examples:
  ccflare                        # Interactive mode
  ccflare --serve                # Start server
  ccflare --add-account work     # Add account
  ccflare --pause work           # Pause account
  ccflare --analyze              # Run performance analysis
  ccflare --stats                # View stats
`);
		process.exit(0);
	}

	// Handle non-interactive commands
	if (parsed.serve) {
		const config = new Config();
		const port =
			parsed.port || config.getRuntime().port || NETWORK.DEFAULT_PORT;
		startServer({ port, withDashboard: true });
		// Keep process alive
		await new Promise(() => {});
		return;
	}

	if (parsed.logs !== undefined) {
		const limit = typeof parsed.logs === "number" ? parsed.logs : 100;

		// First print historical logs if limit was specified
		if (typeof parsed.logs === "number") {
			const history = await tuiCore.getLogHistory(limit);
			for (const log of history) {
				console.log(`[${log.level}] ${log.msg}`);
			}
			console.log("--- Live logs ---");
		}

		// Then stream live logs
		await tuiCore.streamLogs((log) => {
			console.log(`[${log.level}] ${log.msg}`);
		});
		return;
	}

	if (parsed.stats) {
		const stats = await tuiCore.getStats();
		console.log(JSON.stringify(stats, null, 2));
		return;
	}

	if (parsed.addAccount) {
		await tuiCore.addAccount({
			name: parsed.addAccount,
			mode: parsed.mode || "max",
			tier: parsed.tier || 1,
		});
		console.log(`✅ Account "${parsed.addAccount}" added successfully`);
		return;
	}

	if (parsed.list) {
		const accounts = await tuiCore.getAccounts();
		if (accounts.length === 0) {
			console.log("No accounts configured");
		} else {
			console.log("\nAccounts:");
			accounts.forEach((acc) => {
				console.log(`  - ${acc.name} (${acc.mode} mode, tier ${acc.tier})`);
			});
		}
		return;
	}

	if (parsed.remove) {
		await tuiCore.removeAccount(parsed.remove);
		console.log(`✅ Account "${parsed.remove}" removed successfully`);
		return;
	}

	if (parsed.resetStats) {
		await tuiCore.resetStats();
		console.log("✅ Statistics reset successfully");
		return;
	}

	if (parsed.clearHistory) {
		await tuiCore.clearHistory();
		console.log("✅ Request history cleared successfully");
		return;
	}

	if (parsed.pause) {
		const result = await tuiCore.pauseAccount(parsed.pause);
		console.log(result.message);
		if (!result.success) {
			process.exit(1);
		}
		return;
	}

	if (parsed.resume) {
		const result = await tuiCore.resumeAccount(parsed.resume);
		console.log(result.message);
		if (!result.success) {
			process.exit(1);
		}
		return;
	}

	if (parsed.analyze) {
		await tuiCore.analyzePerformance();
		return;
	}

	if (parsed.getModel) {
		const config = new Config();
		const model = config.getDefaultAgentModel();
		console.log(`Current default agent model: ${model}`);
		return;
	}

	if (parsed.setModel) {
		const config = new Config();
		// Validate the model
		const modelMap: Record<string, string> = {
			"opus-4": CLAUDE_MODEL_IDS.OPUS_4,
			"sonnet-4": CLAUDE_MODEL_IDS.SONNET_4,
			"opus-4.1": CLAUDE_MODEL_IDS.OPUS_4_1,
		};

		const fullModel = modelMap[parsed.setModel];
		if (!fullModel) {
			console.error(`❌ Invalid model: ${parsed.setModel}`);
			console.error("Valid models: opus-4, sonnet-4");
			process.exit(1);
		}

		config.setDefaultAgentModel(fullModel);
		console.log(`✅ Default agent model set to: ${fullModel}`);
		return;
	}

	// Default: Launch interactive TUI with auto-started server
	const config = new Config();
	const port = parsed.port || config.getRuntime().port || NETWORK.DEFAULT_PORT;
	await ensureServer(port);
	const { waitUntilExit } = render(React.createElement(App));
	await waitUntilExit();

	// Cleanup server when TUI exits
	if (runningServer) {
		runningServer.stop();
	}

	// Shutdown all resources
	await shutdown();
}

// Run main and handle errors
main().catch(async (error) => {
	console.error("Error:", error.message);
	try {
		await shutdown();
	} catch (shutdownError) {
		console.error("Error during shutdown:", shutdownError);
	}
	process.exit(1);
});

// Handle process termination
process.on("SIGINT", async () => {
	try {
		await shutdown();
	} catch (error) {
		console.error("Error during shutdown:", error);
	}
	process.exit(0);
});

process.on("SIGTERM", async () => {
	try {
		await shutdown();
	} catch (error) {
		console.error("Error during shutdown:", error);
	}
	process.exit(0);
});

================
File: apps/tui/src/types/open.d.ts
================
declare module "open" {
	interface OpenOptions {
		wait?: boolean;
		background?: boolean;
		newInstance?: boolean;
		allowNonzeroExitCode?: boolean;
		app?: {
			name: string | readonly string[];
			arguments?: readonly string[];
		};
	}
	function open(target: string, options?: OpenOptions): Promise<void>;
	export default open;
}

================
File: apps/tui/src/components/ServerScreen.tsx
================
import { NETWORK } from "@ccflare/core";
import { Box, Text, useInput } from "ink";

interface ServerScreenProps {
	onBack: () => void;
}

export function ServerScreen({ onBack }: ServerScreenProps) {
	// Server is auto-started now, so just show the running status
	const port = NETWORK.DEFAULT_PORT;
	const url = `http://localhost:${port}`;

	useInput((input, key) => {
		if (key.escape || input === "q") {
			onBack();
		}
		if (input === "d") {
			// Open dashboard in browser
			import("open")
				.then((module) => {
					const open = module.default as (url: string) => Promise<void>;
					open(url);
				})
				.catch(() => {
					// Fallback if open package is not available
					console.log(`\nOpen dashboard at: ${url}`);
				});
		}
	});

	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					ðŸš€ Server
				</Text>
			</Box>

			<Box flexDirection="column">
				<Text color="green">âœ“ Server running at {url}</Text>
				<Box marginTop={1}>
					<Text dimColor>Press 'd' to open dashboard in browser</Text>
				</Box>
			</Box>

			<Box marginTop={2}>
				<Text dimColor>Press 'q' or ESC to go back</Text>
			</Box>
		</Box>
	);
}

================
File: apps/tui/src/components/StatsScreen.tsx
================
import * as tuiCore from "@ccflare/tui-core";
import {
	formatCost,
	formatNumber,
	formatPercentage,
	formatTokensPerSecond,
} from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import { useCallback, useEffect, useState } from "react";
import { BarChart, PieChart, SparklineChart } from "./charts";

interface StatsScreenProps {
	onBack: () => void;
}

export function StatsScreen({ onBack }: StatsScreenProps) {
	const [stats, setStats] = useState<tuiCore.Stats | null>(null);
	const [loading, setLoading] = useState(true);
	const [lastUpdated, setLastUpdated] = useState<Date>(new Date());
	const [showCharts, setShowCharts] = useState(false);

	useInput((input, key) => {
		if (key.escape || input === "q") {
			onBack();
		}
		if (input === "r") {
			loadStats();
		}
		if (input === "c") {
			setShowCharts(!showCharts);
		}
	});

	const loadStats = useCallback(async () => {
		try {
			const data = await tuiCore.getStats();
			setStats(data);
			setLoading(false);
			setLastUpdated(new Date());
		} catch (_error) {
			setLoading(false);
		}
	}, []);

	useEffect(() => {
		loadStats();
		const interval = setInterval(loadStats, 5000); // Auto-refresh every 5 seconds
		return () => clearInterval(interval);
	}, [loadStats]);

	// For TUI, we want to show just time not full timestamp for space reasons
	const formatTime = (date: Date): string => {
		return date.toLocaleTimeString();
	};

	if (loading) {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					ðŸ“Š Statistics Dashboard
				</Text>
				<Text dimColor>Loading...</Text>
			</Box>
		);
	}

	if (!stats) {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					ðŸ“Š Statistics Dashboard
				</Text>
				<Text color="red">Failed to load statistics</Text>
			</Box>
		);
	}

	// Calculate additional metrics
	const avgTokensPerRequest =
		stats.totalRequests > 0
			? Math.round(stats.totalTokens / stats.totalRequests)
			: 0;
	const avgCostPerRequest =
		stats.totalRequests > 0 ? stats.totalCostUsd / stats.totalRequests : 0;

	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					ðŸ“Š Statistics Dashboard
				</Text>
				<Text dimColor>Last updated: {formatTime(lastUpdated)}</Text>
			</Box>

			{/* Overall Statistics */}
			<Box marginBottom={1}>
				<Text bold underline>
					Overall Statistics
				</Text>
			</Box>

			<Box flexDirection="column" marginBottom={1}>
				<Box>
					<Text>Total Requests: </Text>
					<Text color="yellow" bold>
						{formatNumber(stats.totalRequests)}
					</Text>
				</Box>
				<Box>
					<Text>Success Rate: </Text>
					<Text
						color={
							stats.successRate >= 95
								? "green"
								: stats.successRate >= 80
									? "yellow"
									: "red"
						}
						bold
					>
						{formatPercentage(stats.successRate)}
					</Text>
				</Box>
				<Box>
					<Text>Active Accounts: </Text>
					<Text color="cyan" bold>
						{stats.activeAccounts}
					</Text>
				</Box>
				<Box>
					<Text>Avg Response Time: </Text>
					<Text color="magenta" bold>
						{formatNumber(stats.avgResponseTime)}ms
					</Text>
				</Box>
				{stats.avgTokensPerSecond !== null && (
					<Box>
						<Text>Avg Output Speed: </Text>
						<Text color="blue" bold>
							{formatTokensPerSecond(stats.avgTokensPerSecond)}
						</Text>
					</Box>
				)}
			</Box>

			{/* Token Usage */}
			<Box marginBottom={1}>
				<Text bold underline>
					Token Usage Breakdown
				</Text>
			</Box>

			{stats.tokenDetails ? (
				<Box flexDirection="column" marginBottom={1}>
					<Box marginLeft={2}>
						<Text>â”œâ”€ Input: </Text>
						<Text color="yellow">
							{formatNumber(stats.tokenDetails.inputTokens)}
						</Text>
					</Box>
					{stats.tokenDetails.cacheReadInputTokens > 0 && (
						<Box marginLeft={2}>
							<Text>â”œâ”€ Cache Read: </Text>
							<Text color="cyan">
								{formatNumber(stats.tokenDetails.cacheReadInputTokens)}
							</Text>
						</Box>
					)}
					{stats.tokenDetails.cacheCreationInputTokens > 0 && (
						<Box marginLeft={2}>
							<Text>â”œâ”€ Cache Creation: </Text>
							<Text color="cyan">
								{formatNumber(stats.tokenDetails.cacheCreationInputTokens)}
							</Text>
						</Box>
					)}
					<Box marginLeft={2}>
						<Text>â””â”€ Output: </Text>
						<Text color="yellow">
							{formatNumber(stats.tokenDetails.outputTokens)}
						</Text>
					</Box>
					<Box marginTop={1}>
						<Text bold>Total Tokens: </Text>
						<Text color="green" bold>
							{formatNumber(stats.totalTokens)}
						</Text>
						<Text dimColor>
							{" "}
							({formatNumber(avgTokensPerRequest)} avg/request)
						</Text>
					</Box>
				</Box>
			) : (
				<Box marginBottom={1}>
					<Text>Total Tokens: </Text>
					<Text color="green" bold>
						{formatNumber(stats.totalTokens)}
					</Text>
				</Box>
			)}

			{/* Cost Information */}
			<Box marginBottom={1}>
				<Text bold>Total Cost: </Text>
				<Text color="green" bold>
					{formatCost(stats.totalCostUsd)}
				</Text>
				<Text dimColor> ({formatCost(avgCostPerRequest)} avg/request)</Text>
			</Box>

			{/* Account Usage */}
			{stats.accounts.length > 0 && (
				<>
					<Box marginTop={1} marginBottom={1}>
						<Text bold underline>
							Account Performance
						</Text>
					</Box>
					<Box flexDirection="column">
						{stats.accounts.map((account) => (
							<Box key={account.name}>
								<Text>{account.name}: </Text>
								<Text color="yellow">
									{formatNumber(account.requestCount)} requests
								</Text>
								<Text> (</Text>
								<Text
									color={
										account.successRate >= 95
											? "green"
											: account.successRate >= 80
												? "yellow"
												: "red"
									}
								>
									{formatPercentage(account.successRate)} success
								</Text>
								<Text>)</Text>
							</Box>
						))}
					</Box>
				</>
			)}

			{/* Charts Section - Toggle with 'c' */}
			{showCharts && (
				<>
					<Box marginTop={2} marginBottom={1}>
						<Text bold underline>
							Visual Analytics
						</Text>
					</Box>

					{/* Token Usage Pie Chart */}
					{stats.tokenDetails && (
						<Box marginBottom={2}>
							<PieChart
								title="Token Distribution"
								data={[
									{
										label: "Input",
										value: stats.tokenDetails.inputTokens,
										color: "yellow",
									},
									{
										label: "Cache",
										value:
											stats.tokenDetails.cacheReadInputTokens +
											stats.tokenDetails.cacheCreationInputTokens,
										color: "cyan",
									},
									{
										label: "Output",
										value: stats.tokenDetails.outputTokens,
										color: "green",
									},
								]}
								size="small"
								showLegend={true}
							/>
						</Box>
					)}

					{/* Account Performance Bar Chart */}
					{stats.accounts.length > 0 && (
						<Box marginBottom={2}>
							<BarChart
								title="Account Request Distribution"
								data={stats.accounts.map((account) => ({
									label: account.name,
									value: account.requestCount,
									color:
										account.successRate >= 95
											? "green"
											: account.successRate >= 80
												? "yellow"
												: "red",
								}))}
								width={30}
								showValues={true}
							/>
						</Box>
					)}

					{/* Success Rate Sparkline */}
					<Box marginBottom={2}>
						<Text bold>Performance Trend</Text>
						<Box marginTop={1}>
							<SparklineChart
								data={[85, 88, 90, 92, 91, 93, 95, stats.successRate]}
								label="Success %"
								color={
									stats.successRate >= 95
										? "green"
										: stats.successRate >= 80
											? "yellow"
											: "red"
								}
								showCurrent={true}
							/>
						</Box>
					</Box>
				</>
			)}

			{/* Recent Errors */}
			{stats.recentErrors.length > 0 && !showCharts && (
				<>
					<Box marginTop={1} marginBottom={1}>
						<Text bold underline color="red">
							Recent Errors
						</Text>
					</Box>
					<Box flexDirection="column">
						{stats.recentErrors.slice(0, 5).map((error, idx) => (
							<Box
								key={`error-${idx}-${error.substring(0, 10)}`}
								marginLeft={2}
							>
								<Text color="red" dimColor>
									â€¢ {error.length > 60 ? `${error.substring(0, 60)}...` : error}
								</Text>
							</Box>
						))}
					</Box>
				</>
			)}

			<Box marginTop={2}>
				<Text dimColor>
					[c] {showCharts ? "Hide" : "Show"} Charts â€¢ [r] Refresh â€¢ [q/ESC] Back
				</Text>
			</Box>
		</Box>
	);
}

================
File: apps/tui/src/components/TokenUsageDisplay.tsx
================
import type { RequestSummary } from "@ccflare/tui-core";
import { processTokenUsage } from "@ccflare/ui-common";
import { Box, Text } from "ink";

interface TokenUsageDisplayProps {
	summary: RequestSummary;
}

export function TokenUsageDisplay({ summary }: TokenUsageDisplayProps) {
	const usage = processTokenUsage(summary);

	if (!usage.hasData) {
		return (
			<Box flexDirection="column" marginTop={1}>
				<Text dimColor>No token usage data available</Text>
			</Box>
		);
	}

	const { sections } = usage;

	return (
		<Box flexDirection="column" marginTop={1}>
			<Text bold>Token Usage:</Text>
			<Box marginLeft={2} flexDirection="column">
				{sections.inputTokens && (
					<Box>
						<Text>{sections.inputTokens.label}: </Text>
						<Text color="yellow" bold>
							{sections.inputTokens.value}
						</Text>
					</Box>
				)}

				{sections.outputTokens && (
					<Box>
						<Text>{sections.outputTokens.label}: </Text>
						<Text color="yellow" bold>
							{sections.outputTokens.value}
						</Text>
					</Box>
				)}

				{sections.cacheReadTokens && (
					<Box>
						<Text>{sections.cacheReadTokens.label}: </Text>
						<Text color="cyan" bold>
							{sections.cacheReadTokens.value}
						</Text>
					</Box>
				)}

				{sections.cacheCreationTokens && (
					<Box>
						<Text>{sections.cacheCreationTokens.label}: </Text>
						<Text color="cyan" bold>
							{sections.cacheCreationTokens.value}
						</Text>
					</Box>
				)}

				<Box marginTop={1}>
					<Text>─────────────────────</Text>
				</Box>

				{sections.totalTokens && (
					<Box>
						<Text bold>{sections.totalTokens.label}: </Text>
						<Text color="green" bold>
							{sections.totalTokens.value}
						</Text>
					</Box>
				)}

				{sections.cost && (
					<Box>
						<Text bold>{sections.cost.label}: </Text>
						<Text color="green" bold>
							{sections.cost.value}
						</Text>
					</Box>
				)}
			</Box>
		</Box>
	);
}

================
File: apps/tui/src/components/AnalyticsScreen.tsx
================
import { getModelShortName } from "@ccflare/core";
import * as tuiCore from "@ccflare/tui-core";
import { formatCost, formatNumber, formatPercentage } from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import SelectInput from "ink-select-input";
import Spinner from "ink-spinner";
import { useCallback, useEffect, useState } from "react";
import { BarChart, LineChart, PieChart, SparklineChart } from "./charts";

interface AnalyticsScreenProps {
	onBack: () => void;
}

type TimeRange = "1h" | "6h" | "24h" | "7d";
type ChartView = "overview" | "tokens" | "performance" | "costs" | "models";

const TIME_RANGE_LABELS: Record<TimeRange, string> = {
	"1h": "Last Hour",
	"6h": "Last 6 Hours",
	"24h": "Last 24 Hours",
	"7d": "Last 7 Days",
};

export function AnalyticsScreen({ onBack }: AnalyticsScreenProps) {
	const [timeRange, setTimeRange] = useState<TimeRange>("24h");
	const [chartView, setChartView] = useState<ChartView>("overview");
	const [stats, setStats] = useState<tuiCore.Stats | null>(null);
	const [loading, setLoading] = useState(true);
	interface TimeSeriesDataPoint {
		time: string;
		requests: number;
		tokens: number;
		cost: number;
		responseTime: number;
		errorRate: number;
		cacheHitRate: number;
		successRate: number;
	}

	const [timeSeriesData, setTimeSeriesData] = useState<TimeSeriesDataPoint[]>(
		[],
	);
	const [showMenu, setShowMenu] = useState(false);
	const [modelDistribution, setModelDistribution] = useState<
		tuiCore.ModelDistribution[]
	>([]);

	useInput((input, key) => {
		if (key.escape) {
			if (showMenu) {
				setShowMenu(false);
			} else {
				onBack();
			}
		}
		if (input === "q" && !showMenu) {
			onBack();
		}
		if (input === "r" && !showMenu) {
			loadData();
		}
		if (input === "m" && !showMenu) {
			setShowMenu(true);
		}
		// Time range shortcuts
		if (!showMenu) {
			if (input === "1") setTimeRange("1h");
			if (input === "2") setTimeRange("6h");
			if (input === "3") setTimeRange("24h");
			if (input === "4") setTimeRange("7d");
			// View shortcuts
			if (input === "o") setChartView("overview");
			if (input === "t") setChartView("tokens");
			if (input === "p") setChartView("performance");
			if (input === "c") setChartView("costs");
			if (input === "d") setChartView("models");
		}
	});

	const loadData = useCallback(async () => {
		try {
			setLoading(true);
			// Get basic stats
			const data = await tuiCore.getStats();
			setStats(data);

			// Get analytics with time series data
			const analytics = await tuiCore.getAnalytics(timeRange);

			// Transform time series data for display
			const transformedTimeSeries = analytics.timeSeries.map((point) => {
				const time = new Date(point.time);
				return {
					time:
						timeRange === "7d"
							? time.toLocaleDateString("en", { weekday: "short" })
							: time.toLocaleTimeString("en", {
									hour: "2-digit",
									minute: "2-digit",
								}),
					requests: point.requests,
					tokens: point.tokens,
					cost: point.cost,
					responseTime: point.responseTime,
					errorRate: point.errorRate,
					cacheHitRate: point.cacheHitRate,
					successRate: point.successRate,
				};
			});

			setTimeSeriesData(transformedTimeSeries);
			setLoading(false);
		} catch (_error) {
			setLoading(false);
		}
	}, [timeRange]);

	useEffect(() => {
		loadData();
		const interval = setInterval(loadData, 30000); // Refresh every 30 seconds
		return () => clearInterval(interval);
	}, [loadData]);

	useEffect(() => {
		if (!loading) {
			tuiCore.getAnalytics(timeRange).then((analytics) => {
				setModelDistribution(analytics.modelDistribution);
			});
		}
	}, [timeRange, loading]);

	if (loading || !stats) {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					üìà Analytics Dashboard
				</Text>
				<Box marginTop={1}>
					<Text color="green">
						<Spinner type="dots" />
					</Text>
					<Text> Loading analytics data...</Text>
				</Box>
			</Box>
		);
	}

	// Menu for selecting time range
	if (showMenu) {
		const menuItems = [
			{ label: "üìä Overview", value: "overview" },
			{ label: "ü™ô Token Usage", value: "tokens" },
			{ label: "‚ö° Performance", value: "performance" },
			{ label: "üí∞ Cost Analysis", value: "costs" },
			{ label: "ü§ñ Model Distribution", value: "models" },
			{ label: "‚Üê Back", value: "back" },
		];

		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					Select Analytics View
				</Text>
				<Box marginTop={1}>
					<SelectInput
						items={menuItems}
						onSelect={(item) => {
							if (item.value === "back") {
								setShowMenu(false);
							} else {
								setChartView(item.value as ChartView);
								setShowMenu(false);
							}
						}}
					/>
				</Box>
			</Box>
		);
	}

	// Prepare data for charts
	const requestSparkline = timeSeriesData.map((d) => d.requests);
	const tokenSparkline = timeSeriesData.map((d) => d.tokens);
	const costSparkline = timeSeriesData.map((d) => d.cost);
	const responseTimeData = timeSeriesData.map((d) => ({
		x: d.time,
		y: d.responseTime,
	}));

	// Model distribution for pie chart
	const modelData = modelDistribution.slice(0, 3).map((model, index) => ({
		label: model.model,
		value: model.count,
		color: ["magenta", "cyan", "yellow"][index] as
			| "magenta"
			| "cyan"
			| "yellow",
	}));

	// Account performance for bar chart
	const accountBarData = stats.accounts.map((account) => ({
		label: account.name,
		value: account.requestCount,
		color:
			account.successRate >= 95
				? ("green" as const)
				: account.successRate >= 80
					? ("yellow" as const)
					: ("red" as const),
	}));

	const renderChart = () => {
		switch (chartView) {
			case "overview":
				return (
					<Box flexDirection="column">
						<Box marginBottom={1}>
							<Text bold underline>
								Request Volume & Performance
							</Text>
						</Box>

						{/* Sparklines */}
						<Box flexDirection="column" marginBottom={2}>
							<SparklineChart
								data={requestSparkline}
								label="Requests"
								color="cyan"
								showCurrent={true}
							/>
							<SparklineChart
								data={tokenSparkline}
								label="Tokens  "
								color="yellow"
								showCurrent={true}
							/>
							<SparklineChart
								data={costSparkline}
								label="Cost    "
								color="green"
								showCurrent={true}
							/>
						</Box>

						{/* Response time line chart */}
						<LineChart
							data={responseTimeData.slice(-20)}
							title="Response Time (ms)"
							height={8}
							width={50}
							color="magenta"
						/>
					</Box>
				);

			case "tokens":
				return (
					<Box flexDirection="column">
						{/* Token breakdown bar chart */}
						{stats.tokenDetails && (
							<BarChart
								title="Token Usage Breakdown"
								data={[
									{
										label: "Input",
										value: stats.tokenDetails.inputTokens,
										color: "yellow",
									},
									{
										label: "Cache Read",
										value: stats.tokenDetails.cacheReadInputTokens,
										color: "cyan",
									},
									{
										label: "Cache Create",
										value: stats.tokenDetails.cacheCreationInputTokens,
										color: "blue",
									},
									{
										label: "Output",
										value: stats.tokenDetails.outputTokens,
										color: "green",
									},
								]}
								width={40}
								showValues={true}
							/>
						)}

						<Box marginTop={2}>
							<Text bold>Token Efficiency Metrics</Text>
							<Box marginTop={1}>
								<Text>Avg tokens/request: </Text>
								<Text color="yellow" bold>
									{formatNumber(
										stats.totalRequests > 0
											? Math.round(stats.totalTokens / stats.totalRequests)
											: 0,
									)}
								</Text>
							</Box>
							<Box>
								<Text>Cache hit rate: </Text>
								<Text color="cyan" bold>
									{formatPercentage(
										stats.tokenDetails
											? (stats.tokenDetails.cacheReadInputTokens /
													stats.tokenDetails.inputTokens) *
													100
											: 0,
									)}
								</Text>
							</Box>
						</Box>
					</Box>
				);

			case "performance":
				return (
					<Box flexDirection="column">
						{/* Account performance bar chart */}
						<BarChart
							title="Account Performance (Requests)"
							data={accountBarData}
							width={35}
							showValues={true}
						/>

						<Box marginTop={2}>
							<Text bold underline>
								Performance Metrics
							</Text>
							<Box marginTop={1}>
								<Text>Success Rate: </Text>
								<Text
									color={
										stats.successRate >= 95
											? "green"
											: stats.successRate >= 80
												? "yellow"
												: "red"
									}
									bold
								>
									{formatPercentage(stats.successRate)}
								</Text>
							</Box>
							<Box>
								<Text>Avg Response: </Text>
								<Text color="magenta" bold>
									{formatNumber(stats.avgResponseTime)}ms
								</Text>
							</Box>
						</Box>
					</Box>
				);

			case "costs":
				return (
					<Box flexDirection="column">
						<Box marginBottom={1}>
							<Text bold underline>
								Cost Analysis
							</Text>
						</Box>

						{/* Cost trend sparkline */}
						<Box marginBottom={2}>
							<SparklineChart
								data={costSparkline}
								label="Cost Trend"
								color="green"
								showMinMax={true}
								showCurrent={true}
							/>
						</Box>

						{/* Cost breakdown */}
						<Box flexDirection="column">
							<Box>
								<Text>Total Cost: </Text>
								<Text color="green" bold>
									{formatCost(stats.totalCostUsd)}
								</Text>
							</Box>
							<Box>
								<Text>Avg per request: </Text>
								<Text color="yellow">
									{formatCost(
										stats.totalRequests > 0
											? stats.totalCostUsd / stats.totalRequests
											: 0,
									)}
								</Text>
							</Box>
							<Box>
								<Text>Projected daily: </Text>
								<Text dimColor>
									{formatCost(
										stats.totalCostUsd *
											(24 /
												(timeRange === "1h"
													? 1
													: timeRange === "6h"
														? 6
														: timeRange === "24h"
															? 24
															: 168)),
									)}
								</Text>
							</Box>
						</Box>
					</Box>
				);

			case "models":
				return (
					<Box flexDirection="column">
						{/* Model distribution pie chart */}
						<PieChart
							title="Model Distribution"
							data={modelData}
							size="medium"
							showLegend={true}
						/>

						<Box marginTop={2}>
							<Text bold>Model Performance</Text>
							<Box flexDirection="column" marginTop={1}>
								{modelDistribution.slice(0, 5).map((model) => {
									const shortName = getModelShortName(model.model);
									const color = shortName.includes("opus")
										? "magenta"
										: shortName.includes("sonnet")
											? "cyan"
											: "yellow";
									return (
										<Box key={model.model}>
											<Text>{model.model}: </Text>
											<Text color={color}>
												{formatNumber(model.count)} (
												{formatPercentage(model.percentage)})
											</Text>
										</Box>
									);
								})}
							</Box>
						</Box>
					</Box>
				);

			default:
				return null;
		}
	};

	return (
		<Box flexDirection="column" padding={1}>
			{/* Header */}
			<Box marginBottom={1} justifyContent="space-between">
				<Text color="cyan" bold>
					üìà Analytics Dashboard - {TIME_RANGE_LABELS[timeRange]}
				</Text>
				<Text dimColor> View: {chartView}</Text>
			</Box>

			{/* Time range selector */}
			<Box marginBottom={1}>
				<Text dimColor>
					Time: [1] 1h [2] 6h [3] 24h [4] 7d | View: [o]verview [t]okens [p]erf
					[c]ost [d]models
				</Text>
			</Box>

			{/* Chart content */}
			{renderChart()}

			{/* Controls */}
			<Box marginTop={2}>
				<Text dimColor>[m] Menu ‚Ä¢ [r] Refresh ‚Ä¢ [q/ESC] Back</Text>
			</Box>
		</Box>
	);
}

================
File: apps/tui/src/components/AccountsScreen.tsx
================
import * as tuiCore from "@ccflare/tui-core";
import type { AccountDisplay } from "@ccflare/types";
import { AccountPresenter } from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import SelectInput from "ink-select-input";
import TextInput from "ink-text-input";
import { useCallback, useEffect, useState } from "react";

interface AccountsScreenProps {
	onBack: () => void;
}

type Mode = "list" | "add" | "remove" | "confirmRemove" | "waitingForCode";

export function AccountsScreen({ onBack }: AccountsScreenProps) {
	const [mode, setMode] = useState<Mode>("list");
	const [accounts, setAccounts] = useState<AccountDisplay[]>([]);
	const [newAccountName, setNewAccountName] = useState("");
	const [selectedMode, setSelectedMode] = useState<"max" | "console">("max");
	const [selectedTier, setSelectedTier] = useState<1 | 5 | 20>(1);
	const [step, setStep] = useState<"name" | "mode" | "tier" | "confirm">(
		"name",
	);
	const [authCode, setAuthCode] = useState("");
	const [oauthFlowData, setOauthFlowData] =
		useState<tuiCore.OAuthFlowResult | null>(null);
	const [error, setError] = useState<string | null>(null);
	const [accountToRemove, setAccountToRemove] = useState("");
	const [confirmInput, setConfirmInput] = useState("");

	useInput((input, key) => {
		if (key.escape) {
			if (mode === "confirmRemove") {
				setMode("list");
				setAccountToRemove("");
				setConfirmInput("");
			} else if (mode === "add" || mode === "waitingForCode") {
				setMode("list");
				setNewAccountName("");
				setStep("name");
				setAuthCode("");
				setOauthFlowData(null);
				setError(null);
			} else {
				onBack();
			}
		} else if (input === "q" && mode === "list") {
			onBack();
		}
	});

	const loadAccounts = useCallback(async () => {
		const data = await tuiCore.getAccounts();
		setAccounts(data);
	}, []);

	useEffect(() => {
		loadAccounts();
	}, [loadAccounts]);

	const handleBeginAddAccount = async () => {
		try {
			const flowData = await tuiCore.beginAddAccount({
				name: newAccountName,
				mode: selectedMode,
				tier: selectedTier,
			});
			setOauthFlowData(flowData);
			setMode("waitingForCode");
			setError(null);
		} catch (error) {
			setError(
				error instanceof Error ? error.message : "Failed to begin OAuth flow",
			);
		}
	};

	const handleCompleteAddAccount = async () => {
		if (!oauthFlowData || !authCode) return;

		try {
			await tuiCore.completeAddAccount({
				name: newAccountName,
				mode: selectedMode,
				tier: selectedTier,
				code: authCode,
				flowData: oauthFlowData,
			});
			await loadAccounts();
			setMode("list");
			setNewAccountName("");
			setStep("name");
			setAuthCode("");
			setOauthFlowData(null);
			setError(null);
		} catch (error) {
			setError(
				error instanceof Error ? error.message : "Failed to add account",
			);
		}
	};

	const handleRemoveAccount = (name: string) => {
		setAccountToRemove(name);
		setConfirmInput("");
		setMode("confirmRemove");
	};

	const handleConfirmRemove = async () => {
		if (confirmInput !== accountToRemove) {
			return;
		}

		try {
			await tuiCore.removeAccount(accountToRemove);
			await loadAccounts();
			setMode("list");
			setAccountToRemove("");
			setConfirmInput("");
		} catch (_error) {
			// Handle error
		}
	};

	if (mode === "add") {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					Add Account
				</Text>

				{step === "name" && (
					<Box flexDirection="column" marginTop={1}>
						<Text>Account name:</Text>
						<TextInput
							value={newAccountName}
							onChange={setNewAccountName}
							onSubmit={() => {
								if (newAccountName) setStep("mode");
							}}
						/>
					</Box>
				)}

				{step === "mode" && (
					<Box flexDirection="column" marginTop={1}>
						<Text>Select mode:</Text>
						<SelectInput
							items={[
								{ label: "Max (recommended)", value: "max" },
								{ label: "Console", value: "console" },
							]}
							onSelect={(item) => {
								setSelectedMode(item.value as "max" | "console");
								setStep("tier");
							}}
						/>
					</Box>
				)}

				{step === "tier" && (
					<Box flexDirection="column" marginTop={1}>
						<Text>Select tier:</Text>
						<SelectInput
							items={[
								{ label: "Tier 1 (default)", value: 1 },
								{ label: "Tier 5", value: 5 },
								{ label: "Tier 20", value: 20 },
							]}
							onSelect={(item) => {
								setSelectedTier(item.value as 1 | 5 | 20);
								handleBeginAddAccount();
							}}
						/>
					</Box>
				)}

				{error && (
					<Box marginTop={1}>
						<Text color="red">{error}</Text>
					</Box>
				)}

				<Box marginTop={2}>
					<Text dimColor>Press ESC to cancel</Text>
				</Box>
			</Box>
		);
	}

	if (mode === "waitingForCode") {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					Complete Authentication
				</Text>

				<Box flexDirection="column" marginTop={1}>
					<Text>A browser window should have opened for authentication.</Text>
					<Text>After authorizing, enter the code below:</Text>

					<Box marginTop={1}>
						<Text>Authorization code:</Text>
						<TextInput
							value={authCode}
							onChange={setAuthCode}
							onSubmit={() => {
								if (authCode) handleCompleteAddAccount();
							}}
						/>
					</Box>
				</Box>

				{error && (
					<Box marginTop={1}>
						<Text color="red">{error}</Text>
					</Box>
				)}

				<Box marginTop={2}>
					<Text dimColor>Press ESC to cancel</Text>
				</Box>
			</Box>
		);
	}

	if (mode === "confirmRemove") {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="red" bold>
					‚ö†Ô∏è Confirm Account Removal
				</Text>

				<Box marginTop={1} marginBottom={1}>
					<Text>You are about to remove account '{accountToRemove}'.</Text>
					<Text>This action cannot be undone.</Text>
				</Box>

				<Box flexDirection="column">
					<Text>
						Type <Text bold>{accountToRemove}</Text> to confirm:
					</Text>
					<TextInput
						value={confirmInput}
						onChange={setConfirmInput}
						onSubmit={() => {
							handleConfirmRemove();
						}}
					/>
				</Box>

				{confirmInput && confirmInput !== accountToRemove && (
					<Box marginTop={1}>
						<Text color="red">Account name does not match</Text>
					</Box>
				)}

				<Box marginTop={2}>
					<Text dimColor>Press ENTER to confirm, ESC to cancel</Text>
				</Box>
			</Box>
		);
	}

	const menuItems = [
		...accounts.map((acc) => {
			const presenter = new AccountPresenter(acc);
			return {
				label: `${acc.name} (${presenter.tierDisplay})`,
				value: `account:${acc.name}`,
			};
		}),
		{ label: "‚ûï Add Account", value: "add" },
		{ label: "‚Üê Back", value: "back" },
	];

	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					üë• Manage Accounts
				</Text>
			</Box>

			{accounts.length === 0 ? (
				<Text dimColor>No accounts configured</Text>
			) : (
				<Text dimColor>{accounts.length} account(s) configured</Text>
			)}

			<Box marginTop={1}>
				<SelectInput
					items={menuItems}
					onSelect={(item) => {
						if (item.value === "back") {
							onBack();
						} else if (item.value === "add") {
							setMode("add");
						} else if (item.value.startsWith("account:")) {
							const accountName = item.value.replace("account:", "");
							handleRemoveAccount(accountName);
						}
					}}
				/>
			</Box>
		</Box>
	);
}

================
File: apps/tui/src/components/StrategyScreen.tsx
================
import * as tuiCore from "@ccflare/tui-core";
import { Box, Text, useInput } from "ink";
import SelectInput from "ink-select-input";
import { useCallback, useEffect, useState } from "react";

interface StrategyScreenProps {
	onBack: () => void;
}

type Mode = "view" | "select";

export function StrategyScreen({ onBack }: StrategyScreenProps) {
	const [mode, setMode] = useState<Mode>("view");
	const [currentStrategy, setCurrentStrategy] = useState<string>("");
	const [strategies, setStrategies] = useState<string[]>([]);
	const [loading, setLoading] = useState(true);
	const [error, setError] = useState<string | null>(null);
	const [message, setMessage] = useState<string | null>(null);

	const loadData = useCallback(async () => {
		try {
			setLoading(true);
			setError(null);
			const [current, list] = await Promise.all([
				tuiCore.getStrategy(),
				tuiCore.listStrategies(),
			]);
			setCurrentStrategy(current);
			setStrategies(list);
		} catch (err) {
			setError(err instanceof Error ? err.message : "Failed to load data");
		} finally {
			setLoading(false);
		}
	}, []);

	useEffect(() => {
		loadData();
	}, [loadData]);

	useInput((input, key) => {
		if (key.escape || input === "q") {
			if (mode === "select") {
				setMode("view");
			} else {
				onBack();
			}
		} else if (key.return && mode === "view") {
			setMode("select");
			setMessage(null);
		}
	});

	const handleStrategySelect = useCallback(async (item: { value: string }) => {
		try {
			setError(null);
			await tuiCore.setStrategy(item.value);
			setCurrentStrategy(item.value);
			setMessage(`Strategy changed to: ${item.value}`);
			setMode("view");
		} catch (err) {
			setError(
				err instanceof Error ? err.message : "Failed to update strategy",
			);
		}
	}, []);

	if (loading) {
		return (
			<Box flexDirection="column">
				<Text>Loading strategies...</Text>
			</Box>
		);
	}

	if (mode === "select") {
		const items = strategies.map((strategy) => ({
			label: strategy === currentStrategy ? `${strategy} (current)` : strategy,
			value: strategy,
		}));

		return (
			<Box flexDirection="column">
				<Box marginBottom={1}>
					<Text bold>Select Load Balancer Strategy</Text>
				</Box>
				<SelectInput items={items} onSelect={handleStrategySelect} />
				<Box marginTop={1}>
					<Text dimColor>Press ESC to cancel</Text>
				</Box>
				{error && (
					<Box marginTop={1}>
						<Text color="red">Error: {error}</Text>
					</Box>
				)}
			</Box>
		);
	}

	return (
		<Box flexDirection="column">
			<Box marginBottom={1}>
				<Text bold>⚖️ Load Balancer Strategy</Text>
			</Box>

			{message && (
				<Box marginBottom={1}>
					<Text color="green">✓ {message}</Text>
				</Box>
			)}

			<Box marginBottom={1}>
				<Text>Current Strategy: </Text>
				<Text color="yellow" bold>
					{currentStrategy}
				</Text>
			</Box>

			<Box marginBottom={1}>
				<Text bold>Available Strategies:</Text>
			</Box>

			{strategies.map((strategy) => (
				<Box key={strategy} paddingLeft={2}>
					<Text color={strategy === currentStrategy ? "yellow" : undefined}>
						{strategy === currentStrategy ? "→ " : "  "}
						{strategy}
					</Text>
				</Box>
			))}

			<Box marginTop={1} flexDirection="column">
				<Text dimColor>Press ENTER to change strategy</Text>
				<Text dimColor>Press ESC or q to go back</Text>
			</Box>

			{error && (
				<Box marginTop={1}>
					<Text color="red">Error: {error}</Text>
				</Box>
			)}
		</Box>
	);
}

================
File: apps/tui/src/components/LogsScreen.tsx
================
import * as tuiCore from "@ccflare/tui-core";
import { Box, Text, useInput } from "ink";
import { useEffect, useState } from "react";

interface LogsScreenProps {
	onBack: () => void;
}

interface LogEntry {
	ts: number;
	level: string;
	msg: string;
}

export function LogsScreen({ onBack }: LogsScreenProps) {
	const [logs, setLogs] = useState<LogEntry[]>([]);
	const [paused, setPaused] = useState(false);
	const [loading, setLoading] = useState(true);

	useInput((input, key) => {
		if (key.escape || input === "q") {
			onBack();
		}
		if (input === " ") {
			setPaused(!paused);
		}
		if (input === "c") {
			setLogs([]);
		}
	});

	// Load historical logs on mount
	useEffect(() => {
		const loadHistory = async () => {
			try {
				const history = await tuiCore.getLogHistory();
				setLogs(history.slice(-200)); // Keep last 200 logs
			} catch (error) {
				console.error("Failed to load log history:", error);
			} finally {
				setLoading(false);
			}
		};
		loadHistory();
	}, []);

	useEffect(() => {
		if (!paused && !loading) {
			const unsubscribe = tuiCore.streamLogs((log) => {
				setLogs((prev) => [...prev.slice(-200), log]); // Keep last 200 logs
			});

			return () => {
				unsubscribe();
			};
		}
	}, [paused, loading]);

	const getLogColor = (level: string) => {
		switch (level.toUpperCase()) {
			case "ERROR":
				return "red";
			case "WARN":
				return "yellow";
			case "INFO":
				return "green";
			case "DEBUG":
				return "gray";
			default:
				return "white";
		}
	};

	return (
		<Box flexDirection="column" padding={1} height="100%">
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					ðŸ“œ Logs {paused && <Text color="yellow">(PAUSED)</Text>}
				</Text>
			</Box>

			<Box flexDirection="column" flexGrow={1}>
				{loading ? (
					<Text dimColor>Loading logs...</Text>
				) : logs.length === 0 ? (
					<Text dimColor>No logs yet...</Text>
				) : (
					logs.map((log, i) => (
						<Box key={`${log.ts}-${i}`}>
							<Text color={getLogColor(log.level)}>
								[{log.level}] {log.msg}
							</Text>
						</Box>
					))
				)}
			</Box>

			<Box marginTop={1}>
				<Text dimColor>
					SPACE: {paused ? "Resume" : "Pause"} â€¢ 'c': Clear â€¢ 'q'/ESC: Back
				</Text>
			</Box>
		</Box>
	);
}

================
File: apps/tui/src/components/RequestsScreen.tsx
================
import * as tuiCore from "@ccflare/tui-core";
import { formatCost, formatTokens } from "@ccflare/ui-common";
import { Box, Text, useInput } from "ink";
import { useCallback, useEffect, useState } from "react";
import { TokenUsageDisplay } from "./TokenUsageDisplay";

interface RequestsScreenProps {
	onBack: () => void;
}

export function RequestsScreen({ onBack }: RequestsScreenProps) {
	const [requests, setRequests] = useState<tuiCore.RequestPayload[]>([]);
	const [summaries, setSummaries] = useState<
		Map<string, tuiCore.RequestSummary>
	>(new Map());
	const [loading, setLoading] = useState(true);
	const [selectedIndex, setSelectedIndex] = useState(0);
	const [viewDetails, setViewDetails] = useState(false);
	const [page, setPage] = useState(0);
	const pageSize = 10;

	useInput((input, key) => {
		if (key.escape || input === "q") {
			if (viewDetails) {
				setViewDetails(false);
			} else {
				onBack();
			}
		}

		if (!viewDetails) {
			if (key.upArrow) {
				setSelectedIndex((prev) => Math.max(0, prev - 1));
			}
			if (key.downArrow) {
				setSelectedIndex((prev) =>
					Math.min(
						Math.min(requests.length - 1, page * pageSize + pageSize - 1),
						prev + 1,
					),
				);
			}
			if (key.leftArrow && page > 0) {
				setPage(page - 1);
				setSelectedIndex(page * pageSize - pageSize);
			}
			if (key.rightArrow && (page + 1) * pageSize < requests.length) {
				setPage(page + 1);
				setSelectedIndex(page * pageSize + pageSize);
			}
			if (key.return || input === " ") {
				if (requests.length > 0) {
					setViewDetails(true);
				}
			}
			if (input === "r") {
				loadRequests();
			}
		}
	});

	const loadRequests = useCallback(async () => {
		try {
			const [requestData, summaryData] = await Promise.all([
				tuiCore.getRequests(100),
				tuiCore.getRequestSummaries(100),
			]);
			setRequests(requestData);
			setSummaries(summaryData);
			setLoading(false);
		} catch (_error) {
			setLoading(false);
		}
	}, []);

	useEffect(() => {
		loadRequests();
		const interval = setInterval(loadRequests, 10000); // Auto-refresh every 10 seconds
		return () => clearInterval(interval);
	}, [loadRequests]);

	// For TUI, we want to show just time not full timestamp for space reasons
	const formatTime = (ts: number): string => {
		return new Date(ts).toLocaleTimeString();
	};

	const decodeBase64 = (str: string | null): string => {
		if (!str) return "No data";
		try {
			if (str === "[streamed]") {
				return "[Streaming data not captured]";
			}
			return Buffer.from(str, "base64").toString();
		} catch {
			return "Failed to decode";
		}
	};

	const formatJson = (str: string): string => {
		try {
			const parsed = JSON.parse(str);
			return JSON.stringify(parsed, null, 2);
		} catch {
			// If it's not valid JSON, return as-is
			return str;
		}
	};

	if (loading) {
		return (
			<Box flexDirection="column" padding={1}>
				<Text color="cyan" bold>
					üìú Request History
				</Text>
				<Text dimColor>Loading...</Text>
			</Box>
		);
	}

	const selectedRequest = requests[selectedIndex];
	const selectedSummary = selectedRequest
		? summaries.get(selectedRequest.id)
		: undefined;

	if (viewDetails && selectedRequest) {
		return (
			<Box flexDirection="column" padding={1}>
				<Box marginBottom={1}>
					<Text color="cyan" bold>
						üìú Request Details
					</Text>
				</Box>

				<Box flexDirection="column">
					<Text bold>ID: {selectedRequest.id}</Text>
					<Text bold>Time: {formatTime(selectedRequest.meta.timestamp)}</Text>

					{selectedRequest.meta.accountName && (
						<Text>Account: {selectedRequest.meta.accountName}</Text>
					)}

					{selectedSummary?.model && (
						<Text>
							Model: <Text color="green">{selectedSummary.model}</Text>
						</Text>
					)}

					{selectedSummary?.responseTimeMs && (
						<Text>
							Response Time:{" "}
							<Text color="yellow">{selectedSummary.responseTimeMs}ms</Text>
						</Text>
					)}

					{selectedRequest.meta.retry !== undefined &&
						selectedRequest.meta.retry > 0 && (
							<Text color="yellow">Retry: {selectedRequest.meta.retry}</Text>
						)}

					{selectedRequest.meta.rateLimited && (
						<Text color="orange">Rate Limited</Text>
					)}

					{selectedRequest.error && (
						<Text color="red">Error: {selectedRequest.error}</Text>
					)}

					{/* Token Usage Section */}
					{selectedSummary &&
						(selectedSummary.inputTokens || selectedSummary.outputTokens) && (
							<Box marginTop={1}>
								<TokenUsageDisplay summary={selectedSummary} />
							</Box>
						)}

					<Box marginTop={1}>
						<Text bold>Request Headers:</Text>
						<Box marginLeft={2} flexDirection="column">
							<Text dimColor>
								{formatJson(JSON.stringify(selectedRequest.request.headers))}
							</Text>
						</Box>
					</Box>

					{selectedRequest.request.body && (
						<Box marginTop={1}>
							<Text bold>Request Body:</Text>
							<Box marginLeft={2}>
								<Text dimColor>
									{formatJson(
										decodeBase64(selectedRequest.request.body),
									).substring(0, 500)}
									{decodeBase64(selectedRequest.request.body).length > 500 &&
										"..."}
								</Text>
							</Box>
						</Box>
					)}

					{selectedRequest.response && (
						<>
							<Box marginTop={1}>
								<Text bold>
									Response Status:{" "}
									<Text
										color={
											selectedRequest.response.status >= 200 &&
											selectedRequest.response.status < 300
												? "green"
												: selectedRequest.response.status >= 400 &&
														selectedRequest.response.status < 500
													? "yellow"
													: "red"
										}
									>
										{selectedRequest.response.status}
									</Text>
								</Text>
							</Box>

							{selectedRequest.response.body && (
								<Box marginTop={1}>
									<Text bold>Response Body:</Text>
									<Box marginLeft={2}>
										<Text dimColor>
											{formatJson(
												decodeBase64(selectedRequest.response.body),
											).substring(0, 500)}
											{decodeBase64(selectedRequest.response.body).length >
												500 && "..."}
										</Text>
									</Box>
								</Box>
							)}
						</>
					)}
				</Box>

				<Box marginTop={2}>
					<Text dimColor>Press 'q' or ESC to go back</Text>
				</Box>
			</Box>
		);
	}

	// Paginated view
	const startIdx = page * pageSize;
	const endIdx = Math.min(startIdx + pageSize, requests.length);
	const pageRequests = requests.slice(startIdx, endIdx);
	const totalPages = Math.ceil(requests.length / pageSize);

	return (
		<Box flexDirection="column" padding={1}>
			<Box marginBottom={1}>
				<Text color="cyan" bold>
					üìú Request History
				</Text>
				<Text dimColor>
					Use ‚Üë/‚Üì to navigate, ‚Üê/‚Üí for pages, ENTER to view details
				</Text>
			</Box>

			{requests.length === 0 ? (
				<Text dimColor>No requests found</Text>
			) : (
				<Box flexDirection="column">
					{pageRequests.map((req, idx) => {
						const index = startIdx + idx;
						const isSelected = index === selectedIndex;
						const isError = req.error || !req.meta.success;
						const statusCode = req.response?.status;
						const summary = summaries.get(req.id);

						return (
							<Box key={req.id}>
								<Text
									color={isSelected ? "cyan" : undefined}
									inverse={isSelected}
								>
									{isSelected ? "‚ñ∂ " : "  "}
									{formatTime(req.meta.timestamp)} -{" "}
									{statusCode ? (
										<Text
											color={
												statusCode >= 200 && statusCode < 300
													? "green"
													: statusCode >= 400 && statusCode < 500
														? "yellow"
														: "red"
											}
										>
											{statusCode}
										</Text>
									) : (
										<Text color="red">ERROR</Text>
									)}
									{" - "}
									{req.meta.accountName ||
										req.meta.accountId?.slice(0, 8) ||
										"No Account"}
									{summary?.model && (
										<>
											{" - "}
											<Text color="magenta">
												{summary.model.split("-").pop()}
											</Text>
										</>
									)}
									{summary?.totalTokens && (
										<>
											{" - "}
											<Text dimColor>
												{formatTokens(summary.totalTokens)} tokens
											</Text>
										</>
									)}
									{summary?.costUsd && summary.costUsd > 0 && (
										<>
											{" - "}
											<Text color="green">{formatCost(summary.costUsd)}</Text>
										</>
									)}
									{req.meta.rateLimited && (
										<Text color="orange"> [RATE LIMITED]</Text>
									)}
									{isError &&
										req.error &&
										` - ${req.error.substring(0, 20)}...`}
								</Text>
							</Box>
						);
					})}

					<Box marginTop={1}>
						<Text dimColor>
							Page {page + 1}/{totalPages} ‚Ä¢ {requests.length} total requests
						</Text>
					</Box>
				</Box>
			)}

			<Box marginTop={2}>
				<Text dimColor>Press 'r' to refresh ‚Ä¢ 'q' or ESC to go back</Text>
			</Box>
		</Box>
	);
}

================
File: apps/tui/src/components/charts/PieChart.tsx
================
import { Box, Text } from "ink";
import { formatAxisValue } from "./utils";

export interface PieChartData {
	label: string;
	value: number;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
}

interface PieChartProps {
	data: PieChartData[];
	title?: string;
	showLegend?: boolean;
	size?: "small" | "medium" | "large";
}

const _PIE_CHARS = {
	full: "●",
	three_quarters: "◕",
	half: "◐",
	quarter: "◔",
	empty: "○",
} as const;

const SIZE_CONFIG = {
	small: { radius: 3, chars: ["•", "○"] },
	medium: { radius: 5, chars: ["●", "○"] },
	large: { radius: 7, chars: ["●", "○"] },
} as const;

export function PieChart({
	data,
	title,
	showLegend = true,
	size = "medium",
}: PieChartProps) {
	if (data.length === 0) {
		return (
			<Box flexDirection="column">
				{title && (
					<Text bold underline>
						{title}
					</Text>
				)}
				<Text dimColor>No data available</Text>
			</Box>
		);
	}

	const total = data.reduce((sum, item) => sum + item.value, 0);
	const percentages = data.map((item) => ({
		...item,
		percentage: total > 0 ? (item.value / total) * 100 : 0,
	}));

	// Sort by percentage for better visualization
	percentages.sort((a, b) => b.percentage - a.percentage);

	// Simple ASCII representation
	const { radius } = SIZE_CONFIG[size];
	const diameter = radius * 2 + 1;

	// Create a simple circular visualization
	const createCircle = () => {
		const circle: string[][] = [];
		for (let y = 0; y < diameter; y++) {
			const row: string[] = [];
			for (let x = 0; x < diameter; x++) {
				const dx = x - radius;
				const dy = y - radius;
				const distance = Math.sqrt(dx * dx + dy * dy);

				if (distance <= radius) {
					// Determine which segment this point belongs to
					let angle = Math.atan2(dy, dx) + Math.PI; // 0 to 2π
					angle = angle / (2 * Math.PI); // 0 to 1

					let cumulativePercentage = 0;
					let segmentIndex = 0;
					for (let i = 0; i < percentages.length; i++) {
						cumulativePercentage += percentages[i].percentage / 100;
						if (angle <= cumulativePercentage) {
							segmentIndex = i;
							break;
						}
					}

					const color = percentages[segmentIndex]?.color || "cyan";
					row.push(color);
				} else {
					row.push(" ");
				}
			}
			circle.push(row);
		}
		return circle;
	};

	const circleColors = createCircle();

	return (
		<Box flexDirection="column">
			{title && (
				<Box marginBottom={1}>
					<Text bold underline>
						{title}
					</Text>
				</Box>
			)}

			<Box flexDirection="row">
				{/* Pie visualization */}
				<Box flexDirection="column" marginRight={2}>
					{circleColors.map((row, y) => (
						<Box key={`pie-row-${y}-${radius}`}>
							{row.map((color, x) => (
								<Text
									key={`pie-cell-${x}-${y}-${radius}`}
									color={
										color === " "
											? undefined
											: (color as
													| "green"
													| "yellow"
													| "red"
													| "cyan"
													| "magenta"
													| "blue")
									}
								>
									{color === " " ? " " : "●"}
								</Text>
							))}
						</Box>
					))}
				</Box>

				{/* Legend */}
				{showLegend && (
					<Box flexDirection="column">
						{percentages.map((item, index) => (
							<Box key={`${item.label}-${index}`}>
								<Text color={item.color || "cyan"}>● </Text>
								<Text>{item.label}: </Text>
								<Text bold>{Math.round(item.percentage)}%</Text>
								<Text dimColor> ({formatAxisValue(item.value)})</Text>
							</Box>
						))}
						<Box marginTop={1}>
							<Text dimColor>Total: {formatAxisValue(total)}</Text>
						</Box>
					</Box>
				)}
			</Box>
		</Box>
	);
}

================
File: apps/tui/src/components/charts/SparklineChart.tsx
================
import { Box, Text } from "ink";
import { createSparkline, formatAxisValue } from "./utils";

interface SparklineChartProps {
	data: number[];
	label?: string;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
	showMinMax?: boolean;
	showCurrent?: boolean;
}

export function SparklineChart({
	data,
	label,
	color = "cyan",
	showMinMax = true,
	showCurrent = true,
}: SparklineChartProps) {
	if (data.length === 0) {
		return <Text dimColor>No data</Text>;
	}

	const sparkline = createSparkline(data);
	const min = Math.min(...data);
	const max = Math.max(...data);
	const current = data[data.length - 1];

	return (
		<Box>
			{label && (
				<Box marginRight={1}>
					<Text>{label}:</Text>
				</Box>
			)}
			<Text color={color}>{sparkline}</Text>
			{showMinMax && (
				<Text dimColor>
					{" "}
					[{formatAxisValue(min)} â†’ {formatAxisValue(max)}]
				</Text>
			)}
			{showCurrent && (
				<Text color={color} bold>
					{" "}
					{formatAxisValue(current)}
				</Text>
			)}
		</Box>
	);
}

================
File: apps/tui/src/components/charts/utils.ts
================
// Bar chart characters
export const BAR_CHARS = {
	full: "█",
	seven_eighths: "▇",
	three_quarters: "▆",
	five_eighths: "▅",
	half: "▄",
	three_eighths: "▃",
	quarter: "▂",
	one_eighth: "▁",
	empty: " ",
} as const;

// Line chart characters
export const LINE_CHARS = {
	horizontal: "─",
	vertical: "│",
	cross: "┼",
	bottom_left: "└",
	bottom_right: "┘",
	top_left: "┌",
	top_right: "┐",
	vertical_right: "├",
	vertical_left: "┤",
	horizontal_down: "┬",
	horizontal_up: "┴",
} as const;

// Sparkline characters
export const SPARK_CHARS = ["▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"] as const;

// Get a bar character based on percentage (0-1)
export function getBarChar(percentage: number): string {
	if (percentage >= 1) return BAR_CHARS.full;
	if (percentage >= 0.875) return BAR_CHARS.seven_eighths;
	if (percentage >= 0.75) return BAR_CHARS.three_quarters;
	if (percentage >= 0.625) return BAR_CHARS.five_eighths;
	if (percentage >= 0.5) return BAR_CHARS.half;
	if (percentage >= 0.375) return BAR_CHARS.three_eighths;
	if (percentage >= 0.25) return BAR_CHARS.quarter;
	if (percentage >= 0.125) return BAR_CHARS.one_eighth;
	return BAR_CHARS.empty;
}

// Get a sparkline character based on value position in range
export function getSparkChar(value: number, min: number, max: number): string {
	if (max === min) return SPARK_CHARS[0];
	const percentage = (value - min) / (max - min);
	const index = Math.floor(percentage * (SPARK_CHARS.length - 1));
	return SPARK_CHARS[Math.max(0, Math.min(index, SPARK_CHARS.length - 1))];
}

// Normalize data to fit within a specific range
export function normalizeData(
	data: number[],
	targetMax: number,
): { normalized: number[]; max: number; min: number } {
	const max = Math.max(...data, 0);
	const min = Math.min(...data, 0);
	const range = max - min || 1;

	const normalized = data.map((value) => {
		const percentage = (value - min) / range;
		return percentage * targetMax;
	});

	return { normalized, max, min };
}

// Format a number for display with appropriate units
export function formatAxisValue(value: number): string {
	if (value >= 1000000) {
		return `${(value / 1000000).toFixed(1)}M`;
	}
	if (value >= 1000) {
		return `${(value / 1000).toFixed(1)}K`;
	}
	if (value < 1 && value > 0) {
		return value.toFixed(2);
	}
	return Math.round(value).toString();
}

// Create a horizontal bar
export function createBar(
	value: number,
	maxValue: number,
	width: number,
	showPercentage = true,
): string {
	const percentage = maxValue > 0 ? value / maxValue : 0;
	const filledWidth = Math.floor(percentage * width);
	const remainingWidth = width - filledWidth;

	let bar = "";
	for (let i = 0; i < filledWidth; i++) {
		bar += BAR_CHARS.full;
	}

	// Add partial bar for the remaining percentage
	if (remainingWidth > 0) {
		const remainingPercentage = percentage * width - filledWidth;
		bar += getBarChar(remainingPercentage);
		for (let i = 1; i < remainingWidth; i++) {
			bar += BAR_CHARS.empty;
		}
	}

	if (showPercentage) {
		const percentStr = `${Math.round(percentage * 100)}%`;
		return `${bar} ${percentStr}`;
	}

	return bar;
}

// Create a sparkline from data
export function createSparkline(data: number[]): string {
	if (data.length === 0) return "";

	const max = Math.max(...data);
	const min = Math.min(...data);

	return data.map((value) => getSparkChar(value, min, max)).join("");
}

// Get color based on value and thresholds
export function getColorForValue(
	value: number,
	thresholds: { good: number; warning: number },
	inverse = false,
): "green" | "yellow" | "red" {
	if (inverse) {
		if (value <= thresholds.good) return "green";
		if (value <= thresholds.warning) return "yellow";
		return "red";
	} else {
		if (value >= thresholds.good) return "green";
		if (value >= thresholds.warning) return "yellow";
		return "red";
	}
}

================
File: apps/tui/src/components/charts/index.ts
================
export { BarChart, type BarChartData } from "./BarChart";
export { LineChart, type LineChartData } from "./LineChart";
export { PieChart, type PieChartData } from "./PieChart";
export { SparklineChart } from "./SparklineChart";
export * from "./utils";

================
File: apps/tui/src/components/charts/LineChart.tsx
================
import { Box, Text } from "ink";
import { formatAxisValue, getSparkChar, normalizeData } from "./utils";

export interface LineChartData {
	x: string;
	y: number;
}

interface LineChartProps {
	data: LineChartData[];
	height?: number;
	width?: number;
	title?: string;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
	showAxes?: boolean;
}

export function LineChart({
	data,
	height = 10,
	width = 40,
	title,
	color = "cyan",
	showAxes = true,
}: LineChartProps) {
	if (data.length === 0) {
		return (
			<Box flexDirection="column">
				{title && (
					<Text bold underline>
						{title}
					</Text>
				)}
				<Text dimColor>No data available</Text>
			</Box>
		);
	}

	const values = data.map((d) => d.y);
	const { normalized, max, min } = normalizeData(values, height - 1);

	// Create the chart grid
	const chart: string[][] = Array(height)
		.fill(null)
		.map(() => Array(width).fill(" "));

	// Plot the points
	const xStep = Math.max(1, Math.floor(data.length / width));
	for (let i = 0; i < width && i * xStep < data.length; i++) {
		const dataIndex = i * xStep;
		const value = normalized[dataIndex];
		const y = height - 1 - Math.round(value);
		const x = i;

		if (y >= 0 && y < height) {
			// Use different characters based on the position in the y-axis
			const char = getSparkChar(values[dataIndex], min, max);
			chart[y][x] = char;
		}
	}

	return (
		<Box flexDirection="column">
			{title && (
				<Box marginBottom={1}>
					<Text bold underline>
						{title}
					</Text>
				</Box>
			)}

			{/* Y-axis labels and chart */}
			{showAxes && (
				<Box>
					<Text dimColor>{formatAxisValue(max).padStart(6)} </Text>
					<Text dimColor>┤</Text>
				</Box>
			)}

			{chart.map((row, y) => (
				<Box key={`chart-row-${y}-${height}`}>
					{showAxes && y === Math.floor(height / 2) && (
						<Text dimColor>
							{formatAxisValue((max + min) / 2).padStart(6)}{" "}
						</Text>
					)}
					{showAxes && y !== Math.floor(height / 2) && (
						<Text>{" ".repeat(6)} </Text>
					)}
					{showAxes && <Text dimColor>│</Text>}
					<Text color={color}>{row.join("")}</Text>
				</Box>
			))}

			{showAxes && (
				<>
					<Box>
						<Text dimColor>{formatAxisValue(min).padStart(6)} </Text>
						<Text dimColor>└{"─".repeat(width)}</Text>
					</Box>
					{/* X-axis labels */}
					<Box marginLeft={8}>
						<Text dimColor>
							{data[0].x}
							{" ".repeat(
								Math.max(
									0,
									width - data[0].x.length - data[data.length - 1].x.length,
								),
							)}
							{data[data.length - 1].x}
						</Text>
					</Box>
				</>
			)}
		</Box>
	);
}

================
File: apps/tui/src/components/charts/BarChart.tsx
================
import { Box, Text } from "ink";
import { createBar, formatAxisValue, getColorForValue } from "./utils";

export interface BarChartData {
	label: string;
	value: number;
	color?: "green" | "yellow" | "red" | "cyan" | "magenta" | "blue";
}

interface BarChartProps {
	data: BarChartData[];
	width?: number;
	showValues?: boolean;
	title?: string;
	colorThresholds?: { good: number; warning: number };
}

export function BarChart({
	data,
	width = 30,
	showValues = true,
	title,
	colorThresholds,
}: BarChartProps) {
	if (data.length === 0) {
		return (
			<Box flexDirection="column">
				{title && (
					<Text bold underline>
						{title}
					</Text>
				)}
				<Text dimColor>No data available</Text>
			</Box>
		);
	}

	const maxValue = Math.max(...data.map((d) => d.value));
	const maxLabelLength = Math.max(...data.map((d) => d.label.length));

	return (
		<Box flexDirection="column">
			{title && (
				<Box marginBottom={1}>
					<Text bold underline>
						{title}
					</Text>
				</Box>
			)}
			{data.map((item, index) => {
				const bar = createBar(item.value, maxValue, width, false);
				const color =
					item.color ||
					(colorThresholds
						? getColorForValue(item.value, colorThresholds)
						: "cyan");

				return (
					<Box key={`${item.label}-${index}`}>
						<Box width={maxLabelLength + 2}>
							<Text>{item.label}:</Text>
						</Box>
						<Text color={color}>{bar}</Text>
						{showValues && <Text dimColor> {formatAxisValue(item.value)}</Text>}
					</Box>
				);
			})}
		</Box>
	);
}

================
File: apps/server/package.json
================
{
	"name": "@ccflare/server",
	"version": "0.1.0",
	"type": "module",
	"main": "./src/server.ts",
	"scripts": {
		"dev": "bun run --hot src/server.ts",
		"start": "bun run src/server.ts",
		"build": "bun build src/server.ts --compile --outfile dist/ccflare-server",
		"typecheck": "bunx tsc --noEmit"
	},
	"dependencies": {
		"@ccflare/core": "workspace:*",
		"@ccflare/core-di": "workspace:*",
		"@ccflare/database": "workspace:*",
		"@ccflare/config": "workspace:*",
		"@ccflare/logger": "workspace:*",
		"@ccflare/load-balancer": "workspace:*",
		"@ccflare/proxy": "workspace:*",
		"@ccflare/dashboard-web": "workspace:*",
		"@ccflare/http-api": "workspace:*",
		"@ccflare/types": "workspace:*"
	}
}

================
File: apps/server/tsconfig.json
================
{
	"extends": "../../tsconfig.json",
	"include": ["src/**/*"]
}

================
File: apps/server/src/server.ts
================
import { dirname } from "node:path";
import { Config, type RuntimeConfig } from "@ccflare/config";
import {
	CACHE,
	DEFAULT_STRATEGY,
	HTTP_STATUS,
	NETWORK,
	registerDisposable,
	setPricingLogger,
	shutdown,
	TIME_CONSTANTS,
} from "@ccflare/core";
import { container, SERVICE_KEYS } from "@ccflare/core-di";
// Import React dashboard assets
import dashboardManifest from "@ccflare/dashboard-web/dist/manifest.json";
import type { DatabaseOperations } from "@ccflare/database";
import { AsyncDbWriter, DatabaseFactory } from "@ccflare/database";
import { APIRouter } from "@ccflare/http-api";
import { SessionStrategy } from "@ccflare/load-balancer";
import { Logger } from "@ccflare/logger";
import { getProvider } from "@ccflare/providers";
import {
	getUsageWorker,
	handleProxy,
	type ProxyContext,
	terminateUsageWorker,
} from "@ccflare/proxy";
import { serve } from "bun";

// Helper function to resolve dashboard assets with fallback
function resolveDashboardAsset(assetPath: string): string | null {
	try {
		// Try resolving as a package first
		return Bun.resolveSync(
			`@ccflare/dashboard-web/dist${assetPath}`,
			dirname(import.meta.path),
		);
	} catch {
		// Fallback to relative path within the repo (development / mono-repo usage)
		try {
			return Bun.resolveSync(
				`../../../packages/dashboard-web/dist${assetPath}`,
				dirname(import.meta.path),
			);
		} catch {
			return null;
		}
	}
}

// Helper function to serve dashboard files with proper headers
function serveDashboardFile(
	assetPath: string,
	contentType?: string,
	cacheControl?: string,
): Response {
	const fullPath = resolveDashboardAsset(assetPath);
	if (!fullPath) {
		return new Response("Not Found", { status: HTTP_STATUS.NOT_FOUND });
	}

	// Auto-detect content type if not provided
	if (!contentType) {
		if (assetPath.endsWith(".js")) contentType = "application/javascript";
		else if (assetPath.endsWith(".css")) contentType = "text/css";
		else if (assetPath.endsWith(".html")) contentType = "text/html";
		else if (assetPath.endsWith(".json")) contentType = "application/json";
		else if (assetPath.endsWith(".svg")) contentType = "image/svg+xml";
		else contentType = "text/plain";
	}

	return new Response(Bun.file(fullPath), {
		headers: {
			"Content-Type": contentType,
			"Cache-Control": cacheControl || CACHE.CACHE_CONTROL_NO_CACHE,
		},
	});
}

// Module-level server instance
let serverInstance: ReturnType<typeof serve> | null = null;
let stopRetentionJob: (() => void) | null = null;

// Startup maintenance (one-shot): cleanup + compact
function runStartupMaintenance(config: Config, dbOps: DatabaseOperations) {
	const log = new Logger("StartupMaintenance");
	try {
		const payloadDays = config.getDataRetentionDays();
		const requestDays = config.getRequestRetentionDays();
		const { removedRequests, removedPayloads } = dbOps.cleanupOldRequests(
			payloadDays * 24 * 60 * 60 * 1000,
			requestDays * 24 * 60 * 60 * 1000,
		);
		log.info(
			`Startup cleanup removed ${removedRequests} requests and ${removedPayloads} payloads (payload=${payloadDays}d, requests=${requestDays}d)`,
		);
	} catch (err) {
		log.error(`Startup cleanup error: ${err}`);
	}
	try {
		dbOps.compact();
		log.info("Database compacted at startup");
	} catch (err) {
		log.error(`Database compaction error: ${err}`);
	}
	// Return a no-op stopper for compatibility
	return () => {};
}

// Export for programmatic use
export default function startServer(options?: {
	port?: number;
	withDashboard?: boolean;
}) {
	// Return existing server if already running
	if (serverInstance) {
		return {
			port: serverInstance.port,
			stop: () => {
				if (serverInstance) {
					serverInstance.stop();
					serverInstance = null;
				}
			},
		};
	}

	const { port = NETWORK.DEFAULT_PORT, withDashboard = true } = options || {};

	// Initialize DI container
	container.registerInstance(SERVICE_KEYS.Config, new Config());
	container.registerInstance(SERVICE_KEYS.Logger, new Logger("Server"));

	// Initialize components
	const config = container.resolve<Config>(SERVICE_KEYS.Config);
	const runtime = config.getRuntime();
	// Override port if provided
	if (port !== runtime.port) {
		runtime.port = port;
	}
	DatabaseFactory.initialize(undefined, runtime);
	const dbOps = DatabaseFactory.getInstance();
	const db = dbOps.getDatabase();
	const log = container.resolve<Logger>(SERVICE_KEYS.Logger);
	container.registerInstance(SERVICE_KEYS.Database, dbOps);

	// Initialize async DB writer
	const asyncWriter = new AsyncDbWriter();
	container.registerInstance(SERVICE_KEYS.AsyncWriter, asyncWriter);
	registerDisposable(asyncWriter);

	// Initialize pricing logger
	const pricingLogger = new Logger("Pricing");
	container.registerInstance(SERVICE_KEYS.PricingLogger, pricingLogger);
	setPricingLogger(pricingLogger);

	const apiRouter = new APIRouter({ db, config, dbOps });

	// Run startup maintenance once (cleanup + compact)
	stopRetentionJob = runStartupMaintenance(config, dbOps);

	// Initialize load balancing strategy (will be created after runtime config)

	// Get the provider
	const provider = getProvider("anthropic");
	if (!provider) {
		throw new Error("Anthropic provider not available");
	}

	// Create runtime config
	const runtimeConfig: RuntimeConfig = {
		clientId: config.get(
			"client_id",
			"9d1c250a-e61b-44d9-88ed-5944d1962f5e",
		) as string,
		retry: {
			attempts: config.get("retry_attempts", 3) as number,
			delayMs: config.get("retry_delay_ms", 1000) as number,
			backoff: config.get("retry_backoff", 2) as number,
		},
		sessionDurationMs: config.get(
			"session_duration_ms",
			TIME_CONSTANTS.SESSION_DURATION_DEFAULT,
		) as number,
		port,
	};

	// Now create the strategy with runtime config
	const strategy = new SessionStrategy(runtimeConfig.sessionDurationMs);
	strategy.initialize(dbOps);

	// Proxy context
	const proxyContext: ProxyContext = {
		strategy,
		dbOps,
		runtime: runtimeConfig,
		provider,
		refreshInFlight: new Map(),
		asyncWriter,
		usageWorker: getUsageWorker(),
	};

	// Hot reload strategy configuration
	config.on("change", (changeType, fieldName) => {
		if (fieldName === "strategy") {
			log.info(`Strategy configuration changed: ${changeType}`);
			const newStrategyName = config.getStrategy();
			// For now, only SessionStrategy is supported
			if (newStrategyName === "session") {
				const strategy = new SessionStrategy(runtimeConfig.sessionDurationMs);
				strategy.initialize(dbOps);
				proxyContext.strategy = strategy;
			}
		}
	});

	// Main server
	serverInstance = serve({
		port: runtime.port,
		idleTimeout: NETWORK.IDLE_TIMEOUT_MAX, // Max allowed by Bun
		async fetch(req) {
			const url = new URL(req.url);

			// Try API routes first
			const apiResponse = await apiRouter.handleRequest(url, req);
			if (apiResponse) {
				return apiResponse;
			}

			// Dashboard routes (only if enabled)
			if (withDashboard) {
				// Serve dashboard static assets
				if ((dashboardManifest as Record<string, string>)[url.pathname]) {
					return serveDashboardFile(
						url.pathname,
						undefined,
						CACHE.CACHE_CONTROL_STATIC,
					);
				}

				// For all non-API routes, serve the dashboard index.html (client-side routing)
				// This allows React Router to handle all dashboard routes without maintaining a list
				if (
					!url.pathname.startsWith("/api/") &&
					!url.pathname.startsWith("/v1/")
				) {
					return serveDashboardFile("/index.html", "text/html");
				}
			}

			// All other paths go to proxy
			return handleProxy(req, url, proxyContext);
		},
	});

	// Log server startup
	console.log(`
🎯 ccflare Server v${process.env.npm_package_version || "1.0.0"}
🌐 Port: ${serverInstance.port}
📊 Dashboard: ${withDashboard ? `http://localhost:${serverInstance.port}` : "disabled"}
🔗 API Base: http://localhost:${serverInstance.port}/api

Available endpoints:
- POST   http://localhost:${serverInstance.port}/v1/*            → Proxy to Claude API
- GET    http://localhost:${serverInstance.port}/api/accounts    → List accounts
- POST   http://localhost:${serverInstance.port}/api/accounts    → Add account
- DELETE http://localhost:${serverInstance.port}/api/accounts/:id → Remove account
- GET    http://localhost:${serverInstance.port}/api/stats       → View statistics
- POST   http://localhost:${serverInstance.port}/api/stats/reset → Reset statistics
- GET    http://localhost:${serverInstance.port}/api/config      → View configuration
- PATCH  http://localhost:${serverInstance.port}/api/config      → Update configuration

⚡ Ready to proxy requests...
`);

	// Log configuration
	console.log(
		`⚙️  Current strategy: ${config.getStrategy()} (default: ${DEFAULT_STRATEGY})`,
	);

	// Log initial account status
	const accounts = dbOps.getAllAccounts();
	const activeAccounts = accounts.filter(
		(a) => !a.paused && (!a.expires_at || a.expires_at > Date.now()),
	);
	log.info(
		`Loaded ${accounts.length} accounts (${activeAccounts.length} active)`,
	);
	if (activeAccounts.length === 0) {
		log.warn(
			"No active accounts available - requests will be forwarded without authentication",
		);
	}

	return {
		port: serverInstance.port,
		stop: () => {
			if (serverInstance) {
				serverInstance.stop();
				serverInstance = null;
			}
		},
	};
}

// Graceful shutdown handler
async function handleGracefulShutdown(signal: string) {
	console.log(`\n👋 Received ${signal}, shutting down gracefully...`);
	try {
		if (stopRetentionJob) {
			stopRetentionJob();
			stopRetentionJob = null;
		}
		terminateUsageWorker();
		await shutdown();
		console.log("✅ Shutdown complete");
		process.exit(0);
	} catch (error) {
		console.error("❌ Error during shutdown:", error);
		process.exit(1);
	}
}

// Register signal handlers
process.on("SIGINT", () => handleGracefulShutdown("SIGINT"));
process.on("SIGTERM", () => handleGracefulShutdown("SIGTERM"));

// Run server if this is the main entry point
if (import.meta.main) {
	startServer();
}
